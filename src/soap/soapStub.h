/* soapStub.h
   Generated by gSOAP 2.8.89 for soap/afip_soap.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_NAMESPACE_OF_afip1	"http://wsaa.view.sua.dvadac.desein.afip.gov"
#define SOAP_NAMESPACE_OF_afip2	"https://wsaahomo.afip.gov.ar/ws/services/LoginCms"
#define SOAP_NAMESPACE_OF_afip3	"http://ar.gov.afip.dif.FEV1/"

#ifndef soapStub_H
#define soapStub_H
#include <stdsoap2.h>


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class _afip1__loginCms;	/* soap/afip_soap.h:164 */
class _afip1__loginCmsResponse;	/* soap/afip_soap.h:166 */
class afip2__LoginFault;	/* soap/afip_soap.h:168 */
class afip3__FEAuthRequest;	/* soap/afip_soap.h:170 */
class afip3__FECAERequest;	/* soap/afip_soap.h:172 */
class afip3__FECabRequest;	/* soap/afip_soap.h:176 */
class afip3__ArrayOfFECAEDetRequest;	/* soap/afip_soap.h:178 */
class afip3__FEDetRequest;	/* soap/afip_soap.h:182 */
class afip3__ArrayOfCbteAsoc;	/* soap/afip_soap.h:184 */
class afip3__CbteAsoc;	/* soap/afip_soap.h:186 */
class afip3__ArrayOfTributo;	/* soap/afip_soap.h:188 */
class afip3__Tributo;	/* soap/afip_soap.h:190 */
class afip3__ArrayOfAlicIva;	/* soap/afip_soap.h:192 */
class afip3__AlicIva;	/* soap/afip_soap.h:194 */
class afip3__ArrayOfOpcional;	/* soap/afip_soap.h:196 */
class afip3__Opcional;	/* soap/afip_soap.h:198 */
class afip3__ArrayOfComprador;	/* soap/afip_soap.h:200 */
class afip3__Comprador;	/* soap/afip_soap.h:202 */
class afip3__FECAEResponse;	/* soap/afip_soap.h:204 */
class afip3__FECabResponse;	/* soap/afip_soap.h:208 */
class afip3__ArrayOfFECAEDetResponse;	/* soap/afip_soap.h:210 */
class afip3__FEDetResponse;	/* soap/afip_soap.h:214 */
class afip3__ArrayOfObs;	/* soap/afip_soap.h:216 */
class afip3__Obs;	/* soap/afip_soap.h:218 */
class afip3__ArrayOfEvt;	/* soap/afip_soap.h:220 */
class afip3__Evt;	/* soap/afip_soap.h:222 */
class afip3__ArrayOfErr;	/* soap/afip_soap.h:224 */
class afip3__Err;	/* soap/afip_soap.h:226 */
class afip3__FERegXReqResponse;	/* soap/afip_soap.h:228 */
class afip3__DummyResponse;	/* soap/afip_soap.h:230 */
class afip3__FERecuperaLastCbteResponse;	/* soap/afip_soap.h:232 */
class afip3__FECompConsultaReq;	/* soap/afip_soap.h:234 */
class afip3__FECompConsultaResponse;	/* soap/afip_soap.h:236 */
class afip3__FECAEARequest;	/* soap/afip_soap.h:240 */
class afip3__ArrayOfFECAEADetRequest;	/* soap/afip_soap.h:244 */
class afip3__FECAEAResponse;	/* soap/afip_soap.h:248 */
class afip3__ArrayOfFECAEADetResponse;	/* soap/afip_soap.h:252 */
class afip3__FECAEAGetResponse;	/* soap/afip_soap.h:256 */
class afip3__FECAEAGet;	/* soap/afip_soap.h:258 */
class afip3__FECAEASinMovConsResponse;	/* soap/afip_soap.h:260 */
class afip3__ArrayOfFECAEASinMov;	/* soap/afip_soap.h:262 */
class afip3__FECAEASinMov;	/* soap/afip_soap.h:264 */
class afip3__FECotizacionResponse;	/* soap/afip_soap.h:268 */
class afip3__Cotizacion;	/* soap/afip_soap.h:270 */
class afip3__FETributoResponse;	/* soap/afip_soap.h:272 */
class afip3__ArrayOfTributoTipo;	/* soap/afip_soap.h:274 */
class afip3__TributoTipo;	/* soap/afip_soap.h:276 */
class afip3__MonedaResponse;	/* soap/afip_soap.h:278 */
class afip3__ArrayOfMoneda;	/* soap/afip_soap.h:280 */
class afip3__Moneda;	/* soap/afip_soap.h:282 */
class afip3__IvaTipoResponse;	/* soap/afip_soap.h:284 */
class afip3__ArrayOfIvaTipo;	/* soap/afip_soap.h:286 */
class afip3__IvaTipo;	/* soap/afip_soap.h:288 */
class afip3__OpcionalTipoResponse;	/* soap/afip_soap.h:290 */
class afip3__ArrayOfOpcionalTipo;	/* soap/afip_soap.h:292 */
class afip3__OpcionalTipo;	/* soap/afip_soap.h:294 */
class afip3__ConceptoTipoResponse;	/* soap/afip_soap.h:296 */
class afip3__ArrayOfConceptoTipo;	/* soap/afip_soap.h:298 */
class afip3__ConceptoTipo;	/* soap/afip_soap.h:300 */
class afip3__FEPtoVentaResponse;	/* soap/afip_soap.h:302 */
class afip3__ArrayOfPtoVenta;	/* soap/afip_soap.h:304 */
class afip3__PtoVenta;	/* soap/afip_soap.h:306 */
class afip3__CbteTipoResponse;	/* soap/afip_soap.h:308 */
class afip3__ArrayOfCbteTipo;	/* soap/afip_soap.h:310 */
class afip3__CbteTipo;	/* soap/afip_soap.h:312 */
class afip3__DocTipoResponse;	/* soap/afip_soap.h:314 */
class afip3__ArrayOfDocTipo;	/* soap/afip_soap.h:316 */
class afip3__DocTipo;	/* soap/afip_soap.h:318 */
class afip3__FEPaisResponse;	/* soap/afip_soap.h:320 */
class afip3__ArrayOfPaisTipo;	/* soap/afip_soap.h:322 */
class afip3__PaisTipo;	/* soap/afip_soap.h:324 */
class _afip3__FECAESolicitar;	/* soap/afip_soap.h:326 */
class _afip3__FECAESolicitarResponse;	/* soap/afip_soap.h:328 */
class _afip3__FECompTotXRequest;	/* soap/afip_soap.h:330 */
class _afip3__FECompTotXRequestResponse;	/* soap/afip_soap.h:332 */
class _afip3__FEDummy;	/* soap/afip_soap.h:334 */
class _afip3__FEDummyResponse;	/* soap/afip_soap.h:336 */
class _afip3__FECompUltimoAutorizado;	/* soap/afip_soap.h:338 */
class _afip3__FECompUltimoAutorizadoResponse;	/* soap/afip_soap.h:340 */
class _afip3__FECompConsultar;	/* soap/afip_soap.h:342 */
class _afip3__FECompConsultarResponse;	/* soap/afip_soap.h:344 */
class _afip3__FECAEARegInformativo;	/* soap/afip_soap.h:346 */
class _afip3__FECAEARegInformativoResponse;	/* soap/afip_soap.h:348 */
class _afip3__FECAEASolicitar;	/* soap/afip_soap.h:350 */
class _afip3__FECAEASolicitarResponse;	/* soap/afip_soap.h:352 */
class _afip3__FECAEASinMovimientoConsultar;	/* soap/afip_soap.h:354 */
class _afip3__FECAEASinMovimientoConsultarResponse;	/* soap/afip_soap.h:356 */
class _afip3__FECAEASinMovimientoInformar;	/* soap/afip_soap.h:358 */
class _afip3__FECAEASinMovimientoInformarResponse;	/* soap/afip_soap.h:360 */
class _afip3__FECAEAConsultar;	/* soap/afip_soap.h:362 */
class _afip3__FECAEAConsultarResponse;	/* soap/afip_soap.h:364 */
class _afip3__FEParamGetCotizacion;	/* soap/afip_soap.h:366 */
class _afip3__FEParamGetCotizacionResponse;	/* soap/afip_soap.h:368 */
class _afip3__FEParamGetTiposTributos;	/* soap/afip_soap.h:370 */
class _afip3__FEParamGetTiposTributosResponse;	/* soap/afip_soap.h:372 */
class _afip3__FEParamGetTiposMonedas;	/* soap/afip_soap.h:374 */
class _afip3__FEParamGetTiposMonedasResponse;	/* soap/afip_soap.h:376 */
class _afip3__FEParamGetTiposIva;	/* soap/afip_soap.h:378 */
class _afip3__FEParamGetTiposIvaResponse;	/* soap/afip_soap.h:380 */
class _afip3__FEParamGetTiposOpcional;	/* soap/afip_soap.h:382 */
class _afip3__FEParamGetTiposOpcionalResponse;	/* soap/afip_soap.h:384 */
class _afip3__FEParamGetTiposConcepto;	/* soap/afip_soap.h:386 */
class _afip3__FEParamGetTiposConceptoResponse;	/* soap/afip_soap.h:388 */
class _afip3__FEParamGetPtosVenta;	/* soap/afip_soap.h:390 */
class _afip3__FEParamGetPtosVentaResponse;	/* soap/afip_soap.h:392 */
class _afip3__FEParamGetTiposCbte;	/* soap/afip_soap.h:394 */
class _afip3__FEParamGetTiposCbteResponse;	/* soap/afip_soap.h:396 */
class _afip3__FEParamGetTiposDoc;	/* soap/afip_soap.h:398 */
class _afip3__FEParamGetTiposDocResponse;	/* soap/afip_soap.h:400 */
class _afip3__FEParamGetTiposPaises;	/* soap/afip_soap.h:402 */
class _afip3__FEParamGetTiposPaisesResponse;	/* soap/afip_soap.h:404 */
class afip3__FECAECabRequest;	/* soap/afip_soap.h:174 */
class afip3__FECAEDetRequest;	/* soap/afip_soap.h:180 */
class afip3__FECAECabResponse;	/* soap/afip_soap.h:206 */
class afip3__FECAEDetResponse;	/* soap/afip_soap.h:212 */
class afip3__FECAEACabRequest;	/* soap/afip_soap.h:242 */
class afip3__FECAEADetRequest;	/* soap/afip_soap.h:246 */
class afip3__FECAEACabResponse;	/* soap/afip_soap.h:250 */
class afip3__FECAEADetResponse;	/* soap/afip_soap.h:254 */
class afip3__FECAEASinMovResponse;	/* soap/afip_soap.h:266 */
class afip3__FECompConsResponse;	/* soap/afip_soap.h:238 */
struct __afip2__loginCms;	/* soap/afip_soap.h:3896 */
struct __afip4__FECAESolicitar;	/* soap/afip_soap.h:3983 */
struct __afip4__FECompTotXRequest;	/* soap/afip_soap.h:4055 */
struct __afip4__FEDummy;	/* soap/afip_soap.h:4126 */
struct __afip4__FECompUltimoAutorizado;	/* soap/afip_soap.h:4198 */
struct __afip4__FECompConsultar;	/* soap/afip_soap.h:4269 */
struct __afip4__FECAEARegInformativo;	/* soap/afip_soap.h:4340 */
struct __afip4__FECAEASolicitar;	/* soap/afip_soap.h:4411 */
struct __afip4__FECAEASinMovimientoConsultar;	/* soap/afip_soap.h:4482 */
struct __afip4__FECAEASinMovimientoInformar;	/* soap/afip_soap.h:4553 */
struct __afip4__FECAEAConsultar;	/* soap/afip_soap.h:4624 */
struct __afip4__FEParamGetCotizacion;	/* soap/afip_soap.h:4695 */
struct __afip4__FEParamGetTiposTributos;	/* soap/afip_soap.h:4767 */
struct __afip4__FEParamGetTiposMonedas;	/* soap/afip_soap.h:4838 */
struct __afip4__FEParamGetTiposIva;	/* soap/afip_soap.h:4909 */
struct __afip4__FEParamGetTiposOpcional;	/* soap/afip_soap.h:4980 */
struct __afip4__FEParamGetTiposConcepto;	/* soap/afip_soap.h:5051 */
struct __afip4__FEParamGetPtosVenta;	/* soap/afip_soap.h:5122 */
struct __afip4__FEParamGetTiposCbte;	/* soap/afip_soap.h:5193 */
struct __afip4__FEParamGetTiposDoc;	/* soap/afip_soap.h:5264 */
struct __afip4__FEParamGetTiposPaises;	/* soap/afip_soap.h:5336 */
struct __afip5__FECAESolicitar;	/* soap/afip_soap.h:5423 */
struct __afip5__FECompTotXRequest;	/* soap/afip_soap.h:5495 */
struct __afip5__FEDummy;	/* soap/afip_soap.h:5566 */
struct __afip5__FECompUltimoAutorizado;	/* soap/afip_soap.h:5638 */
struct __afip5__FECompConsultar;	/* soap/afip_soap.h:5709 */
struct __afip5__FECAEARegInformativo;	/* soap/afip_soap.h:5780 */
struct __afip5__FECAEASolicitar;	/* soap/afip_soap.h:5851 */
struct __afip5__FECAEASinMovimientoConsultar;	/* soap/afip_soap.h:5922 */
struct __afip5__FECAEASinMovimientoInformar;	/* soap/afip_soap.h:5993 */
struct __afip5__FECAEAConsultar;	/* soap/afip_soap.h:6064 */
struct __afip5__FEParamGetCotizacion;	/* soap/afip_soap.h:6135 */
struct __afip5__FEParamGetTiposTributos;	/* soap/afip_soap.h:6207 */
struct __afip5__FEParamGetTiposMonedas;	/* soap/afip_soap.h:6278 */
struct __afip5__FEParamGetTiposIva;	/* soap/afip_soap.h:6349 */
struct __afip5__FEParamGetTiposOpcional;	/* soap/afip_soap.h:6420 */
struct __afip5__FEParamGetTiposConcepto;	/* soap/afip_soap.h:6491 */
struct __afip5__FEParamGetPtosVenta;	/* soap/afip_soap.h:6562 */
struct __afip5__FEParamGetTiposCbte;	/* soap/afip_soap.h:6633 */
struct __afip5__FEParamGetTiposDoc;	/* soap/afip_soap.h:6704 */
struct __afip5__FEParamGetTiposPaises;	/* soap/afip_soap.h:6776 */

/* soap/afip_soap.h:164 */
#ifndef SOAP_TYPE__afip1__loginCms
#define SOAP_TYPE__afip1__loginCms (8)
/* complex XML schema type 'afip1:loginCms': */
class SOAP_CMAC _afip1__loginCms {
      public:
        /// Required element 'afip1:in0' of XML schema type 'xsd:string'
        std::string in0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip1__loginCms
        virtual long soap_type(void) const { return SOAP_TYPE__afip1__loginCms; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip1__loginCms, default initialized and not managed by a soap context
        virtual _afip1__loginCms *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip1__loginCms); }
      public:
        /// Constructor with default initializations
        _afip1__loginCms() : in0(), soap() { }
        virtual ~_afip1__loginCms() { }
        /// Friend allocator used by soap_new__afip1__loginCms(struct soap*, int)
        friend SOAP_FMAC1 _afip1__loginCms * SOAP_FMAC2 soap_instantiate__afip1__loginCms(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:166 */
#ifndef SOAP_TYPE__afip1__loginCmsResponse
#define SOAP_TYPE__afip1__loginCmsResponse (9)
/* complex XML schema type 'afip1:loginCmsResponse': */
class SOAP_CMAC _afip1__loginCmsResponse {
      public:
        /// Required element 'afip1:loginCmsReturn' of XML schema type 'xsd:string'
        std::string loginCmsReturn;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip1__loginCmsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__afip1__loginCmsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip1__loginCmsResponse, default initialized and not managed by a soap context
        virtual _afip1__loginCmsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip1__loginCmsResponse); }
      public:
        /// Constructor with default initializations
        _afip1__loginCmsResponse() : loginCmsReturn(), soap() { }
        virtual ~_afip1__loginCmsResponse() { }
        /// Friend allocator used by soap_new__afip1__loginCmsResponse(struct soap*, int)
        friend SOAP_FMAC1 _afip1__loginCmsResponse * SOAP_FMAC2 soap_instantiate__afip1__loginCmsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:168 */
#ifndef SOAP_TYPE_afip2__LoginFault
#define SOAP_TYPE_afip2__LoginFault (10)
/* complex XML schema type 'afip2:LoginFault': */
class SOAP_CMAC afip2__LoginFault {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip2__LoginFault
        virtual long soap_type(void) const { return SOAP_TYPE_afip2__LoginFault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip2__LoginFault, default initialized and not managed by a soap context
        virtual afip2__LoginFault *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip2__LoginFault); }
      public:
        /// Constructor with default initializations
        afip2__LoginFault() : soap() { }
        virtual ~afip2__LoginFault() { }
        /// Friend allocator used by soap_new_afip2__LoginFault(struct soap*, int)
        friend SOAP_FMAC1 afip2__LoginFault * SOAP_FMAC2 soap_instantiate_afip2__LoginFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:170 */
#ifndef SOAP_TYPE_afip3__FEAuthRequest
#define SOAP_TYPE_afip3__FEAuthRequest (11)
/* complex XML schema type 'afip3:FEAuthRequest': */
class SOAP_CMAC afip3__FEAuthRequest {
      public:
        /// Optional element 'afip3:Token' of XML schema type 'xsd:string'
        std::string *Token;
        /// Optional element 'afip3:Sign' of XML schema type 'xsd:string'
        std::string *Sign;
        /// Required element 'afip3:Cuit' of XML schema type 'xsd:long'
        LONG64 Cuit;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__FEAuthRequest
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__FEAuthRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__FEAuthRequest, default initialized and not managed by a soap context
        virtual afip3__FEAuthRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__FEAuthRequest); }
      public:
        /// Constructor with default initializations
        afip3__FEAuthRequest() : Token(), Sign(), Cuit(), soap() { }
        virtual ~afip3__FEAuthRequest() { }
        /// Friend allocator used by soap_new_afip3__FEAuthRequest(struct soap*, int)
        friend SOAP_FMAC1 afip3__FEAuthRequest * SOAP_FMAC2 soap_instantiate_afip3__FEAuthRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:172 */
#ifndef SOAP_TYPE_afip3__FECAERequest
#define SOAP_TYPE_afip3__FECAERequest (12)
/* complex XML schema type 'afip3:FECAERequest': */
class SOAP_CMAC afip3__FECAERequest {
      public:
        /// Optional element 'afip3:FeCabReq' of XML schema type 'afip3:FECAECabRequest'
        afip3__FECAECabRequest *FeCabReq;
        /// Optional element 'afip3:FeDetReq' of XML schema type 'afip3:ArrayOfFECAEDetRequest'
        afip3__ArrayOfFECAEDetRequest *FeDetReq;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__FECAERequest
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__FECAERequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__FECAERequest, default initialized and not managed by a soap context
        virtual afip3__FECAERequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__FECAERequest); }
      public:
        /// Constructor with default initializations
        afip3__FECAERequest() : FeCabReq(), FeDetReq(), soap() { }
        virtual ~afip3__FECAERequest() { }
        /// Friend allocator used by soap_new_afip3__FECAERequest(struct soap*, int)
        friend SOAP_FMAC1 afip3__FECAERequest * SOAP_FMAC2 soap_instantiate_afip3__FECAERequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:176 */
#ifndef SOAP_TYPE_afip3__FECabRequest
#define SOAP_TYPE_afip3__FECabRequest (14)
/* complex XML schema type 'afip3:FECabRequest': */
class SOAP_CMAC afip3__FECabRequest {
      public:
        /// Required element 'afip3:CantReg' of XML schema type 'xsd:int'
        int CantReg;
        /// Required element 'afip3:PtoVta' of XML schema type 'xsd:int'
        int PtoVta;
        /// Required element 'afip3:CbteTipo' of XML schema type 'xsd:int'
        int CbteTipo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__FECabRequest
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__FECabRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__FECabRequest, default initialized and not managed by a soap context
        virtual afip3__FECabRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__FECabRequest); }
      public:
        /// Constructor with default initializations
        afip3__FECabRequest() : CantReg(), PtoVta(), CbteTipo(), soap() { }
        virtual ~afip3__FECabRequest() { }
        /// Friend allocator used by soap_new_afip3__FECabRequest(struct soap*, int)
        friend SOAP_FMAC1 afip3__FECabRequest * SOAP_FMAC2 soap_instantiate_afip3__FECabRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:178 */
#ifndef SOAP_TYPE_afip3__ArrayOfFECAEDetRequest
#define SOAP_TYPE_afip3__ArrayOfFECAEDetRequest (15)
/* complex XML schema type 'afip3:ArrayOfFECAEDetRequest': */
class SOAP_CMAC afip3__ArrayOfFECAEDetRequest {
      public:
        /// Optional element 'afip3:FECAEDetRequest' of XML schema type 'afip3:FECAEDetRequest'
        std::vector<afip3__FECAEDetRequest *> FECAEDetRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__ArrayOfFECAEDetRequest
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__ArrayOfFECAEDetRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__ArrayOfFECAEDetRequest, default initialized and not managed by a soap context
        virtual afip3__ArrayOfFECAEDetRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__ArrayOfFECAEDetRequest); }
      public:
        /// Constructor with default initializations
        afip3__ArrayOfFECAEDetRequest() : FECAEDetRequest(), soap() { }
        virtual ~afip3__ArrayOfFECAEDetRequest() { }
        /// Friend allocator used by soap_new_afip3__ArrayOfFECAEDetRequest(struct soap*, int)
        friend SOAP_FMAC1 afip3__ArrayOfFECAEDetRequest * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfFECAEDetRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:182 */
#ifndef SOAP_TYPE_afip3__FEDetRequest
#define SOAP_TYPE_afip3__FEDetRequest (17)
/* complex XML schema type 'afip3:FEDetRequest': */
class SOAP_CMAC afip3__FEDetRequest {
      public:
        /// Required element 'afip3:Concepto' of XML schema type 'xsd:int'
        int Concepto;
        /// Required element 'afip3:DocTipo' of XML schema type 'xsd:int'
        int DocTipo;
        /// Required element 'afip3:DocNro' of XML schema type 'xsd:long'
        LONG64 DocNro;
        /// Required element 'afip3:CbteDesde' of XML schema type 'xsd:long'
        LONG64 CbteDesde;
        /// Required element 'afip3:CbteHasta' of XML schema type 'xsd:long'
        LONG64 CbteHasta;
        /// Optional element 'afip3:CbteFch' of XML schema type 'xsd:string'
        std::string *CbteFch;
        /// Required element 'afip3:ImpTotal' of XML schema type 'xsd:double'
        double ImpTotal;
        /// Required element 'afip3:ImpTotConc' of XML schema type 'xsd:double'
        double ImpTotConc;
        /// Required element 'afip3:ImpNeto' of XML schema type 'xsd:double'
        double ImpNeto;
        /// Required element 'afip3:ImpOpEx' of XML schema type 'xsd:double'
        double ImpOpEx;
        /// Required element 'afip3:ImpTrib' of XML schema type 'xsd:double'
        double ImpTrib;
        /// Required element 'afip3:ImpIVA' of XML schema type 'xsd:double'
        double ImpIVA;
        /// Optional element 'afip3:FchServDesde' of XML schema type 'xsd:string'
        std::string *FchServDesde;
        /// Optional element 'afip3:FchServHasta' of XML schema type 'xsd:string'
        std::string *FchServHasta;
        /// Optional element 'afip3:FchVtoPago' of XML schema type 'xsd:string'
        std::string *FchVtoPago;
        /// Optional element 'afip3:MonId' of XML schema type 'xsd:string'
        std::string *MonId;
        /// Required element 'afip3:MonCotiz' of XML schema type 'xsd:double'
        double MonCotiz;
        /// Optional element 'afip3:CbtesAsoc' of XML schema type 'afip3:ArrayOfCbteAsoc'
        afip3__ArrayOfCbteAsoc *CbtesAsoc;
        /// Optional element 'afip3:Tributos' of XML schema type 'afip3:ArrayOfTributo'
        afip3__ArrayOfTributo *Tributos;
        /// Optional element 'afip3:Iva' of XML schema type 'afip3:ArrayOfAlicIva'
        afip3__ArrayOfAlicIva *Iva;
        /// Optional element 'afip3:Opcionales' of XML schema type 'afip3:ArrayOfOpcional'
        afip3__ArrayOfOpcional *Opcionales;
        /// Optional element 'afip3:Compradores' of XML schema type 'afip3:ArrayOfComprador'
        afip3__ArrayOfComprador *Compradores;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__FEDetRequest
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__FEDetRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__FEDetRequest, default initialized and not managed by a soap context
        virtual afip3__FEDetRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__FEDetRequest); }
      public:
        /// Constructor with default initializations
        afip3__FEDetRequest() : Concepto(), DocTipo(), DocNro(), CbteDesde(), CbteHasta(), CbteFch(), ImpTotal(), ImpTotConc(), ImpNeto(), ImpOpEx(), ImpTrib(), ImpIVA(), FchServDesde(), FchServHasta(), FchVtoPago(), MonId(), MonCotiz(), CbtesAsoc(), Tributos(), Iva(), Opcionales(), Compradores(), soap() { }
        virtual ~afip3__FEDetRequest() { }
        /// Friend allocator used by soap_new_afip3__FEDetRequest(struct soap*, int)
        friend SOAP_FMAC1 afip3__FEDetRequest * SOAP_FMAC2 soap_instantiate_afip3__FEDetRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:184 */
#ifndef SOAP_TYPE_afip3__ArrayOfCbteAsoc
#define SOAP_TYPE_afip3__ArrayOfCbteAsoc (18)
/* complex XML schema type 'afip3:ArrayOfCbteAsoc': */
class SOAP_CMAC afip3__ArrayOfCbteAsoc {
      public:
        /// Optional element 'afip3:CbteAsoc' of XML schema type 'afip3:CbteAsoc'
        std::vector<afip3__CbteAsoc *> CbteAsoc;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__ArrayOfCbteAsoc
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__ArrayOfCbteAsoc; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__ArrayOfCbteAsoc, default initialized and not managed by a soap context
        virtual afip3__ArrayOfCbteAsoc *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__ArrayOfCbteAsoc); }
      public:
        /// Constructor with default initializations
        afip3__ArrayOfCbteAsoc() : CbteAsoc(), soap() { }
        virtual ~afip3__ArrayOfCbteAsoc() { }
        /// Friend allocator used by soap_new_afip3__ArrayOfCbteAsoc(struct soap*, int)
        friend SOAP_FMAC1 afip3__ArrayOfCbteAsoc * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfCbteAsoc(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:186 */
#ifndef SOAP_TYPE_afip3__CbteAsoc
#define SOAP_TYPE_afip3__CbteAsoc (19)
/* complex XML schema type 'afip3:CbteAsoc': */
class SOAP_CMAC afip3__CbteAsoc {
      public:
        /// Required element 'afip3:Tipo' of XML schema type 'xsd:int'
        int Tipo;
        /// Required element 'afip3:PtoVta' of XML schema type 'xsd:int'
        int PtoVta;
        /// Required element 'afip3:Nro' of XML schema type 'xsd:long'
        LONG64 Nro;
        /// Optional element 'afip3:Cuit' of XML schema type 'xsd:string'
        std::string *Cuit;
        /// Optional element 'afip3:CbteFch' of XML schema type 'xsd:string'
        std::string *CbteFch;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__CbteAsoc
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__CbteAsoc; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__CbteAsoc, default initialized and not managed by a soap context
        virtual afip3__CbteAsoc *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__CbteAsoc); }
      public:
        /// Constructor with default initializations
        afip3__CbteAsoc() : Tipo(), PtoVta(), Nro(), Cuit(), CbteFch(), soap() { }
        virtual ~afip3__CbteAsoc() { }
        /// Friend allocator used by soap_new_afip3__CbteAsoc(struct soap*, int)
        friend SOAP_FMAC1 afip3__CbteAsoc * SOAP_FMAC2 soap_instantiate_afip3__CbteAsoc(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:188 */
#ifndef SOAP_TYPE_afip3__ArrayOfTributo
#define SOAP_TYPE_afip3__ArrayOfTributo (20)
/* complex XML schema type 'afip3:ArrayOfTributo': */
class SOAP_CMAC afip3__ArrayOfTributo {
      public:
        /// Optional element 'afip3:Tributo' of XML schema type 'afip3:Tributo'
        std::vector<afip3__Tributo *> Tributo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__ArrayOfTributo
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__ArrayOfTributo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__ArrayOfTributo, default initialized and not managed by a soap context
        virtual afip3__ArrayOfTributo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__ArrayOfTributo); }
      public:
        /// Constructor with default initializations
        afip3__ArrayOfTributo() : Tributo(), soap() { }
        virtual ~afip3__ArrayOfTributo() { }
        /// Friend allocator used by soap_new_afip3__ArrayOfTributo(struct soap*, int)
        friend SOAP_FMAC1 afip3__ArrayOfTributo * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfTributo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:190 */
#ifndef SOAP_TYPE_afip3__Tributo
#define SOAP_TYPE_afip3__Tributo (21)
/* complex XML schema type 'afip3:Tributo': */
class SOAP_CMAC afip3__Tributo {
      public:
        /// Required element 'afip3:Id' of XML schema type 'xsd:short'
        short Id;
        /// Optional element 'afip3:Desc' of XML schema type 'xsd:string'
        std::string *Desc;
        /// Required element 'afip3:BaseImp' of XML schema type 'xsd:double'
        double BaseImp;
        /// Required element 'afip3:Alic' of XML schema type 'xsd:double'
        double Alic;
        /// Required element 'afip3:Importe' of XML schema type 'xsd:double'
        double Importe;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__Tributo
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__Tributo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__Tributo, default initialized and not managed by a soap context
        virtual afip3__Tributo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__Tributo); }
      public:
        /// Constructor with default initializations
        afip3__Tributo() : Id(), Desc(), BaseImp(), Alic(), Importe(), soap() { }
        virtual ~afip3__Tributo() { }
        /// Friend allocator used by soap_new_afip3__Tributo(struct soap*, int)
        friend SOAP_FMAC1 afip3__Tributo * SOAP_FMAC2 soap_instantiate_afip3__Tributo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:192 */
#ifndef SOAP_TYPE_afip3__ArrayOfAlicIva
#define SOAP_TYPE_afip3__ArrayOfAlicIva (22)
/* complex XML schema type 'afip3:ArrayOfAlicIva': */
class SOAP_CMAC afip3__ArrayOfAlicIva {
      public:
        /// Optional element 'afip3:AlicIva' of XML schema type 'afip3:AlicIva'
        std::vector<afip3__AlicIva *> AlicIva;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__ArrayOfAlicIva
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__ArrayOfAlicIva; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__ArrayOfAlicIva, default initialized and not managed by a soap context
        virtual afip3__ArrayOfAlicIva *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__ArrayOfAlicIva); }
      public:
        /// Constructor with default initializations
        afip3__ArrayOfAlicIva() : AlicIva(), soap() { }
        virtual ~afip3__ArrayOfAlicIva() { }
        /// Friend allocator used by soap_new_afip3__ArrayOfAlicIva(struct soap*, int)
        friend SOAP_FMAC1 afip3__ArrayOfAlicIva * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfAlicIva(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:194 */
#ifndef SOAP_TYPE_afip3__AlicIva
#define SOAP_TYPE_afip3__AlicIva (23)
/* complex XML schema type 'afip3:AlicIva': */
class SOAP_CMAC afip3__AlicIva {
      public:
        /// Required element 'afip3:Id' of XML schema type 'xsd:int'
        int Id;
        /// Required element 'afip3:BaseImp' of XML schema type 'xsd:double'
        double BaseImp;
        /// Required element 'afip3:Importe' of XML schema type 'xsd:double'
        double Importe;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__AlicIva
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__AlicIva; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__AlicIva, default initialized and not managed by a soap context
        virtual afip3__AlicIva *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__AlicIva); }
      public:
        /// Constructor with default initializations
        afip3__AlicIva() : Id(), BaseImp(), Importe(), soap() { }
        virtual ~afip3__AlicIva() { }
        /// Friend allocator used by soap_new_afip3__AlicIva(struct soap*, int)
        friend SOAP_FMAC1 afip3__AlicIva * SOAP_FMAC2 soap_instantiate_afip3__AlicIva(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:196 */
#ifndef SOAP_TYPE_afip3__ArrayOfOpcional
#define SOAP_TYPE_afip3__ArrayOfOpcional (24)
/* complex XML schema type 'afip3:ArrayOfOpcional': */
class SOAP_CMAC afip3__ArrayOfOpcional {
      public:
        /// Optional element 'afip3:Opcional' of XML schema type 'afip3:Opcional'
        std::vector<afip3__Opcional *> Opcional;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__ArrayOfOpcional
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__ArrayOfOpcional; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__ArrayOfOpcional, default initialized and not managed by a soap context
        virtual afip3__ArrayOfOpcional *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__ArrayOfOpcional); }
      public:
        /// Constructor with default initializations
        afip3__ArrayOfOpcional() : Opcional(), soap() { }
        virtual ~afip3__ArrayOfOpcional() { }
        /// Friend allocator used by soap_new_afip3__ArrayOfOpcional(struct soap*, int)
        friend SOAP_FMAC1 afip3__ArrayOfOpcional * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfOpcional(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:198 */
#ifndef SOAP_TYPE_afip3__Opcional
#define SOAP_TYPE_afip3__Opcional (25)
/* complex XML schema type 'afip3:Opcional': */
class SOAP_CMAC afip3__Opcional {
      public:
        /// Optional element 'afip3:Id' of XML schema type 'xsd:string'
        std::string *Id;
        /// Optional element 'afip3:Valor' of XML schema type 'xsd:string'
        std::string *Valor;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__Opcional
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__Opcional; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__Opcional, default initialized and not managed by a soap context
        virtual afip3__Opcional *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__Opcional); }
      public:
        /// Constructor with default initializations
        afip3__Opcional() : Id(), Valor(), soap() { }
        virtual ~afip3__Opcional() { }
        /// Friend allocator used by soap_new_afip3__Opcional(struct soap*, int)
        friend SOAP_FMAC1 afip3__Opcional * SOAP_FMAC2 soap_instantiate_afip3__Opcional(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:200 */
#ifndef SOAP_TYPE_afip3__ArrayOfComprador
#define SOAP_TYPE_afip3__ArrayOfComprador (26)
/* complex XML schema type 'afip3:ArrayOfComprador': */
class SOAP_CMAC afip3__ArrayOfComprador {
      public:
        /// Optional element 'afip3:Comprador' of XML schema type 'afip3:Comprador'
        std::vector<afip3__Comprador *> Comprador;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__ArrayOfComprador
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__ArrayOfComprador; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__ArrayOfComprador, default initialized and not managed by a soap context
        virtual afip3__ArrayOfComprador *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__ArrayOfComprador); }
      public:
        /// Constructor with default initializations
        afip3__ArrayOfComprador() : Comprador(), soap() { }
        virtual ~afip3__ArrayOfComprador() { }
        /// Friend allocator used by soap_new_afip3__ArrayOfComprador(struct soap*, int)
        friend SOAP_FMAC1 afip3__ArrayOfComprador * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfComprador(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:202 */
#ifndef SOAP_TYPE_afip3__Comprador
#define SOAP_TYPE_afip3__Comprador (27)
/* complex XML schema type 'afip3:Comprador': */
class SOAP_CMAC afip3__Comprador {
      public:
        /// Required element 'afip3:DocTipo' of XML schema type 'xsd:int'
        int DocTipo;
        /// Required element 'afip3:DocNro' of XML schema type 'xsd:long'
        LONG64 DocNro;
        /// Required element 'afip3:Porcentaje' of XML schema type 'xsd:double'
        double Porcentaje;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__Comprador
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__Comprador; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__Comprador, default initialized and not managed by a soap context
        virtual afip3__Comprador *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__Comprador); }
      public:
        /// Constructor with default initializations
        afip3__Comprador() : DocTipo(), DocNro(), Porcentaje(), soap() { }
        virtual ~afip3__Comprador() { }
        /// Friend allocator used by soap_new_afip3__Comprador(struct soap*, int)
        friend SOAP_FMAC1 afip3__Comprador * SOAP_FMAC2 soap_instantiate_afip3__Comprador(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:204 */
#ifndef SOAP_TYPE_afip3__FECAEResponse
#define SOAP_TYPE_afip3__FECAEResponse (28)
/* complex XML schema type 'afip3:FECAEResponse': */
class SOAP_CMAC afip3__FECAEResponse {
      public:
        /// Optional element 'afip3:FeCabResp' of XML schema type 'afip3:FECAECabResponse'
        afip3__FECAECabResponse *FeCabResp;
        /// Optional element 'afip3:FeDetResp' of XML schema type 'afip3:ArrayOfFECAEDetResponse'
        afip3__ArrayOfFECAEDetResponse *FeDetResp;
        /// Optional element 'afip3:Events' of XML schema type 'afip3:ArrayOfEvt'
        afip3__ArrayOfEvt *Events;
        /// Optional element 'afip3:Errors' of XML schema type 'afip3:ArrayOfErr'
        afip3__ArrayOfErr *Errors;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__FECAEResponse
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__FECAEResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__FECAEResponse, default initialized and not managed by a soap context
        virtual afip3__FECAEResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__FECAEResponse); }
      public:
        /// Constructor with default initializations
        afip3__FECAEResponse() : FeCabResp(), FeDetResp(), Events(), Errors(), soap() { }
        virtual ~afip3__FECAEResponse() { }
        /// Friend allocator used by soap_new_afip3__FECAEResponse(struct soap*, int)
        friend SOAP_FMAC1 afip3__FECAEResponse * SOAP_FMAC2 soap_instantiate_afip3__FECAEResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:208 */
#ifndef SOAP_TYPE_afip3__FECabResponse
#define SOAP_TYPE_afip3__FECabResponse (30)
/* complex XML schema type 'afip3:FECabResponse': */
class SOAP_CMAC afip3__FECabResponse {
      public:
        /// Required element 'afip3:Cuit' of XML schema type 'xsd:long'
        LONG64 Cuit;
        /// Required element 'afip3:PtoVta' of XML schema type 'xsd:int'
        int PtoVta;
        /// Required element 'afip3:CbteTipo' of XML schema type 'xsd:int'
        int CbteTipo;
        /// Optional element 'afip3:FchProceso' of XML schema type 'xsd:string'
        std::string *FchProceso;
        /// Required element 'afip3:CantReg' of XML schema type 'xsd:int'
        int CantReg;
        /// Optional element 'afip3:Resultado' of XML schema type 'xsd:string'
        std::string *Resultado;
        /// Optional element 'afip3:Reproceso' of XML schema type 'xsd:string'
        std::string *Reproceso;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__FECabResponse
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__FECabResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__FECabResponse, default initialized and not managed by a soap context
        virtual afip3__FECabResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__FECabResponse); }
      public:
        /// Constructor with default initializations
        afip3__FECabResponse() : Cuit(), PtoVta(), CbteTipo(), FchProceso(), CantReg(), Resultado(), Reproceso(), soap() { }
        virtual ~afip3__FECabResponse() { }
        /// Friend allocator used by soap_new_afip3__FECabResponse(struct soap*, int)
        friend SOAP_FMAC1 afip3__FECabResponse * SOAP_FMAC2 soap_instantiate_afip3__FECabResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:210 */
#ifndef SOAP_TYPE_afip3__ArrayOfFECAEDetResponse
#define SOAP_TYPE_afip3__ArrayOfFECAEDetResponse (31)
/* complex XML schema type 'afip3:ArrayOfFECAEDetResponse': */
class SOAP_CMAC afip3__ArrayOfFECAEDetResponse {
      public:
        /// Optional element 'afip3:FECAEDetResponse' of XML schema type 'afip3:FECAEDetResponse'
        std::vector<afip3__FECAEDetResponse *> FECAEDetResponse;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__ArrayOfFECAEDetResponse
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__ArrayOfFECAEDetResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__ArrayOfFECAEDetResponse, default initialized and not managed by a soap context
        virtual afip3__ArrayOfFECAEDetResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__ArrayOfFECAEDetResponse); }
      public:
        /// Constructor with default initializations
        afip3__ArrayOfFECAEDetResponse() : FECAEDetResponse(), soap() { }
        virtual ~afip3__ArrayOfFECAEDetResponse() { }
        /// Friend allocator used by soap_new_afip3__ArrayOfFECAEDetResponse(struct soap*, int)
        friend SOAP_FMAC1 afip3__ArrayOfFECAEDetResponse * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfFECAEDetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:214 */
#ifndef SOAP_TYPE_afip3__FEDetResponse
#define SOAP_TYPE_afip3__FEDetResponse (33)
/* complex XML schema type 'afip3:FEDetResponse': */
class SOAP_CMAC afip3__FEDetResponse {
      public:
        /// Required element 'afip3:Concepto' of XML schema type 'xsd:int'
        int Concepto;
        /// Required element 'afip3:DocTipo' of XML schema type 'xsd:int'
        int DocTipo;
        /// Required element 'afip3:DocNro' of XML schema type 'xsd:long'
        LONG64 DocNro;
        /// Required element 'afip3:CbteDesde' of XML schema type 'xsd:long'
        LONG64 CbteDesde;
        /// Required element 'afip3:CbteHasta' of XML schema type 'xsd:long'
        LONG64 CbteHasta;
        /// Optional element 'afip3:CbteFch' of XML schema type 'xsd:string'
        std::string *CbteFch;
        /// Optional element 'afip3:Resultado' of XML schema type 'xsd:string'
        std::string *Resultado;
        /// Optional element 'afip3:Observaciones' of XML schema type 'afip3:ArrayOfObs'
        afip3__ArrayOfObs *Observaciones;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__FEDetResponse
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__FEDetResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__FEDetResponse, default initialized and not managed by a soap context
        virtual afip3__FEDetResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__FEDetResponse); }
      public:
        /// Constructor with default initializations
        afip3__FEDetResponse() : Concepto(), DocTipo(), DocNro(), CbteDesde(), CbteHasta(), CbteFch(), Resultado(), Observaciones(), soap() { }
        virtual ~afip3__FEDetResponse() { }
        /// Friend allocator used by soap_new_afip3__FEDetResponse(struct soap*, int)
        friend SOAP_FMAC1 afip3__FEDetResponse * SOAP_FMAC2 soap_instantiate_afip3__FEDetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:216 */
#ifndef SOAP_TYPE_afip3__ArrayOfObs
#define SOAP_TYPE_afip3__ArrayOfObs (34)
/* complex XML schema type 'afip3:ArrayOfObs': */
class SOAP_CMAC afip3__ArrayOfObs {
      public:
        /// Optional element 'afip3:Obs' of XML schema type 'afip3:Obs'
        std::vector<afip3__Obs *> Obs;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__ArrayOfObs
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__ArrayOfObs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__ArrayOfObs, default initialized and not managed by a soap context
        virtual afip3__ArrayOfObs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__ArrayOfObs); }
      public:
        /// Constructor with default initializations
        afip3__ArrayOfObs() : Obs(), soap() { }
        virtual ~afip3__ArrayOfObs() { }
        /// Friend allocator used by soap_new_afip3__ArrayOfObs(struct soap*, int)
        friend SOAP_FMAC1 afip3__ArrayOfObs * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfObs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:218 */
#ifndef SOAP_TYPE_afip3__Obs
#define SOAP_TYPE_afip3__Obs (35)
/* complex XML schema type 'afip3:Obs': */
class SOAP_CMAC afip3__Obs {
      public:
        /// Required element 'afip3:Code' of XML schema type 'xsd:int'
        int Code;
        /// Optional element 'afip3:Msg' of XML schema type 'xsd:string'
        std::string *Msg;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__Obs
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__Obs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__Obs, default initialized and not managed by a soap context
        virtual afip3__Obs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__Obs); }
      public:
        /// Constructor with default initializations
        afip3__Obs() : Code(), Msg(), soap() { }
        virtual ~afip3__Obs() { }
        /// Friend allocator used by soap_new_afip3__Obs(struct soap*, int)
        friend SOAP_FMAC1 afip3__Obs * SOAP_FMAC2 soap_instantiate_afip3__Obs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:220 */
#ifndef SOAP_TYPE_afip3__ArrayOfEvt
#define SOAP_TYPE_afip3__ArrayOfEvt (36)
/* complex XML schema type 'afip3:ArrayOfEvt': */
class SOAP_CMAC afip3__ArrayOfEvt {
      public:
        /// Optional element 'afip3:Evt' of XML schema type 'afip3:Evt'
        std::vector<afip3__Evt *> Evt;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__ArrayOfEvt
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__ArrayOfEvt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__ArrayOfEvt, default initialized and not managed by a soap context
        virtual afip3__ArrayOfEvt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__ArrayOfEvt); }
      public:
        /// Constructor with default initializations
        afip3__ArrayOfEvt() : Evt(), soap() { }
        virtual ~afip3__ArrayOfEvt() { }
        /// Friend allocator used by soap_new_afip3__ArrayOfEvt(struct soap*, int)
        friend SOAP_FMAC1 afip3__ArrayOfEvt * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfEvt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:222 */
#ifndef SOAP_TYPE_afip3__Evt
#define SOAP_TYPE_afip3__Evt (37)
/* complex XML schema type 'afip3:Evt': */
class SOAP_CMAC afip3__Evt {
      public:
        /// Required element 'afip3:Code' of XML schema type 'xsd:int'
        int Code;
        /// Optional element 'afip3:Msg' of XML schema type 'xsd:string'
        std::string *Msg;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__Evt
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__Evt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__Evt, default initialized and not managed by a soap context
        virtual afip3__Evt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__Evt); }
      public:
        /// Constructor with default initializations
        afip3__Evt() : Code(), Msg(), soap() { }
        virtual ~afip3__Evt() { }
        /// Friend allocator used by soap_new_afip3__Evt(struct soap*, int)
        friend SOAP_FMAC1 afip3__Evt * SOAP_FMAC2 soap_instantiate_afip3__Evt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:224 */
#ifndef SOAP_TYPE_afip3__ArrayOfErr
#define SOAP_TYPE_afip3__ArrayOfErr (38)
/* complex XML schema type 'afip3:ArrayOfErr': */
class SOAP_CMAC afip3__ArrayOfErr {
      public:
        /// Optional element 'afip3:Err' of XML schema type 'afip3:Err'
        std::vector<afip3__Err *> Err;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__ArrayOfErr
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__ArrayOfErr; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__ArrayOfErr, default initialized and not managed by a soap context
        virtual afip3__ArrayOfErr *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__ArrayOfErr); }
      public:
        /// Constructor with default initializations
        afip3__ArrayOfErr() : Err(), soap() { }
        virtual ~afip3__ArrayOfErr() { }
        /// Friend allocator used by soap_new_afip3__ArrayOfErr(struct soap*, int)
        friend SOAP_FMAC1 afip3__ArrayOfErr * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfErr(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:226 */
#ifndef SOAP_TYPE_afip3__Err
#define SOAP_TYPE_afip3__Err (39)
/* complex XML schema type 'afip3:Err': */
class SOAP_CMAC afip3__Err {
      public:
        /// Required element 'afip3:Code' of XML schema type 'xsd:int'
        int Code;
        /// Optional element 'afip3:Msg' of XML schema type 'xsd:string'
        std::string *Msg;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__Err
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__Err; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__Err, default initialized and not managed by a soap context
        virtual afip3__Err *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__Err); }
      public:
        /// Constructor with default initializations
        afip3__Err() : Code(), Msg(), soap() { }
        virtual ~afip3__Err() { }
        /// Friend allocator used by soap_new_afip3__Err(struct soap*, int)
        friend SOAP_FMAC1 afip3__Err * SOAP_FMAC2 soap_instantiate_afip3__Err(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:228 */
#ifndef SOAP_TYPE_afip3__FERegXReqResponse
#define SOAP_TYPE_afip3__FERegXReqResponse (40)
/* complex XML schema type 'afip3:FERegXReqResponse': */
class SOAP_CMAC afip3__FERegXReqResponse {
      public:
        /// Required element 'afip3:RegXReq' of XML schema type 'xsd:int'
        int RegXReq;
        /// Optional element 'afip3:Errors' of XML schema type 'afip3:ArrayOfErr'
        afip3__ArrayOfErr *Errors;
        /// Optional element 'afip3:Events' of XML schema type 'afip3:ArrayOfEvt'
        afip3__ArrayOfEvt *Events;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__FERegXReqResponse
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__FERegXReqResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__FERegXReqResponse, default initialized and not managed by a soap context
        virtual afip3__FERegXReqResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__FERegXReqResponse); }
      public:
        /// Constructor with default initializations
        afip3__FERegXReqResponse() : RegXReq(), Errors(), Events(), soap() { }
        virtual ~afip3__FERegXReqResponse() { }
        /// Friend allocator used by soap_new_afip3__FERegXReqResponse(struct soap*, int)
        friend SOAP_FMAC1 afip3__FERegXReqResponse * SOAP_FMAC2 soap_instantiate_afip3__FERegXReqResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:230 */
#ifndef SOAP_TYPE_afip3__DummyResponse
#define SOAP_TYPE_afip3__DummyResponse (41)
/* complex XML schema type 'afip3:DummyResponse': */
class SOAP_CMAC afip3__DummyResponse {
      public:
        /// Optional element 'afip3:AppServer' of XML schema type 'xsd:string'
        std::string *AppServer;
        /// Optional element 'afip3:DbServer' of XML schema type 'xsd:string'
        std::string *DbServer;
        /// Optional element 'afip3:AuthServer' of XML schema type 'xsd:string'
        std::string *AuthServer;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__DummyResponse
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__DummyResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__DummyResponse, default initialized and not managed by a soap context
        virtual afip3__DummyResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__DummyResponse); }
      public:
        /// Constructor with default initializations
        afip3__DummyResponse() : AppServer(), DbServer(), AuthServer(), soap() { }
        virtual ~afip3__DummyResponse() { }
        /// Friend allocator used by soap_new_afip3__DummyResponse(struct soap*, int)
        friend SOAP_FMAC1 afip3__DummyResponse * SOAP_FMAC2 soap_instantiate_afip3__DummyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:232 */
#ifndef SOAP_TYPE_afip3__FERecuperaLastCbteResponse
#define SOAP_TYPE_afip3__FERecuperaLastCbteResponse (42)
/* complex XML schema type 'afip3:FERecuperaLastCbteResponse': */
class SOAP_CMAC afip3__FERecuperaLastCbteResponse {
      public:
        /// Required element 'afip3:PtoVta' of XML schema type 'xsd:int'
        int PtoVta;
        /// Required element 'afip3:CbteTipo' of XML schema type 'xsd:int'
        int CbteTipo;
        /// Required element 'afip3:CbteNro' of XML schema type 'xsd:int'
        int CbteNro;
        /// Optional element 'afip3:Errors' of XML schema type 'afip3:ArrayOfErr'
        afip3__ArrayOfErr *Errors;
        /// Optional element 'afip3:Events' of XML schema type 'afip3:ArrayOfEvt'
        afip3__ArrayOfEvt *Events;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__FERecuperaLastCbteResponse
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__FERecuperaLastCbteResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__FERecuperaLastCbteResponse, default initialized and not managed by a soap context
        virtual afip3__FERecuperaLastCbteResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__FERecuperaLastCbteResponse); }
      public:
        /// Constructor with default initializations
        afip3__FERecuperaLastCbteResponse() : PtoVta(), CbteTipo(), CbteNro(), Errors(), Events(), soap() { }
        virtual ~afip3__FERecuperaLastCbteResponse() { }
        /// Friend allocator used by soap_new_afip3__FERecuperaLastCbteResponse(struct soap*, int)
        friend SOAP_FMAC1 afip3__FERecuperaLastCbteResponse * SOAP_FMAC2 soap_instantiate_afip3__FERecuperaLastCbteResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:234 */
#ifndef SOAP_TYPE_afip3__FECompConsultaReq
#define SOAP_TYPE_afip3__FECompConsultaReq (43)
/* complex XML schema type 'afip3:FECompConsultaReq': */
class SOAP_CMAC afip3__FECompConsultaReq {
      public:
        /// Required element 'afip3:CbteTipo' of XML schema type 'xsd:int'
        int CbteTipo;
        /// Required element 'afip3:CbteNro' of XML schema type 'xsd:long'
        LONG64 CbteNro;
        /// Required element 'afip3:PtoVta' of XML schema type 'xsd:int'
        int PtoVta;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__FECompConsultaReq
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__FECompConsultaReq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__FECompConsultaReq, default initialized and not managed by a soap context
        virtual afip3__FECompConsultaReq *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__FECompConsultaReq); }
      public:
        /// Constructor with default initializations
        afip3__FECompConsultaReq() : CbteTipo(), CbteNro(), PtoVta(), soap() { }
        virtual ~afip3__FECompConsultaReq() { }
        /// Friend allocator used by soap_new_afip3__FECompConsultaReq(struct soap*, int)
        friend SOAP_FMAC1 afip3__FECompConsultaReq * SOAP_FMAC2 soap_instantiate_afip3__FECompConsultaReq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:236 */
#ifndef SOAP_TYPE_afip3__FECompConsultaResponse
#define SOAP_TYPE_afip3__FECompConsultaResponse (44)
/* complex XML schema type 'afip3:FECompConsultaResponse': */
class SOAP_CMAC afip3__FECompConsultaResponse {
      public:
        /// Optional element 'afip3:ResultGet' of XML schema type 'afip3:FECompConsResponse'
        afip3__FECompConsResponse *ResultGet;
        /// Optional element 'afip3:Errors' of XML schema type 'afip3:ArrayOfErr'
        afip3__ArrayOfErr *Errors;
        /// Optional element 'afip3:Events' of XML schema type 'afip3:ArrayOfEvt'
        afip3__ArrayOfEvt *Events;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__FECompConsultaResponse
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__FECompConsultaResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__FECompConsultaResponse, default initialized and not managed by a soap context
        virtual afip3__FECompConsultaResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__FECompConsultaResponse); }
      public:
        /// Constructor with default initializations
        afip3__FECompConsultaResponse() : ResultGet(), Errors(), Events(), soap() { }
        virtual ~afip3__FECompConsultaResponse() { }
        /// Friend allocator used by soap_new_afip3__FECompConsultaResponse(struct soap*, int)
        friend SOAP_FMAC1 afip3__FECompConsultaResponse * SOAP_FMAC2 soap_instantiate_afip3__FECompConsultaResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:240 */
#ifndef SOAP_TYPE_afip3__FECAEARequest
#define SOAP_TYPE_afip3__FECAEARequest (46)
/* complex XML schema type 'afip3:FECAEARequest': */
class SOAP_CMAC afip3__FECAEARequest {
      public:
        /// Optional element 'afip3:FeCabReq' of XML schema type 'afip3:FECAEACabRequest'
        afip3__FECAEACabRequest *FeCabReq;
        /// Optional element 'afip3:FeDetReq' of XML schema type 'afip3:ArrayOfFECAEADetRequest'
        afip3__ArrayOfFECAEADetRequest *FeDetReq;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__FECAEARequest
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__FECAEARequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__FECAEARequest, default initialized and not managed by a soap context
        virtual afip3__FECAEARequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__FECAEARequest); }
      public:
        /// Constructor with default initializations
        afip3__FECAEARequest() : FeCabReq(), FeDetReq(), soap() { }
        virtual ~afip3__FECAEARequest() { }
        /// Friend allocator used by soap_new_afip3__FECAEARequest(struct soap*, int)
        friend SOAP_FMAC1 afip3__FECAEARequest * SOAP_FMAC2 soap_instantiate_afip3__FECAEARequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:244 */
#ifndef SOAP_TYPE_afip3__ArrayOfFECAEADetRequest
#define SOAP_TYPE_afip3__ArrayOfFECAEADetRequest (48)
/* complex XML schema type 'afip3:ArrayOfFECAEADetRequest': */
class SOAP_CMAC afip3__ArrayOfFECAEADetRequest {
      public:
        /// Optional element 'afip3:FECAEADetRequest' of XML schema type 'afip3:FECAEADetRequest'
        std::vector<afip3__FECAEADetRequest *> FECAEADetRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__ArrayOfFECAEADetRequest
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__ArrayOfFECAEADetRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__ArrayOfFECAEADetRequest, default initialized and not managed by a soap context
        virtual afip3__ArrayOfFECAEADetRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__ArrayOfFECAEADetRequest); }
      public:
        /// Constructor with default initializations
        afip3__ArrayOfFECAEADetRequest() : FECAEADetRequest(), soap() { }
        virtual ~afip3__ArrayOfFECAEADetRequest() { }
        /// Friend allocator used by soap_new_afip3__ArrayOfFECAEADetRequest(struct soap*, int)
        friend SOAP_FMAC1 afip3__ArrayOfFECAEADetRequest * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfFECAEADetRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:248 */
#ifndef SOAP_TYPE_afip3__FECAEAResponse
#define SOAP_TYPE_afip3__FECAEAResponse (50)
/* complex XML schema type 'afip3:FECAEAResponse': */
class SOAP_CMAC afip3__FECAEAResponse {
      public:
        /// Optional element 'afip3:FeCabResp' of XML schema type 'afip3:FECAEACabResponse'
        afip3__FECAEACabResponse *FeCabResp;
        /// Optional element 'afip3:FeDetResp' of XML schema type 'afip3:ArrayOfFECAEADetResponse'
        afip3__ArrayOfFECAEADetResponse *FeDetResp;
        /// Optional element 'afip3:Events' of XML schema type 'afip3:ArrayOfEvt'
        afip3__ArrayOfEvt *Events;
        /// Optional element 'afip3:Errors' of XML schema type 'afip3:ArrayOfErr'
        afip3__ArrayOfErr *Errors;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__FECAEAResponse
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__FECAEAResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__FECAEAResponse, default initialized and not managed by a soap context
        virtual afip3__FECAEAResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__FECAEAResponse); }
      public:
        /// Constructor with default initializations
        afip3__FECAEAResponse() : FeCabResp(), FeDetResp(), Events(), Errors(), soap() { }
        virtual ~afip3__FECAEAResponse() { }
        /// Friend allocator used by soap_new_afip3__FECAEAResponse(struct soap*, int)
        friend SOAP_FMAC1 afip3__FECAEAResponse * SOAP_FMAC2 soap_instantiate_afip3__FECAEAResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:252 */
#ifndef SOAP_TYPE_afip3__ArrayOfFECAEADetResponse
#define SOAP_TYPE_afip3__ArrayOfFECAEADetResponse (52)
/* complex XML schema type 'afip3:ArrayOfFECAEADetResponse': */
class SOAP_CMAC afip3__ArrayOfFECAEADetResponse {
      public:
        /// Optional element 'afip3:FECAEADetResponse' of XML schema type 'afip3:FECAEADetResponse'
        std::vector<afip3__FECAEADetResponse *> FECAEADetResponse;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__ArrayOfFECAEADetResponse
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__ArrayOfFECAEADetResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__ArrayOfFECAEADetResponse, default initialized and not managed by a soap context
        virtual afip3__ArrayOfFECAEADetResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__ArrayOfFECAEADetResponse); }
      public:
        /// Constructor with default initializations
        afip3__ArrayOfFECAEADetResponse() : FECAEADetResponse(), soap() { }
        virtual ~afip3__ArrayOfFECAEADetResponse() { }
        /// Friend allocator used by soap_new_afip3__ArrayOfFECAEADetResponse(struct soap*, int)
        friend SOAP_FMAC1 afip3__ArrayOfFECAEADetResponse * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfFECAEADetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:256 */
#ifndef SOAP_TYPE_afip3__FECAEAGetResponse
#define SOAP_TYPE_afip3__FECAEAGetResponse (54)
/* complex XML schema type 'afip3:FECAEAGetResponse': */
class SOAP_CMAC afip3__FECAEAGetResponse {
      public:
        /// Optional element 'afip3:ResultGet' of XML schema type 'afip3:FECAEAGet'
        afip3__FECAEAGet *ResultGet;
        /// Optional element 'afip3:Errors' of XML schema type 'afip3:ArrayOfErr'
        afip3__ArrayOfErr *Errors;
        /// Optional element 'afip3:Events' of XML schema type 'afip3:ArrayOfEvt'
        afip3__ArrayOfEvt *Events;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__FECAEAGetResponse
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__FECAEAGetResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__FECAEAGetResponse, default initialized and not managed by a soap context
        virtual afip3__FECAEAGetResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__FECAEAGetResponse); }
      public:
        /// Constructor with default initializations
        afip3__FECAEAGetResponse() : ResultGet(), Errors(), Events(), soap() { }
        virtual ~afip3__FECAEAGetResponse() { }
        /// Friend allocator used by soap_new_afip3__FECAEAGetResponse(struct soap*, int)
        friend SOAP_FMAC1 afip3__FECAEAGetResponse * SOAP_FMAC2 soap_instantiate_afip3__FECAEAGetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:258 */
#ifndef SOAP_TYPE_afip3__FECAEAGet
#define SOAP_TYPE_afip3__FECAEAGet (55)
/* complex XML schema type 'afip3:FECAEAGet': */
class SOAP_CMAC afip3__FECAEAGet {
      public:
        /// Optional element 'afip3:CAEA' of XML schema type 'xsd:string'
        std::string *CAEA;
        /// Required element 'afip3:Periodo' of XML schema type 'xsd:int'
        int Periodo;
        /// Required element 'afip3:Orden' of XML schema type 'xsd:short'
        short Orden;
        /// Optional element 'afip3:FchVigDesde' of XML schema type 'xsd:string'
        std::string *FchVigDesde;
        /// Optional element 'afip3:FchVigHasta' of XML schema type 'xsd:string'
        std::string *FchVigHasta;
        /// Optional element 'afip3:FchTopeInf' of XML schema type 'xsd:string'
        std::string *FchTopeInf;
        /// Optional element 'afip3:FchProceso' of XML schema type 'xsd:string'
        std::string *FchProceso;
        /// Optional element 'afip3:Observaciones' of XML schema type 'afip3:ArrayOfObs'
        afip3__ArrayOfObs *Observaciones;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__FECAEAGet
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__FECAEAGet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__FECAEAGet, default initialized and not managed by a soap context
        virtual afip3__FECAEAGet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__FECAEAGet); }
      public:
        /// Constructor with default initializations
        afip3__FECAEAGet() : CAEA(), Periodo(), Orden(), FchVigDesde(), FchVigHasta(), FchTopeInf(), FchProceso(), Observaciones(), soap() { }
        virtual ~afip3__FECAEAGet() { }
        /// Friend allocator used by soap_new_afip3__FECAEAGet(struct soap*, int)
        friend SOAP_FMAC1 afip3__FECAEAGet * SOAP_FMAC2 soap_instantiate_afip3__FECAEAGet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:260 */
#ifndef SOAP_TYPE_afip3__FECAEASinMovConsResponse
#define SOAP_TYPE_afip3__FECAEASinMovConsResponse (56)
/* complex XML schema type 'afip3:FECAEASinMovConsResponse': */
class SOAP_CMAC afip3__FECAEASinMovConsResponse {
      public:
        /// Optional element 'afip3:ResultGet' of XML schema type 'afip3:ArrayOfFECAEASinMov'
        afip3__ArrayOfFECAEASinMov *ResultGet;
        /// Optional element 'afip3:Errors' of XML schema type 'afip3:ArrayOfErr'
        afip3__ArrayOfErr *Errors;
        /// Optional element 'afip3:Events' of XML schema type 'afip3:ArrayOfEvt'
        afip3__ArrayOfEvt *Events;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__FECAEASinMovConsResponse
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__FECAEASinMovConsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__FECAEASinMovConsResponse, default initialized and not managed by a soap context
        virtual afip3__FECAEASinMovConsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__FECAEASinMovConsResponse); }
      public:
        /// Constructor with default initializations
        afip3__FECAEASinMovConsResponse() : ResultGet(), Errors(), Events(), soap() { }
        virtual ~afip3__FECAEASinMovConsResponse() { }
        /// Friend allocator used by soap_new_afip3__FECAEASinMovConsResponse(struct soap*, int)
        friend SOAP_FMAC1 afip3__FECAEASinMovConsResponse * SOAP_FMAC2 soap_instantiate_afip3__FECAEASinMovConsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:262 */
#ifndef SOAP_TYPE_afip3__ArrayOfFECAEASinMov
#define SOAP_TYPE_afip3__ArrayOfFECAEASinMov (57)
/* complex XML schema type 'afip3:ArrayOfFECAEASinMov': */
class SOAP_CMAC afip3__ArrayOfFECAEASinMov {
      public:
        /// Optional element 'afip3:FECAEASinMov' of XML schema type 'afip3:FECAEASinMov'
        std::vector<afip3__FECAEASinMov *> FECAEASinMov;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__ArrayOfFECAEASinMov
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__ArrayOfFECAEASinMov; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__ArrayOfFECAEASinMov, default initialized and not managed by a soap context
        virtual afip3__ArrayOfFECAEASinMov *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__ArrayOfFECAEASinMov); }
      public:
        /// Constructor with default initializations
        afip3__ArrayOfFECAEASinMov() : FECAEASinMov(), soap() { }
        virtual ~afip3__ArrayOfFECAEASinMov() { }
        /// Friend allocator used by soap_new_afip3__ArrayOfFECAEASinMov(struct soap*, int)
        friend SOAP_FMAC1 afip3__ArrayOfFECAEASinMov * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfFECAEASinMov(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:264 */
#ifndef SOAP_TYPE_afip3__FECAEASinMov
#define SOAP_TYPE_afip3__FECAEASinMov (58)
/* complex XML schema type 'afip3:FECAEASinMov': */
class SOAP_CMAC afip3__FECAEASinMov {
      public:
        /// Optional element 'afip3:CAEA' of XML schema type 'xsd:string'
        std::string *CAEA;
        /// Optional element 'afip3:FchProceso' of XML schema type 'xsd:string'
        std::string *FchProceso;
        /// Required element 'afip3:PtoVta' of XML schema type 'xsd:int'
        int PtoVta;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__FECAEASinMov
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__FECAEASinMov; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__FECAEASinMov, default initialized and not managed by a soap context
        virtual afip3__FECAEASinMov *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__FECAEASinMov); }
      public:
        /// Constructor with default initializations
        afip3__FECAEASinMov() : CAEA(), FchProceso(), PtoVta(), soap() { }
        virtual ~afip3__FECAEASinMov() { }
        /// Friend allocator used by soap_new_afip3__FECAEASinMov(struct soap*, int)
        friend SOAP_FMAC1 afip3__FECAEASinMov * SOAP_FMAC2 soap_instantiate_afip3__FECAEASinMov(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:268 */
#ifndef SOAP_TYPE_afip3__FECotizacionResponse
#define SOAP_TYPE_afip3__FECotizacionResponse (60)
/* complex XML schema type 'afip3:FECotizacionResponse': */
class SOAP_CMAC afip3__FECotizacionResponse {
      public:
        /// Optional element 'afip3:ResultGet' of XML schema type 'afip3:Cotizacion'
        afip3__Cotizacion *ResultGet;
        /// Optional element 'afip3:Errors' of XML schema type 'afip3:ArrayOfErr'
        afip3__ArrayOfErr *Errors;
        /// Optional element 'afip3:Events' of XML schema type 'afip3:ArrayOfEvt'
        afip3__ArrayOfEvt *Events;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__FECotizacionResponse
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__FECotizacionResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__FECotizacionResponse, default initialized and not managed by a soap context
        virtual afip3__FECotizacionResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__FECotizacionResponse); }
      public:
        /// Constructor with default initializations
        afip3__FECotizacionResponse() : ResultGet(), Errors(), Events(), soap() { }
        virtual ~afip3__FECotizacionResponse() { }
        /// Friend allocator used by soap_new_afip3__FECotizacionResponse(struct soap*, int)
        friend SOAP_FMAC1 afip3__FECotizacionResponse * SOAP_FMAC2 soap_instantiate_afip3__FECotizacionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:270 */
#ifndef SOAP_TYPE_afip3__Cotizacion
#define SOAP_TYPE_afip3__Cotizacion (61)
/* complex XML schema type 'afip3:Cotizacion': */
class SOAP_CMAC afip3__Cotizacion {
      public:
        /// Optional element 'afip3:MonId' of XML schema type 'xsd:string'
        std::string *MonId;
        /// Required element 'afip3:MonCotiz' of XML schema type 'xsd:double'
        double MonCotiz;
        /// Optional element 'afip3:FchCotiz' of XML schema type 'xsd:string'
        std::string *FchCotiz;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__Cotizacion
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__Cotizacion; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__Cotizacion, default initialized and not managed by a soap context
        virtual afip3__Cotizacion *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__Cotizacion); }
      public:
        /// Constructor with default initializations
        afip3__Cotizacion() : MonId(), MonCotiz(), FchCotiz(), soap() { }
        virtual ~afip3__Cotizacion() { }
        /// Friend allocator used by soap_new_afip3__Cotizacion(struct soap*, int)
        friend SOAP_FMAC1 afip3__Cotizacion * SOAP_FMAC2 soap_instantiate_afip3__Cotizacion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:272 */
#ifndef SOAP_TYPE_afip3__FETributoResponse
#define SOAP_TYPE_afip3__FETributoResponse (62)
/* complex XML schema type 'afip3:FETributoResponse': */
class SOAP_CMAC afip3__FETributoResponse {
      public:
        /// Optional element 'afip3:ResultGet' of XML schema type 'afip3:ArrayOfTributoTipo'
        afip3__ArrayOfTributoTipo *ResultGet;
        /// Optional element 'afip3:Errors' of XML schema type 'afip3:ArrayOfErr'
        afip3__ArrayOfErr *Errors;
        /// Optional element 'afip3:Events' of XML schema type 'afip3:ArrayOfEvt'
        afip3__ArrayOfEvt *Events;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__FETributoResponse
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__FETributoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__FETributoResponse, default initialized and not managed by a soap context
        virtual afip3__FETributoResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__FETributoResponse); }
      public:
        /// Constructor with default initializations
        afip3__FETributoResponse() : ResultGet(), Errors(), Events(), soap() { }
        virtual ~afip3__FETributoResponse() { }
        /// Friend allocator used by soap_new_afip3__FETributoResponse(struct soap*, int)
        friend SOAP_FMAC1 afip3__FETributoResponse * SOAP_FMAC2 soap_instantiate_afip3__FETributoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:274 */
#ifndef SOAP_TYPE_afip3__ArrayOfTributoTipo
#define SOAP_TYPE_afip3__ArrayOfTributoTipo (63)
/* complex XML schema type 'afip3:ArrayOfTributoTipo': */
class SOAP_CMAC afip3__ArrayOfTributoTipo {
      public:
        /// Optional element 'afip3:TributoTipo' of XML schema type 'afip3:TributoTipo'
        std::vector<afip3__TributoTipo *> TributoTipo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__ArrayOfTributoTipo
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__ArrayOfTributoTipo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__ArrayOfTributoTipo, default initialized and not managed by a soap context
        virtual afip3__ArrayOfTributoTipo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__ArrayOfTributoTipo); }
      public:
        /// Constructor with default initializations
        afip3__ArrayOfTributoTipo() : TributoTipo(), soap() { }
        virtual ~afip3__ArrayOfTributoTipo() { }
        /// Friend allocator used by soap_new_afip3__ArrayOfTributoTipo(struct soap*, int)
        friend SOAP_FMAC1 afip3__ArrayOfTributoTipo * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfTributoTipo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:276 */
#ifndef SOAP_TYPE_afip3__TributoTipo
#define SOAP_TYPE_afip3__TributoTipo (64)
/* complex XML schema type 'afip3:TributoTipo': */
class SOAP_CMAC afip3__TributoTipo {
      public:
        /// Required element 'afip3:Id' of XML schema type 'xsd:short'
        short Id;
        /// Optional element 'afip3:Desc' of XML schema type 'xsd:string'
        std::string *Desc;
        /// Optional element 'afip3:FchDesde' of XML schema type 'xsd:string'
        std::string *FchDesde;
        /// Optional element 'afip3:FchHasta' of XML schema type 'xsd:string'
        std::string *FchHasta;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__TributoTipo
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__TributoTipo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__TributoTipo, default initialized and not managed by a soap context
        virtual afip3__TributoTipo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__TributoTipo); }
      public:
        /// Constructor with default initializations
        afip3__TributoTipo() : Id(), Desc(), FchDesde(), FchHasta(), soap() { }
        virtual ~afip3__TributoTipo() { }
        /// Friend allocator used by soap_new_afip3__TributoTipo(struct soap*, int)
        friend SOAP_FMAC1 afip3__TributoTipo * SOAP_FMAC2 soap_instantiate_afip3__TributoTipo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:278 */
#ifndef SOAP_TYPE_afip3__MonedaResponse
#define SOAP_TYPE_afip3__MonedaResponse (65)
/* complex XML schema type 'afip3:MonedaResponse': */
class SOAP_CMAC afip3__MonedaResponse {
      public:
        /// Optional element 'afip3:ResultGet' of XML schema type 'afip3:ArrayOfMoneda'
        afip3__ArrayOfMoneda *ResultGet;
        /// Optional element 'afip3:Errors' of XML schema type 'afip3:ArrayOfErr'
        afip3__ArrayOfErr *Errors;
        /// Optional element 'afip3:Events' of XML schema type 'afip3:ArrayOfEvt'
        afip3__ArrayOfEvt *Events;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__MonedaResponse
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__MonedaResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__MonedaResponse, default initialized and not managed by a soap context
        virtual afip3__MonedaResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__MonedaResponse); }
      public:
        /// Constructor with default initializations
        afip3__MonedaResponse() : ResultGet(), Errors(), Events(), soap() { }
        virtual ~afip3__MonedaResponse() { }
        /// Friend allocator used by soap_new_afip3__MonedaResponse(struct soap*, int)
        friend SOAP_FMAC1 afip3__MonedaResponse * SOAP_FMAC2 soap_instantiate_afip3__MonedaResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:280 */
#ifndef SOAP_TYPE_afip3__ArrayOfMoneda
#define SOAP_TYPE_afip3__ArrayOfMoneda (66)
/* complex XML schema type 'afip3:ArrayOfMoneda': */
class SOAP_CMAC afip3__ArrayOfMoneda {
      public:
        /// Optional element 'afip3:Moneda' of XML schema type 'afip3:Moneda'
        std::vector<afip3__Moneda *> Moneda;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__ArrayOfMoneda
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__ArrayOfMoneda; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__ArrayOfMoneda, default initialized and not managed by a soap context
        virtual afip3__ArrayOfMoneda *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__ArrayOfMoneda); }
      public:
        /// Constructor with default initializations
        afip3__ArrayOfMoneda() : Moneda(), soap() { }
        virtual ~afip3__ArrayOfMoneda() { }
        /// Friend allocator used by soap_new_afip3__ArrayOfMoneda(struct soap*, int)
        friend SOAP_FMAC1 afip3__ArrayOfMoneda * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfMoneda(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:282 */
#ifndef SOAP_TYPE_afip3__Moneda
#define SOAP_TYPE_afip3__Moneda (67)
/* complex XML schema type 'afip3:Moneda': */
class SOAP_CMAC afip3__Moneda {
      public:
        /// Optional element 'afip3:Id' of XML schema type 'xsd:string'
        std::string *Id;
        /// Optional element 'afip3:Desc' of XML schema type 'xsd:string'
        std::string *Desc;
        /// Optional element 'afip3:FchDesde' of XML schema type 'xsd:string'
        std::string *FchDesde;
        /// Optional element 'afip3:FchHasta' of XML schema type 'xsd:string'
        std::string *FchHasta;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__Moneda
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__Moneda; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__Moneda, default initialized and not managed by a soap context
        virtual afip3__Moneda *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__Moneda); }
      public:
        /// Constructor with default initializations
        afip3__Moneda() : Id(), Desc(), FchDesde(), FchHasta(), soap() { }
        virtual ~afip3__Moneda() { }
        /// Friend allocator used by soap_new_afip3__Moneda(struct soap*, int)
        friend SOAP_FMAC1 afip3__Moneda * SOAP_FMAC2 soap_instantiate_afip3__Moneda(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:284 */
#ifndef SOAP_TYPE_afip3__IvaTipoResponse
#define SOAP_TYPE_afip3__IvaTipoResponse (68)
/* complex XML schema type 'afip3:IvaTipoResponse': */
class SOAP_CMAC afip3__IvaTipoResponse {
      public:
        /// Optional element 'afip3:ResultGet' of XML schema type 'afip3:ArrayOfIvaTipo'
        afip3__ArrayOfIvaTipo *ResultGet;
        /// Optional element 'afip3:Errors' of XML schema type 'afip3:ArrayOfErr'
        afip3__ArrayOfErr *Errors;
        /// Optional element 'afip3:Events' of XML schema type 'afip3:ArrayOfEvt'
        afip3__ArrayOfEvt *Events;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__IvaTipoResponse
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__IvaTipoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__IvaTipoResponse, default initialized and not managed by a soap context
        virtual afip3__IvaTipoResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__IvaTipoResponse); }
      public:
        /// Constructor with default initializations
        afip3__IvaTipoResponse() : ResultGet(), Errors(), Events(), soap() { }
        virtual ~afip3__IvaTipoResponse() { }
        /// Friend allocator used by soap_new_afip3__IvaTipoResponse(struct soap*, int)
        friend SOAP_FMAC1 afip3__IvaTipoResponse * SOAP_FMAC2 soap_instantiate_afip3__IvaTipoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:286 */
#ifndef SOAP_TYPE_afip3__ArrayOfIvaTipo
#define SOAP_TYPE_afip3__ArrayOfIvaTipo (69)
/* complex XML schema type 'afip3:ArrayOfIvaTipo': */
class SOAP_CMAC afip3__ArrayOfIvaTipo {
      public:
        /// Optional element 'afip3:IvaTipo' of XML schema type 'afip3:IvaTipo'
        std::vector<afip3__IvaTipo *> IvaTipo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__ArrayOfIvaTipo
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__ArrayOfIvaTipo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__ArrayOfIvaTipo, default initialized and not managed by a soap context
        virtual afip3__ArrayOfIvaTipo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__ArrayOfIvaTipo); }
      public:
        /// Constructor with default initializations
        afip3__ArrayOfIvaTipo() : IvaTipo(), soap() { }
        virtual ~afip3__ArrayOfIvaTipo() { }
        /// Friend allocator used by soap_new_afip3__ArrayOfIvaTipo(struct soap*, int)
        friend SOAP_FMAC1 afip3__ArrayOfIvaTipo * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfIvaTipo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:288 */
#ifndef SOAP_TYPE_afip3__IvaTipo
#define SOAP_TYPE_afip3__IvaTipo (70)
/* complex XML schema type 'afip3:IvaTipo': */
class SOAP_CMAC afip3__IvaTipo {
      public:
        /// Optional element 'afip3:Id' of XML schema type 'xsd:string'
        std::string *Id;
        /// Optional element 'afip3:Desc' of XML schema type 'xsd:string'
        std::string *Desc;
        /// Optional element 'afip3:FchDesde' of XML schema type 'xsd:string'
        std::string *FchDesde;
        /// Optional element 'afip3:FchHasta' of XML schema type 'xsd:string'
        std::string *FchHasta;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__IvaTipo
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__IvaTipo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__IvaTipo, default initialized and not managed by a soap context
        virtual afip3__IvaTipo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__IvaTipo); }
      public:
        /// Constructor with default initializations
        afip3__IvaTipo() : Id(), Desc(), FchDesde(), FchHasta(), soap() { }
        virtual ~afip3__IvaTipo() { }
        /// Friend allocator used by soap_new_afip3__IvaTipo(struct soap*, int)
        friend SOAP_FMAC1 afip3__IvaTipo * SOAP_FMAC2 soap_instantiate_afip3__IvaTipo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:290 */
#ifndef SOAP_TYPE_afip3__OpcionalTipoResponse
#define SOAP_TYPE_afip3__OpcionalTipoResponse (71)
/* complex XML schema type 'afip3:OpcionalTipoResponse': */
class SOAP_CMAC afip3__OpcionalTipoResponse {
      public:
        /// Optional element 'afip3:ResultGet' of XML schema type 'afip3:ArrayOfOpcionalTipo'
        afip3__ArrayOfOpcionalTipo *ResultGet;
        /// Optional element 'afip3:Errors' of XML schema type 'afip3:ArrayOfErr'
        afip3__ArrayOfErr *Errors;
        /// Optional element 'afip3:Events' of XML schema type 'afip3:ArrayOfEvt'
        afip3__ArrayOfEvt *Events;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__OpcionalTipoResponse
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__OpcionalTipoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__OpcionalTipoResponse, default initialized and not managed by a soap context
        virtual afip3__OpcionalTipoResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__OpcionalTipoResponse); }
      public:
        /// Constructor with default initializations
        afip3__OpcionalTipoResponse() : ResultGet(), Errors(), Events(), soap() { }
        virtual ~afip3__OpcionalTipoResponse() { }
        /// Friend allocator used by soap_new_afip3__OpcionalTipoResponse(struct soap*, int)
        friend SOAP_FMAC1 afip3__OpcionalTipoResponse * SOAP_FMAC2 soap_instantiate_afip3__OpcionalTipoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:292 */
#ifndef SOAP_TYPE_afip3__ArrayOfOpcionalTipo
#define SOAP_TYPE_afip3__ArrayOfOpcionalTipo (72)
/* complex XML schema type 'afip3:ArrayOfOpcionalTipo': */
class SOAP_CMAC afip3__ArrayOfOpcionalTipo {
      public:
        /// Optional element 'afip3:OpcionalTipo' of XML schema type 'afip3:OpcionalTipo'
        std::vector<afip3__OpcionalTipo *> OpcionalTipo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__ArrayOfOpcionalTipo
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__ArrayOfOpcionalTipo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__ArrayOfOpcionalTipo, default initialized and not managed by a soap context
        virtual afip3__ArrayOfOpcionalTipo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__ArrayOfOpcionalTipo); }
      public:
        /// Constructor with default initializations
        afip3__ArrayOfOpcionalTipo() : OpcionalTipo(), soap() { }
        virtual ~afip3__ArrayOfOpcionalTipo() { }
        /// Friend allocator used by soap_new_afip3__ArrayOfOpcionalTipo(struct soap*, int)
        friend SOAP_FMAC1 afip3__ArrayOfOpcionalTipo * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfOpcionalTipo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:294 */
#ifndef SOAP_TYPE_afip3__OpcionalTipo
#define SOAP_TYPE_afip3__OpcionalTipo (73)
/* complex XML schema type 'afip3:OpcionalTipo': */
class SOAP_CMAC afip3__OpcionalTipo {
      public:
        /// Optional element 'afip3:Id' of XML schema type 'xsd:string'
        std::string *Id;
        /// Optional element 'afip3:Desc' of XML schema type 'xsd:string'
        std::string *Desc;
        /// Optional element 'afip3:FchDesde' of XML schema type 'xsd:string'
        std::string *FchDesde;
        /// Optional element 'afip3:FchHasta' of XML schema type 'xsd:string'
        std::string *FchHasta;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__OpcionalTipo
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__OpcionalTipo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__OpcionalTipo, default initialized and not managed by a soap context
        virtual afip3__OpcionalTipo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__OpcionalTipo); }
      public:
        /// Constructor with default initializations
        afip3__OpcionalTipo() : Id(), Desc(), FchDesde(), FchHasta(), soap() { }
        virtual ~afip3__OpcionalTipo() { }
        /// Friend allocator used by soap_new_afip3__OpcionalTipo(struct soap*, int)
        friend SOAP_FMAC1 afip3__OpcionalTipo * SOAP_FMAC2 soap_instantiate_afip3__OpcionalTipo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:296 */
#ifndef SOAP_TYPE_afip3__ConceptoTipoResponse
#define SOAP_TYPE_afip3__ConceptoTipoResponse (74)
/* complex XML schema type 'afip3:ConceptoTipoResponse': */
class SOAP_CMAC afip3__ConceptoTipoResponse {
      public:
        /// Optional element 'afip3:ResultGet' of XML schema type 'afip3:ArrayOfConceptoTipo'
        afip3__ArrayOfConceptoTipo *ResultGet;
        /// Optional element 'afip3:Errors' of XML schema type 'afip3:ArrayOfErr'
        afip3__ArrayOfErr *Errors;
        /// Optional element 'afip3:Events' of XML schema type 'afip3:ArrayOfEvt'
        afip3__ArrayOfEvt *Events;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__ConceptoTipoResponse
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__ConceptoTipoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__ConceptoTipoResponse, default initialized and not managed by a soap context
        virtual afip3__ConceptoTipoResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__ConceptoTipoResponse); }
      public:
        /// Constructor with default initializations
        afip3__ConceptoTipoResponse() : ResultGet(), Errors(), Events(), soap() { }
        virtual ~afip3__ConceptoTipoResponse() { }
        /// Friend allocator used by soap_new_afip3__ConceptoTipoResponse(struct soap*, int)
        friend SOAP_FMAC1 afip3__ConceptoTipoResponse * SOAP_FMAC2 soap_instantiate_afip3__ConceptoTipoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:298 */
#ifndef SOAP_TYPE_afip3__ArrayOfConceptoTipo
#define SOAP_TYPE_afip3__ArrayOfConceptoTipo (75)
/* complex XML schema type 'afip3:ArrayOfConceptoTipo': */
class SOAP_CMAC afip3__ArrayOfConceptoTipo {
      public:
        /// Optional element 'afip3:ConceptoTipo' of XML schema type 'afip3:ConceptoTipo'
        std::vector<afip3__ConceptoTipo *> ConceptoTipo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__ArrayOfConceptoTipo
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__ArrayOfConceptoTipo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__ArrayOfConceptoTipo, default initialized and not managed by a soap context
        virtual afip3__ArrayOfConceptoTipo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__ArrayOfConceptoTipo); }
      public:
        /// Constructor with default initializations
        afip3__ArrayOfConceptoTipo() : ConceptoTipo(), soap() { }
        virtual ~afip3__ArrayOfConceptoTipo() { }
        /// Friend allocator used by soap_new_afip3__ArrayOfConceptoTipo(struct soap*, int)
        friend SOAP_FMAC1 afip3__ArrayOfConceptoTipo * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfConceptoTipo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:300 */
#ifndef SOAP_TYPE_afip3__ConceptoTipo
#define SOAP_TYPE_afip3__ConceptoTipo (76)
/* complex XML schema type 'afip3:ConceptoTipo': */
class SOAP_CMAC afip3__ConceptoTipo {
      public:
        /// Required element 'afip3:Id' of XML schema type 'xsd:int'
        int Id;
        /// Optional element 'afip3:Desc' of XML schema type 'xsd:string'
        std::string *Desc;
        /// Optional element 'afip3:FchDesde' of XML schema type 'xsd:string'
        std::string *FchDesde;
        /// Optional element 'afip3:FchHasta' of XML schema type 'xsd:string'
        std::string *FchHasta;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__ConceptoTipo
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__ConceptoTipo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__ConceptoTipo, default initialized and not managed by a soap context
        virtual afip3__ConceptoTipo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__ConceptoTipo); }
      public:
        /// Constructor with default initializations
        afip3__ConceptoTipo() : Id(), Desc(), FchDesde(), FchHasta(), soap() { }
        virtual ~afip3__ConceptoTipo() { }
        /// Friend allocator used by soap_new_afip3__ConceptoTipo(struct soap*, int)
        friend SOAP_FMAC1 afip3__ConceptoTipo * SOAP_FMAC2 soap_instantiate_afip3__ConceptoTipo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:302 */
#ifndef SOAP_TYPE_afip3__FEPtoVentaResponse
#define SOAP_TYPE_afip3__FEPtoVentaResponse (77)
/* complex XML schema type 'afip3:FEPtoVentaResponse': */
class SOAP_CMAC afip3__FEPtoVentaResponse {
      public:
        /// Optional element 'afip3:ResultGet' of XML schema type 'afip3:ArrayOfPtoVenta'
        afip3__ArrayOfPtoVenta *ResultGet;
        /// Optional element 'afip3:Errors' of XML schema type 'afip3:ArrayOfErr'
        afip3__ArrayOfErr *Errors;
        /// Optional element 'afip3:Events' of XML schema type 'afip3:ArrayOfEvt'
        afip3__ArrayOfEvt *Events;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__FEPtoVentaResponse
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__FEPtoVentaResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__FEPtoVentaResponse, default initialized and not managed by a soap context
        virtual afip3__FEPtoVentaResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__FEPtoVentaResponse); }
      public:
        /// Constructor with default initializations
        afip3__FEPtoVentaResponse() : ResultGet(), Errors(), Events(), soap() { }
        virtual ~afip3__FEPtoVentaResponse() { }
        /// Friend allocator used by soap_new_afip3__FEPtoVentaResponse(struct soap*, int)
        friend SOAP_FMAC1 afip3__FEPtoVentaResponse * SOAP_FMAC2 soap_instantiate_afip3__FEPtoVentaResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:304 */
#ifndef SOAP_TYPE_afip3__ArrayOfPtoVenta
#define SOAP_TYPE_afip3__ArrayOfPtoVenta (78)
/* complex XML schema type 'afip3:ArrayOfPtoVenta': */
class SOAP_CMAC afip3__ArrayOfPtoVenta {
      public:
        /// Optional element 'afip3:PtoVenta' of XML schema type 'afip3:PtoVenta'
        std::vector<afip3__PtoVenta *> PtoVenta;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__ArrayOfPtoVenta
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__ArrayOfPtoVenta; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__ArrayOfPtoVenta, default initialized and not managed by a soap context
        virtual afip3__ArrayOfPtoVenta *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__ArrayOfPtoVenta); }
      public:
        /// Constructor with default initializations
        afip3__ArrayOfPtoVenta() : PtoVenta(), soap() { }
        virtual ~afip3__ArrayOfPtoVenta() { }
        /// Friend allocator used by soap_new_afip3__ArrayOfPtoVenta(struct soap*, int)
        friend SOAP_FMAC1 afip3__ArrayOfPtoVenta * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfPtoVenta(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:306 */
#ifndef SOAP_TYPE_afip3__PtoVenta
#define SOAP_TYPE_afip3__PtoVenta (79)
/* complex XML schema type 'afip3:PtoVenta': */
class SOAP_CMAC afip3__PtoVenta {
      public:
        /// Required element 'afip3:Nro' of XML schema type 'xsd:int'
        int Nro;
        /// Optional element 'afip3:EmisionTipo' of XML schema type 'xsd:string'
        std::string *EmisionTipo;
        /// Optional element 'afip3:Bloqueado' of XML schema type 'xsd:string'
        std::string *Bloqueado;
        /// Optional element 'afip3:FchBaja' of XML schema type 'xsd:string'
        std::string *FchBaja;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__PtoVenta
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__PtoVenta; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__PtoVenta, default initialized and not managed by a soap context
        virtual afip3__PtoVenta *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__PtoVenta); }
      public:
        /// Constructor with default initializations
        afip3__PtoVenta() : Nro(), EmisionTipo(), Bloqueado(), FchBaja(), soap() { }
        virtual ~afip3__PtoVenta() { }
        /// Friend allocator used by soap_new_afip3__PtoVenta(struct soap*, int)
        friend SOAP_FMAC1 afip3__PtoVenta * SOAP_FMAC2 soap_instantiate_afip3__PtoVenta(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:308 */
#ifndef SOAP_TYPE_afip3__CbteTipoResponse
#define SOAP_TYPE_afip3__CbteTipoResponse (80)
/* complex XML schema type 'afip3:CbteTipoResponse': */
class SOAP_CMAC afip3__CbteTipoResponse {
      public:
        /// Optional element 'afip3:ResultGet' of XML schema type 'afip3:ArrayOfCbteTipo'
        afip3__ArrayOfCbteTipo *ResultGet;
        /// Optional element 'afip3:Errors' of XML schema type 'afip3:ArrayOfErr'
        afip3__ArrayOfErr *Errors;
        /// Optional element 'afip3:Events' of XML schema type 'afip3:ArrayOfEvt'
        afip3__ArrayOfEvt *Events;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__CbteTipoResponse
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__CbteTipoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__CbteTipoResponse, default initialized and not managed by a soap context
        virtual afip3__CbteTipoResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__CbteTipoResponse); }
      public:
        /// Constructor with default initializations
        afip3__CbteTipoResponse() : ResultGet(), Errors(), Events(), soap() { }
        virtual ~afip3__CbteTipoResponse() { }
        /// Friend allocator used by soap_new_afip3__CbteTipoResponse(struct soap*, int)
        friend SOAP_FMAC1 afip3__CbteTipoResponse * SOAP_FMAC2 soap_instantiate_afip3__CbteTipoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:310 */
#ifndef SOAP_TYPE_afip3__ArrayOfCbteTipo
#define SOAP_TYPE_afip3__ArrayOfCbteTipo (81)
/* complex XML schema type 'afip3:ArrayOfCbteTipo': */
class SOAP_CMAC afip3__ArrayOfCbteTipo {
      public:
        /// Optional element 'afip3:CbteTipo' of XML schema type 'afip3:CbteTipo'
        std::vector<afip3__CbteTipo *> CbteTipo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__ArrayOfCbteTipo
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__ArrayOfCbteTipo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__ArrayOfCbteTipo, default initialized and not managed by a soap context
        virtual afip3__ArrayOfCbteTipo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__ArrayOfCbteTipo); }
      public:
        /// Constructor with default initializations
        afip3__ArrayOfCbteTipo() : CbteTipo(), soap() { }
        virtual ~afip3__ArrayOfCbteTipo() { }
        /// Friend allocator used by soap_new_afip3__ArrayOfCbteTipo(struct soap*, int)
        friend SOAP_FMAC1 afip3__ArrayOfCbteTipo * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfCbteTipo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:312 */
#ifndef SOAP_TYPE_afip3__CbteTipo
#define SOAP_TYPE_afip3__CbteTipo (82)
/* complex XML schema type 'afip3:CbteTipo': */
class SOAP_CMAC afip3__CbteTipo {
      public:
        /// Required element 'afip3:Id' of XML schema type 'xsd:int'
        int Id;
        /// Optional element 'afip3:Desc' of XML schema type 'xsd:string'
        std::string *Desc;
        /// Optional element 'afip3:FchDesde' of XML schema type 'xsd:string'
        std::string *FchDesde;
        /// Optional element 'afip3:FchHasta' of XML schema type 'xsd:string'
        std::string *FchHasta;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__CbteTipo
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__CbteTipo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__CbteTipo, default initialized and not managed by a soap context
        virtual afip3__CbteTipo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__CbteTipo); }
      public:
        /// Constructor with default initializations
        afip3__CbteTipo() : Id(), Desc(), FchDesde(), FchHasta(), soap() { }
        virtual ~afip3__CbteTipo() { }
        /// Friend allocator used by soap_new_afip3__CbteTipo(struct soap*, int)
        friend SOAP_FMAC1 afip3__CbteTipo * SOAP_FMAC2 soap_instantiate_afip3__CbteTipo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:314 */
#ifndef SOAP_TYPE_afip3__DocTipoResponse
#define SOAP_TYPE_afip3__DocTipoResponse (83)
/* complex XML schema type 'afip3:DocTipoResponse': */
class SOAP_CMAC afip3__DocTipoResponse {
      public:
        /// Optional element 'afip3:ResultGet' of XML schema type 'afip3:ArrayOfDocTipo'
        afip3__ArrayOfDocTipo *ResultGet;
        /// Optional element 'afip3:Errors' of XML schema type 'afip3:ArrayOfErr'
        afip3__ArrayOfErr *Errors;
        /// Optional element 'afip3:Events' of XML schema type 'afip3:ArrayOfEvt'
        afip3__ArrayOfEvt *Events;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__DocTipoResponse
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__DocTipoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__DocTipoResponse, default initialized and not managed by a soap context
        virtual afip3__DocTipoResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__DocTipoResponse); }
      public:
        /// Constructor with default initializations
        afip3__DocTipoResponse() : ResultGet(), Errors(), Events(), soap() { }
        virtual ~afip3__DocTipoResponse() { }
        /// Friend allocator used by soap_new_afip3__DocTipoResponse(struct soap*, int)
        friend SOAP_FMAC1 afip3__DocTipoResponse * SOAP_FMAC2 soap_instantiate_afip3__DocTipoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:316 */
#ifndef SOAP_TYPE_afip3__ArrayOfDocTipo
#define SOAP_TYPE_afip3__ArrayOfDocTipo (84)
/* complex XML schema type 'afip3:ArrayOfDocTipo': */
class SOAP_CMAC afip3__ArrayOfDocTipo {
      public:
        /// Optional element 'afip3:DocTipo' of XML schema type 'afip3:DocTipo'
        std::vector<afip3__DocTipo *> DocTipo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__ArrayOfDocTipo
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__ArrayOfDocTipo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__ArrayOfDocTipo, default initialized and not managed by a soap context
        virtual afip3__ArrayOfDocTipo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__ArrayOfDocTipo); }
      public:
        /// Constructor with default initializations
        afip3__ArrayOfDocTipo() : DocTipo(), soap() { }
        virtual ~afip3__ArrayOfDocTipo() { }
        /// Friend allocator used by soap_new_afip3__ArrayOfDocTipo(struct soap*, int)
        friend SOAP_FMAC1 afip3__ArrayOfDocTipo * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfDocTipo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:318 */
#ifndef SOAP_TYPE_afip3__DocTipo
#define SOAP_TYPE_afip3__DocTipo (85)
/* complex XML schema type 'afip3:DocTipo': */
class SOAP_CMAC afip3__DocTipo {
      public:
        /// Required element 'afip3:Id' of XML schema type 'xsd:int'
        int Id;
        /// Optional element 'afip3:Desc' of XML schema type 'xsd:string'
        std::string *Desc;
        /// Optional element 'afip3:FchDesde' of XML schema type 'xsd:string'
        std::string *FchDesde;
        /// Optional element 'afip3:FchHasta' of XML schema type 'xsd:string'
        std::string *FchHasta;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__DocTipo
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__DocTipo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__DocTipo, default initialized and not managed by a soap context
        virtual afip3__DocTipo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__DocTipo); }
      public:
        /// Constructor with default initializations
        afip3__DocTipo() : Id(), Desc(), FchDesde(), FchHasta(), soap() { }
        virtual ~afip3__DocTipo() { }
        /// Friend allocator used by soap_new_afip3__DocTipo(struct soap*, int)
        friend SOAP_FMAC1 afip3__DocTipo * SOAP_FMAC2 soap_instantiate_afip3__DocTipo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:320 */
#ifndef SOAP_TYPE_afip3__FEPaisResponse
#define SOAP_TYPE_afip3__FEPaisResponse (86)
/* complex XML schema type 'afip3:FEPaisResponse': */
class SOAP_CMAC afip3__FEPaisResponse {
      public:
        /// Optional element 'afip3:ResultGet' of XML schema type 'afip3:ArrayOfPaisTipo'
        afip3__ArrayOfPaisTipo *ResultGet;
        /// Optional element 'afip3:Errors' of XML schema type 'afip3:ArrayOfErr'
        afip3__ArrayOfErr *Errors;
        /// Optional element 'afip3:Events' of XML schema type 'afip3:ArrayOfEvt'
        afip3__ArrayOfEvt *Events;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__FEPaisResponse
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__FEPaisResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__FEPaisResponse, default initialized and not managed by a soap context
        virtual afip3__FEPaisResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__FEPaisResponse); }
      public:
        /// Constructor with default initializations
        afip3__FEPaisResponse() : ResultGet(), Errors(), Events(), soap() { }
        virtual ~afip3__FEPaisResponse() { }
        /// Friend allocator used by soap_new_afip3__FEPaisResponse(struct soap*, int)
        friend SOAP_FMAC1 afip3__FEPaisResponse * SOAP_FMAC2 soap_instantiate_afip3__FEPaisResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:322 */
#ifndef SOAP_TYPE_afip3__ArrayOfPaisTipo
#define SOAP_TYPE_afip3__ArrayOfPaisTipo (87)
/* complex XML schema type 'afip3:ArrayOfPaisTipo': */
class SOAP_CMAC afip3__ArrayOfPaisTipo {
      public:
        /// Optional element 'afip3:PaisTipo' of XML schema type 'afip3:PaisTipo'
        std::vector<afip3__PaisTipo *> PaisTipo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__ArrayOfPaisTipo
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__ArrayOfPaisTipo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__ArrayOfPaisTipo, default initialized and not managed by a soap context
        virtual afip3__ArrayOfPaisTipo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__ArrayOfPaisTipo); }
      public:
        /// Constructor with default initializations
        afip3__ArrayOfPaisTipo() : PaisTipo(), soap() { }
        virtual ~afip3__ArrayOfPaisTipo() { }
        /// Friend allocator used by soap_new_afip3__ArrayOfPaisTipo(struct soap*, int)
        friend SOAP_FMAC1 afip3__ArrayOfPaisTipo * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfPaisTipo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:324 */
#ifndef SOAP_TYPE_afip3__PaisTipo
#define SOAP_TYPE_afip3__PaisTipo (88)
/* complex XML schema type 'afip3:PaisTipo': */
class SOAP_CMAC afip3__PaisTipo {
      public:
        /// Required element 'afip3:Id' of XML schema type 'xsd:short'
        short Id;
        /// Optional element 'afip3:Desc' of XML schema type 'xsd:string'
        std::string *Desc;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_afip3__PaisTipo
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__PaisTipo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__PaisTipo, default initialized and not managed by a soap context
        virtual afip3__PaisTipo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__PaisTipo); }
      public:
        /// Constructor with default initializations
        afip3__PaisTipo() : Id(), Desc(), soap() { }
        virtual ~afip3__PaisTipo() { }
        /// Friend allocator used by soap_new_afip3__PaisTipo(struct soap*, int)
        friend SOAP_FMAC1 afip3__PaisTipo * SOAP_FMAC2 soap_instantiate_afip3__PaisTipo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:326 */
#ifndef SOAP_TYPE__afip3__FECAESolicitar
#define SOAP_TYPE__afip3__FECAESolicitar (89)
/* complex XML schema type 'afip3:FECAESolicitar': */
class SOAP_CMAC _afip3__FECAESolicitar {
      public:
        /// Optional element 'afip3:Auth' of XML schema type 'afip3:FEAuthRequest'
        afip3__FEAuthRequest *Auth;
        /// Optional element 'afip3:FeCAEReq' of XML schema type 'afip3:FECAERequest'
        afip3__FECAERequest *FeCAEReq;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FECAESolicitar
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FECAESolicitar; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FECAESolicitar, default initialized and not managed by a soap context
        virtual _afip3__FECAESolicitar *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FECAESolicitar); }
      public:
        /// Constructor with default initializations
        _afip3__FECAESolicitar() : Auth(), FeCAEReq(), soap() { }
        virtual ~_afip3__FECAESolicitar() { }
        /// Friend allocator used by soap_new__afip3__FECAESolicitar(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FECAESolicitar * SOAP_FMAC2 soap_instantiate__afip3__FECAESolicitar(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:328 */
#ifndef SOAP_TYPE__afip3__FECAESolicitarResponse
#define SOAP_TYPE__afip3__FECAESolicitarResponse (90)
/* complex XML schema type 'afip3:FECAESolicitarResponse': */
class SOAP_CMAC _afip3__FECAESolicitarResponse {
      public:
        /// Optional element 'afip3:FECAESolicitarResult' of XML schema type 'afip3:FECAEResponse'
        afip3__FECAEResponse *FECAESolicitarResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FECAESolicitarResponse
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FECAESolicitarResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FECAESolicitarResponse, default initialized and not managed by a soap context
        virtual _afip3__FECAESolicitarResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FECAESolicitarResponse); }
      public:
        /// Constructor with default initializations
        _afip3__FECAESolicitarResponse() : FECAESolicitarResult(), soap() { }
        virtual ~_afip3__FECAESolicitarResponse() { }
        /// Friend allocator used by soap_new__afip3__FECAESolicitarResponse(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FECAESolicitarResponse * SOAP_FMAC2 soap_instantiate__afip3__FECAESolicitarResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:330 */
#ifndef SOAP_TYPE__afip3__FECompTotXRequest
#define SOAP_TYPE__afip3__FECompTotXRequest (91)
/* complex XML schema type 'afip3:FECompTotXRequest': */
class SOAP_CMAC _afip3__FECompTotXRequest {
      public:
        /// Optional element 'afip3:Auth' of XML schema type 'afip3:FEAuthRequest'
        afip3__FEAuthRequest *Auth;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FECompTotXRequest
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FECompTotXRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FECompTotXRequest, default initialized and not managed by a soap context
        virtual _afip3__FECompTotXRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FECompTotXRequest); }
      public:
        /// Constructor with default initializations
        _afip3__FECompTotXRequest() : Auth(), soap() { }
        virtual ~_afip3__FECompTotXRequest() { }
        /// Friend allocator used by soap_new__afip3__FECompTotXRequest(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FECompTotXRequest * SOAP_FMAC2 soap_instantiate__afip3__FECompTotXRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:332 */
#ifndef SOAP_TYPE__afip3__FECompTotXRequestResponse
#define SOAP_TYPE__afip3__FECompTotXRequestResponse (92)
/* complex XML schema type 'afip3:FECompTotXRequestResponse': */
class SOAP_CMAC _afip3__FECompTotXRequestResponse {
      public:
        /// Optional element 'afip3:FECompTotXRequestResult' of XML schema type 'afip3:FERegXReqResponse'
        afip3__FERegXReqResponse *FECompTotXRequestResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FECompTotXRequestResponse
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FECompTotXRequestResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FECompTotXRequestResponse, default initialized and not managed by a soap context
        virtual _afip3__FECompTotXRequestResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FECompTotXRequestResponse); }
      public:
        /// Constructor with default initializations
        _afip3__FECompTotXRequestResponse() : FECompTotXRequestResult(), soap() { }
        virtual ~_afip3__FECompTotXRequestResponse() { }
        /// Friend allocator used by soap_new__afip3__FECompTotXRequestResponse(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FECompTotXRequestResponse * SOAP_FMAC2 soap_instantiate__afip3__FECompTotXRequestResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:334 */
#ifndef SOAP_TYPE__afip3__FEDummy
#define SOAP_TYPE__afip3__FEDummy (93)
/* complex XML schema type 'afip3:FEDummy': */
class SOAP_CMAC _afip3__FEDummy {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FEDummy
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FEDummy; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FEDummy, default initialized and not managed by a soap context
        virtual _afip3__FEDummy *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FEDummy); }
      public:
        /// Constructor with default initializations
        _afip3__FEDummy() : soap() { }
        virtual ~_afip3__FEDummy() { }
        /// Friend allocator used by soap_new__afip3__FEDummy(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FEDummy * SOAP_FMAC2 soap_instantiate__afip3__FEDummy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:336 */
#ifndef SOAP_TYPE__afip3__FEDummyResponse
#define SOAP_TYPE__afip3__FEDummyResponse (94)
/* complex XML schema type 'afip3:FEDummyResponse': */
class SOAP_CMAC _afip3__FEDummyResponse {
      public:
        /// Optional element 'afip3:FEDummyResult' of XML schema type 'afip3:DummyResponse'
        afip3__DummyResponse *FEDummyResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FEDummyResponse
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FEDummyResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FEDummyResponse, default initialized and not managed by a soap context
        virtual _afip3__FEDummyResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FEDummyResponse); }
      public:
        /// Constructor with default initializations
        _afip3__FEDummyResponse() : FEDummyResult(), soap() { }
        virtual ~_afip3__FEDummyResponse() { }
        /// Friend allocator used by soap_new__afip3__FEDummyResponse(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FEDummyResponse * SOAP_FMAC2 soap_instantiate__afip3__FEDummyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:338 */
#ifndef SOAP_TYPE__afip3__FECompUltimoAutorizado
#define SOAP_TYPE__afip3__FECompUltimoAutorizado (95)
/* complex XML schema type 'afip3:FECompUltimoAutorizado': */
class SOAP_CMAC _afip3__FECompUltimoAutorizado {
      public:
        /// Optional element 'afip3:Auth' of XML schema type 'afip3:FEAuthRequest'
        afip3__FEAuthRequest *Auth;
        /// Required element 'afip3:PtoVta' of XML schema type 'xsd:int'
        int PtoVta;
        /// Required element 'afip3:CbteTipo' of XML schema type 'xsd:int'
        int CbteTipo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FECompUltimoAutorizado
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FECompUltimoAutorizado; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FECompUltimoAutorizado, default initialized and not managed by a soap context
        virtual _afip3__FECompUltimoAutorizado *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FECompUltimoAutorizado); }
      public:
        /// Constructor with default initializations
        _afip3__FECompUltimoAutorizado() : Auth(), PtoVta(), CbteTipo(), soap() { }
        virtual ~_afip3__FECompUltimoAutorizado() { }
        /// Friend allocator used by soap_new__afip3__FECompUltimoAutorizado(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FECompUltimoAutorizado * SOAP_FMAC2 soap_instantiate__afip3__FECompUltimoAutorizado(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:340 */
#ifndef SOAP_TYPE__afip3__FECompUltimoAutorizadoResponse
#define SOAP_TYPE__afip3__FECompUltimoAutorizadoResponse (96)
/* complex XML schema type 'afip3:FECompUltimoAutorizadoResponse': */
class SOAP_CMAC _afip3__FECompUltimoAutorizadoResponse {
      public:
        /// Optional element 'afip3:FECompUltimoAutorizadoResult' of XML schema type 'afip3:FERecuperaLastCbteResponse'
        afip3__FERecuperaLastCbteResponse *FECompUltimoAutorizadoResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FECompUltimoAutorizadoResponse
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FECompUltimoAutorizadoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FECompUltimoAutorizadoResponse, default initialized and not managed by a soap context
        virtual _afip3__FECompUltimoAutorizadoResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FECompUltimoAutorizadoResponse); }
      public:
        /// Constructor with default initializations
        _afip3__FECompUltimoAutorizadoResponse() : FECompUltimoAutorizadoResult(), soap() { }
        virtual ~_afip3__FECompUltimoAutorizadoResponse() { }
        /// Friend allocator used by soap_new__afip3__FECompUltimoAutorizadoResponse(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FECompUltimoAutorizadoResponse * SOAP_FMAC2 soap_instantiate__afip3__FECompUltimoAutorizadoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:342 */
#ifndef SOAP_TYPE__afip3__FECompConsultar
#define SOAP_TYPE__afip3__FECompConsultar (97)
/* complex XML schema type 'afip3:FECompConsultar': */
class SOAP_CMAC _afip3__FECompConsultar {
      public:
        /// Optional element 'afip3:Auth' of XML schema type 'afip3:FEAuthRequest'
        afip3__FEAuthRequest *Auth;
        /// Optional element 'afip3:FeCompConsReq' of XML schema type 'afip3:FECompConsultaReq'
        afip3__FECompConsultaReq *FeCompConsReq;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FECompConsultar
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FECompConsultar; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FECompConsultar, default initialized and not managed by a soap context
        virtual _afip3__FECompConsultar *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FECompConsultar); }
      public:
        /// Constructor with default initializations
        _afip3__FECompConsultar() : Auth(), FeCompConsReq(), soap() { }
        virtual ~_afip3__FECompConsultar() { }
        /// Friend allocator used by soap_new__afip3__FECompConsultar(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FECompConsultar * SOAP_FMAC2 soap_instantiate__afip3__FECompConsultar(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:344 */
#ifndef SOAP_TYPE__afip3__FECompConsultarResponse
#define SOAP_TYPE__afip3__FECompConsultarResponse (98)
/* complex XML schema type 'afip3:FECompConsultarResponse': */
class SOAP_CMAC _afip3__FECompConsultarResponse {
      public:
        /// Optional element 'afip3:FECompConsultarResult' of XML schema type 'afip3:FECompConsultaResponse'
        afip3__FECompConsultaResponse *FECompConsultarResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FECompConsultarResponse
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FECompConsultarResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FECompConsultarResponse, default initialized and not managed by a soap context
        virtual _afip3__FECompConsultarResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FECompConsultarResponse); }
      public:
        /// Constructor with default initializations
        _afip3__FECompConsultarResponse() : FECompConsultarResult(), soap() { }
        virtual ~_afip3__FECompConsultarResponse() { }
        /// Friend allocator used by soap_new__afip3__FECompConsultarResponse(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FECompConsultarResponse * SOAP_FMAC2 soap_instantiate__afip3__FECompConsultarResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:346 */
#ifndef SOAP_TYPE__afip3__FECAEARegInformativo
#define SOAP_TYPE__afip3__FECAEARegInformativo (99)
/* complex XML schema type 'afip3:FECAEARegInformativo': */
class SOAP_CMAC _afip3__FECAEARegInformativo {
      public:
        /// Optional element 'afip3:Auth' of XML schema type 'afip3:FEAuthRequest'
        afip3__FEAuthRequest *Auth;
        /// Optional element 'afip3:FeCAEARegInfReq' of XML schema type 'afip3:FECAEARequest'
        afip3__FECAEARequest *FeCAEARegInfReq;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FECAEARegInformativo
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FECAEARegInformativo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FECAEARegInformativo, default initialized and not managed by a soap context
        virtual _afip3__FECAEARegInformativo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FECAEARegInformativo); }
      public:
        /// Constructor with default initializations
        _afip3__FECAEARegInformativo() : Auth(), FeCAEARegInfReq(), soap() { }
        virtual ~_afip3__FECAEARegInformativo() { }
        /// Friend allocator used by soap_new__afip3__FECAEARegInformativo(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FECAEARegInformativo * SOAP_FMAC2 soap_instantiate__afip3__FECAEARegInformativo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:348 */
#ifndef SOAP_TYPE__afip3__FECAEARegInformativoResponse
#define SOAP_TYPE__afip3__FECAEARegInformativoResponse (100)
/* complex XML schema type 'afip3:FECAEARegInformativoResponse': */
class SOAP_CMAC _afip3__FECAEARegInformativoResponse {
      public:
        /// Optional element 'afip3:FECAEARegInformativoResult' of XML schema type 'afip3:FECAEAResponse'
        afip3__FECAEAResponse *FECAEARegInformativoResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FECAEARegInformativoResponse
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FECAEARegInformativoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FECAEARegInformativoResponse, default initialized and not managed by a soap context
        virtual _afip3__FECAEARegInformativoResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FECAEARegInformativoResponse); }
      public:
        /// Constructor with default initializations
        _afip3__FECAEARegInformativoResponse() : FECAEARegInformativoResult(), soap() { }
        virtual ~_afip3__FECAEARegInformativoResponse() { }
        /// Friend allocator used by soap_new__afip3__FECAEARegInformativoResponse(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FECAEARegInformativoResponse * SOAP_FMAC2 soap_instantiate__afip3__FECAEARegInformativoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:350 */
#ifndef SOAP_TYPE__afip3__FECAEASolicitar
#define SOAP_TYPE__afip3__FECAEASolicitar (101)
/* complex XML schema type 'afip3:FECAEASolicitar': */
class SOAP_CMAC _afip3__FECAEASolicitar {
      public:
        /// Optional element 'afip3:Auth' of XML schema type 'afip3:FEAuthRequest'
        afip3__FEAuthRequest *Auth;
        /// Required element 'afip3:Periodo' of XML schema type 'xsd:int'
        int Periodo;
        /// Required element 'afip3:Orden' of XML schema type 'xsd:short'
        short Orden;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FECAEASolicitar
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FECAEASolicitar; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FECAEASolicitar, default initialized and not managed by a soap context
        virtual _afip3__FECAEASolicitar *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FECAEASolicitar); }
      public:
        /// Constructor with default initializations
        _afip3__FECAEASolicitar() : Auth(), Periodo(), Orden(), soap() { }
        virtual ~_afip3__FECAEASolicitar() { }
        /// Friend allocator used by soap_new__afip3__FECAEASolicitar(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FECAEASolicitar * SOAP_FMAC2 soap_instantiate__afip3__FECAEASolicitar(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:352 */
#ifndef SOAP_TYPE__afip3__FECAEASolicitarResponse
#define SOAP_TYPE__afip3__FECAEASolicitarResponse (102)
/* complex XML schema type 'afip3:FECAEASolicitarResponse': */
class SOAP_CMAC _afip3__FECAEASolicitarResponse {
      public:
        /// Optional element 'afip3:FECAEASolicitarResult' of XML schema type 'afip3:FECAEAGetResponse'
        afip3__FECAEAGetResponse *FECAEASolicitarResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FECAEASolicitarResponse
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FECAEASolicitarResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FECAEASolicitarResponse, default initialized and not managed by a soap context
        virtual _afip3__FECAEASolicitarResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FECAEASolicitarResponse); }
      public:
        /// Constructor with default initializations
        _afip3__FECAEASolicitarResponse() : FECAEASolicitarResult(), soap() { }
        virtual ~_afip3__FECAEASolicitarResponse() { }
        /// Friend allocator used by soap_new__afip3__FECAEASolicitarResponse(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FECAEASolicitarResponse * SOAP_FMAC2 soap_instantiate__afip3__FECAEASolicitarResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:354 */
#ifndef SOAP_TYPE__afip3__FECAEASinMovimientoConsultar
#define SOAP_TYPE__afip3__FECAEASinMovimientoConsultar (103)
/* complex XML schema type 'afip3:FECAEASinMovimientoConsultar': */
class SOAP_CMAC _afip3__FECAEASinMovimientoConsultar {
      public:
        /// Optional element 'afip3:Auth' of XML schema type 'afip3:FEAuthRequest'
        afip3__FEAuthRequest *Auth;
        /// Optional element 'afip3:CAEA' of XML schema type 'xsd:string'
        std::string *CAEA;
        /// Required element 'afip3:PtoVta' of XML schema type 'xsd:int'
        int PtoVta;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FECAEASinMovimientoConsultar
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FECAEASinMovimientoConsultar; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FECAEASinMovimientoConsultar, default initialized and not managed by a soap context
        virtual _afip3__FECAEASinMovimientoConsultar *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FECAEASinMovimientoConsultar); }
      public:
        /// Constructor with default initializations
        _afip3__FECAEASinMovimientoConsultar() : Auth(), CAEA(), PtoVta(), soap() { }
        virtual ~_afip3__FECAEASinMovimientoConsultar() { }
        /// Friend allocator used by soap_new__afip3__FECAEASinMovimientoConsultar(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FECAEASinMovimientoConsultar * SOAP_FMAC2 soap_instantiate__afip3__FECAEASinMovimientoConsultar(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:356 */
#ifndef SOAP_TYPE__afip3__FECAEASinMovimientoConsultarResponse
#define SOAP_TYPE__afip3__FECAEASinMovimientoConsultarResponse (104)
/* complex XML schema type 'afip3:FECAEASinMovimientoConsultarResponse': */
class SOAP_CMAC _afip3__FECAEASinMovimientoConsultarResponse {
      public:
        /// Optional element 'afip3:FECAEASinMovimientoConsultarResult' of XML schema type 'afip3:FECAEASinMovConsResponse'
        afip3__FECAEASinMovConsResponse *FECAEASinMovimientoConsultarResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FECAEASinMovimientoConsultarResponse
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FECAEASinMovimientoConsultarResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FECAEASinMovimientoConsultarResponse, default initialized and not managed by a soap context
        virtual _afip3__FECAEASinMovimientoConsultarResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FECAEASinMovimientoConsultarResponse); }
      public:
        /// Constructor with default initializations
        _afip3__FECAEASinMovimientoConsultarResponse() : FECAEASinMovimientoConsultarResult(), soap() { }
        virtual ~_afip3__FECAEASinMovimientoConsultarResponse() { }
        /// Friend allocator used by soap_new__afip3__FECAEASinMovimientoConsultarResponse(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FECAEASinMovimientoConsultarResponse * SOAP_FMAC2 soap_instantiate__afip3__FECAEASinMovimientoConsultarResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:358 */
#ifndef SOAP_TYPE__afip3__FECAEASinMovimientoInformar
#define SOAP_TYPE__afip3__FECAEASinMovimientoInformar (105)
/* complex XML schema type 'afip3:FECAEASinMovimientoInformar': */
class SOAP_CMAC _afip3__FECAEASinMovimientoInformar {
      public:
        /// Optional element 'afip3:Auth' of XML schema type 'afip3:FEAuthRequest'
        afip3__FEAuthRequest *Auth;
        /// Required element 'afip3:PtoVta' of XML schema type 'xsd:int'
        int PtoVta;
        /// Optional element 'afip3:CAEA' of XML schema type 'xsd:string'
        std::string *CAEA;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FECAEASinMovimientoInformar
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FECAEASinMovimientoInformar; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FECAEASinMovimientoInformar, default initialized and not managed by a soap context
        virtual _afip3__FECAEASinMovimientoInformar *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FECAEASinMovimientoInformar); }
      public:
        /// Constructor with default initializations
        _afip3__FECAEASinMovimientoInformar() : Auth(), PtoVta(), CAEA(), soap() { }
        virtual ~_afip3__FECAEASinMovimientoInformar() { }
        /// Friend allocator used by soap_new__afip3__FECAEASinMovimientoInformar(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FECAEASinMovimientoInformar * SOAP_FMAC2 soap_instantiate__afip3__FECAEASinMovimientoInformar(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:360 */
#ifndef SOAP_TYPE__afip3__FECAEASinMovimientoInformarResponse
#define SOAP_TYPE__afip3__FECAEASinMovimientoInformarResponse (106)
/* complex XML schema type 'afip3:FECAEASinMovimientoInformarResponse': */
class SOAP_CMAC _afip3__FECAEASinMovimientoInformarResponse {
      public:
        /// Optional element 'afip3:FECAEASinMovimientoInformarResult' of XML schema type 'afip3:FECAEASinMovResponse'
        afip3__FECAEASinMovResponse *FECAEASinMovimientoInformarResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FECAEASinMovimientoInformarResponse
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FECAEASinMovimientoInformarResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FECAEASinMovimientoInformarResponse, default initialized and not managed by a soap context
        virtual _afip3__FECAEASinMovimientoInformarResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FECAEASinMovimientoInformarResponse); }
      public:
        /// Constructor with default initializations
        _afip3__FECAEASinMovimientoInformarResponse() : FECAEASinMovimientoInformarResult(), soap() { }
        virtual ~_afip3__FECAEASinMovimientoInformarResponse() { }
        /// Friend allocator used by soap_new__afip3__FECAEASinMovimientoInformarResponse(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FECAEASinMovimientoInformarResponse * SOAP_FMAC2 soap_instantiate__afip3__FECAEASinMovimientoInformarResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:362 */
#ifndef SOAP_TYPE__afip3__FECAEAConsultar
#define SOAP_TYPE__afip3__FECAEAConsultar (107)
/* complex XML schema type 'afip3:FECAEAConsultar': */
class SOAP_CMAC _afip3__FECAEAConsultar {
      public:
        /// Optional element 'afip3:Auth' of XML schema type 'afip3:FEAuthRequest'
        afip3__FEAuthRequest *Auth;
        /// Required element 'afip3:Periodo' of XML schema type 'xsd:int'
        int Periodo;
        /// Required element 'afip3:Orden' of XML schema type 'xsd:short'
        short Orden;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FECAEAConsultar
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FECAEAConsultar; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FECAEAConsultar, default initialized and not managed by a soap context
        virtual _afip3__FECAEAConsultar *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FECAEAConsultar); }
      public:
        /// Constructor with default initializations
        _afip3__FECAEAConsultar() : Auth(), Periodo(), Orden(), soap() { }
        virtual ~_afip3__FECAEAConsultar() { }
        /// Friend allocator used by soap_new__afip3__FECAEAConsultar(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FECAEAConsultar * SOAP_FMAC2 soap_instantiate__afip3__FECAEAConsultar(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:364 */
#ifndef SOAP_TYPE__afip3__FECAEAConsultarResponse
#define SOAP_TYPE__afip3__FECAEAConsultarResponse (108)
/* complex XML schema type 'afip3:FECAEAConsultarResponse': */
class SOAP_CMAC _afip3__FECAEAConsultarResponse {
      public:
        /// Optional element 'afip3:FECAEAConsultarResult' of XML schema type 'afip3:FECAEAGetResponse'
        afip3__FECAEAGetResponse *FECAEAConsultarResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FECAEAConsultarResponse
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FECAEAConsultarResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FECAEAConsultarResponse, default initialized and not managed by a soap context
        virtual _afip3__FECAEAConsultarResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FECAEAConsultarResponse); }
      public:
        /// Constructor with default initializations
        _afip3__FECAEAConsultarResponse() : FECAEAConsultarResult(), soap() { }
        virtual ~_afip3__FECAEAConsultarResponse() { }
        /// Friend allocator used by soap_new__afip3__FECAEAConsultarResponse(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FECAEAConsultarResponse * SOAP_FMAC2 soap_instantiate__afip3__FECAEAConsultarResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:366 */
#ifndef SOAP_TYPE__afip3__FEParamGetCotizacion
#define SOAP_TYPE__afip3__FEParamGetCotizacion (109)
/* complex XML schema type 'afip3:FEParamGetCotizacion': */
class SOAP_CMAC _afip3__FEParamGetCotizacion {
      public:
        /// Optional element 'afip3:Auth' of XML schema type 'afip3:FEAuthRequest'
        afip3__FEAuthRequest *Auth;
        /// Optional element 'afip3:MonId' of XML schema type 'xsd:string'
        std::string *MonId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FEParamGetCotizacion
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FEParamGetCotizacion; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FEParamGetCotizacion, default initialized and not managed by a soap context
        virtual _afip3__FEParamGetCotizacion *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FEParamGetCotizacion); }
      public:
        /// Constructor with default initializations
        _afip3__FEParamGetCotizacion() : Auth(), MonId(), soap() { }
        virtual ~_afip3__FEParamGetCotizacion() { }
        /// Friend allocator used by soap_new__afip3__FEParamGetCotizacion(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FEParamGetCotizacion * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetCotizacion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:368 */
#ifndef SOAP_TYPE__afip3__FEParamGetCotizacionResponse
#define SOAP_TYPE__afip3__FEParamGetCotizacionResponse (110)
/* complex XML schema type 'afip3:FEParamGetCotizacionResponse': */
class SOAP_CMAC _afip3__FEParamGetCotizacionResponse {
      public:
        /// Optional element 'afip3:FEParamGetCotizacionResult' of XML schema type 'afip3:FECotizacionResponse'
        afip3__FECotizacionResponse *FEParamGetCotizacionResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FEParamGetCotizacionResponse
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FEParamGetCotizacionResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FEParamGetCotizacionResponse, default initialized and not managed by a soap context
        virtual _afip3__FEParamGetCotizacionResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FEParamGetCotizacionResponse); }
      public:
        /// Constructor with default initializations
        _afip3__FEParamGetCotizacionResponse() : FEParamGetCotizacionResult(), soap() { }
        virtual ~_afip3__FEParamGetCotizacionResponse() { }
        /// Friend allocator used by soap_new__afip3__FEParamGetCotizacionResponse(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FEParamGetCotizacionResponse * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetCotizacionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:370 */
#ifndef SOAP_TYPE__afip3__FEParamGetTiposTributos
#define SOAP_TYPE__afip3__FEParamGetTiposTributos (111)
/* complex XML schema type 'afip3:FEParamGetTiposTributos': */
class SOAP_CMAC _afip3__FEParamGetTiposTributos {
      public:
        /// Optional element 'afip3:Auth' of XML schema type 'afip3:FEAuthRequest'
        afip3__FEAuthRequest *Auth;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FEParamGetTiposTributos
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FEParamGetTiposTributos; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FEParamGetTiposTributos, default initialized and not managed by a soap context
        virtual _afip3__FEParamGetTiposTributos *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FEParamGetTiposTributos); }
      public:
        /// Constructor with default initializations
        _afip3__FEParamGetTiposTributos() : Auth(), soap() { }
        virtual ~_afip3__FEParamGetTiposTributos() { }
        /// Friend allocator used by soap_new__afip3__FEParamGetTiposTributos(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FEParamGetTiposTributos * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetTiposTributos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:372 */
#ifndef SOAP_TYPE__afip3__FEParamGetTiposTributosResponse
#define SOAP_TYPE__afip3__FEParamGetTiposTributosResponse (112)
/* complex XML schema type 'afip3:FEParamGetTiposTributosResponse': */
class SOAP_CMAC _afip3__FEParamGetTiposTributosResponse {
      public:
        /// Optional element 'afip3:FEParamGetTiposTributosResult' of XML schema type 'afip3:FETributoResponse'
        afip3__FETributoResponse *FEParamGetTiposTributosResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FEParamGetTiposTributosResponse
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FEParamGetTiposTributosResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FEParamGetTiposTributosResponse, default initialized and not managed by a soap context
        virtual _afip3__FEParamGetTiposTributosResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FEParamGetTiposTributosResponse); }
      public:
        /// Constructor with default initializations
        _afip3__FEParamGetTiposTributosResponse() : FEParamGetTiposTributosResult(), soap() { }
        virtual ~_afip3__FEParamGetTiposTributosResponse() { }
        /// Friend allocator used by soap_new__afip3__FEParamGetTiposTributosResponse(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FEParamGetTiposTributosResponse * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetTiposTributosResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:374 */
#ifndef SOAP_TYPE__afip3__FEParamGetTiposMonedas
#define SOAP_TYPE__afip3__FEParamGetTiposMonedas (113)
/* complex XML schema type 'afip3:FEParamGetTiposMonedas': */
class SOAP_CMAC _afip3__FEParamGetTiposMonedas {
      public:
        /// Optional element 'afip3:Auth' of XML schema type 'afip3:FEAuthRequest'
        afip3__FEAuthRequest *Auth;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FEParamGetTiposMonedas
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FEParamGetTiposMonedas; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FEParamGetTiposMonedas, default initialized and not managed by a soap context
        virtual _afip3__FEParamGetTiposMonedas *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FEParamGetTiposMonedas); }
      public:
        /// Constructor with default initializations
        _afip3__FEParamGetTiposMonedas() : Auth(), soap() { }
        virtual ~_afip3__FEParamGetTiposMonedas() { }
        /// Friend allocator used by soap_new__afip3__FEParamGetTiposMonedas(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FEParamGetTiposMonedas * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetTiposMonedas(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:376 */
#ifndef SOAP_TYPE__afip3__FEParamGetTiposMonedasResponse
#define SOAP_TYPE__afip3__FEParamGetTiposMonedasResponse (114)
/* complex XML schema type 'afip3:FEParamGetTiposMonedasResponse': */
class SOAP_CMAC _afip3__FEParamGetTiposMonedasResponse {
      public:
        /// Optional element 'afip3:FEParamGetTiposMonedasResult' of XML schema type 'afip3:MonedaResponse'
        afip3__MonedaResponse *FEParamGetTiposMonedasResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FEParamGetTiposMonedasResponse
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FEParamGetTiposMonedasResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FEParamGetTiposMonedasResponse, default initialized and not managed by a soap context
        virtual _afip3__FEParamGetTiposMonedasResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FEParamGetTiposMonedasResponse); }
      public:
        /// Constructor with default initializations
        _afip3__FEParamGetTiposMonedasResponse() : FEParamGetTiposMonedasResult(), soap() { }
        virtual ~_afip3__FEParamGetTiposMonedasResponse() { }
        /// Friend allocator used by soap_new__afip3__FEParamGetTiposMonedasResponse(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FEParamGetTiposMonedasResponse * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetTiposMonedasResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:378 */
#ifndef SOAP_TYPE__afip3__FEParamGetTiposIva
#define SOAP_TYPE__afip3__FEParamGetTiposIva (115)
/* complex XML schema type 'afip3:FEParamGetTiposIva': */
class SOAP_CMAC _afip3__FEParamGetTiposIva {
      public:
        /// Optional element 'afip3:Auth' of XML schema type 'afip3:FEAuthRequest'
        afip3__FEAuthRequest *Auth;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FEParamGetTiposIva
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FEParamGetTiposIva; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FEParamGetTiposIva, default initialized and not managed by a soap context
        virtual _afip3__FEParamGetTiposIva *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FEParamGetTiposIva); }
      public:
        /// Constructor with default initializations
        _afip3__FEParamGetTiposIva() : Auth(), soap() { }
        virtual ~_afip3__FEParamGetTiposIva() { }
        /// Friend allocator used by soap_new__afip3__FEParamGetTiposIva(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FEParamGetTiposIva * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetTiposIva(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:380 */
#ifndef SOAP_TYPE__afip3__FEParamGetTiposIvaResponse
#define SOAP_TYPE__afip3__FEParamGetTiposIvaResponse (116)
/* complex XML schema type 'afip3:FEParamGetTiposIvaResponse': */
class SOAP_CMAC _afip3__FEParamGetTiposIvaResponse {
      public:
        /// Optional element 'afip3:FEParamGetTiposIvaResult' of XML schema type 'afip3:IvaTipoResponse'
        afip3__IvaTipoResponse *FEParamGetTiposIvaResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FEParamGetTiposIvaResponse
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FEParamGetTiposIvaResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FEParamGetTiposIvaResponse, default initialized and not managed by a soap context
        virtual _afip3__FEParamGetTiposIvaResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FEParamGetTiposIvaResponse); }
      public:
        /// Constructor with default initializations
        _afip3__FEParamGetTiposIvaResponse() : FEParamGetTiposIvaResult(), soap() { }
        virtual ~_afip3__FEParamGetTiposIvaResponse() { }
        /// Friend allocator used by soap_new__afip3__FEParamGetTiposIvaResponse(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FEParamGetTiposIvaResponse * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetTiposIvaResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:382 */
#ifndef SOAP_TYPE__afip3__FEParamGetTiposOpcional
#define SOAP_TYPE__afip3__FEParamGetTiposOpcional (117)
/* complex XML schema type 'afip3:FEParamGetTiposOpcional': */
class SOAP_CMAC _afip3__FEParamGetTiposOpcional {
      public:
        /// Optional element 'afip3:Auth' of XML schema type 'afip3:FEAuthRequest'
        afip3__FEAuthRequest *Auth;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FEParamGetTiposOpcional
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FEParamGetTiposOpcional; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FEParamGetTiposOpcional, default initialized and not managed by a soap context
        virtual _afip3__FEParamGetTiposOpcional *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FEParamGetTiposOpcional); }
      public:
        /// Constructor with default initializations
        _afip3__FEParamGetTiposOpcional() : Auth(), soap() { }
        virtual ~_afip3__FEParamGetTiposOpcional() { }
        /// Friend allocator used by soap_new__afip3__FEParamGetTiposOpcional(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FEParamGetTiposOpcional * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetTiposOpcional(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:384 */
#ifndef SOAP_TYPE__afip3__FEParamGetTiposOpcionalResponse
#define SOAP_TYPE__afip3__FEParamGetTiposOpcionalResponse (118)
/* complex XML schema type 'afip3:FEParamGetTiposOpcionalResponse': */
class SOAP_CMAC _afip3__FEParamGetTiposOpcionalResponse {
      public:
        /// Optional element 'afip3:FEParamGetTiposOpcionalResult' of XML schema type 'afip3:OpcionalTipoResponse'
        afip3__OpcionalTipoResponse *FEParamGetTiposOpcionalResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FEParamGetTiposOpcionalResponse
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FEParamGetTiposOpcionalResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FEParamGetTiposOpcionalResponse, default initialized and not managed by a soap context
        virtual _afip3__FEParamGetTiposOpcionalResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FEParamGetTiposOpcionalResponse); }
      public:
        /// Constructor with default initializations
        _afip3__FEParamGetTiposOpcionalResponse() : FEParamGetTiposOpcionalResult(), soap() { }
        virtual ~_afip3__FEParamGetTiposOpcionalResponse() { }
        /// Friend allocator used by soap_new__afip3__FEParamGetTiposOpcionalResponse(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FEParamGetTiposOpcionalResponse * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetTiposOpcionalResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:386 */
#ifndef SOAP_TYPE__afip3__FEParamGetTiposConcepto
#define SOAP_TYPE__afip3__FEParamGetTiposConcepto (119)
/* complex XML schema type 'afip3:FEParamGetTiposConcepto': */
class SOAP_CMAC _afip3__FEParamGetTiposConcepto {
      public:
        /// Optional element 'afip3:Auth' of XML schema type 'afip3:FEAuthRequest'
        afip3__FEAuthRequest *Auth;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FEParamGetTiposConcepto
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FEParamGetTiposConcepto; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FEParamGetTiposConcepto, default initialized and not managed by a soap context
        virtual _afip3__FEParamGetTiposConcepto *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FEParamGetTiposConcepto); }
      public:
        /// Constructor with default initializations
        _afip3__FEParamGetTiposConcepto() : Auth(), soap() { }
        virtual ~_afip3__FEParamGetTiposConcepto() { }
        /// Friend allocator used by soap_new__afip3__FEParamGetTiposConcepto(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FEParamGetTiposConcepto * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetTiposConcepto(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:388 */
#ifndef SOAP_TYPE__afip3__FEParamGetTiposConceptoResponse
#define SOAP_TYPE__afip3__FEParamGetTiposConceptoResponse (120)
/* complex XML schema type 'afip3:FEParamGetTiposConceptoResponse': */
class SOAP_CMAC _afip3__FEParamGetTiposConceptoResponse {
      public:
        /// Optional element 'afip3:FEParamGetTiposConceptoResult' of XML schema type 'afip3:ConceptoTipoResponse'
        afip3__ConceptoTipoResponse *FEParamGetTiposConceptoResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FEParamGetTiposConceptoResponse
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FEParamGetTiposConceptoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FEParamGetTiposConceptoResponse, default initialized and not managed by a soap context
        virtual _afip3__FEParamGetTiposConceptoResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FEParamGetTiposConceptoResponse); }
      public:
        /// Constructor with default initializations
        _afip3__FEParamGetTiposConceptoResponse() : FEParamGetTiposConceptoResult(), soap() { }
        virtual ~_afip3__FEParamGetTiposConceptoResponse() { }
        /// Friend allocator used by soap_new__afip3__FEParamGetTiposConceptoResponse(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FEParamGetTiposConceptoResponse * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetTiposConceptoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:390 */
#ifndef SOAP_TYPE__afip3__FEParamGetPtosVenta
#define SOAP_TYPE__afip3__FEParamGetPtosVenta (121)
/* complex XML schema type 'afip3:FEParamGetPtosVenta': */
class SOAP_CMAC _afip3__FEParamGetPtosVenta {
      public:
        /// Optional element 'afip3:Auth' of XML schema type 'afip3:FEAuthRequest'
        afip3__FEAuthRequest *Auth;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FEParamGetPtosVenta
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FEParamGetPtosVenta; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FEParamGetPtosVenta, default initialized and not managed by a soap context
        virtual _afip3__FEParamGetPtosVenta *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FEParamGetPtosVenta); }
      public:
        /// Constructor with default initializations
        _afip3__FEParamGetPtosVenta() : Auth(), soap() { }
        virtual ~_afip3__FEParamGetPtosVenta() { }
        /// Friend allocator used by soap_new__afip3__FEParamGetPtosVenta(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FEParamGetPtosVenta * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetPtosVenta(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:392 */
#ifndef SOAP_TYPE__afip3__FEParamGetPtosVentaResponse
#define SOAP_TYPE__afip3__FEParamGetPtosVentaResponse (122)
/* complex XML schema type 'afip3:FEParamGetPtosVentaResponse': */
class SOAP_CMAC _afip3__FEParamGetPtosVentaResponse {
      public:
        /// Optional element 'afip3:FEParamGetPtosVentaResult' of XML schema type 'afip3:FEPtoVentaResponse'
        afip3__FEPtoVentaResponse *FEParamGetPtosVentaResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FEParamGetPtosVentaResponse
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FEParamGetPtosVentaResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FEParamGetPtosVentaResponse, default initialized and not managed by a soap context
        virtual _afip3__FEParamGetPtosVentaResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FEParamGetPtosVentaResponse); }
      public:
        /// Constructor with default initializations
        _afip3__FEParamGetPtosVentaResponse() : FEParamGetPtosVentaResult(), soap() { }
        virtual ~_afip3__FEParamGetPtosVentaResponse() { }
        /// Friend allocator used by soap_new__afip3__FEParamGetPtosVentaResponse(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FEParamGetPtosVentaResponse * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetPtosVentaResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:394 */
#ifndef SOAP_TYPE__afip3__FEParamGetTiposCbte
#define SOAP_TYPE__afip3__FEParamGetTiposCbte (123)
/* complex XML schema type 'afip3:FEParamGetTiposCbte': */
class SOAP_CMAC _afip3__FEParamGetTiposCbte {
      public:
        /// Optional element 'afip3:Auth' of XML schema type 'afip3:FEAuthRequest'
        afip3__FEAuthRequest *Auth;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FEParamGetTiposCbte
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FEParamGetTiposCbte; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FEParamGetTiposCbte, default initialized and not managed by a soap context
        virtual _afip3__FEParamGetTiposCbte *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FEParamGetTiposCbte); }
      public:
        /// Constructor with default initializations
        _afip3__FEParamGetTiposCbte() : Auth(), soap() { }
        virtual ~_afip3__FEParamGetTiposCbte() { }
        /// Friend allocator used by soap_new__afip3__FEParamGetTiposCbte(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FEParamGetTiposCbte * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetTiposCbte(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:396 */
#ifndef SOAP_TYPE__afip3__FEParamGetTiposCbteResponse
#define SOAP_TYPE__afip3__FEParamGetTiposCbteResponse (124)
/* complex XML schema type 'afip3:FEParamGetTiposCbteResponse': */
class SOAP_CMAC _afip3__FEParamGetTiposCbteResponse {
      public:
        /// Optional element 'afip3:FEParamGetTiposCbteResult' of XML schema type 'afip3:CbteTipoResponse'
        afip3__CbteTipoResponse *FEParamGetTiposCbteResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FEParamGetTiposCbteResponse
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FEParamGetTiposCbteResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FEParamGetTiposCbteResponse, default initialized and not managed by a soap context
        virtual _afip3__FEParamGetTiposCbteResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FEParamGetTiposCbteResponse); }
      public:
        /// Constructor with default initializations
        _afip3__FEParamGetTiposCbteResponse() : FEParamGetTiposCbteResult(), soap() { }
        virtual ~_afip3__FEParamGetTiposCbteResponse() { }
        /// Friend allocator used by soap_new__afip3__FEParamGetTiposCbteResponse(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FEParamGetTiposCbteResponse * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetTiposCbteResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:398 */
#ifndef SOAP_TYPE__afip3__FEParamGetTiposDoc
#define SOAP_TYPE__afip3__FEParamGetTiposDoc (125)
/* complex XML schema type 'afip3:FEParamGetTiposDoc': */
class SOAP_CMAC _afip3__FEParamGetTiposDoc {
      public:
        /// Optional element 'afip3:Auth' of XML schema type 'afip3:FEAuthRequest'
        afip3__FEAuthRequest *Auth;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FEParamGetTiposDoc
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FEParamGetTiposDoc; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FEParamGetTiposDoc, default initialized and not managed by a soap context
        virtual _afip3__FEParamGetTiposDoc *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FEParamGetTiposDoc); }
      public:
        /// Constructor with default initializations
        _afip3__FEParamGetTiposDoc() : Auth(), soap() { }
        virtual ~_afip3__FEParamGetTiposDoc() { }
        /// Friend allocator used by soap_new__afip3__FEParamGetTiposDoc(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FEParamGetTiposDoc * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetTiposDoc(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:400 */
#ifndef SOAP_TYPE__afip3__FEParamGetTiposDocResponse
#define SOAP_TYPE__afip3__FEParamGetTiposDocResponse (126)
/* complex XML schema type 'afip3:FEParamGetTiposDocResponse': */
class SOAP_CMAC _afip3__FEParamGetTiposDocResponse {
      public:
        /// Optional element 'afip3:FEParamGetTiposDocResult' of XML schema type 'afip3:DocTipoResponse'
        afip3__DocTipoResponse *FEParamGetTiposDocResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FEParamGetTiposDocResponse
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FEParamGetTiposDocResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FEParamGetTiposDocResponse, default initialized and not managed by a soap context
        virtual _afip3__FEParamGetTiposDocResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FEParamGetTiposDocResponse); }
      public:
        /// Constructor with default initializations
        _afip3__FEParamGetTiposDocResponse() : FEParamGetTiposDocResult(), soap() { }
        virtual ~_afip3__FEParamGetTiposDocResponse() { }
        /// Friend allocator used by soap_new__afip3__FEParamGetTiposDocResponse(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FEParamGetTiposDocResponse * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetTiposDocResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:402 */
#ifndef SOAP_TYPE__afip3__FEParamGetTiposPaises
#define SOAP_TYPE__afip3__FEParamGetTiposPaises (127)
/* complex XML schema type 'afip3:FEParamGetTiposPaises': */
class SOAP_CMAC _afip3__FEParamGetTiposPaises {
      public:
        /// Optional element 'afip3:Auth' of XML schema type 'afip3:FEAuthRequest'
        afip3__FEAuthRequest *Auth;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FEParamGetTiposPaises
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FEParamGetTiposPaises; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FEParamGetTiposPaises, default initialized and not managed by a soap context
        virtual _afip3__FEParamGetTiposPaises *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FEParamGetTiposPaises); }
      public:
        /// Constructor with default initializations
        _afip3__FEParamGetTiposPaises() : Auth(), soap() { }
        virtual ~_afip3__FEParamGetTiposPaises() { }
        /// Friend allocator used by soap_new__afip3__FEParamGetTiposPaises(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FEParamGetTiposPaises * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetTiposPaises(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:404 */
#ifndef SOAP_TYPE__afip3__FEParamGetTiposPaisesResponse
#define SOAP_TYPE__afip3__FEParamGetTiposPaisesResponse (128)
/* complex XML schema type 'afip3:FEParamGetTiposPaisesResponse': */
class SOAP_CMAC _afip3__FEParamGetTiposPaisesResponse {
      public:
        /// Optional element 'afip3:FEParamGetTiposPaisesResult' of XML schema type 'afip3:FEPaisResponse'
        afip3__FEPaisResponse *FEParamGetTiposPaisesResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__afip3__FEParamGetTiposPaisesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__afip3__FEParamGetTiposPaisesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _afip3__FEParamGetTiposPaisesResponse, default initialized and not managed by a soap context
        virtual _afip3__FEParamGetTiposPaisesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_afip3__FEParamGetTiposPaisesResponse); }
      public:
        /// Constructor with default initializations
        _afip3__FEParamGetTiposPaisesResponse() : FEParamGetTiposPaisesResult(), soap() { }
        virtual ~_afip3__FEParamGetTiposPaisesResponse() { }
        /// Friend allocator used by soap_new__afip3__FEParamGetTiposPaisesResponse(struct soap*, int)
        friend SOAP_FMAC1 _afip3__FEParamGetTiposPaisesResponse * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetTiposPaisesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:174 */
#ifndef SOAP_TYPE_afip3__FECAECabRequest
#define SOAP_TYPE_afip3__FECAECabRequest (13)
/* complex XML schema type 'afip3:FECAECabRequest': */
class SOAP_CMAC afip3__FECAECabRequest : public afip3__FECabRequest {
      public:
        /// Return unique type id SOAP_TYPE_afip3__FECAECabRequest
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__FECAECabRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__FECAECabRequest, default initialized and not managed by a soap context
        virtual afip3__FECAECabRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__FECAECabRequest); }
      public:
        /// Constructor with default initializations
        afip3__FECAECabRequest() { }
        virtual ~afip3__FECAECabRequest() { }
        /// Friend allocator used by soap_new_afip3__FECAECabRequest(struct soap*, int)
        friend SOAP_FMAC1 afip3__FECAECabRequest * SOAP_FMAC2 soap_instantiate_afip3__FECAECabRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:180 */
#ifndef SOAP_TYPE_afip3__FECAEDetRequest
#define SOAP_TYPE_afip3__FECAEDetRequest (16)
/* complex XML schema type 'afip3:FECAEDetRequest': */
class SOAP_CMAC afip3__FECAEDetRequest : public afip3__FEDetRequest {
      public:
        /// Return unique type id SOAP_TYPE_afip3__FECAEDetRequest
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__FECAEDetRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__FECAEDetRequest, default initialized and not managed by a soap context
        virtual afip3__FECAEDetRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__FECAEDetRequest); }
      public:
        /// Constructor with default initializations
        afip3__FECAEDetRequest() { }
        virtual ~afip3__FECAEDetRequest() { }
        /// Friend allocator used by soap_new_afip3__FECAEDetRequest(struct soap*, int)
        friend SOAP_FMAC1 afip3__FECAEDetRequest * SOAP_FMAC2 soap_instantiate_afip3__FECAEDetRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:206 */
#ifndef SOAP_TYPE_afip3__FECAECabResponse
#define SOAP_TYPE_afip3__FECAECabResponse (29)
/* complex XML schema type 'afip3:FECAECabResponse': */
class SOAP_CMAC afip3__FECAECabResponse : public afip3__FECabResponse {
      public:
        /// Return unique type id SOAP_TYPE_afip3__FECAECabResponse
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__FECAECabResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__FECAECabResponse, default initialized and not managed by a soap context
        virtual afip3__FECAECabResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__FECAECabResponse); }
      public:
        /// Constructor with default initializations
        afip3__FECAECabResponse() { }
        virtual ~afip3__FECAECabResponse() { }
        /// Friend allocator used by soap_new_afip3__FECAECabResponse(struct soap*, int)
        friend SOAP_FMAC1 afip3__FECAECabResponse * SOAP_FMAC2 soap_instantiate_afip3__FECAECabResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:212 */
#ifndef SOAP_TYPE_afip3__FECAEDetResponse
#define SOAP_TYPE_afip3__FECAEDetResponse (32)
/* complex XML schema type 'afip3:FECAEDetResponse': */
class SOAP_CMAC afip3__FECAEDetResponse : public afip3__FEDetResponse {
      public:
        /// Optional element 'afip3:CAE' of XML schema type 'xsd:string'
        std::string *CAE;
        /// Optional element 'afip3:CAEFchVto' of XML schema type 'xsd:string'
        std::string *CAEFchVto;
      public:
        /// Return unique type id SOAP_TYPE_afip3__FECAEDetResponse
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__FECAEDetResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__FECAEDetResponse, default initialized and not managed by a soap context
        virtual afip3__FECAEDetResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__FECAEDetResponse); }
      public:
        /// Constructor with default initializations
        afip3__FECAEDetResponse() : CAE(), CAEFchVto() { }
        virtual ~afip3__FECAEDetResponse() { }
        /// Friend allocator used by soap_new_afip3__FECAEDetResponse(struct soap*, int)
        friend SOAP_FMAC1 afip3__FECAEDetResponse * SOAP_FMAC2 soap_instantiate_afip3__FECAEDetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:242 */
#ifndef SOAP_TYPE_afip3__FECAEACabRequest
#define SOAP_TYPE_afip3__FECAEACabRequest (47)
/* complex XML schema type 'afip3:FECAEACabRequest': */
class SOAP_CMAC afip3__FECAEACabRequest : public afip3__FECabRequest {
      public:
        /// Return unique type id SOAP_TYPE_afip3__FECAEACabRequest
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__FECAEACabRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__FECAEACabRequest, default initialized and not managed by a soap context
        virtual afip3__FECAEACabRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__FECAEACabRequest); }
      public:
        /// Constructor with default initializations
        afip3__FECAEACabRequest() { }
        virtual ~afip3__FECAEACabRequest() { }
        /// Friend allocator used by soap_new_afip3__FECAEACabRequest(struct soap*, int)
        friend SOAP_FMAC1 afip3__FECAEACabRequest * SOAP_FMAC2 soap_instantiate_afip3__FECAEACabRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:246 */
#ifndef SOAP_TYPE_afip3__FECAEADetRequest
#define SOAP_TYPE_afip3__FECAEADetRequest (49)
/* complex XML schema type 'afip3:FECAEADetRequest': */
class SOAP_CMAC afip3__FECAEADetRequest : public afip3__FEDetRequest {
      public:
        /// Optional element 'afip3:CAEA' of XML schema type 'xsd:string'
        std::string *CAEA;
        /// Optional element 'afip3:CbteFchHsGen' of XML schema type 'xsd:string'
        std::string *CbteFchHsGen;
      public:
        /// Return unique type id SOAP_TYPE_afip3__FECAEADetRequest
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__FECAEADetRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__FECAEADetRequest, default initialized and not managed by a soap context
        virtual afip3__FECAEADetRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__FECAEADetRequest); }
      public:
        /// Constructor with default initializations
        afip3__FECAEADetRequest() : CAEA(), CbteFchHsGen() { }
        virtual ~afip3__FECAEADetRequest() { }
        /// Friend allocator used by soap_new_afip3__FECAEADetRequest(struct soap*, int)
        friend SOAP_FMAC1 afip3__FECAEADetRequest * SOAP_FMAC2 soap_instantiate_afip3__FECAEADetRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:250 */
#ifndef SOAP_TYPE_afip3__FECAEACabResponse
#define SOAP_TYPE_afip3__FECAEACabResponse (51)
/* complex XML schema type 'afip3:FECAEACabResponse': */
class SOAP_CMAC afip3__FECAEACabResponse : public afip3__FECabResponse {
      public:
        /// Return unique type id SOAP_TYPE_afip3__FECAEACabResponse
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__FECAEACabResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__FECAEACabResponse, default initialized and not managed by a soap context
        virtual afip3__FECAEACabResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__FECAEACabResponse); }
      public:
        /// Constructor with default initializations
        afip3__FECAEACabResponse() { }
        virtual ~afip3__FECAEACabResponse() { }
        /// Friend allocator used by soap_new_afip3__FECAEACabResponse(struct soap*, int)
        friend SOAP_FMAC1 afip3__FECAEACabResponse * SOAP_FMAC2 soap_instantiate_afip3__FECAEACabResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:254 */
#ifndef SOAP_TYPE_afip3__FECAEADetResponse
#define SOAP_TYPE_afip3__FECAEADetResponse (53)
/* complex XML schema type 'afip3:FECAEADetResponse': */
class SOAP_CMAC afip3__FECAEADetResponse : public afip3__FEDetResponse {
      public:
        /// Optional element 'afip3:CAEA' of XML schema type 'xsd:string'
        std::string *CAEA;
      public:
        /// Return unique type id SOAP_TYPE_afip3__FECAEADetResponse
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__FECAEADetResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__FECAEADetResponse, default initialized and not managed by a soap context
        virtual afip3__FECAEADetResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__FECAEADetResponse); }
      public:
        /// Constructor with default initializations
        afip3__FECAEADetResponse() : CAEA() { }
        virtual ~afip3__FECAEADetResponse() { }
        /// Friend allocator used by soap_new_afip3__FECAEADetResponse(struct soap*, int)
        friend SOAP_FMAC1 afip3__FECAEADetResponse * SOAP_FMAC2 soap_instantiate_afip3__FECAEADetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:266 */
#ifndef SOAP_TYPE_afip3__FECAEASinMovResponse
#define SOAP_TYPE_afip3__FECAEASinMovResponse (59)
/* complex XML schema type 'afip3:FECAEASinMovResponse': */
class SOAP_CMAC afip3__FECAEASinMovResponse : public afip3__FECAEASinMov {
      public:
        /// Optional element 'afip3:Resultado' of XML schema type 'xsd:string'
        std::string *Resultado;
        /// Optional element 'afip3:Errors' of XML schema type 'afip3:ArrayOfErr'
        afip3__ArrayOfErr *Errors;
        /// Optional element 'afip3:Events' of XML schema type 'afip3:ArrayOfEvt'
        afip3__ArrayOfEvt *Events;
      public:
        /// Return unique type id SOAP_TYPE_afip3__FECAEASinMovResponse
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__FECAEASinMovResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__FECAEASinMovResponse, default initialized and not managed by a soap context
        virtual afip3__FECAEASinMovResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__FECAEASinMovResponse); }
      public:
        /// Constructor with default initializations
        afip3__FECAEASinMovResponse() : Resultado(), Errors(), Events() { }
        virtual ~afip3__FECAEASinMovResponse() { }
        /// Friend allocator used by soap_new_afip3__FECAEASinMovResponse(struct soap*, int)
        friend SOAP_FMAC1 afip3__FECAEASinMovResponse * SOAP_FMAC2 soap_instantiate_afip3__FECAEASinMovResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:238 */
#ifndef SOAP_TYPE_afip3__FECompConsResponse
#define SOAP_TYPE_afip3__FECompConsResponse (45)
/* complex XML schema type 'afip3:FECompConsResponse': */
class SOAP_CMAC afip3__FECompConsResponse : public afip3__FECAEDetRequest {
      public:
        /// Optional element 'afip3:Resultado' of XML schema type 'xsd:string'
        std::string *Resultado;
        /// Optional element 'afip3:CodAutorizacion' of XML schema type 'xsd:string'
        std::string *CodAutorizacion;
        /// Optional element 'afip3:EmisionTipo' of XML schema type 'xsd:string'
        std::string *EmisionTipo;
        /// Optional element 'afip3:FchVto' of XML schema type 'xsd:string'
        std::string *FchVto;
        /// Optional element 'afip3:FchProceso' of XML schema type 'xsd:string'
        std::string *FchProceso;
        /// Optional element 'afip3:Observaciones' of XML schema type 'afip3:ArrayOfObs'
        afip3__ArrayOfObs *Observaciones;
        /// Required element 'afip3:PtoVta' of XML schema type 'xsd:int'
        int PtoVta;
        /// Required element 'afip3:CbteTipo' of XML schema type 'xsd:int'
        int CbteTipo;
      public:
        /// Return unique type id SOAP_TYPE_afip3__FECompConsResponse
        virtual long soap_type(void) const { return SOAP_TYPE_afip3__FECompConsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type afip3__FECompConsResponse, default initialized and not managed by a soap context
        virtual afip3__FECompConsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(afip3__FECompConsResponse); }
      public:
        /// Constructor with default initializations
        afip3__FECompConsResponse() : Resultado(), CodAutorizacion(), EmisionTipo(), FchVto(), FchProceso(), Observaciones(), PtoVta(), CbteTipo() { }
        virtual ~afip3__FECompConsResponse() { }
        /// Friend allocator used by soap_new_afip3__FECompConsResponse(struct soap*, int)
        friend SOAP_FMAC1 afip3__FECompConsResponse * SOAP_FMAC2 soap_instantiate_afip3__FECompConsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:3810 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (231)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        /** Optional element 'afip2:fault' of XML schema type 'afip2:LoginFault' */
        afip2__LoginFault *afip2__fault;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_<typename> assigned to __type */
        /** Do not create a cyclic data structure through this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
        char *__any;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : afip2__fault(), __type(), fault(), __any() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* soap/afip_soap.h:3896 */
#ifndef SOAP_TYPE___afip2__loginCms
#define SOAP_TYPE___afip2__loginCms (238)
/* Wrapper: */
struct SOAP_CMAC __afip2__loginCms {
      public:
        /** Optional element 'afip1:loginCms' of XML schema type 'afip1:loginCms' */
        _afip1__loginCms *afip1__loginCms;
      public:
        /** Return unique type id SOAP_TYPE___afip2__loginCms */
        long soap_type() const { return SOAP_TYPE___afip2__loginCms; }
        /** Constructor with member initializations */
        __afip2__loginCms() : afip1__loginCms() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip2__loginCms * SOAP_FMAC2 soap_instantiate___afip2__loginCms(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:3983 */
#ifndef SOAP_TYPE___afip4__FECAESolicitar
#define SOAP_TYPE___afip4__FECAESolicitar (242)
/* Wrapper: */
struct SOAP_CMAC __afip4__FECAESolicitar {
      public:
        /** Optional element 'afip3:FECAESolicitar' of XML schema type 'afip3:FECAESolicitar' */
        _afip3__FECAESolicitar *afip3__FECAESolicitar;
      public:
        /** Return unique type id SOAP_TYPE___afip4__FECAESolicitar */
        long soap_type() const { return SOAP_TYPE___afip4__FECAESolicitar; }
        /** Constructor with member initializations */
        __afip4__FECAESolicitar() : afip3__FECAESolicitar() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip4__FECAESolicitar * SOAP_FMAC2 soap_instantiate___afip4__FECAESolicitar(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:4055 */
#ifndef SOAP_TYPE___afip4__FECompTotXRequest
#define SOAP_TYPE___afip4__FECompTotXRequest (246)
/* Wrapper: */
struct SOAP_CMAC __afip4__FECompTotXRequest {
      public:
        /** Optional element 'afip3:FECompTotXRequest' of XML schema type 'afip3:FECompTotXRequest' */
        _afip3__FECompTotXRequest *afip3__FECompTotXRequest;
      public:
        /** Return unique type id SOAP_TYPE___afip4__FECompTotXRequest */
        long soap_type() const { return SOAP_TYPE___afip4__FECompTotXRequest; }
        /** Constructor with member initializations */
        __afip4__FECompTotXRequest() : afip3__FECompTotXRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip4__FECompTotXRequest * SOAP_FMAC2 soap_instantiate___afip4__FECompTotXRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:4126 */
#ifndef SOAP_TYPE___afip4__FEDummy
#define SOAP_TYPE___afip4__FEDummy (250)
/* Wrapper: */
struct SOAP_CMAC __afip4__FEDummy {
      public:
        /** Optional element 'afip3:FEDummy' of XML schema type 'afip3:FEDummy' */
        _afip3__FEDummy *afip3__FEDummy;
      public:
        /** Return unique type id SOAP_TYPE___afip4__FEDummy */
        long soap_type() const { return SOAP_TYPE___afip4__FEDummy; }
        /** Constructor with member initializations */
        __afip4__FEDummy() : afip3__FEDummy() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip4__FEDummy * SOAP_FMAC2 soap_instantiate___afip4__FEDummy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:4198 */
#ifndef SOAP_TYPE___afip4__FECompUltimoAutorizado
#define SOAP_TYPE___afip4__FECompUltimoAutorizado (254)
/* Wrapper: */
struct SOAP_CMAC __afip4__FECompUltimoAutorizado {
      public:
        /** Optional element 'afip3:FECompUltimoAutorizado' of XML schema type 'afip3:FECompUltimoAutorizado' */
        _afip3__FECompUltimoAutorizado *afip3__FECompUltimoAutorizado;
      public:
        /** Return unique type id SOAP_TYPE___afip4__FECompUltimoAutorizado */
        long soap_type() const { return SOAP_TYPE___afip4__FECompUltimoAutorizado; }
        /** Constructor with member initializations */
        __afip4__FECompUltimoAutorizado() : afip3__FECompUltimoAutorizado() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip4__FECompUltimoAutorizado * SOAP_FMAC2 soap_instantiate___afip4__FECompUltimoAutorizado(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:4269 */
#ifndef SOAP_TYPE___afip4__FECompConsultar
#define SOAP_TYPE___afip4__FECompConsultar (258)
/* Wrapper: */
struct SOAP_CMAC __afip4__FECompConsultar {
      public:
        /** Optional element 'afip3:FECompConsultar' of XML schema type 'afip3:FECompConsultar' */
        _afip3__FECompConsultar *afip3__FECompConsultar;
      public:
        /** Return unique type id SOAP_TYPE___afip4__FECompConsultar */
        long soap_type() const { return SOAP_TYPE___afip4__FECompConsultar; }
        /** Constructor with member initializations */
        __afip4__FECompConsultar() : afip3__FECompConsultar() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip4__FECompConsultar * SOAP_FMAC2 soap_instantiate___afip4__FECompConsultar(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:4340 */
#ifndef SOAP_TYPE___afip4__FECAEARegInformativo
#define SOAP_TYPE___afip4__FECAEARegInformativo (262)
/* Wrapper: */
struct SOAP_CMAC __afip4__FECAEARegInformativo {
      public:
        /** Optional element 'afip3:FECAEARegInformativo' of XML schema type 'afip3:FECAEARegInformativo' */
        _afip3__FECAEARegInformativo *afip3__FECAEARegInformativo;
      public:
        /** Return unique type id SOAP_TYPE___afip4__FECAEARegInformativo */
        long soap_type() const { return SOAP_TYPE___afip4__FECAEARegInformativo; }
        /** Constructor with member initializations */
        __afip4__FECAEARegInformativo() : afip3__FECAEARegInformativo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip4__FECAEARegInformativo * SOAP_FMAC2 soap_instantiate___afip4__FECAEARegInformativo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:4411 */
#ifndef SOAP_TYPE___afip4__FECAEASolicitar
#define SOAP_TYPE___afip4__FECAEASolicitar (266)
/* Wrapper: */
struct SOAP_CMAC __afip4__FECAEASolicitar {
      public:
        /** Optional element 'afip3:FECAEASolicitar' of XML schema type 'afip3:FECAEASolicitar' */
        _afip3__FECAEASolicitar *afip3__FECAEASolicitar;
      public:
        /** Return unique type id SOAP_TYPE___afip4__FECAEASolicitar */
        long soap_type() const { return SOAP_TYPE___afip4__FECAEASolicitar; }
        /** Constructor with member initializations */
        __afip4__FECAEASolicitar() : afip3__FECAEASolicitar() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip4__FECAEASolicitar * SOAP_FMAC2 soap_instantiate___afip4__FECAEASolicitar(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:4482 */
#ifndef SOAP_TYPE___afip4__FECAEASinMovimientoConsultar
#define SOAP_TYPE___afip4__FECAEASinMovimientoConsultar (270)
/* Wrapper: */
struct SOAP_CMAC __afip4__FECAEASinMovimientoConsultar {
      public:
        /** Optional element 'afip3:FECAEASinMovimientoConsultar' of XML schema type 'afip3:FECAEASinMovimientoConsultar' */
        _afip3__FECAEASinMovimientoConsultar *afip3__FECAEASinMovimientoConsultar;
      public:
        /** Return unique type id SOAP_TYPE___afip4__FECAEASinMovimientoConsultar */
        long soap_type() const { return SOAP_TYPE___afip4__FECAEASinMovimientoConsultar; }
        /** Constructor with member initializations */
        __afip4__FECAEASinMovimientoConsultar() : afip3__FECAEASinMovimientoConsultar() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip4__FECAEASinMovimientoConsultar * SOAP_FMAC2 soap_instantiate___afip4__FECAEASinMovimientoConsultar(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:4553 */
#ifndef SOAP_TYPE___afip4__FECAEASinMovimientoInformar
#define SOAP_TYPE___afip4__FECAEASinMovimientoInformar (274)
/* Wrapper: */
struct SOAP_CMAC __afip4__FECAEASinMovimientoInformar {
      public:
        /** Optional element 'afip3:FECAEASinMovimientoInformar' of XML schema type 'afip3:FECAEASinMovimientoInformar' */
        _afip3__FECAEASinMovimientoInformar *afip3__FECAEASinMovimientoInformar;
      public:
        /** Return unique type id SOAP_TYPE___afip4__FECAEASinMovimientoInformar */
        long soap_type() const { return SOAP_TYPE___afip4__FECAEASinMovimientoInformar; }
        /** Constructor with member initializations */
        __afip4__FECAEASinMovimientoInformar() : afip3__FECAEASinMovimientoInformar() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip4__FECAEASinMovimientoInformar * SOAP_FMAC2 soap_instantiate___afip4__FECAEASinMovimientoInformar(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:4624 */
#ifndef SOAP_TYPE___afip4__FECAEAConsultar
#define SOAP_TYPE___afip4__FECAEAConsultar (278)
/* Wrapper: */
struct SOAP_CMAC __afip4__FECAEAConsultar {
      public:
        /** Optional element 'afip3:FECAEAConsultar' of XML schema type 'afip3:FECAEAConsultar' */
        _afip3__FECAEAConsultar *afip3__FECAEAConsultar;
      public:
        /** Return unique type id SOAP_TYPE___afip4__FECAEAConsultar */
        long soap_type() const { return SOAP_TYPE___afip4__FECAEAConsultar; }
        /** Constructor with member initializations */
        __afip4__FECAEAConsultar() : afip3__FECAEAConsultar() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip4__FECAEAConsultar * SOAP_FMAC2 soap_instantiate___afip4__FECAEAConsultar(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:4695 */
#ifndef SOAP_TYPE___afip4__FEParamGetCotizacion
#define SOAP_TYPE___afip4__FEParamGetCotizacion (282)
/* Wrapper: */
struct SOAP_CMAC __afip4__FEParamGetCotizacion {
      public:
        /** Optional element 'afip3:FEParamGetCotizacion' of XML schema type 'afip3:FEParamGetCotizacion' */
        _afip3__FEParamGetCotizacion *afip3__FEParamGetCotizacion;
      public:
        /** Return unique type id SOAP_TYPE___afip4__FEParamGetCotizacion */
        long soap_type() const { return SOAP_TYPE___afip4__FEParamGetCotizacion; }
        /** Constructor with member initializations */
        __afip4__FEParamGetCotizacion() : afip3__FEParamGetCotizacion() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip4__FEParamGetCotizacion * SOAP_FMAC2 soap_instantiate___afip4__FEParamGetCotizacion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:4767 */
#ifndef SOAP_TYPE___afip4__FEParamGetTiposTributos
#define SOAP_TYPE___afip4__FEParamGetTiposTributos (286)
/* Wrapper: */
struct SOAP_CMAC __afip4__FEParamGetTiposTributos {
      public:
        /** Optional element 'afip3:FEParamGetTiposTributos' of XML schema type 'afip3:FEParamGetTiposTributos' */
        _afip3__FEParamGetTiposTributos *afip3__FEParamGetTiposTributos;
      public:
        /** Return unique type id SOAP_TYPE___afip4__FEParamGetTiposTributos */
        long soap_type() const { return SOAP_TYPE___afip4__FEParamGetTiposTributos; }
        /** Constructor with member initializations */
        __afip4__FEParamGetTiposTributos() : afip3__FEParamGetTiposTributos() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip4__FEParamGetTiposTributos * SOAP_FMAC2 soap_instantiate___afip4__FEParamGetTiposTributos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:4838 */
#ifndef SOAP_TYPE___afip4__FEParamGetTiposMonedas
#define SOAP_TYPE___afip4__FEParamGetTiposMonedas (290)
/* Wrapper: */
struct SOAP_CMAC __afip4__FEParamGetTiposMonedas {
      public:
        /** Optional element 'afip3:FEParamGetTiposMonedas' of XML schema type 'afip3:FEParamGetTiposMonedas' */
        _afip3__FEParamGetTiposMonedas *afip3__FEParamGetTiposMonedas;
      public:
        /** Return unique type id SOAP_TYPE___afip4__FEParamGetTiposMonedas */
        long soap_type() const { return SOAP_TYPE___afip4__FEParamGetTiposMonedas; }
        /** Constructor with member initializations */
        __afip4__FEParamGetTiposMonedas() : afip3__FEParamGetTiposMonedas() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip4__FEParamGetTiposMonedas * SOAP_FMAC2 soap_instantiate___afip4__FEParamGetTiposMonedas(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:4909 */
#ifndef SOAP_TYPE___afip4__FEParamGetTiposIva
#define SOAP_TYPE___afip4__FEParamGetTiposIva (294)
/* Wrapper: */
struct SOAP_CMAC __afip4__FEParamGetTiposIva {
      public:
        /** Optional element 'afip3:FEParamGetTiposIva' of XML schema type 'afip3:FEParamGetTiposIva' */
        _afip3__FEParamGetTiposIva *afip3__FEParamGetTiposIva;
      public:
        /** Return unique type id SOAP_TYPE___afip4__FEParamGetTiposIva */
        long soap_type() const { return SOAP_TYPE___afip4__FEParamGetTiposIva; }
        /** Constructor with member initializations */
        __afip4__FEParamGetTiposIva() : afip3__FEParamGetTiposIva() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip4__FEParamGetTiposIva * SOAP_FMAC2 soap_instantiate___afip4__FEParamGetTiposIva(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:4980 */
#ifndef SOAP_TYPE___afip4__FEParamGetTiposOpcional
#define SOAP_TYPE___afip4__FEParamGetTiposOpcional (298)
/* Wrapper: */
struct SOAP_CMAC __afip4__FEParamGetTiposOpcional {
      public:
        /** Optional element 'afip3:FEParamGetTiposOpcional' of XML schema type 'afip3:FEParamGetTiposOpcional' */
        _afip3__FEParamGetTiposOpcional *afip3__FEParamGetTiposOpcional;
      public:
        /** Return unique type id SOAP_TYPE___afip4__FEParamGetTiposOpcional */
        long soap_type() const { return SOAP_TYPE___afip4__FEParamGetTiposOpcional; }
        /** Constructor with member initializations */
        __afip4__FEParamGetTiposOpcional() : afip3__FEParamGetTiposOpcional() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip4__FEParamGetTiposOpcional * SOAP_FMAC2 soap_instantiate___afip4__FEParamGetTiposOpcional(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:5051 */
#ifndef SOAP_TYPE___afip4__FEParamGetTiposConcepto
#define SOAP_TYPE___afip4__FEParamGetTiposConcepto (302)
/* Wrapper: */
struct SOAP_CMAC __afip4__FEParamGetTiposConcepto {
      public:
        /** Optional element 'afip3:FEParamGetTiposConcepto' of XML schema type 'afip3:FEParamGetTiposConcepto' */
        _afip3__FEParamGetTiposConcepto *afip3__FEParamGetTiposConcepto;
      public:
        /** Return unique type id SOAP_TYPE___afip4__FEParamGetTiposConcepto */
        long soap_type() const { return SOAP_TYPE___afip4__FEParamGetTiposConcepto; }
        /** Constructor with member initializations */
        __afip4__FEParamGetTiposConcepto() : afip3__FEParamGetTiposConcepto() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip4__FEParamGetTiposConcepto * SOAP_FMAC2 soap_instantiate___afip4__FEParamGetTiposConcepto(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:5122 */
#ifndef SOAP_TYPE___afip4__FEParamGetPtosVenta
#define SOAP_TYPE___afip4__FEParamGetPtosVenta (306)
/* Wrapper: */
struct SOAP_CMAC __afip4__FEParamGetPtosVenta {
      public:
        /** Optional element 'afip3:FEParamGetPtosVenta' of XML schema type 'afip3:FEParamGetPtosVenta' */
        _afip3__FEParamGetPtosVenta *afip3__FEParamGetPtosVenta;
      public:
        /** Return unique type id SOAP_TYPE___afip4__FEParamGetPtosVenta */
        long soap_type() const { return SOAP_TYPE___afip4__FEParamGetPtosVenta; }
        /** Constructor with member initializations */
        __afip4__FEParamGetPtosVenta() : afip3__FEParamGetPtosVenta() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip4__FEParamGetPtosVenta * SOAP_FMAC2 soap_instantiate___afip4__FEParamGetPtosVenta(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:5193 */
#ifndef SOAP_TYPE___afip4__FEParamGetTiposCbte
#define SOAP_TYPE___afip4__FEParamGetTiposCbte (310)
/* Wrapper: */
struct SOAP_CMAC __afip4__FEParamGetTiposCbte {
      public:
        /** Optional element 'afip3:FEParamGetTiposCbte' of XML schema type 'afip3:FEParamGetTiposCbte' */
        _afip3__FEParamGetTiposCbte *afip3__FEParamGetTiposCbte;
      public:
        /** Return unique type id SOAP_TYPE___afip4__FEParamGetTiposCbte */
        long soap_type() const { return SOAP_TYPE___afip4__FEParamGetTiposCbte; }
        /** Constructor with member initializations */
        __afip4__FEParamGetTiposCbte() : afip3__FEParamGetTiposCbte() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip4__FEParamGetTiposCbte * SOAP_FMAC2 soap_instantiate___afip4__FEParamGetTiposCbte(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:5264 */
#ifndef SOAP_TYPE___afip4__FEParamGetTiposDoc
#define SOAP_TYPE___afip4__FEParamGetTiposDoc (314)
/* Wrapper: */
struct SOAP_CMAC __afip4__FEParamGetTiposDoc {
      public:
        /** Optional element 'afip3:FEParamGetTiposDoc' of XML schema type 'afip3:FEParamGetTiposDoc' */
        _afip3__FEParamGetTiposDoc *afip3__FEParamGetTiposDoc;
      public:
        /** Return unique type id SOAP_TYPE___afip4__FEParamGetTiposDoc */
        long soap_type() const { return SOAP_TYPE___afip4__FEParamGetTiposDoc; }
        /** Constructor with member initializations */
        __afip4__FEParamGetTiposDoc() : afip3__FEParamGetTiposDoc() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip4__FEParamGetTiposDoc * SOAP_FMAC2 soap_instantiate___afip4__FEParamGetTiposDoc(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:5336 */
#ifndef SOAP_TYPE___afip4__FEParamGetTiposPaises
#define SOAP_TYPE___afip4__FEParamGetTiposPaises (318)
/* Wrapper: */
struct SOAP_CMAC __afip4__FEParamGetTiposPaises {
      public:
        /** Optional element 'afip3:FEParamGetTiposPaises' of XML schema type 'afip3:FEParamGetTiposPaises' */
        _afip3__FEParamGetTiposPaises *afip3__FEParamGetTiposPaises;
      public:
        /** Return unique type id SOAP_TYPE___afip4__FEParamGetTiposPaises */
        long soap_type() const { return SOAP_TYPE___afip4__FEParamGetTiposPaises; }
        /** Constructor with member initializations */
        __afip4__FEParamGetTiposPaises() : afip3__FEParamGetTiposPaises() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip4__FEParamGetTiposPaises * SOAP_FMAC2 soap_instantiate___afip4__FEParamGetTiposPaises(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:5423 */
#ifndef SOAP_TYPE___afip5__FECAESolicitar
#define SOAP_TYPE___afip5__FECAESolicitar (320)
/* Wrapper: */
struct SOAP_CMAC __afip5__FECAESolicitar {
      public:
        /** Optional element 'afip3:FECAESolicitar' of XML schema type 'afip3:FECAESolicitar' */
        _afip3__FECAESolicitar *afip3__FECAESolicitar;
      public:
        /** Return unique type id SOAP_TYPE___afip5__FECAESolicitar */
        long soap_type() const { return SOAP_TYPE___afip5__FECAESolicitar; }
        /** Constructor with member initializations */
        __afip5__FECAESolicitar() : afip3__FECAESolicitar() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip5__FECAESolicitar * SOAP_FMAC2 soap_instantiate___afip5__FECAESolicitar(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:5495 */
#ifndef SOAP_TYPE___afip5__FECompTotXRequest
#define SOAP_TYPE___afip5__FECompTotXRequest (322)
/* Wrapper: */
struct SOAP_CMAC __afip5__FECompTotXRequest {
      public:
        /** Optional element 'afip3:FECompTotXRequest' of XML schema type 'afip3:FECompTotXRequest' */
        _afip3__FECompTotXRequest *afip3__FECompTotXRequest;
      public:
        /** Return unique type id SOAP_TYPE___afip5__FECompTotXRequest */
        long soap_type() const { return SOAP_TYPE___afip5__FECompTotXRequest; }
        /** Constructor with member initializations */
        __afip5__FECompTotXRequest() : afip3__FECompTotXRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip5__FECompTotXRequest * SOAP_FMAC2 soap_instantiate___afip5__FECompTotXRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:5566 */
#ifndef SOAP_TYPE___afip5__FEDummy
#define SOAP_TYPE___afip5__FEDummy (324)
/* Wrapper: */
struct SOAP_CMAC __afip5__FEDummy {
      public:
        /** Optional element 'afip3:FEDummy' of XML schema type 'afip3:FEDummy' */
        _afip3__FEDummy *afip3__FEDummy;
      public:
        /** Return unique type id SOAP_TYPE___afip5__FEDummy */
        long soap_type() const { return SOAP_TYPE___afip5__FEDummy; }
        /** Constructor with member initializations */
        __afip5__FEDummy() : afip3__FEDummy() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip5__FEDummy * SOAP_FMAC2 soap_instantiate___afip5__FEDummy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:5638 */
#ifndef SOAP_TYPE___afip5__FECompUltimoAutorizado
#define SOAP_TYPE___afip5__FECompUltimoAutorizado (326)
/* Wrapper: */
struct SOAP_CMAC __afip5__FECompUltimoAutorizado {
      public:
        /** Optional element 'afip3:FECompUltimoAutorizado' of XML schema type 'afip3:FECompUltimoAutorizado' */
        _afip3__FECompUltimoAutorizado *afip3__FECompUltimoAutorizado;
      public:
        /** Return unique type id SOAP_TYPE___afip5__FECompUltimoAutorizado */
        long soap_type() const { return SOAP_TYPE___afip5__FECompUltimoAutorizado; }
        /** Constructor with member initializations */
        __afip5__FECompUltimoAutorizado() : afip3__FECompUltimoAutorizado() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip5__FECompUltimoAutorizado * SOAP_FMAC2 soap_instantiate___afip5__FECompUltimoAutorizado(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:5709 */
#ifndef SOAP_TYPE___afip5__FECompConsultar
#define SOAP_TYPE___afip5__FECompConsultar (328)
/* Wrapper: */
struct SOAP_CMAC __afip5__FECompConsultar {
      public:
        /** Optional element 'afip3:FECompConsultar' of XML schema type 'afip3:FECompConsultar' */
        _afip3__FECompConsultar *afip3__FECompConsultar;
      public:
        /** Return unique type id SOAP_TYPE___afip5__FECompConsultar */
        long soap_type() const { return SOAP_TYPE___afip5__FECompConsultar; }
        /** Constructor with member initializations */
        __afip5__FECompConsultar() : afip3__FECompConsultar() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip5__FECompConsultar * SOAP_FMAC2 soap_instantiate___afip5__FECompConsultar(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:5780 */
#ifndef SOAP_TYPE___afip5__FECAEARegInformativo
#define SOAP_TYPE___afip5__FECAEARegInformativo (330)
/* Wrapper: */
struct SOAP_CMAC __afip5__FECAEARegInformativo {
      public:
        /** Optional element 'afip3:FECAEARegInformativo' of XML schema type 'afip3:FECAEARegInformativo' */
        _afip3__FECAEARegInformativo *afip3__FECAEARegInformativo;
      public:
        /** Return unique type id SOAP_TYPE___afip5__FECAEARegInformativo */
        long soap_type() const { return SOAP_TYPE___afip5__FECAEARegInformativo; }
        /** Constructor with member initializations */
        __afip5__FECAEARegInformativo() : afip3__FECAEARegInformativo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip5__FECAEARegInformativo * SOAP_FMAC2 soap_instantiate___afip5__FECAEARegInformativo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:5851 */
#ifndef SOAP_TYPE___afip5__FECAEASolicitar
#define SOAP_TYPE___afip5__FECAEASolicitar (332)
/* Wrapper: */
struct SOAP_CMAC __afip5__FECAEASolicitar {
      public:
        /** Optional element 'afip3:FECAEASolicitar' of XML schema type 'afip3:FECAEASolicitar' */
        _afip3__FECAEASolicitar *afip3__FECAEASolicitar;
      public:
        /** Return unique type id SOAP_TYPE___afip5__FECAEASolicitar */
        long soap_type() const { return SOAP_TYPE___afip5__FECAEASolicitar; }
        /** Constructor with member initializations */
        __afip5__FECAEASolicitar() : afip3__FECAEASolicitar() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip5__FECAEASolicitar * SOAP_FMAC2 soap_instantiate___afip5__FECAEASolicitar(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:5922 */
#ifndef SOAP_TYPE___afip5__FECAEASinMovimientoConsultar
#define SOAP_TYPE___afip5__FECAEASinMovimientoConsultar (334)
/* Wrapper: */
struct SOAP_CMAC __afip5__FECAEASinMovimientoConsultar {
      public:
        /** Optional element 'afip3:FECAEASinMovimientoConsultar' of XML schema type 'afip3:FECAEASinMovimientoConsultar' */
        _afip3__FECAEASinMovimientoConsultar *afip3__FECAEASinMovimientoConsultar;
      public:
        /** Return unique type id SOAP_TYPE___afip5__FECAEASinMovimientoConsultar */
        long soap_type() const { return SOAP_TYPE___afip5__FECAEASinMovimientoConsultar; }
        /** Constructor with member initializations */
        __afip5__FECAEASinMovimientoConsultar() : afip3__FECAEASinMovimientoConsultar() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip5__FECAEASinMovimientoConsultar * SOAP_FMAC2 soap_instantiate___afip5__FECAEASinMovimientoConsultar(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:5993 */
#ifndef SOAP_TYPE___afip5__FECAEASinMovimientoInformar
#define SOAP_TYPE___afip5__FECAEASinMovimientoInformar (336)
/* Wrapper: */
struct SOAP_CMAC __afip5__FECAEASinMovimientoInformar {
      public:
        /** Optional element 'afip3:FECAEASinMovimientoInformar' of XML schema type 'afip3:FECAEASinMovimientoInformar' */
        _afip3__FECAEASinMovimientoInformar *afip3__FECAEASinMovimientoInformar;
      public:
        /** Return unique type id SOAP_TYPE___afip5__FECAEASinMovimientoInformar */
        long soap_type() const { return SOAP_TYPE___afip5__FECAEASinMovimientoInformar; }
        /** Constructor with member initializations */
        __afip5__FECAEASinMovimientoInformar() : afip3__FECAEASinMovimientoInformar() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip5__FECAEASinMovimientoInformar * SOAP_FMAC2 soap_instantiate___afip5__FECAEASinMovimientoInformar(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:6064 */
#ifndef SOAP_TYPE___afip5__FECAEAConsultar
#define SOAP_TYPE___afip5__FECAEAConsultar (338)
/* Wrapper: */
struct SOAP_CMAC __afip5__FECAEAConsultar {
      public:
        /** Optional element 'afip3:FECAEAConsultar' of XML schema type 'afip3:FECAEAConsultar' */
        _afip3__FECAEAConsultar *afip3__FECAEAConsultar;
      public:
        /** Return unique type id SOAP_TYPE___afip5__FECAEAConsultar */
        long soap_type() const { return SOAP_TYPE___afip5__FECAEAConsultar; }
        /** Constructor with member initializations */
        __afip5__FECAEAConsultar() : afip3__FECAEAConsultar() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip5__FECAEAConsultar * SOAP_FMAC2 soap_instantiate___afip5__FECAEAConsultar(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:6135 */
#ifndef SOAP_TYPE___afip5__FEParamGetCotizacion
#define SOAP_TYPE___afip5__FEParamGetCotizacion (340)
/* Wrapper: */
struct SOAP_CMAC __afip5__FEParamGetCotizacion {
      public:
        /** Optional element 'afip3:FEParamGetCotizacion' of XML schema type 'afip3:FEParamGetCotizacion' */
        _afip3__FEParamGetCotizacion *afip3__FEParamGetCotizacion;
      public:
        /** Return unique type id SOAP_TYPE___afip5__FEParamGetCotizacion */
        long soap_type() const { return SOAP_TYPE___afip5__FEParamGetCotizacion; }
        /** Constructor with member initializations */
        __afip5__FEParamGetCotizacion() : afip3__FEParamGetCotizacion() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip5__FEParamGetCotizacion * SOAP_FMAC2 soap_instantiate___afip5__FEParamGetCotizacion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:6207 */
#ifndef SOAP_TYPE___afip5__FEParamGetTiposTributos
#define SOAP_TYPE___afip5__FEParamGetTiposTributos (342)
/* Wrapper: */
struct SOAP_CMAC __afip5__FEParamGetTiposTributos {
      public:
        /** Optional element 'afip3:FEParamGetTiposTributos' of XML schema type 'afip3:FEParamGetTiposTributos' */
        _afip3__FEParamGetTiposTributos *afip3__FEParamGetTiposTributos;
      public:
        /** Return unique type id SOAP_TYPE___afip5__FEParamGetTiposTributos */
        long soap_type() const { return SOAP_TYPE___afip5__FEParamGetTiposTributos; }
        /** Constructor with member initializations */
        __afip5__FEParamGetTiposTributos() : afip3__FEParamGetTiposTributos() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip5__FEParamGetTiposTributos * SOAP_FMAC2 soap_instantiate___afip5__FEParamGetTiposTributos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:6278 */
#ifndef SOAP_TYPE___afip5__FEParamGetTiposMonedas
#define SOAP_TYPE___afip5__FEParamGetTiposMonedas (344)
/* Wrapper: */
struct SOAP_CMAC __afip5__FEParamGetTiposMonedas {
      public:
        /** Optional element 'afip3:FEParamGetTiposMonedas' of XML schema type 'afip3:FEParamGetTiposMonedas' */
        _afip3__FEParamGetTiposMonedas *afip3__FEParamGetTiposMonedas;
      public:
        /** Return unique type id SOAP_TYPE___afip5__FEParamGetTiposMonedas */
        long soap_type() const { return SOAP_TYPE___afip5__FEParamGetTiposMonedas; }
        /** Constructor with member initializations */
        __afip5__FEParamGetTiposMonedas() : afip3__FEParamGetTiposMonedas() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip5__FEParamGetTiposMonedas * SOAP_FMAC2 soap_instantiate___afip5__FEParamGetTiposMonedas(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:6349 */
#ifndef SOAP_TYPE___afip5__FEParamGetTiposIva
#define SOAP_TYPE___afip5__FEParamGetTiposIva (346)
/* Wrapper: */
struct SOAP_CMAC __afip5__FEParamGetTiposIva {
      public:
        /** Optional element 'afip3:FEParamGetTiposIva' of XML schema type 'afip3:FEParamGetTiposIva' */
        _afip3__FEParamGetTiposIva *afip3__FEParamGetTiposIva;
      public:
        /** Return unique type id SOAP_TYPE___afip5__FEParamGetTiposIva */
        long soap_type() const { return SOAP_TYPE___afip5__FEParamGetTiposIva; }
        /** Constructor with member initializations */
        __afip5__FEParamGetTiposIva() : afip3__FEParamGetTiposIva() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip5__FEParamGetTiposIva * SOAP_FMAC2 soap_instantiate___afip5__FEParamGetTiposIva(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:6420 */
#ifndef SOAP_TYPE___afip5__FEParamGetTiposOpcional
#define SOAP_TYPE___afip5__FEParamGetTiposOpcional (348)
/* Wrapper: */
struct SOAP_CMAC __afip5__FEParamGetTiposOpcional {
      public:
        /** Optional element 'afip3:FEParamGetTiposOpcional' of XML schema type 'afip3:FEParamGetTiposOpcional' */
        _afip3__FEParamGetTiposOpcional *afip3__FEParamGetTiposOpcional;
      public:
        /** Return unique type id SOAP_TYPE___afip5__FEParamGetTiposOpcional */
        long soap_type() const { return SOAP_TYPE___afip5__FEParamGetTiposOpcional; }
        /** Constructor with member initializations */
        __afip5__FEParamGetTiposOpcional() : afip3__FEParamGetTiposOpcional() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip5__FEParamGetTiposOpcional * SOAP_FMAC2 soap_instantiate___afip5__FEParamGetTiposOpcional(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:6491 */
#ifndef SOAP_TYPE___afip5__FEParamGetTiposConcepto
#define SOAP_TYPE___afip5__FEParamGetTiposConcepto (350)
/* Wrapper: */
struct SOAP_CMAC __afip5__FEParamGetTiposConcepto {
      public:
        /** Optional element 'afip3:FEParamGetTiposConcepto' of XML schema type 'afip3:FEParamGetTiposConcepto' */
        _afip3__FEParamGetTiposConcepto *afip3__FEParamGetTiposConcepto;
      public:
        /** Return unique type id SOAP_TYPE___afip5__FEParamGetTiposConcepto */
        long soap_type() const { return SOAP_TYPE___afip5__FEParamGetTiposConcepto; }
        /** Constructor with member initializations */
        __afip5__FEParamGetTiposConcepto() : afip3__FEParamGetTiposConcepto() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip5__FEParamGetTiposConcepto * SOAP_FMAC2 soap_instantiate___afip5__FEParamGetTiposConcepto(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:6562 */
#ifndef SOAP_TYPE___afip5__FEParamGetPtosVenta
#define SOAP_TYPE___afip5__FEParamGetPtosVenta (352)
/* Wrapper: */
struct SOAP_CMAC __afip5__FEParamGetPtosVenta {
      public:
        /** Optional element 'afip3:FEParamGetPtosVenta' of XML schema type 'afip3:FEParamGetPtosVenta' */
        _afip3__FEParamGetPtosVenta *afip3__FEParamGetPtosVenta;
      public:
        /** Return unique type id SOAP_TYPE___afip5__FEParamGetPtosVenta */
        long soap_type() const { return SOAP_TYPE___afip5__FEParamGetPtosVenta; }
        /** Constructor with member initializations */
        __afip5__FEParamGetPtosVenta() : afip3__FEParamGetPtosVenta() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip5__FEParamGetPtosVenta * SOAP_FMAC2 soap_instantiate___afip5__FEParamGetPtosVenta(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:6633 */
#ifndef SOAP_TYPE___afip5__FEParamGetTiposCbte
#define SOAP_TYPE___afip5__FEParamGetTiposCbte (354)
/* Wrapper: */
struct SOAP_CMAC __afip5__FEParamGetTiposCbte {
      public:
        /** Optional element 'afip3:FEParamGetTiposCbte' of XML schema type 'afip3:FEParamGetTiposCbte' */
        _afip3__FEParamGetTiposCbte *afip3__FEParamGetTiposCbte;
      public:
        /** Return unique type id SOAP_TYPE___afip5__FEParamGetTiposCbte */
        long soap_type() const { return SOAP_TYPE___afip5__FEParamGetTiposCbte; }
        /** Constructor with member initializations */
        __afip5__FEParamGetTiposCbte() : afip3__FEParamGetTiposCbte() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip5__FEParamGetTiposCbte * SOAP_FMAC2 soap_instantiate___afip5__FEParamGetTiposCbte(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:6704 */
#ifndef SOAP_TYPE___afip5__FEParamGetTiposDoc
#define SOAP_TYPE___afip5__FEParamGetTiposDoc (356)
/* Wrapper: */
struct SOAP_CMAC __afip5__FEParamGetTiposDoc {
      public:
        /** Optional element 'afip3:FEParamGetTiposDoc' of XML schema type 'afip3:FEParamGetTiposDoc' */
        _afip3__FEParamGetTiposDoc *afip3__FEParamGetTiposDoc;
      public:
        /** Return unique type id SOAP_TYPE___afip5__FEParamGetTiposDoc */
        long soap_type() const { return SOAP_TYPE___afip5__FEParamGetTiposDoc; }
        /** Constructor with member initializations */
        __afip5__FEParamGetTiposDoc() : afip3__FEParamGetTiposDoc() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip5__FEParamGetTiposDoc * SOAP_FMAC2 soap_instantiate___afip5__FEParamGetTiposDoc(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:6776 */
#ifndef SOAP_TYPE___afip5__FEParamGetTiposPaises
#define SOAP_TYPE___afip5__FEParamGetTiposPaises (358)
/* Wrapper: */
struct SOAP_CMAC __afip5__FEParamGetTiposPaises {
      public:
        /** Optional element 'afip3:FEParamGetTiposPaises' of XML schema type 'afip3:FEParamGetTiposPaises' */
        _afip3__FEParamGetTiposPaises *afip3__FEParamGetTiposPaises;
      public:
        /** Return unique type id SOAP_TYPE___afip5__FEParamGetTiposPaises */
        long soap_type() const { return SOAP_TYPE___afip5__FEParamGetTiposPaises; }
        /** Constructor with member initializations */
        __afip5__FEParamGetTiposPaises() : afip3__FEParamGetTiposPaises() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __afip5__FEParamGetTiposPaises * SOAP_FMAC2 soap_instantiate___afip5__FEParamGetTiposPaises(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap/afip_soap.h:7481 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (359)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* soap/afip_soap.h:7481 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (360)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XML schema type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* soap/afip_soap.h:7481 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (362)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* soap/afip_soap.h:7481 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (363)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XML schema type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XML schema type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XML schema type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XML schema type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* short has binding name 'short' for type 'xsd:short' */
#ifndef SOAP_TYPE_short
#define SOAP_TYPE_short (147)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* LONG64 has binding name 'LONG64' for type 'xsd:long' */
#ifndef SOAP_TYPE_LONG64
#define SOAP_TYPE_LONG64 (132)
#endif

/* double has binding name 'double' for type 'xsd:double' */
#ifndef SOAP_TYPE_double
#define SOAP_TYPE_double (137)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (129)
#endif

/* _afip3__FEParamGetTiposPaisesResponse has binding name '_afip3__FEParamGetTiposPaisesResponse' for type '' */
#ifndef SOAP_TYPE__afip3__FEParamGetTiposPaisesResponse
#define SOAP_TYPE__afip3__FEParamGetTiposPaisesResponse (128)
#endif

/* _afip3__FEParamGetTiposPaises has binding name '_afip3__FEParamGetTiposPaises' for type '' */
#ifndef SOAP_TYPE__afip3__FEParamGetTiposPaises
#define SOAP_TYPE__afip3__FEParamGetTiposPaises (127)
#endif

/* _afip3__FEParamGetTiposDocResponse has binding name '_afip3__FEParamGetTiposDocResponse' for type '' */
#ifndef SOAP_TYPE__afip3__FEParamGetTiposDocResponse
#define SOAP_TYPE__afip3__FEParamGetTiposDocResponse (126)
#endif

/* _afip3__FEParamGetTiposDoc has binding name '_afip3__FEParamGetTiposDoc' for type '' */
#ifndef SOAP_TYPE__afip3__FEParamGetTiposDoc
#define SOAP_TYPE__afip3__FEParamGetTiposDoc (125)
#endif

/* _afip3__FEParamGetTiposCbteResponse has binding name '_afip3__FEParamGetTiposCbteResponse' for type '' */
#ifndef SOAP_TYPE__afip3__FEParamGetTiposCbteResponse
#define SOAP_TYPE__afip3__FEParamGetTiposCbteResponse (124)
#endif

/* _afip3__FEParamGetTiposCbte has binding name '_afip3__FEParamGetTiposCbte' for type '' */
#ifndef SOAP_TYPE__afip3__FEParamGetTiposCbte
#define SOAP_TYPE__afip3__FEParamGetTiposCbte (123)
#endif

/* _afip3__FEParamGetPtosVentaResponse has binding name '_afip3__FEParamGetPtosVentaResponse' for type '' */
#ifndef SOAP_TYPE__afip3__FEParamGetPtosVentaResponse
#define SOAP_TYPE__afip3__FEParamGetPtosVentaResponse (122)
#endif

/* _afip3__FEParamGetPtosVenta has binding name '_afip3__FEParamGetPtosVenta' for type '' */
#ifndef SOAP_TYPE__afip3__FEParamGetPtosVenta
#define SOAP_TYPE__afip3__FEParamGetPtosVenta (121)
#endif

/* _afip3__FEParamGetTiposConceptoResponse has binding name '_afip3__FEParamGetTiposConceptoResponse' for type '' */
#ifndef SOAP_TYPE__afip3__FEParamGetTiposConceptoResponse
#define SOAP_TYPE__afip3__FEParamGetTiposConceptoResponse (120)
#endif

/* _afip3__FEParamGetTiposConcepto has binding name '_afip3__FEParamGetTiposConcepto' for type '' */
#ifndef SOAP_TYPE__afip3__FEParamGetTiposConcepto
#define SOAP_TYPE__afip3__FEParamGetTiposConcepto (119)
#endif

/* _afip3__FEParamGetTiposOpcionalResponse has binding name '_afip3__FEParamGetTiposOpcionalResponse' for type '' */
#ifndef SOAP_TYPE__afip3__FEParamGetTiposOpcionalResponse
#define SOAP_TYPE__afip3__FEParamGetTiposOpcionalResponse (118)
#endif

/* _afip3__FEParamGetTiposOpcional has binding name '_afip3__FEParamGetTiposOpcional' for type '' */
#ifndef SOAP_TYPE__afip3__FEParamGetTiposOpcional
#define SOAP_TYPE__afip3__FEParamGetTiposOpcional (117)
#endif

/* _afip3__FEParamGetTiposIvaResponse has binding name '_afip3__FEParamGetTiposIvaResponse' for type '' */
#ifndef SOAP_TYPE__afip3__FEParamGetTiposIvaResponse
#define SOAP_TYPE__afip3__FEParamGetTiposIvaResponse (116)
#endif

/* _afip3__FEParamGetTiposIva has binding name '_afip3__FEParamGetTiposIva' for type '' */
#ifndef SOAP_TYPE__afip3__FEParamGetTiposIva
#define SOAP_TYPE__afip3__FEParamGetTiposIva (115)
#endif

/* _afip3__FEParamGetTiposMonedasResponse has binding name '_afip3__FEParamGetTiposMonedasResponse' for type '' */
#ifndef SOAP_TYPE__afip3__FEParamGetTiposMonedasResponse
#define SOAP_TYPE__afip3__FEParamGetTiposMonedasResponse (114)
#endif

/* _afip3__FEParamGetTiposMonedas has binding name '_afip3__FEParamGetTiposMonedas' for type '' */
#ifndef SOAP_TYPE__afip3__FEParamGetTiposMonedas
#define SOAP_TYPE__afip3__FEParamGetTiposMonedas (113)
#endif

/* _afip3__FEParamGetTiposTributosResponse has binding name '_afip3__FEParamGetTiposTributosResponse' for type '' */
#ifndef SOAP_TYPE__afip3__FEParamGetTiposTributosResponse
#define SOAP_TYPE__afip3__FEParamGetTiposTributosResponse (112)
#endif

/* _afip3__FEParamGetTiposTributos has binding name '_afip3__FEParamGetTiposTributos' for type '' */
#ifndef SOAP_TYPE__afip3__FEParamGetTiposTributos
#define SOAP_TYPE__afip3__FEParamGetTiposTributos (111)
#endif

/* _afip3__FEParamGetCotizacionResponse has binding name '_afip3__FEParamGetCotizacionResponse' for type '' */
#ifndef SOAP_TYPE__afip3__FEParamGetCotizacionResponse
#define SOAP_TYPE__afip3__FEParamGetCotizacionResponse (110)
#endif

/* _afip3__FEParamGetCotizacion has binding name '_afip3__FEParamGetCotizacion' for type '' */
#ifndef SOAP_TYPE__afip3__FEParamGetCotizacion
#define SOAP_TYPE__afip3__FEParamGetCotizacion (109)
#endif

/* _afip3__FECAEAConsultarResponse has binding name '_afip3__FECAEAConsultarResponse' for type '' */
#ifndef SOAP_TYPE__afip3__FECAEAConsultarResponse
#define SOAP_TYPE__afip3__FECAEAConsultarResponse (108)
#endif

/* _afip3__FECAEAConsultar has binding name '_afip3__FECAEAConsultar' for type '' */
#ifndef SOAP_TYPE__afip3__FECAEAConsultar
#define SOAP_TYPE__afip3__FECAEAConsultar (107)
#endif

/* _afip3__FECAEASinMovimientoInformarResponse has binding name '_afip3__FECAEASinMovimientoInformarResponse' for type '' */
#ifndef SOAP_TYPE__afip3__FECAEASinMovimientoInformarResponse
#define SOAP_TYPE__afip3__FECAEASinMovimientoInformarResponse (106)
#endif

/* _afip3__FECAEASinMovimientoInformar has binding name '_afip3__FECAEASinMovimientoInformar' for type '' */
#ifndef SOAP_TYPE__afip3__FECAEASinMovimientoInformar
#define SOAP_TYPE__afip3__FECAEASinMovimientoInformar (105)
#endif

/* _afip3__FECAEASinMovimientoConsultarResponse has binding name '_afip3__FECAEASinMovimientoConsultarResponse' for type '' */
#ifndef SOAP_TYPE__afip3__FECAEASinMovimientoConsultarResponse
#define SOAP_TYPE__afip3__FECAEASinMovimientoConsultarResponse (104)
#endif

/* _afip3__FECAEASinMovimientoConsultar has binding name '_afip3__FECAEASinMovimientoConsultar' for type '' */
#ifndef SOAP_TYPE__afip3__FECAEASinMovimientoConsultar
#define SOAP_TYPE__afip3__FECAEASinMovimientoConsultar (103)
#endif

/* _afip3__FECAEASolicitarResponse has binding name '_afip3__FECAEASolicitarResponse' for type '' */
#ifndef SOAP_TYPE__afip3__FECAEASolicitarResponse
#define SOAP_TYPE__afip3__FECAEASolicitarResponse (102)
#endif

/* _afip3__FECAEASolicitar has binding name '_afip3__FECAEASolicitar' for type '' */
#ifndef SOAP_TYPE__afip3__FECAEASolicitar
#define SOAP_TYPE__afip3__FECAEASolicitar (101)
#endif

/* _afip3__FECAEARegInformativoResponse has binding name '_afip3__FECAEARegInformativoResponse' for type '' */
#ifndef SOAP_TYPE__afip3__FECAEARegInformativoResponse
#define SOAP_TYPE__afip3__FECAEARegInformativoResponse (100)
#endif

/* _afip3__FECAEARegInformativo has binding name '_afip3__FECAEARegInformativo' for type '' */
#ifndef SOAP_TYPE__afip3__FECAEARegInformativo
#define SOAP_TYPE__afip3__FECAEARegInformativo (99)
#endif

/* _afip3__FECompConsultarResponse has binding name '_afip3__FECompConsultarResponse' for type '' */
#ifndef SOAP_TYPE__afip3__FECompConsultarResponse
#define SOAP_TYPE__afip3__FECompConsultarResponse (98)
#endif

/* _afip3__FECompConsultar has binding name '_afip3__FECompConsultar' for type '' */
#ifndef SOAP_TYPE__afip3__FECompConsultar
#define SOAP_TYPE__afip3__FECompConsultar (97)
#endif

/* _afip3__FECompUltimoAutorizadoResponse has binding name '_afip3__FECompUltimoAutorizadoResponse' for type '' */
#ifndef SOAP_TYPE__afip3__FECompUltimoAutorizadoResponse
#define SOAP_TYPE__afip3__FECompUltimoAutorizadoResponse (96)
#endif

/* _afip3__FECompUltimoAutorizado has binding name '_afip3__FECompUltimoAutorizado' for type '' */
#ifndef SOAP_TYPE__afip3__FECompUltimoAutorizado
#define SOAP_TYPE__afip3__FECompUltimoAutorizado (95)
#endif

/* _afip3__FEDummyResponse has binding name '_afip3__FEDummyResponse' for type '' */
#ifndef SOAP_TYPE__afip3__FEDummyResponse
#define SOAP_TYPE__afip3__FEDummyResponse (94)
#endif

/* _afip3__FEDummy has binding name '_afip3__FEDummy' for type '' */
#ifndef SOAP_TYPE__afip3__FEDummy
#define SOAP_TYPE__afip3__FEDummy (93)
#endif

/* _afip3__FECompTotXRequestResponse has binding name '_afip3__FECompTotXRequestResponse' for type '' */
#ifndef SOAP_TYPE__afip3__FECompTotXRequestResponse
#define SOAP_TYPE__afip3__FECompTotXRequestResponse (92)
#endif

/* _afip3__FECompTotXRequest has binding name '_afip3__FECompTotXRequest' for type '' */
#ifndef SOAP_TYPE__afip3__FECompTotXRequest
#define SOAP_TYPE__afip3__FECompTotXRequest (91)
#endif

/* _afip3__FECAESolicitarResponse has binding name '_afip3__FECAESolicitarResponse' for type '' */
#ifndef SOAP_TYPE__afip3__FECAESolicitarResponse
#define SOAP_TYPE__afip3__FECAESolicitarResponse (90)
#endif

/* _afip3__FECAESolicitar has binding name '_afip3__FECAESolicitar' for type '' */
#ifndef SOAP_TYPE__afip3__FECAESolicitar
#define SOAP_TYPE__afip3__FECAESolicitar (89)
#endif

/* afip3__PaisTipo has binding name 'afip3__PaisTipo' for type 'afip3:PaisTipo' */
#ifndef SOAP_TYPE_afip3__PaisTipo
#define SOAP_TYPE_afip3__PaisTipo (88)
#endif

/* afip3__ArrayOfPaisTipo has binding name 'afip3__ArrayOfPaisTipo' for type 'afip3:ArrayOfPaisTipo' */
#ifndef SOAP_TYPE_afip3__ArrayOfPaisTipo
#define SOAP_TYPE_afip3__ArrayOfPaisTipo (87)
#endif

/* afip3__FEPaisResponse has binding name 'afip3__FEPaisResponse' for type 'afip3:FEPaisResponse' */
#ifndef SOAP_TYPE_afip3__FEPaisResponse
#define SOAP_TYPE_afip3__FEPaisResponse (86)
#endif

/* afip3__DocTipo has binding name 'afip3__DocTipo' for type 'afip3:DocTipo' */
#ifndef SOAP_TYPE_afip3__DocTipo
#define SOAP_TYPE_afip3__DocTipo (85)
#endif

/* afip3__ArrayOfDocTipo has binding name 'afip3__ArrayOfDocTipo' for type 'afip3:ArrayOfDocTipo' */
#ifndef SOAP_TYPE_afip3__ArrayOfDocTipo
#define SOAP_TYPE_afip3__ArrayOfDocTipo (84)
#endif

/* afip3__DocTipoResponse has binding name 'afip3__DocTipoResponse' for type 'afip3:DocTipoResponse' */
#ifndef SOAP_TYPE_afip3__DocTipoResponse
#define SOAP_TYPE_afip3__DocTipoResponse (83)
#endif

/* afip3__CbteTipo has binding name 'afip3__CbteTipo' for type 'afip3:CbteTipo' */
#ifndef SOAP_TYPE_afip3__CbteTipo
#define SOAP_TYPE_afip3__CbteTipo (82)
#endif

/* afip3__ArrayOfCbteTipo has binding name 'afip3__ArrayOfCbteTipo' for type 'afip3:ArrayOfCbteTipo' */
#ifndef SOAP_TYPE_afip3__ArrayOfCbteTipo
#define SOAP_TYPE_afip3__ArrayOfCbteTipo (81)
#endif

/* afip3__CbteTipoResponse has binding name 'afip3__CbteTipoResponse' for type 'afip3:CbteTipoResponse' */
#ifndef SOAP_TYPE_afip3__CbteTipoResponse
#define SOAP_TYPE_afip3__CbteTipoResponse (80)
#endif

/* afip3__PtoVenta has binding name 'afip3__PtoVenta' for type 'afip3:PtoVenta' */
#ifndef SOAP_TYPE_afip3__PtoVenta
#define SOAP_TYPE_afip3__PtoVenta (79)
#endif

/* afip3__ArrayOfPtoVenta has binding name 'afip3__ArrayOfPtoVenta' for type 'afip3:ArrayOfPtoVenta' */
#ifndef SOAP_TYPE_afip3__ArrayOfPtoVenta
#define SOAP_TYPE_afip3__ArrayOfPtoVenta (78)
#endif

/* afip3__FEPtoVentaResponse has binding name 'afip3__FEPtoVentaResponse' for type 'afip3:FEPtoVentaResponse' */
#ifndef SOAP_TYPE_afip3__FEPtoVentaResponse
#define SOAP_TYPE_afip3__FEPtoVentaResponse (77)
#endif

/* afip3__ConceptoTipo has binding name 'afip3__ConceptoTipo' for type 'afip3:ConceptoTipo' */
#ifndef SOAP_TYPE_afip3__ConceptoTipo
#define SOAP_TYPE_afip3__ConceptoTipo (76)
#endif

/* afip3__ArrayOfConceptoTipo has binding name 'afip3__ArrayOfConceptoTipo' for type 'afip3:ArrayOfConceptoTipo' */
#ifndef SOAP_TYPE_afip3__ArrayOfConceptoTipo
#define SOAP_TYPE_afip3__ArrayOfConceptoTipo (75)
#endif

/* afip3__ConceptoTipoResponse has binding name 'afip3__ConceptoTipoResponse' for type 'afip3:ConceptoTipoResponse' */
#ifndef SOAP_TYPE_afip3__ConceptoTipoResponse
#define SOAP_TYPE_afip3__ConceptoTipoResponse (74)
#endif

/* afip3__OpcionalTipo has binding name 'afip3__OpcionalTipo' for type 'afip3:OpcionalTipo' */
#ifndef SOAP_TYPE_afip3__OpcionalTipo
#define SOAP_TYPE_afip3__OpcionalTipo (73)
#endif

/* afip3__ArrayOfOpcionalTipo has binding name 'afip3__ArrayOfOpcionalTipo' for type 'afip3:ArrayOfOpcionalTipo' */
#ifndef SOAP_TYPE_afip3__ArrayOfOpcionalTipo
#define SOAP_TYPE_afip3__ArrayOfOpcionalTipo (72)
#endif

/* afip3__OpcionalTipoResponse has binding name 'afip3__OpcionalTipoResponse' for type 'afip3:OpcionalTipoResponse' */
#ifndef SOAP_TYPE_afip3__OpcionalTipoResponse
#define SOAP_TYPE_afip3__OpcionalTipoResponse (71)
#endif

/* afip3__IvaTipo has binding name 'afip3__IvaTipo' for type 'afip3:IvaTipo' */
#ifndef SOAP_TYPE_afip3__IvaTipo
#define SOAP_TYPE_afip3__IvaTipo (70)
#endif

/* afip3__ArrayOfIvaTipo has binding name 'afip3__ArrayOfIvaTipo' for type 'afip3:ArrayOfIvaTipo' */
#ifndef SOAP_TYPE_afip3__ArrayOfIvaTipo
#define SOAP_TYPE_afip3__ArrayOfIvaTipo (69)
#endif

/* afip3__IvaTipoResponse has binding name 'afip3__IvaTipoResponse' for type 'afip3:IvaTipoResponse' */
#ifndef SOAP_TYPE_afip3__IvaTipoResponse
#define SOAP_TYPE_afip3__IvaTipoResponse (68)
#endif

/* afip3__Moneda has binding name 'afip3__Moneda' for type 'afip3:Moneda' */
#ifndef SOAP_TYPE_afip3__Moneda
#define SOAP_TYPE_afip3__Moneda (67)
#endif

/* afip3__ArrayOfMoneda has binding name 'afip3__ArrayOfMoneda' for type 'afip3:ArrayOfMoneda' */
#ifndef SOAP_TYPE_afip3__ArrayOfMoneda
#define SOAP_TYPE_afip3__ArrayOfMoneda (66)
#endif

/* afip3__MonedaResponse has binding name 'afip3__MonedaResponse' for type 'afip3:MonedaResponse' */
#ifndef SOAP_TYPE_afip3__MonedaResponse
#define SOAP_TYPE_afip3__MonedaResponse (65)
#endif

/* afip3__TributoTipo has binding name 'afip3__TributoTipo' for type 'afip3:TributoTipo' */
#ifndef SOAP_TYPE_afip3__TributoTipo
#define SOAP_TYPE_afip3__TributoTipo (64)
#endif

/* afip3__ArrayOfTributoTipo has binding name 'afip3__ArrayOfTributoTipo' for type 'afip3:ArrayOfTributoTipo' */
#ifndef SOAP_TYPE_afip3__ArrayOfTributoTipo
#define SOAP_TYPE_afip3__ArrayOfTributoTipo (63)
#endif

/* afip3__FETributoResponse has binding name 'afip3__FETributoResponse' for type 'afip3:FETributoResponse' */
#ifndef SOAP_TYPE_afip3__FETributoResponse
#define SOAP_TYPE_afip3__FETributoResponse (62)
#endif

/* afip3__Cotizacion has binding name 'afip3__Cotizacion' for type 'afip3:Cotizacion' */
#ifndef SOAP_TYPE_afip3__Cotizacion
#define SOAP_TYPE_afip3__Cotizacion (61)
#endif

/* afip3__FECotizacionResponse has binding name 'afip3__FECotizacionResponse' for type 'afip3:FECotizacionResponse' */
#ifndef SOAP_TYPE_afip3__FECotizacionResponse
#define SOAP_TYPE_afip3__FECotizacionResponse (60)
#endif

/* afip3__FECAEASinMovResponse has binding name 'afip3__FECAEASinMovResponse' for type 'afip3:FECAEASinMovResponse' */
#ifndef SOAP_TYPE_afip3__FECAEASinMovResponse
#define SOAP_TYPE_afip3__FECAEASinMovResponse (59)
#endif

/* afip3__FECAEASinMov has binding name 'afip3__FECAEASinMov' for type 'afip3:FECAEASinMov' */
#ifndef SOAP_TYPE_afip3__FECAEASinMov
#define SOAP_TYPE_afip3__FECAEASinMov (58)
#endif

/* afip3__ArrayOfFECAEASinMov has binding name 'afip3__ArrayOfFECAEASinMov' for type 'afip3:ArrayOfFECAEASinMov' */
#ifndef SOAP_TYPE_afip3__ArrayOfFECAEASinMov
#define SOAP_TYPE_afip3__ArrayOfFECAEASinMov (57)
#endif

/* afip3__FECAEASinMovConsResponse has binding name 'afip3__FECAEASinMovConsResponse' for type 'afip3:FECAEASinMovConsResponse' */
#ifndef SOAP_TYPE_afip3__FECAEASinMovConsResponse
#define SOAP_TYPE_afip3__FECAEASinMovConsResponse (56)
#endif

/* afip3__FECAEAGet has binding name 'afip3__FECAEAGet' for type 'afip3:FECAEAGet' */
#ifndef SOAP_TYPE_afip3__FECAEAGet
#define SOAP_TYPE_afip3__FECAEAGet (55)
#endif

/* afip3__FECAEAGetResponse has binding name 'afip3__FECAEAGetResponse' for type 'afip3:FECAEAGetResponse' */
#ifndef SOAP_TYPE_afip3__FECAEAGetResponse
#define SOAP_TYPE_afip3__FECAEAGetResponse (54)
#endif

/* afip3__FECAEADetResponse has binding name 'afip3__FECAEADetResponse' for type 'afip3:FECAEADetResponse' */
#ifndef SOAP_TYPE_afip3__FECAEADetResponse
#define SOAP_TYPE_afip3__FECAEADetResponse (53)
#endif

/* afip3__ArrayOfFECAEADetResponse has binding name 'afip3__ArrayOfFECAEADetResponse' for type 'afip3:ArrayOfFECAEADetResponse' */
#ifndef SOAP_TYPE_afip3__ArrayOfFECAEADetResponse
#define SOAP_TYPE_afip3__ArrayOfFECAEADetResponse (52)
#endif

/* afip3__FECAEACabResponse has binding name 'afip3__FECAEACabResponse' for type 'afip3:FECAEACabResponse' */
#ifndef SOAP_TYPE_afip3__FECAEACabResponse
#define SOAP_TYPE_afip3__FECAEACabResponse (51)
#endif

/* afip3__FECAEAResponse has binding name 'afip3__FECAEAResponse' for type 'afip3:FECAEAResponse' */
#ifndef SOAP_TYPE_afip3__FECAEAResponse
#define SOAP_TYPE_afip3__FECAEAResponse (50)
#endif

/* afip3__FECAEADetRequest has binding name 'afip3__FECAEADetRequest' for type 'afip3:FECAEADetRequest' */
#ifndef SOAP_TYPE_afip3__FECAEADetRequest
#define SOAP_TYPE_afip3__FECAEADetRequest (49)
#endif

/* afip3__ArrayOfFECAEADetRequest has binding name 'afip3__ArrayOfFECAEADetRequest' for type 'afip3:ArrayOfFECAEADetRequest' */
#ifndef SOAP_TYPE_afip3__ArrayOfFECAEADetRequest
#define SOAP_TYPE_afip3__ArrayOfFECAEADetRequest (48)
#endif

/* afip3__FECAEACabRequest has binding name 'afip3__FECAEACabRequest' for type 'afip3:FECAEACabRequest' */
#ifndef SOAP_TYPE_afip3__FECAEACabRequest
#define SOAP_TYPE_afip3__FECAEACabRequest (47)
#endif

/* afip3__FECAEARequest has binding name 'afip3__FECAEARequest' for type 'afip3:FECAEARequest' */
#ifndef SOAP_TYPE_afip3__FECAEARequest
#define SOAP_TYPE_afip3__FECAEARequest (46)
#endif

/* afip3__FECompConsResponse has binding name 'afip3__FECompConsResponse' for type 'afip3:FECompConsResponse' */
#ifndef SOAP_TYPE_afip3__FECompConsResponse
#define SOAP_TYPE_afip3__FECompConsResponse (45)
#endif

/* afip3__FECompConsultaResponse has binding name 'afip3__FECompConsultaResponse' for type 'afip3:FECompConsultaResponse' */
#ifndef SOAP_TYPE_afip3__FECompConsultaResponse
#define SOAP_TYPE_afip3__FECompConsultaResponse (44)
#endif

/* afip3__FECompConsultaReq has binding name 'afip3__FECompConsultaReq' for type 'afip3:FECompConsultaReq' */
#ifndef SOAP_TYPE_afip3__FECompConsultaReq
#define SOAP_TYPE_afip3__FECompConsultaReq (43)
#endif

/* afip3__FERecuperaLastCbteResponse has binding name 'afip3__FERecuperaLastCbteResponse' for type 'afip3:FERecuperaLastCbteResponse' */
#ifndef SOAP_TYPE_afip3__FERecuperaLastCbteResponse
#define SOAP_TYPE_afip3__FERecuperaLastCbteResponse (42)
#endif

/* afip3__DummyResponse has binding name 'afip3__DummyResponse' for type 'afip3:DummyResponse' */
#ifndef SOAP_TYPE_afip3__DummyResponse
#define SOAP_TYPE_afip3__DummyResponse (41)
#endif

/* afip3__FERegXReqResponse has binding name 'afip3__FERegXReqResponse' for type 'afip3:FERegXReqResponse' */
#ifndef SOAP_TYPE_afip3__FERegXReqResponse
#define SOAP_TYPE_afip3__FERegXReqResponse (40)
#endif

/* afip3__Err has binding name 'afip3__Err' for type 'afip3:Err' */
#ifndef SOAP_TYPE_afip3__Err
#define SOAP_TYPE_afip3__Err (39)
#endif

/* afip3__ArrayOfErr has binding name 'afip3__ArrayOfErr' for type 'afip3:ArrayOfErr' */
#ifndef SOAP_TYPE_afip3__ArrayOfErr
#define SOAP_TYPE_afip3__ArrayOfErr (38)
#endif

/* afip3__Evt has binding name 'afip3__Evt' for type 'afip3:Evt' */
#ifndef SOAP_TYPE_afip3__Evt
#define SOAP_TYPE_afip3__Evt (37)
#endif

/* afip3__ArrayOfEvt has binding name 'afip3__ArrayOfEvt' for type 'afip3:ArrayOfEvt' */
#ifndef SOAP_TYPE_afip3__ArrayOfEvt
#define SOAP_TYPE_afip3__ArrayOfEvt (36)
#endif

/* afip3__Obs has binding name 'afip3__Obs' for type 'afip3:Obs' */
#ifndef SOAP_TYPE_afip3__Obs
#define SOAP_TYPE_afip3__Obs (35)
#endif

/* afip3__ArrayOfObs has binding name 'afip3__ArrayOfObs' for type 'afip3:ArrayOfObs' */
#ifndef SOAP_TYPE_afip3__ArrayOfObs
#define SOAP_TYPE_afip3__ArrayOfObs (34)
#endif

/* afip3__FEDetResponse has binding name 'afip3__FEDetResponse' for type 'afip3:FEDetResponse' */
#ifndef SOAP_TYPE_afip3__FEDetResponse
#define SOAP_TYPE_afip3__FEDetResponse (33)
#endif

/* afip3__FECAEDetResponse has binding name 'afip3__FECAEDetResponse' for type 'afip3:FECAEDetResponse' */
#ifndef SOAP_TYPE_afip3__FECAEDetResponse
#define SOAP_TYPE_afip3__FECAEDetResponse (32)
#endif

/* afip3__ArrayOfFECAEDetResponse has binding name 'afip3__ArrayOfFECAEDetResponse' for type 'afip3:ArrayOfFECAEDetResponse' */
#ifndef SOAP_TYPE_afip3__ArrayOfFECAEDetResponse
#define SOAP_TYPE_afip3__ArrayOfFECAEDetResponse (31)
#endif

/* afip3__FECabResponse has binding name 'afip3__FECabResponse' for type 'afip3:FECabResponse' */
#ifndef SOAP_TYPE_afip3__FECabResponse
#define SOAP_TYPE_afip3__FECabResponse (30)
#endif

/* afip3__FECAECabResponse has binding name 'afip3__FECAECabResponse' for type 'afip3:FECAECabResponse' */
#ifndef SOAP_TYPE_afip3__FECAECabResponse
#define SOAP_TYPE_afip3__FECAECabResponse (29)
#endif

/* afip3__FECAEResponse has binding name 'afip3__FECAEResponse' for type 'afip3:FECAEResponse' */
#ifndef SOAP_TYPE_afip3__FECAEResponse
#define SOAP_TYPE_afip3__FECAEResponse (28)
#endif

/* afip3__Comprador has binding name 'afip3__Comprador' for type 'afip3:Comprador' */
#ifndef SOAP_TYPE_afip3__Comprador
#define SOAP_TYPE_afip3__Comprador (27)
#endif

/* afip3__ArrayOfComprador has binding name 'afip3__ArrayOfComprador' for type 'afip3:ArrayOfComprador' */
#ifndef SOAP_TYPE_afip3__ArrayOfComprador
#define SOAP_TYPE_afip3__ArrayOfComprador (26)
#endif

/* afip3__Opcional has binding name 'afip3__Opcional' for type 'afip3:Opcional' */
#ifndef SOAP_TYPE_afip3__Opcional
#define SOAP_TYPE_afip3__Opcional (25)
#endif

/* afip3__ArrayOfOpcional has binding name 'afip3__ArrayOfOpcional' for type 'afip3:ArrayOfOpcional' */
#ifndef SOAP_TYPE_afip3__ArrayOfOpcional
#define SOAP_TYPE_afip3__ArrayOfOpcional (24)
#endif

/* afip3__AlicIva has binding name 'afip3__AlicIva' for type 'afip3:AlicIva' */
#ifndef SOAP_TYPE_afip3__AlicIva
#define SOAP_TYPE_afip3__AlicIva (23)
#endif

/* afip3__ArrayOfAlicIva has binding name 'afip3__ArrayOfAlicIva' for type 'afip3:ArrayOfAlicIva' */
#ifndef SOAP_TYPE_afip3__ArrayOfAlicIva
#define SOAP_TYPE_afip3__ArrayOfAlicIva (22)
#endif

/* afip3__Tributo has binding name 'afip3__Tributo' for type 'afip3:Tributo' */
#ifndef SOAP_TYPE_afip3__Tributo
#define SOAP_TYPE_afip3__Tributo (21)
#endif

/* afip3__ArrayOfTributo has binding name 'afip3__ArrayOfTributo' for type 'afip3:ArrayOfTributo' */
#ifndef SOAP_TYPE_afip3__ArrayOfTributo
#define SOAP_TYPE_afip3__ArrayOfTributo (20)
#endif

/* afip3__CbteAsoc has binding name 'afip3__CbteAsoc' for type 'afip3:CbteAsoc' */
#ifndef SOAP_TYPE_afip3__CbteAsoc
#define SOAP_TYPE_afip3__CbteAsoc (19)
#endif

/* afip3__ArrayOfCbteAsoc has binding name 'afip3__ArrayOfCbteAsoc' for type 'afip3:ArrayOfCbteAsoc' */
#ifndef SOAP_TYPE_afip3__ArrayOfCbteAsoc
#define SOAP_TYPE_afip3__ArrayOfCbteAsoc (18)
#endif

/* afip3__FEDetRequest has binding name 'afip3__FEDetRequest' for type 'afip3:FEDetRequest' */
#ifndef SOAP_TYPE_afip3__FEDetRequest
#define SOAP_TYPE_afip3__FEDetRequest (17)
#endif

/* afip3__FECAEDetRequest has binding name 'afip3__FECAEDetRequest' for type 'afip3:FECAEDetRequest' */
#ifndef SOAP_TYPE_afip3__FECAEDetRequest
#define SOAP_TYPE_afip3__FECAEDetRequest (16)
#endif

/* afip3__ArrayOfFECAEDetRequest has binding name 'afip3__ArrayOfFECAEDetRequest' for type 'afip3:ArrayOfFECAEDetRequest' */
#ifndef SOAP_TYPE_afip3__ArrayOfFECAEDetRequest
#define SOAP_TYPE_afip3__ArrayOfFECAEDetRequest (15)
#endif

/* afip3__FECabRequest has binding name 'afip3__FECabRequest' for type 'afip3:FECabRequest' */
#ifndef SOAP_TYPE_afip3__FECabRequest
#define SOAP_TYPE_afip3__FECabRequest (14)
#endif

/* afip3__FECAECabRequest has binding name 'afip3__FECAECabRequest' for type 'afip3:FECAECabRequest' */
#ifndef SOAP_TYPE_afip3__FECAECabRequest
#define SOAP_TYPE_afip3__FECAECabRequest (13)
#endif

/* afip3__FECAERequest has binding name 'afip3__FECAERequest' for type 'afip3:FECAERequest' */
#ifndef SOAP_TYPE_afip3__FECAERequest
#define SOAP_TYPE_afip3__FECAERequest (12)
#endif

/* afip3__FEAuthRequest has binding name 'afip3__FEAuthRequest' for type 'afip3:FEAuthRequest' */
#ifndef SOAP_TYPE_afip3__FEAuthRequest
#define SOAP_TYPE_afip3__FEAuthRequest (11)
#endif

/* afip2__LoginFault has binding name 'afip2__LoginFault' for type 'afip2:LoginFault' */
#ifndef SOAP_TYPE_afip2__LoginFault
#define SOAP_TYPE_afip2__LoginFault (10)
#endif

/* _afip1__loginCmsResponse has binding name '_afip1__loginCmsResponse' for type '' */
#ifndef SOAP_TYPE__afip1__loginCmsResponse
#define SOAP_TYPE__afip1__loginCmsResponse (9)
#endif

/* _afip1__loginCms has binding name '_afip1__loginCms' for type '' */
#ifndef SOAP_TYPE__afip1__loginCms
#define SOAP_TYPE__afip1__loginCms (8)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (363)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (362)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (360)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (359)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (231)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (365)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (364)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (361)
#endif

/* _afip3__FEParamGetTiposPaises * has binding name 'PointerTo_afip3__FEParamGetTiposPaises' for type '' */
#ifndef SOAP_TYPE_PointerTo_afip3__FEParamGetTiposPaises
#define SOAP_TYPE_PointerTo_afip3__FEParamGetTiposPaises (315)
#endif

/* _afip3__FEParamGetTiposDoc * has binding name 'PointerTo_afip3__FEParamGetTiposDoc' for type '' */
#ifndef SOAP_TYPE_PointerTo_afip3__FEParamGetTiposDoc
#define SOAP_TYPE_PointerTo_afip3__FEParamGetTiposDoc (311)
#endif

/* _afip3__FEParamGetTiposCbte * has binding name 'PointerTo_afip3__FEParamGetTiposCbte' for type '' */
#ifndef SOAP_TYPE_PointerTo_afip3__FEParamGetTiposCbte
#define SOAP_TYPE_PointerTo_afip3__FEParamGetTiposCbte (307)
#endif

/* _afip3__FEParamGetPtosVenta * has binding name 'PointerTo_afip3__FEParamGetPtosVenta' for type '' */
#ifndef SOAP_TYPE_PointerTo_afip3__FEParamGetPtosVenta
#define SOAP_TYPE_PointerTo_afip3__FEParamGetPtosVenta (303)
#endif

/* _afip3__FEParamGetTiposConcepto * has binding name 'PointerTo_afip3__FEParamGetTiposConcepto' for type '' */
#ifndef SOAP_TYPE_PointerTo_afip3__FEParamGetTiposConcepto
#define SOAP_TYPE_PointerTo_afip3__FEParamGetTiposConcepto (299)
#endif

/* _afip3__FEParamGetTiposOpcional * has binding name 'PointerTo_afip3__FEParamGetTiposOpcional' for type '' */
#ifndef SOAP_TYPE_PointerTo_afip3__FEParamGetTiposOpcional
#define SOAP_TYPE_PointerTo_afip3__FEParamGetTiposOpcional (295)
#endif

/* _afip3__FEParamGetTiposIva * has binding name 'PointerTo_afip3__FEParamGetTiposIva' for type '' */
#ifndef SOAP_TYPE_PointerTo_afip3__FEParamGetTiposIva
#define SOAP_TYPE_PointerTo_afip3__FEParamGetTiposIva (291)
#endif

/* _afip3__FEParamGetTiposMonedas * has binding name 'PointerTo_afip3__FEParamGetTiposMonedas' for type '' */
#ifndef SOAP_TYPE_PointerTo_afip3__FEParamGetTiposMonedas
#define SOAP_TYPE_PointerTo_afip3__FEParamGetTiposMonedas (287)
#endif

/* _afip3__FEParamGetTiposTributos * has binding name 'PointerTo_afip3__FEParamGetTiposTributos' for type '' */
#ifndef SOAP_TYPE_PointerTo_afip3__FEParamGetTiposTributos
#define SOAP_TYPE_PointerTo_afip3__FEParamGetTiposTributos (283)
#endif

/* _afip3__FEParamGetCotizacion * has binding name 'PointerTo_afip3__FEParamGetCotizacion' for type '' */
#ifndef SOAP_TYPE_PointerTo_afip3__FEParamGetCotizacion
#define SOAP_TYPE_PointerTo_afip3__FEParamGetCotizacion (279)
#endif

/* _afip3__FECAEAConsultar * has binding name 'PointerTo_afip3__FECAEAConsultar' for type '' */
#ifndef SOAP_TYPE_PointerTo_afip3__FECAEAConsultar
#define SOAP_TYPE_PointerTo_afip3__FECAEAConsultar (275)
#endif

/* _afip3__FECAEASinMovimientoInformar * has binding name 'PointerTo_afip3__FECAEASinMovimientoInformar' for type '' */
#ifndef SOAP_TYPE_PointerTo_afip3__FECAEASinMovimientoInformar
#define SOAP_TYPE_PointerTo_afip3__FECAEASinMovimientoInformar (271)
#endif

/* _afip3__FECAEASinMovimientoConsultar * has binding name 'PointerTo_afip3__FECAEASinMovimientoConsultar' for type '' */
#ifndef SOAP_TYPE_PointerTo_afip3__FECAEASinMovimientoConsultar
#define SOAP_TYPE_PointerTo_afip3__FECAEASinMovimientoConsultar (267)
#endif

/* _afip3__FECAEASolicitar * has binding name 'PointerTo_afip3__FECAEASolicitar' for type '' */
#ifndef SOAP_TYPE_PointerTo_afip3__FECAEASolicitar
#define SOAP_TYPE_PointerTo_afip3__FECAEASolicitar (263)
#endif

/* _afip3__FECAEARegInformativo * has binding name 'PointerTo_afip3__FECAEARegInformativo' for type '' */
#ifndef SOAP_TYPE_PointerTo_afip3__FECAEARegInformativo
#define SOAP_TYPE_PointerTo_afip3__FECAEARegInformativo (259)
#endif

/* _afip3__FECompConsultar * has binding name 'PointerTo_afip3__FECompConsultar' for type '' */
#ifndef SOAP_TYPE_PointerTo_afip3__FECompConsultar
#define SOAP_TYPE_PointerTo_afip3__FECompConsultar (255)
#endif

/* _afip3__FECompUltimoAutorizado * has binding name 'PointerTo_afip3__FECompUltimoAutorizado' for type '' */
#ifndef SOAP_TYPE_PointerTo_afip3__FECompUltimoAutorizado
#define SOAP_TYPE_PointerTo_afip3__FECompUltimoAutorizado (251)
#endif

/* _afip3__FEDummy * has binding name 'PointerTo_afip3__FEDummy' for type '' */
#ifndef SOAP_TYPE_PointerTo_afip3__FEDummy
#define SOAP_TYPE_PointerTo_afip3__FEDummy (247)
#endif

/* _afip3__FECompTotXRequest * has binding name 'PointerTo_afip3__FECompTotXRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_afip3__FECompTotXRequest
#define SOAP_TYPE_PointerTo_afip3__FECompTotXRequest (243)
#endif

/* _afip3__FECAESolicitar * has binding name 'PointerTo_afip3__FECAESolicitar' for type '' */
#ifndef SOAP_TYPE_PointerTo_afip3__FECAESolicitar
#define SOAP_TYPE_PointerTo_afip3__FECAESolicitar (239)
#endif

/* _afip1__loginCms * has binding name 'PointerTo_afip1__loginCms' for type '' */
#ifndef SOAP_TYPE_PointerTo_afip1__loginCms
#define SOAP_TYPE_PointerTo_afip1__loginCms (235)
#endif

/* afip2__LoginFault * has binding name 'PointerToafip2__LoginFault' for type 'afip2:LoginFault' */
#ifndef SOAP_TYPE_PointerToafip2__LoginFault
#define SOAP_TYPE_PointerToafip2__LoginFault (232)
#endif

/* afip3__FEPaisResponse * has binding name 'PointerToafip3__FEPaisResponse' for type 'afip3:FEPaisResponse' */
#ifndef SOAP_TYPE_PointerToafip3__FEPaisResponse
#define SOAP_TYPE_PointerToafip3__FEPaisResponse (230)
#endif

/* afip3__DocTipoResponse * has binding name 'PointerToafip3__DocTipoResponse' for type 'afip3:DocTipoResponse' */
#ifndef SOAP_TYPE_PointerToafip3__DocTipoResponse
#define SOAP_TYPE_PointerToafip3__DocTipoResponse (229)
#endif

/* afip3__CbteTipoResponse * has binding name 'PointerToafip3__CbteTipoResponse' for type 'afip3:CbteTipoResponse' */
#ifndef SOAP_TYPE_PointerToafip3__CbteTipoResponse
#define SOAP_TYPE_PointerToafip3__CbteTipoResponse (228)
#endif

/* afip3__FEPtoVentaResponse * has binding name 'PointerToafip3__FEPtoVentaResponse' for type 'afip3:FEPtoVentaResponse' */
#ifndef SOAP_TYPE_PointerToafip3__FEPtoVentaResponse
#define SOAP_TYPE_PointerToafip3__FEPtoVentaResponse (227)
#endif

/* afip3__ConceptoTipoResponse * has binding name 'PointerToafip3__ConceptoTipoResponse' for type 'afip3:ConceptoTipoResponse' */
#ifndef SOAP_TYPE_PointerToafip3__ConceptoTipoResponse
#define SOAP_TYPE_PointerToafip3__ConceptoTipoResponse (226)
#endif

/* afip3__OpcionalTipoResponse * has binding name 'PointerToafip3__OpcionalTipoResponse' for type 'afip3:OpcionalTipoResponse' */
#ifndef SOAP_TYPE_PointerToafip3__OpcionalTipoResponse
#define SOAP_TYPE_PointerToafip3__OpcionalTipoResponse (225)
#endif

/* afip3__IvaTipoResponse * has binding name 'PointerToafip3__IvaTipoResponse' for type 'afip3:IvaTipoResponse' */
#ifndef SOAP_TYPE_PointerToafip3__IvaTipoResponse
#define SOAP_TYPE_PointerToafip3__IvaTipoResponse (224)
#endif

/* afip3__MonedaResponse * has binding name 'PointerToafip3__MonedaResponse' for type 'afip3:MonedaResponse' */
#ifndef SOAP_TYPE_PointerToafip3__MonedaResponse
#define SOAP_TYPE_PointerToafip3__MonedaResponse (223)
#endif

/* afip3__FETributoResponse * has binding name 'PointerToafip3__FETributoResponse' for type 'afip3:FETributoResponse' */
#ifndef SOAP_TYPE_PointerToafip3__FETributoResponse
#define SOAP_TYPE_PointerToafip3__FETributoResponse (222)
#endif

/* afip3__FECotizacionResponse * has binding name 'PointerToafip3__FECotizacionResponse' for type 'afip3:FECotizacionResponse' */
#ifndef SOAP_TYPE_PointerToafip3__FECotizacionResponse
#define SOAP_TYPE_PointerToafip3__FECotizacionResponse (221)
#endif

/* afip3__FECAEASinMovResponse * has binding name 'PointerToafip3__FECAEASinMovResponse' for type 'afip3:FECAEASinMovResponse' */
#ifndef SOAP_TYPE_PointerToafip3__FECAEASinMovResponse
#define SOAP_TYPE_PointerToafip3__FECAEASinMovResponse (220)
#endif

/* afip3__FECAEASinMovConsResponse * has binding name 'PointerToafip3__FECAEASinMovConsResponse' for type 'afip3:FECAEASinMovConsResponse' */
#ifndef SOAP_TYPE_PointerToafip3__FECAEASinMovConsResponse
#define SOAP_TYPE_PointerToafip3__FECAEASinMovConsResponse (219)
#endif

/* afip3__FECAEAGetResponse * has binding name 'PointerToafip3__FECAEAGetResponse' for type 'afip3:FECAEAGetResponse' */
#ifndef SOAP_TYPE_PointerToafip3__FECAEAGetResponse
#define SOAP_TYPE_PointerToafip3__FECAEAGetResponse (218)
#endif

/* afip3__FECAEAResponse * has binding name 'PointerToafip3__FECAEAResponse' for type 'afip3:FECAEAResponse' */
#ifndef SOAP_TYPE_PointerToafip3__FECAEAResponse
#define SOAP_TYPE_PointerToafip3__FECAEAResponse (217)
#endif

/* afip3__FECAEARequest * has binding name 'PointerToafip3__FECAEARequest' for type 'afip3:FECAEARequest' */
#ifndef SOAP_TYPE_PointerToafip3__FECAEARequest
#define SOAP_TYPE_PointerToafip3__FECAEARequest (216)
#endif

/* afip3__FECompConsultaResponse * has binding name 'PointerToafip3__FECompConsultaResponse' for type 'afip3:FECompConsultaResponse' */
#ifndef SOAP_TYPE_PointerToafip3__FECompConsultaResponse
#define SOAP_TYPE_PointerToafip3__FECompConsultaResponse (215)
#endif

/* afip3__FECompConsultaReq * has binding name 'PointerToafip3__FECompConsultaReq' for type 'afip3:FECompConsultaReq' */
#ifndef SOAP_TYPE_PointerToafip3__FECompConsultaReq
#define SOAP_TYPE_PointerToafip3__FECompConsultaReq (214)
#endif

/* afip3__FERecuperaLastCbteResponse * has binding name 'PointerToafip3__FERecuperaLastCbteResponse' for type 'afip3:FERecuperaLastCbteResponse' */
#ifndef SOAP_TYPE_PointerToafip3__FERecuperaLastCbteResponse
#define SOAP_TYPE_PointerToafip3__FERecuperaLastCbteResponse (213)
#endif

/* afip3__DummyResponse * has binding name 'PointerToafip3__DummyResponse' for type 'afip3:DummyResponse' */
#ifndef SOAP_TYPE_PointerToafip3__DummyResponse
#define SOAP_TYPE_PointerToafip3__DummyResponse (212)
#endif

/* afip3__FERegXReqResponse * has binding name 'PointerToafip3__FERegXReqResponse' for type 'afip3:FERegXReqResponse' */
#ifndef SOAP_TYPE_PointerToafip3__FERegXReqResponse
#define SOAP_TYPE_PointerToafip3__FERegXReqResponse (211)
#endif

/* afip3__FECAEResponse * has binding name 'PointerToafip3__FECAEResponse' for type 'afip3:FECAEResponse' */
#ifndef SOAP_TYPE_PointerToafip3__FECAEResponse
#define SOAP_TYPE_PointerToafip3__FECAEResponse (210)
#endif

/* afip3__FECAERequest * has binding name 'PointerToafip3__FECAERequest' for type 'afip3:FECAERequest' */
#ifndef SOAP_TYPE_PointerToafip3__FECAERequest
#define SOAP_TYPE_PointerToafip3__FECAERequest (209)
#endif

/* afip3__FEAuthRequest * has binding name 'PointerToafip3__FEAuthRequest' for type 'afip3:FEAuthRequest' */
#ifndef SOAP_TYPE_PointerToafip3__FEAuthRequest
#define SOAP_TYPE_PointerToafip3__FEAuthRequest (208)
#endif

/* afip3__PaisTipo * has binding name 'PointerToafip3__PaisTipo' for type 'afip3:PaisTipo' */
#ifndef SOAP_TYPE_PointerToafip3__PaisTipo
#define SOAP_TYPE_PointerToafip3__PaisTipo (206)
#endif

/* afip3__ArrayOfPaisTipo * has binding name 'PointerToafip3__ArrayOfPaisTipo' for type 'afip3:ArrayOfPaisTipo' */
#ifndef SOAP_TYPE_PointerToafip3__ArrayOfPaisTipo
#define SOAP_TYPE_PointerToafip3__ArrayOfPaisTipo (205)
#endif

/* afip3__DocTipo * has binding name 'PointerToafip3__DocTipo' for type 'afip3:DocTipo' */
#ifndef SOAP_TYPE_PointerToafip3__DocTipo
#define SOAP_TYPE_PointerToafip3__DocTipo (203)
#endif

/* afip3__ArrayOfDocTipo * has binding name 'PointerToafip3__ArrayOfDocTipo' for type 'afip3:ArrayOfDocTipo' */
#ifndef SOAP_TYPE_PointerToafip3__ArrayOfDocTipo
#define SOAP_TYPE_PointerToafip3__ArrayOfDocTipo (202)
#endif

/* afip3__CbteTipo * has binding name 'PointerToafip3__CbteTipo' for type 'afip3:CbteTipo' */
#ifndef SOAP_TYPE_PointerToafip3__CbteTipo
#define SOAP_TYPE_PointerToafip3__CbteTipo (200)
#endif

/* afip3__ArrayOfCbteTipo * has binding name 'PointerToafip3__ArrayOfCbteTipo' for type 'afip3:ArrayOfCbteTipo' */
#ifndef SOAP_TYPE_PointerToafip3__ArrayOfCbteTipo
#define SOAP_TYPE_PointerToafip3__ArrayOfCbteTipo (199)
#endif

/* afip3__PtoVenta * has binding name 'PointerToafip3__PtoVenta' for type 'afip3:PtoVenta' */
#ifndef SOAP_TYPE_PointerToafip3__PtoVenta
#define SOAP_TYPE_PointerToafip3__PtoVenta (197)
#endif

/* afip3__ArrayOfPtoVenta * has binding name 'PointerToafip3__ArrayOfPtoVenta' for type 'afip3:ArrayOfPtoVenta' */
#ifndef SOAP_TYPE_PointerToafip3__ArrayOfPtoVenta
#define SOAP_TYPE_PointerToafip3__ArrayOfPtoVenta (196)
#endif

/* afip3__ConceptoTipo * has binding name 'PointerToafip3__ConceptoTipo' for type 'afip3:ConceptoTipo' */
#ifndef SOAP_TYPE_PointerToafip3__ConceptoTipo
#define SOAP_TYPE_PointerToafip3__ConceptoTipo (194)
#endif

/* afip3__ArrayOfConceptoTipo * has binding name 'PointerToafip3__ArrayOfConceptoTipo' for type 'afip3:ArrayOfConceptoTipo' */
#ifndef SOAP_TYPE_PointerToafip3__ArrayOfConceptoTipo
#define SOAP_TYPE_PointerToafip3__ArrayOfConceptoTipo (193)
#endif

/* afip3__OpcionalTipo * has binding name 'PointerToafip3__OpcionalTipo' for type 'afip3:OpcionalTipo' */
#ifndef SOAP_TYPE_PointerToafip3__OpcionalTipo
#define SOAP_TYPE_PointerToafip3__OpcionalTipo (191)
#endif

/* afip3__ArrayOfOpcionalTipo * has binding name 'PointerToafip3__ArrayOfOpcionalTipo' for type 'afip3:ArrayOfOpcionalTipo' */
#ifndef SOAP_TYPE_PointerToafip3__ArrayOfOpcionalTipo
#define SOAP_TYPE_PointerToafip3__ArrayOfOpcionalTipo (190)
#endif

/* afip3__IvaTipo * has binding name 'PointerToafip3__IvaTipo' for type 'afip3:IvaTipo' */
#ifndef SOAP_TYPE_PointerToafip3__IvaTipo
#define SOAP_TYPE_PointerToafip3__IvaTipo (188)
#endif

/* afip3__ArrayOfIvaTipo * has binding name 'PointerToafip3__ArrayOfIvaTipo' for type 'afip3:ArrayOfIvaTipo' */
#ifndef SOAP_TYPE_PointerToafip3__ArrayOfIvaTipo
#define SOAP_TYPE_PointerToafip3__ArrayOfIvaTipo (187)
#endif

/* afip3__Moneda * has binding name 'PointerToafip3__Moneda' for type 'afip3:Moneda' */
#ifndef SOAP_TYPE_PointerToafip3__Moneda
#define SOAP_TYPE_PointerToafip3__Moneda (185)
#endif

/* afip3__ArrayOfMoneda * has binding name 'PointerToafip3__ArrayOfMoneda' for type 'afip3:ArrayOfMoneda' */
#ifndef SOAP_TYPE_PointerToafip3__ArrayOfMoneda
#define SOAP_TYPE_PointerToafip3__ArrayOfMoneda (184)
#endif

/* afip3__TributoTipo * has binding name 'PointerToafip3__TributoTipo' for type 'afip3:TributoTipo' */
#ifndef SOAP_TYPE_PointerToafip3__TributoTipo
#define SOAP_TYPE_PointerToafip3__TributoTipo (182)
#endif

/* afip3__ArrayOfTributoTipo * has binding name 'PointerToafip3__ArrayOfTributoTipo' for type 'afip3:ArrayOfTributoTipo' */
#ifndef SOAP_TYPE_PointerToafip3__ArrayOfTributoTipo
#define SOAP_TYPE_PointerToafip3__ArrayOfTributoTipo (181)
#endif

/* afip3__Cotizacion * has binding name 'PointerToafip3__Cotizacion' for type 'afip3:Cotizacion' */
#ifndef SOAP_TYPE_PointerToafip3__Cotizacion
#define SOAP_TYPE_PointerToafip3__Cotizacion (180)
#endif

/* afip3__FECAEASinMov * has binding name 'PointerToafip3__FECAEASinMov' for type 'afip3:FECAEASinMov' */
#ifndef SOAP_TYPE_PointerToafip3__FECAEASinMov
#define SOAP_TYPE_PointerToafip3__FECAEASinMov (178)
#endif

/* afip3__ArrayOfFECAEASinMov * has binding name 'PointerToafip3__ArrayOfFECAEASinMov' for type 'afip3:ArrayOfFECAEASinMov' */
#ifndef SOAP_TYPE_PointerToafip3__ArrayOfFECAEASinMov
#define SOAP_TYPE_PointerToafip3__ArrayOfFECAEASinMov (177)
#endif

/* afip3__FECAEAGet * has binding name 'PointerToafip3__FECAEAGet' for type 'afip3:FECAEAGet' */
#ifndef SOAP_TYPE_PointerToafip3__FECAEAGet
#define SOAP_TYPE_PointerToafip3__FECAEAGet (176)
#endif

/* afip3__FECAEADetResponse * has binding name 'PointerToafip3__FECAEADetResponse' for type 'afip3:FECAEADetResponse' */
#ifndef SOAP_TYPE_PointerToafip3__FECAEADetResponse
#define SOAP_TYPE_PointerToafip3__FECAEADetResponse (174)
#endif

/* afip3__ArrayOfFECAEADetResponse * has binding name 'PointerToafip3__ArrayOfFECAEADetResponse' for type 'afip3:ArrayOfFECAEADetResponse' */
#ifndef SOAP_TYPE_PointerToafip3__ArrayOfFECAEADetResponse
#define SOAP_TYPE_PointerToafip3__ArrayOfFECAEADetResponse (173)
#endif

/* afip3__FECAEACabResponse * has binding name 'PointerToafip3__FECAEACabResponse' for type 'afip3:FECAEACabResponse' */
#ifndef SOAP_TYPE_PointerToafip3__FECAEACabResponse
#define SOAP_TYPE_PointerToafip3__FECAEACabResponse (172)
#endif

/* afip3__FECAEADetRequest * has binding name 'PointerToafip3__FECAEADetRequest' for type 'afip3:FECAEADetRequest' */
#ifndef SOAP_TYPE_PointerToafip3__FECAEADetRequest
#define SOAP_TYPE_PointerToafip3__FECAEADetRequest (170)
#endif

/* afip3__ArrayOfFECAEADetRequest * has binding name 'PointerToafip3__ArrayOfFECAEADetRequest' for type 'afip3:ArrayOfFECAEADetRequest' */
#ifndef SOAP_TYPE_PointerToafip3__ArrayOfFECAEADetRequest
#define SOAP_TYPE_PointerToafip3__ArrayOfFECAEADetRequest (169)
#endif

/* afip3__FECAEACabRequest * has binding name 'PointerToafip3__FECAEACabRequest' for type 'afip3:FECAEACabRequest' */
#ifndef SOAP_TYPE_PointerToafip3__FECAEACabRequest
#define SOAP_TYPE_PointerToafip3__FECAEACabRequest (168)
#endif

/* afip3__FECompConsResponse * has binding name 'PointerToafip3__FECompConsResponse' for type 'afip3:FECompConsResponse' */
#ifndef SOAP_TYPE_PointerToafip3__FECompConsResponse
#define SOAP_TYPE_PointerToafip3__FECompConsResponse (167)
#endif

/* afip3__Err * has binding name 'PointerToafip3__Err' for type 'afip3:Err' */
#ifndef SOAP_TYPE_PointerToafip3__Err
#define SOAP_TYPE_PointerToafip3__Err (165)
#endif

/* afip3__Evt * has binding name 'PointerToafip3__Evt' for type 'afip3:Evt' */
#ifndef SOAP_TYPE_PointerToafip3__Evt
#define SOAP_TYPE_PointerToafip3__Evt (163)
#endif

/* afip3__Obs * has binding name 'PointerToafip3__Obs' for type 'afip3:Obs' */
#ifndef SOAP_TYPE_PointerToafip3__Obs
#define SOAP_TYPE_PointerToafip3__Obs (161)
#endif

/* afip3__ArrayOfObs * has binding name 'PointerToafip3__ArrayOfObs' for type 'afip3:ArrayOfObs' */
#ifndef SOAP_TYPE_PointerToafip3__ArrayOfObs
#define SOAP_TYPE_PointerToafip3__ArrayOfObs (160)
#endif

/* afip3__FECAEDetResponse * has binding name 'PointerToafip3__FECAEDetResponse' for type 'afip3:FECAEDetResponse' */
#ifndef SOAP_TYPE_PointerToafip3__FECAEDetResponse
#define SOAP_TYPE_PointerToafip3__FECAEDetResponse (158)
#endif

/* afip3__ArrayOfErr * has binding name 'PointerToafip3__ArrayOfErr' for type 'afip3:ArrayOfErr' */
#ifndef SOAP_TYPE_PointerToafip3__ArrayOfErr
#define SOAP_TYPE_PointerToafip3__ArrayOfErr (157)
#endif

/* afip3__ArrayOfEvt * has binding name 'PointerToafip3__ArrayOfEvt' for type 'afip3:ArrayOfEvt' */
#ifndef SOAP_TYPE_PointerToafip3__ArrayOfEvt
#define SOAP_TYPE_PointerToafip3__ArrayOfEvt (156)
#endif

/* afip3__ArrayOfFECAEDetResponse * has binding name 'PointerToafip3__ArrayOfFECAEDetResponse' for type 'afip3:ArrayOfFECAEDetResponse' */
#ifndef SOAP_TYPE_PointerToafip3__ArrayOfFECAEDetResponse
#define SOAP_TYPE_PointerToafip3__ArrayOfFECAEDetResponse (155)
#endif

/* afip3__FECAECabResponse * has binding name 'PointerToafip3__FECAECabResponse' for type 'afip3:FECAECabResponse' */
#ifndef SOAP_TYPE_PointerToafip3__FECAECabResponse
#define SOAP_TYPE_PointerToafip3__FECAECabResponse (154)
#endif

/* afip3__Comprador * has binding name 'PointerToafip3__Comprador' for type 'afip3:Comprador' */
#ifndef SOAP_TYPE_PointerToafip3__Comprador
#define SOAP_TYPE_PointerToafip3__Comprador (152)
#endif

/* afip3__Opcional * has binding name 'PointerToafip3__Opcional' for type 'afip3:Opcional' */
#ifndef SOAP_TYPE_PointerToafip3__Opcional
#define SOAP_TYPE_PointerToafip3__Opcional (150)
#endif

/* afip3__AlicIva * has binding name 'PointerToafip3__AlicIva' for type 'afip3:AlicIva' */
#ifndef SOAP_TYPE_PointerToafip3__AlicIva
#define SOAP_TYPE_PointerToafip3__AlicIva (148)
#endif

/* afip3__Tributo * has binding name 'PointerToafip3__Tributo' for type 'afip3:Tributo' */
#ifndef SOAP_TYPE_PointerToafip3__Tributo
#define SOAP_TYPE_PointerToafip3__Tributo (145)
#endif

/* afip3__CbteAsoc * has binding name 'PointerToafip3__CbteAsoc' for type 'afip3:CbteAsoc' */
#ifndef SOAP_TYPE_PointerToafip3__CbteAsoc
#define SOAP_TYPE_PointerToafip3__CbteAsoc (143)
#endif

/* afip3__ArrayOfComprador * has binding name 'PointerToafip3__ArrayOfComprador' for type 'afip3:ArrayOfComprador' */
#ifndef SOAP_TYPE_PointerToafip3__ArrayOfComprador
#define SOAP_TYPE_PointerToafip3__ArrayOfComprador (142)
#endif

/* afip3__ArrayOfOpcional * has binding name 'PointerToafip3__ArrayOfOpcional' for type 'afip3:ArrayOfOpcional' */
#ifndef SOAP_TYPE_PointerToafip3__ArrayOfOpcional
#define SOAP_TYPE_PointerToafip3__ArrayOfOpcional (141)
#endif

/* afip3__ArrayOfAlicIva * has binding name 'PointerToafip3__ArrayOfAlicIva' for type 'afip3:ArrayOfAlicIva' */
#ifndef SOAP_TYPE_PointerToafip3__ArrayOfAlicIva
#define SOAP_TYPE_PointerToafip3__ArrayOfAlicIva (140)
#endif

/* afip3__ArrayOfTributo * has binding name 'PointerToafip3__ArrayOfTributo' for type 'afip3:ArrayOfTributo' */
#ifndef SOAP_TYPE_PointerToafip3__ArrayOfTributo
#define SOAP_TYPE_PointerToafip3__ArrayOfTributo (139)
#endif

/* afip3__ArrayOfCbteAsoc * has binding name 'PointerToafip3__ArrayOfCbteAsoc' for type 'afip3:ArrayOfCbteAsoc' */
#ifndef SOAP_TYPE_PointerToafip3__ArrayOfCbteAsoc
#define SOAP_TYPE_PointerToafip3__ArrayOfCbteAsoc (138)
#endif

/* afip3__FECAEDetRequest * has binding name 'PointerToafip3__FECAEDetRequest' for type 'afip3:FECAEDetRequest' */
#ifndef SOAP_TYPE_PointerToafip3__FECAEDetRequest
#define SOAP_TYPE_PointerToafip3__FECAEDetRequest (135)
#endif

/* afip3__ArrayOfFECAEDetRequest * has binding name 'PointerToafip3__ArrayOfFECAEDetRequest' for type 'afip3:ArrayOfFECAEDetRequest' */
#ifndef SOAP_TYPE_PointerToafip3__ArrayOfFECAEDetRequest
#define SOAP_TYPE_PointerToafip3__ArrayOfFECAEDetRequest (134)
#endif

/* afip3__FECAECabRequest * has binding name 'PointerToafip3__FECAECabRequest' for type 'afip3:FECAECabRequest' */
#ifndef SOAP_TYPE_PointerToafip3__FECAECabRequest
#define SOAP_TYPE_PointerToafip3__FECAECabRequest (133)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__string
#define SOAP_TYPE_PointerTostd__string (131)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<afip3__PaisTipo *>  has binding name 'std__vectorTemplateOfPointerToafip3__PaisTipo' for type 'afip3:PaisTipo' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToafip3__PaisTipo
#define SOAP_TYPE_std__vectorTemplateOfPointerToafip3__PaisTipo (207)
#endif

/* std::vector<afip3__DocTipo *>  has binding name 'std__vectorTemplateOfPointerToafip3__DocTipo' for type 'afip3:DocTipo' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToafip3__DocTipo
#define SOAP_TYPE_std__vectorTemplateOfPointerToafip3__DocTipo (204)
#endif

/* std::vector<afip3__CbteTipo *>  has binding name 'std__vectorTemplateOfPointerToafip3__CbteTipo' for type 'afip3:CbteTipo' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToafip3__CbteTipo
#define SOAP_TYPE_std__vectorTemplateOfPointerToafip3__CbteTipo (201)
#endif

/* std::vector<afip3__PtoVenta *>  has binding name 'std__vectorTemplateOfPointerToafip3__PtoVenta' for type 'afip3:PtoVenta' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToafip3__PtoVenta
#define SOAP_TYPE_std__vectorTemplateOfPointerToafip3__PtoVenta (198)
#endif

/* std::vector<afip3__ConceptoTipo *>  has binding name 'std__vectorTemplateOfPointerToafip3__ConceptoTipo' for type 'afip3:ConceptoTipo' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToafip3__ConceptoTipo
#define SOAP_TYPE_std__vectorTemplateOfPointerToafip3__ConceptoTipo (195)
#endif

/* std::vector<afip3__OpcionalTipo *>  has binding name 'std__vectorTemplateOfPointerToafip3__OpcionalTipo' for type 'afip3:OpcionalTipo' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToafip3__OpcionalTipo
#define SOAP_TYPE_std__vectorTemplateOfPointerToafip3__OpcionalTipo (192)
#endif

/* std::vector<afip3__IvaTipo *>  has binding name 'std__vectorTemplateOfPointerToafip3__IvaTipo' for type 'afip3:IvaTipo' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToafip3__IvaTipo
#define SOAP_TYPE_std__vectorTemplateOfPointerToafip3__IvaTipo (189)
#endif

/* std::vector<afip3__Moneda *>  has binding name 'std__vectorTemplateOfPointerToafip3__Moneda' for type 'afip3:Moneda' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Moneda
#define SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Moneda (186)
#endif

/* std::vector<afip3__TributoTipo *>  has binding name 'std__vectorTemplateOfPointerToafip3__TributoTipo' for type 'afip3:TributoTipo' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToafip3__TributoTipo
#define SOAP_TYPE_std__vectorTemplateOfPointerToafip3__TributoTipo (183)
#endif

/* std::vector<afip3__FECAEASinMov *>  has binding name 'std__vectorTemplateOfPointerToafip3__FECAEASinMov' for type 'afip3:FECAEASinMov' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEASinMov
#define SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEASinMov (179)
#endif

/* std::vector<afip3__FECAEADetResponse *>  has binding name 'std__vectorTemplateOfPointerToafip3__FECAEADetResponse' for type 'afip3:FECAEADetResponse' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEADetResponse
#define SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEADetResponse (175)
#endif

/* std::vector<afip3__FECAEADetRequest *>  has binding name 'std__vectorTemplateOfPointerToafip3__FECAEADetRequest' for type 'afip3:FECAEADetRequest' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEADetRequest
#define SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEADetRequest (171)
#endif

/* std::vector<afip3__Err *>  has binding name 'std__vectorTemplateOfPointerToafip3__Err' for type 'afip3:Err' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Err
#define SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Err (166)
#endif

/* std::vector<afip3__Evt *>  has binding name 'std__vectorTemplateOfPointerToafip3__Evt' for type 'afip3:Evt' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Evt
#define SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Evt (164)
#endif

/* std::vector<afip3__Obs *>  has binding name 'std__vectorTemplateOfPointerToafip3__Obs' for type 'afip3:Obs' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Obs
#define SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Obs (162)
#endif

/* std::vector<afip3__FECAEDetResponse *>  has binding name 'std__vectorTemplateOfPointerToafip3__FECAEDetResponse' for type 'afip3:FECAEDetResponse' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEDetResponse
#define SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEDetResponse (159)
#endif

/* std::vector<afip3__Comprador *>  has binding name 'std__vectorTemplateOfPointerToafip3__Comprador' for type 'afip3:Comprador' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Comprador
#define SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Comprador (153)
#endif

/* std::vector<afip3__Opcional *>  has binding name 'std__vectorTemplateOfPointerToafip3__Opcional' for type 'afip3:Opcional' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Opcional
#define SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Opcional (151)
#endif

/* std::vector<afip3__AlicIva *>  has binding name 'std__vectorTemplateOfPointerToafip3__AlicIva' for type 'afip3:AlicIva' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToafip3__AlicIva
#define SOAP_TYPE_std__vectorTemplateOfPointerToafip3__AlicIva (149)
#endif

/* std::vector<afip3__Tributo *>  has binding name 'std__vectorTemplateOfPointerToafip3__Tributo' for type 'afip3:Tributo' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Tributo
#define SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Tributo (146)
#endif

/* std::vector<afip3__CbteAsoc *>  has binding name 'std__vectorTemplateOfPointerToafip3__CbteAsoc' for type 'afip3:CbteAsoc' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToafip3__CbteAsoc
#define SOAP_TYPE_std__vectorTemplateOfPointerToafip3__CbteAsoc (144)
#endif

/* std::vector<afip3__FECAEDetRequest *>  has binding name 'std__vectorTemplateOfPointerToafip3__FECAEDetRequest' for type 'afip3:FECAEDetRequest' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEDetRequest
#define SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEDetRequest (136)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
