/* afipC.cpp
   Generated by gSOAP 2.8.89 for soap/afip_soap.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "afipH.h"

namespace afip {

SOAP_SOURCE_STAMP("@(#) afipC.cpp ver 2.8.89 2019-08-29 04:26:03 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
	}
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code == NULL)
		soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason == NULL)
		soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
				return NULL;
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_subcode(struct soap *soap)
{
	const char **s = soap_faultsubcode(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_string(struct soap *soap)
{
	const char **s = soap_faultstring(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
			soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
		soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_detail(struct soap *soap)
{
	const char **s = soap_faultdetail(soap);
	return s ? *s : NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, NULL, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, const char *tag, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_afip_byte:
		return soap_in_byte(soap, tag, NULL, "xsd:byte");
	case SOAP_TYPE_afip_short:
		return soap_in_short(soap, tag, NULL, "xsd:short");
	case SOAP_TYPE_afip_int:
		return soap_in_int(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_afip_LONG64:
		return soap_in_LONG64(soap, tag, NULL, "xsd:long");
	case SOAP_TYPE_afip_double:
		return soap_in_double(soap, tag, NULL, "xsd:double");
	case SOAP_TYPE_afip_std__string:
		return soap_in_std__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_afip_ns3__PaisTipo:
		return soap_in_ns3__PaisTipo(soap, tag, NULL, "ns3:PaisTipo");
	case SOAP_TYPE_afip_ns3__ArrayOfPaisTipo:
		return soap_in_ns3__ArrayOfPaisTipo(soap, tag, NULL, "ns3:ArrayOfPaisTipo");
	case SOAP_TYPE_afip_ns3__FEPaisResponse:
		return soap_in_ns3__FEPaisResponse(soap, tag, NULL, "ns3:FEPaisResponse");
	case SOAP_TYPE_afip_ns3__DocTipo:
		return soap_in_ns3__DocTipo(soap, tag, NULL, "ns3:DocTipo");
	case SOAP_TYPE_afip_ns3__ArrayOfDocTipo:
		return soap_in_ns3__ArrayOfDocTipo(soap, tag, NULL, "ns3:ArrayOfDocTipo");
	case SOAP_TYPE_afip_ns3__DocTipoResponse:
		return soap_in_ns3__DocTipoResponse(soap, tag, NULL, "ns3:DocTipoResponse");
	case SOAP_TYPE_afip_ns3__CbteTipo:
		return soap_in_ns3__CbteTipo(soap, tag, NULL, "ns3:CbteTipo");
	case SOAP_TYPE_afip_ns3__ArrayOfCbteTipo:
		return soap_in_ns3__ArrayOfCbteTipo(soap, tag, NULL, "ns3:ArrayOfCbteTipo");
	case SOAP_TYPE_afip_ns3__CbteTipoResponse:
		return soap_in_ns3__CbteTipoResponse(soap, tag, NULL, "ns3:CbteTipoResponse");
	case SOAP_TYPE_afip_ns3__PtoVenta:
		return soap_in_ns3__PtoVenta(soap, tag, NULL, "ns3:PtoVenta");
	case SOAP_TYPE_afip_ns3__ArrayOfPtoVenta:
		return soap_in_ns3__ArrayOfPtoVenta(soap, tag, NULL, "ns3:ArrayOfPtoVenta");
	case SOAP_TYPE_afip_ns3__FEPtoVentaResponse:
		return soap_in_ns3__FEPtoVentaResponse(soap, tag, NULL, "ns3:FEPtoVentaResponse");
	case SOAP_TYPE_afip_ns3__ConceptoTipo:
		return soap_in_ns3__ConceptoTipo(soap, tag, NULL, "ns3:ConceptoTipo");
	case SOAP_TYPE_afip_ns3__ArrayOfConceptoTipo:
		return soap_in_ns3__ArrayOfConceptoTipo(soap, tag, NULL, "ns3:ArrayOfConceptoTipo");
	case SOAP_TYPE_afip_ns3__ConceptoTipoResponse:
		return soap_in_ns3__ConceptoTipoResponse(soap, tag, NULL, "ns3:ConceptoTipoResponse");
	case SOAP_TYPE_afip_ns3__OpcionalTipo:
		return soap_in_ns3__OpcionalTipo(soap, tag, NULL, "ns3:OpcionalTipo");
	case SOAP_TYPE_afip_ns3__ArrayOfOpcionalTipo:
		return soap_in_ns3__ArrayOfOpcionalTipo(soap, tag, NULL, "ns3:ArrayOfOpcionalTipo");
	case SOAP_TYPE_afip_ns3__OpcionalTipoResponse:
		return soap_in_ns3__OpcionalTipoResponse(soap, tag, NULL, "ns3:OpcionalTipoResponse");
	case SOAP_TYPE_afip_ns3__IvaTipo:
		return soap_in_ns3__IvaTipo(soap, tag, NULL, "ns3:IvaTipo");
	case SOAP_TYPE_afip_ns3__ArrayOfIvaTipo:
		return soap_in_ns3__ArrayOfIvaTipo(soap, tag, NULL, "ns3:ArrayOfIvaTipo");
	case SOAP_TYPE_afip_ns3__IvaTipoResponse:
		return soap_in_ns3__IvaTipoResponse(soap, tag, NULL, "ns3:IvaTipoResponse");
	case SOAP_TYPE_afip_ns3__Moneda:
		return soap_in_ns3__Moneda(soap, tag, NULL, "ns3:Moneda");
	case SOAP_TYPE_afip_ns3__ArrayOfMoneda:
		return soap_in_ns3__ArrayOfMoneda(soap, tag, NULL, "ns3:ArrayOfMoneda");
	case SOAP_TYPE_afip_ns3__MonedaResponse:
		return soap_in_ns3__MonedaResponse(soap, tag, NULL, "ns3:MonedaResponse");
	case SOAP_TYPE_afip_ns3__TributoTipo:
		return soap_in_ns3__TributoTipo(soap, tag, NULL, "ns3:TributoTipo");
	case SOAP_TYPE_afip_ns3__ArrayOfTributoTipo:
		return soap_in_ns3__ArrayOfTributoTipo(soap, tag, NULL, "ns3:ArrayOfTributoTipo");
	case SOAP_TYPE_afip_ns3__FETributoResponse:
		return soap_in_ns3__FETributoResponse(soap, tag, NULL, "ns3:FETributoResponse");
	case SOAP_TYPE_afip_ns3__Cotizacion:
		return soap_in_ns3__Cotizacion(soap, tag, NULL, "ns3:Cotizacion");
	case SOAP_TYPE_afip_ns3__FECotizacionResponse:
		return soap_in_ns3__FECotizacionResponse(soap, tag, NULL, "ns3:FECotizacionResponse");
	case SOAP_TYPE_afip_ns3__FECAEASinMovResponse:
		return soap_in_ns3__FECAEASinMovResponse(soap, tag, NULL, "ns3:FECAEASinMovResponse");
	case SOAP_TYPE_afip_ns3__FECAEASinMov:
		return soap_in_ns3__FECAEASinMov(soap, tag, NULL, "ns3:FECAEASinMov");
	case SOAP_TYPE_afip_ns3__ArrayOfFECAEASinMov:
		return soap_in_ns3__ArrayOfFECAEASinMov(soap, tag, NULL, "ns3:ArrayOfFECAEASinMov");
	case SOAP_TYPE_afip_ns3__FECAEASinMovConsResponse:
		return soap_in_ns3__FECAEASinMovConsResponse(soap, tag, NULL, "ns3:FECAEASinMovConsResponse");
	case SOAP_TYPE_afip_ns3__FECAEAGet:
		return soap_in_ns3__FECAEAGet(soap, tag, NULL, "ns3:FECAEAGet");
	case SOAP_TYPE_afip_ns3__FECAEAGetResponse:
		return soap_in_ns3__FECAEAGetResponse(soap, tag, NULL, "ns3:FECAEAGetResponse");
	case SOAP_TYPE_afip_ns3__FECAEADetResponse:
		return soap_in_ns3__FECAEADetResponse(soap, tag, NULL, "ns3:FECAEADetResponse");
	case SOAP_TYPE_afip_ns3__ArrayOfFECAEADetResponse:
		return soap_in_ns3__ArrayOfFECAEADetResponse(soap, tag, NULL, "ns3:ArrayOfFECAEADetResponse");
	case SOAP_TYPE_afip_ns3__FECAEACabResponse:
		return soap_in_ns3__FECAEACabResponse(soap, tag, NULL, "ns3:FECAEACabResponse");
	case SOAP_TYPE_afip_ns3__FECAEAResponse:
		return soap_in_ns3__FECAEAResponse(soap, tag, NULL, "ns3:FECAEAResponse");
	case SOAP_TYPE_afip_ns3__FECAEADetRequest:
		return soap_in_ns3__FECAEADetRequest(soap, tag, NULL, "ns3:FECAEADetRequest");
	case SOAP_TYPE_afip_ns3__ArrayOfFECAEADetRequest:
		return soap_in_ns3__ArrayOfFECAEADetRequest(soap, tag, NULL, "ns3:ArrayOfFECAEADetRequest");
	case SOAP_TYPE_afip_ns3__FECAEACabRequest:
		return soap_in_ns3__FECAEACabRequest(soap, tag, NULL, "ns3:FECAEACabRequest");
	case SOAP_TYPE_afip_ns3__FECAEARequest:
		return soap_in_ns3__FECAEARequest(soap, tag, NULL, "ns3:FECAEARequest");
	case SOAP_TYPE_afip_ns3__FECompConsResponse:
		return soap_in_ns3__FECompConsResponse(soap, tag, NULL, "ns3:FECompConsResponse");
	case SOAP_TYPE_afip_ns3__FECompConsultaResponse:
		return soap_in_ns3__FECompConsultaResponse(soap, tag, NULL, "ns3:FECompConsultaResponse");
	case SOAP_TYPE_afip_ns3__FECompConsultaReq:
		return soap_in_ns3__FECompConsultaReq(soap, tag, NULL, "ns3:FECompConsultaReq");
	case SOAP_TYPE_afip_ns3__FERecuperaLastCbteResponse:
		return soap_in_ns3__FERecuperaLastCbteResponse(soap, tag, NULL, "ns3:FERecuperaLastCbteResponse");
	case SOAP_TYPE_afip_ns3__DummyResponse:
		return soap_in_ns3__DummyResponse(soap, tag, NULL, "ns3:DummyResponse");
	case SOAP_TYPE_afip_ns3__FERegXReqResponse:
		return soap_in_ns3__FERegXReqResponse(soap, tag, NULL, "ns3:FERegXReqResponse");
	case SOAP_TYPE_afip_ns3__Err:
		return soap_in_ns3__Err(soap, tag, NULL, "ns3:Err");
	case SOAP_TYPE_afip_ns3__ArrayOfErr:
		return soap_in_ns3__ArrayOfErr(soap, tag, NULL, "ns3:ArrayOfErr");
	case SOAP_TYPE_afip_ns3__Evt:
		return soap_in_ns3__Evt(soap, tag, NULL, "ns3:Evt");
	case SOAP_TYPE_afip_ns3__ArrayOfEvt:
		return soap_in_ns3__ArrayOfEvt(soap, tag, NULL, "ns3:ArrayOfEvt");
	case SOAP_TYPE_afip_ns3__Obs:
		return soap_in_ns3__Obs(soap, tag, NULL, "ns3:Obs");
	case SOAP_TYPE_afip_ns3__ArrayOfObs:
		return soap_in_ns3__ArrayOfObs(soap, tag, NULL, "ns3:ArrayOfObs");
	case SOAP_TYPE_afip_ns3__FEDetResponse:
		return soap_in_ns3__FEDetResponse(soap, tag, NULL, "ns3:FEDetResponse");
	case SOAP_TYPE_afip_ns3__FECAEDetResponse:
		return soap_in_ns3__FECAEDetResponse(soap, tag, NULL, "ns3:FECAEDetResponse");
	case SOAP_TYPE_afip_ns3__ArrayOfFECAEDetResponse:
		return soap_in_ns3__ArrayOfFECAEDetResponse(soap, tag, NULL, "ns3:ArrayOfFECAEDetResponse");
	case SOAP_TYPE_afip_ns3__FECabResponse:
		return soap_in_ns3__FECabResponse(soap, tag, NULL, "ns3:FECabResponse");
	case SOAP_TYPE_afip_ns3__FECAECabResponse:
		return soap_in_ns3__FECAECabResponse(soap, tag, NULL, "ns3:FECAECabResponse");
	case SOAP_TYPE_afip_ns3__FECAEResponse:
		return soap_in_ns3__FECAEResponse(soap, tag, NULL, "ns3:FECAEResponse");
	case SOAP_TYPE_afip_ns3__Comprador:
		return soap_in_ns3__Comprador(soap, tag, NULL, "ns3:Comprador");
	case SOAP_TYPE_afip_ns3__ArrayOfComprador:
		return soap_in_ns3__ArrayOfComprador(soap, tag, NULL, "ns3:ArrayOfComprador");
	case SOAP_TYPE_afip_ns3__Opcional:
		return soap_in_ns3__Opcional(soap, tag, NULL, "ns3:Opcional");
	case SOAP_TYPE_afip_ns3__ArrayOfOpcional:
		return soap_in_ns3__ArrayOfOpcional(soap, tag, NULL, "ns3:ArrayOfOpcional");
	case SOAP_TYPE_afip_ns3__AlicIva:
		return soap_in_ns3__AlicIva(soap, tag, NULL, "ns3:AlicIva");
	case SOAP_TYPE_afip_ns3__ArrayOfAlicIva:
		return soap_in_ns3__ArrayOfAlicIva(soap, tag, NULL, "ns3:ArrayOfAlicIva");
	case SOAP_TYPE_afip_ns3__Tributo:
		return soap_in_ns3__Tributo(soap, tag, NULL, "ns3:Tributo");
	case SOAP_TYPE_afip_ns3__ArrayOfTributo:
		return soap_in_ns3__ArrayOfTributo(soap, tag, NULL, "ns3:ArrayOfTributo");
	case SOAP_TYPE_afip_ns3__CbteAsoc:
		return soap_in_ns3__CbteAsoc(soap, tag, NULL, "ns3:CbteAsoc");
	case SOAP_TYPE_afip_ns3__ArrayOfCbteAsoc:
		return soap_in_ns3__ArrayOfCbteAsoc(soap, tag, NULL, "ns3:ArrayOfCbteAsoc");
	case SOAP_TYPE_afip_ns3__FEDetRequest:
		return soap_in_ns3__FEDetRequest(soap, tag, NULL, "ns3:FEDetRequest");
	case SOAP_TYPE_afip_ns3__FECAEDetRequest:
		return soap_in_ns3__FECAEDetRequest(soap, tag, NULL, "ns3:FECAEDetRequest");
	case SOAP_TYPE_afip_ns3__ArrayOfFECAEDetRequest:
		return soap_in_ns3__ArrayOfFECAEDetRequest(soap, tag, NULL, "ns3:ArrayOfFECAEDetRequest");
	case SOAP_TYPE_afip_ns3__FECabRequest:
		return soap_in_ns3__FECabRequest(soap, tag, NULL, "ns3:FECabRequest");
	case SOAP_TYPE_afip_ns3__FECAECabRequest:
		return soap_in_ns3__FECAECabRequest(soap, tag, NULL, "ns3:FECAECabRequest");
	case SOAP_TYPE_afip_ns3__FECAERequest:
		return soap_in_ns3__FECAERequest(soap, tag, NULL, "ns3:FECAERequest");
	case SOAP_TYPE_afip_ns3__FEAuthRequest:
		return soap_in_ns3__FEAuthRequest(soap, tag, NULL, "ns3:FEAuthRequest");
	case SOAP_TYPE_afip_ns2__LoginFault:
		return soap_in_ns2__LoginFault(soap, tag, NULL, "ns2:LoginFault");
	case SOAP_TYPE_afip_PointerTo_ns3__FEParamGetTiposPaises:
		return soap_in_PointerTo_ns3__FEParamGetTiposPaises(soap, tag, NULL, "ns3:FEParamGetTiposPaises");
	case SOAP_TYPE_afip_PointerTo_ns3__FEParamGetTiposDoc:
		return soap_in_PointerTo_ns3__FEParamGetTiposDoc(soap, tag, NULL, "ns3:FEParamGetTiposDoc");
	case SOAP_TYPE_afip_PointerTo_ns3__FEParamGetTiposCbte:
		return soap_in_PointerTo_ns3__FEParamGetTiposCbte(soap, tag, NULL, "ns3:FEParamGetTiposCbte");
	case SOAP_TYPE_afip_PointerTo_ns3__FEParamGetPtosVenta:
		return soap_in_PointerTo_ns3__FEParamGetPtosVenta(soap, tag, NULL, "ns3:FEParamGetPtosVenta");
	case SOAP_TYPE_afip_PointerTo_ns3__FEParamGetTiposConcepto:
		return soap_in_PointerTo_ns3__FEParamGetTiposConcepto(soap, tag, NULL, "ns3:FEParamGetTiposConcepto");
	case SOAP_TYPE_afip_PointerTo_ns3__FEParamGetTiposOpcional:
		return soap_in_PointerTo_ns3__FEParamGetTiposOpcional(soap, tag, NULL, "ns3:FEParamGetTiposOpcional");
	case SOAP_TYPE_afip_PointerTo_ns3__FEParamGetTiposIva:
		return soap_in_PointerTo_ns3__FEParamGetTiposIva(soap, tag, NULL, "ns3:FEParamGetTiposIva");
	case SOAP_TYPE_afip_PointerTo_ns3__FEParamGetTiposMonedas:
		return soap_in_PointerTo_ns3__FEParamGetTiposMonedas(soap, tag, NULL, "ns3:FEParamGetTiposMonedas");
	case SOAP_TYPE_afip_PointerTo_ns3__FEParamGetTiposTributos:
		return soap_in_PointerTo_ns3__FEParamGetTiposTributos(soap, tag, NULL, "ns3:FEParamGetTiposTributos");
	case SOAP_TYPE_afip_PointerTo_ns3__FEParamGetCotizacion:
		return soap_in_PointerTo_ns3__FEParamGetCotizacion(soap, tag, NULL, "ns3:FEParamGetCotizacion");
	case SOAP_TYPE_afip_PointerTo_ns3__FECAEAConsultar:
		return soap_in_PointerTo_ns3__FECAEAConsultar(soap, tag, NULL, "ns3:FECAEAConsultar");
	case SOAP_TYPE_afip_PointerTo_ns3__FECAEASinMovimientoInformar:
		return soap_in_PointerTo_ns3__FECAEASinMovimientoInformar(soap, tag, NULL, "ns3:FECAEASinMovimientoInformar");
	case SOAP_TYPE_afip_PointerTo_ns3__FECAEASinMovimientoConsultar:
		return soap_in_PointerTo_ns3__FECAEASinMovimientoConsultar(soap, tag, NULL, "ns3:FECAEASinMovimientoConsultar");
	case SOAP_TYPE_afip_PointerTo_ns3__FECAEASolicitar:
		return soap_in_PointerTo_ns3__FECAEASolicitar(soap, tag, NULL, "ns3:FECAEASolicitar");
	case SOAP_TYPE_afip_PointerTo_ns3__FECAEARegInformativo:
		return soap_in_PointerTo_ns3__FECAEARegInformativo(soap, tag, NULL, "ns3:FECAEARegInformativo");
	case SOAP_TYPE_afip_PointerTo_ns3__FECompConsultar:
		return soap_in_PointerTo_ns3__FECompConsultar(soap, tag, NULL, "ns3:FECompConsultar");
	case SOAP_TYPE_afip_PointerTo_ns3__FECompUltimoAutorizado:
		return soap_in_PointerTo_ns3__FECompUltimoAutorizado(soap, tag, NULL, "ns3:FECompUltimoAutorizado");
	case SOAP_TYPE_afip_PointerTo_ns3__FEDummy:
		return soap_in_PointerTo_ns3__FEDummy(soap, tag, NULL, "ns3:FEDummy");
	case SOAP_TYPE_afip_PointerTo_ns3__FECompTotXRequest:
		return soap_in_PointerTo_ns3__FECompTotXRequest(soap, tag, NULL, "ns3:FECompTotXRequest");
	case SOAP_TYPE_afip_PointerTo_ns3__FECAESolicitar:
		return soap_in_PointerTo_ns3__FECAESolicitar(soap, tag, NULL, "ns3:FECAESolicitar");
	case SOAP_TYPE_afip_PointerTo_ns1__loginCms:
		return soap_in_PointerTo_ns1__loginCms(soap, tag, NULL, "ns1:loginCms");
	case SOAP_TYPE_afip_PointerTons2__LoginFault:
		return soap_in_PointerTons2__LoginFault(soap, tag, NULL, "ns2:LoginFault");
	case SOAP_TYPE_afip_PointerTons3__FEPaisResponse:
		return soap_in_PointerTons3__FEPaisResponse(soap, tag, NULL, "ns3:FEPaisResponse");
	case SOAP_TYPE_afip_PointerTons3__DocTipoResponse:
		return soap_in_PointerTons3__DocTipoResponse(soap, tag, NULL, "ns3:DocTipoResponse");
	case SOAP_TYPE_afip_PointerTons3__CbteTipoResponse:
		return soap_in_PointerTons3__CbteTipoResponse(soap, tag, NULL, "ns3:CbteTipoResponse");
	case SOAP_TYPE_afip_PointerTons3__FEPtoVentaResponse:
		return soap_in_PointerTons3__FEPtoVentaResponse(soap, tag, NULL, "ns3:FEPtoVentaResponse");
	case SOAP_TYPE_afip_PointerTons3__ConceptoTipoResponse:
		return soap_in_PointerTons3__ConceptoTipoResponse(soap, tag, NULL, "ns3:ConceptoTipoResponse");
	case SOAP_TYPE_afip_PointerTons3__OpcionalTipoResponse:
		return soap_in_PointerTons3__OpcionalTipoResponse(soap, tag, NULL, "ns3:OpcionalTipoResponse");
	case SOAP_TYPE_afip_PointerTons3__IvaTipoResponse:
		return soap_in_PointerTons3__IvaTipoResponse(soap, tag, NULL, "ns3:IvaTipoResponse");
	case SOAP_TYPE_afip_PointerTons3__MonedaResponse:
		return soap_in_PointerTons3__MonedaResponse(soap, tag, NULL, "ns3:MonedaResponse");
	case SOAP_TYPE_afip_PointerTons3__FETributoResponse:
		return soap_in_PointerTons3__FETributoResponse(soap, tag, NULL, "ns3:FETributoResponse");
	case SOAP_TYPE_afip_PointerTons3__FECotizacionResponse:
		return soap_in_PointerTons3__FECotizacionResponse(soap, tag, NULL, "ns3:FECotizacionResponse");
	case SOAP_TYPE_afip_PointerTons3__FECAEASinMovResponse:
		return soap_in_PointerTons3__FECAEASinMovResponse(soap, tag, NULL, "ns3:FECAEASinMovResponse");
	case SOAP_TYPE_afip_PointerTons3__FECAEASinMovConsResponse:
		return soap_in_PointerTons3__FECAEASinMovConsResponse(soap, tag, NULL, "ns3:FECAEASinMovConsResponse");
	case SOAP_TYPE_afip_PointerTons3__FECAEAGetResponse:
		return soap_in_PointerTons3__FECAEAGetResponse(soap, tag, NULL, "ns3:FECAEAGetResponse");
	case SOAP_TYPE_afip_PointerTons3__FECAEAResponse:
		return soap_in_PointerTons3__FECAEAResponse(soap, tag, NULL, "ns3:FECAEAResponse");
	case SOAP_TYPE_afip_PointerTons3__FECAEARequest:
		return soap_in_PointerTons3__FECAEARequest(soap, tag, NULL, "ns3:FECAEARequest");
	case SOAP_TYPE_afip_PointerTons3__FECompConsultaResponse:
		return soap_in_PointerTons3__FECompConsultaResponse(soap, tag, NULL, "ns3:FECompConsultaResponse");
	case SOAP_TYPE_afip_PointerTons3__FECompConsultaReq:
		return soap_in_PointerTons3__FECompConsultaReq(soap, tag, NULL, "ns3:FECompConsultaReq");
	case SOAP_TYPE_afip_PointerTons3__FERecuperaLastCbteResponse:
		return soap_in_PointerTons3__FERecuperaLastCbteResponse(soap, tag, NULL, "ns3:FERecuperaLastCbteResponse");
	case SOAP_TYPE_afip_PointerTons3__DummyResponse:
		return soap_in_PointerTons3__DummyResponse(soap, tag, NULL, "ns3:DummyResponse");
	case SOAP_TYPE_afip_PointerTons3__FERegXReqResponse:
		return soap_in_PointerTons3__FERegXReqResponse(soap, tag, NULL, "ns3:FERegXReqResponse");
	case SOAP_TYPE_afip_PointerTons3__FECAEResponse:
		return soap_in_PointerTons3__FECAEResponse(soap, tag, NULL, "ns3:FECAEResponse");
	case SOAP_TYPE_afip_PointerTons3__FECAERequest:
		return soap_in_PointerTons3__FECAERequest(soap, tag, NULL, "ns3:FECAERequest");
	case SOAP_TYPE_afip_PointerTons3__FEAuthRequest:
		return soap_in_PointerTons3__FEAuthRequest(soap, tag, NULL, "ns3:FEAuthRequest");
	case SOAP_TYPE_afip_PointerTons3__PaisTipo:
		return soap_in_PointerTons3__PaisTipo(soap, tag, NULL, "ns3:PaisTipo");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfPaisTipo:
		return soap_in_PointerTons3__ArrayOfPaisTipo(soap, tag, NULL, "ns3:ArrayOfPaisTipo");
	case SOAP_TYPE_afip_PointerTons3__DocTipo:
		return soap_in_PointerTons3__DocTipo(soap, tag, NULL, "ns3:DocTipo");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfDocTipo:
		return soap_in_PointerTons3__ArrayOfDocTipo(soap, tag, NULL, "ns3:ArrayOfDocTipo");
	case SOAP_TYPE_afip_PointerTons3__CbteTipo:
		return soap_in_PointerTons3__CbteTipo(soap, tag, NULL, "ns3:CbteTipo");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfCbteTipo:
		return soap_in_PointerTons3__ArrayOfCbteTipo(soap, tag, NULL, "ns3:ArrayOfCbteTipo");
	case SOAP_TYPE_afip_PointerTons3__PtoVenta:
		return soap_in_PointerTons3__PtoVenta(soap, tag, NULL, "ns3:PtoVenta");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfPtoVenta:
		return soap_in_PointerTons3__ArrayOfPtoVenta(soap, tag, NULL, "ns3:ArrayOfPtoVenta");
	case SOAP_TYPE_afip_PointerTons3__ConceptoTipo:
		return soap_in_PointerTons3__ConceptoTipo(soap, tag, NULL, "ns3:ConceptoTipo");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfConceptoTipo:
		return soap_in_PointerTons3__ArrayOfConceptoTipo(soap, tag, NULL, "ns3:ArrayOfConceptoTipo");
	case SOAP_TYPE_afip_PointerTons3__OpcionalTipo:
		return soap_in_PointerTons3__OpcionalTipo(soap, tag, NULL, "ns3:OpcionalTipo");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfOpcionalTipo:
		return soap_in_PointerTons3__ArrayOfOpcionalTipo(soap, tag, NULL, "ns3:ArrayOfOpcionalTipo");
	case SOAP_TYPE_afip_PointerTons3__IvaTipo:
		return soap_in_PointerTons3__IvaTipo(soap, tag, NULL, "ns3:IvaTipo");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfIvaTipo:
		return soap_in_PointerTons3__ArrayOfIvaTipo(soap, tag, NULL, "ns3:ArrayOfIvaTipo");
	case SOAP_TYPE_afip_PointerTons3__Moneda:
		return soap_in_PointerTons3__Moneda(soap, tag, NULL, "ns3:Moneda");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfMoneda:
		return soap_in_PointerTons3__ArrayOfMoneda(soap, tag, NULL, "ns3:ArrayOfMoneda");
	case SOAP_TYPE_afip_PointerTons3__TributoTipo:
		return soap_in_PointerTons3__TributoTipo(soap, tag, NULL, "ns3:TributoTipo");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfTributoTipo:
		return soap_in_PointerTons3__ArrayOfTributoTipo(soap, tag, NULL, "ns3:ArrayOfTributoTipo");
	case SOAP_TYPE_afip_PointerTons3__Cotizacion:
		return soap_in_PointerTons3__Cotizacion(soap, tag, NULL, "ns3:Cotizacion");
	case SOAP_TYPE_afip_PointerTons3__FECAEASinMov:
		return soap_in_PointerTons3__FECAEASinMov(soap, tag, NULL, "ns3:FECAEASinMov");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfFECAEASinMov:
		return soap_in_PointerTons3__ArrayOfFECAEASinMov(soap, tag, NULL, "ns3:ArrayOfFECAEASinMov");
	case SOAP_TYPE_afip_PointerTons3__FECAEAGet:
		return soap_in_PointerTons3__FECAEAGet(soap, tag, NULL, "ns3:FECAEAGet");
	case SOAP_TYPE_afip_PointerTons3__FECAEADetResponse:
		return soap_in_PointerTons3__FECAEADetResponse(soap, tag, NULL, "ns3:FECAEADetResponse");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfFECAEADetResponse:
		return soap_in_PointerTons3__ArrayOfFECAEADetResponse(soap, tag, NULL, "ns3:ArrayOfFECAEADetResponse");
	case SOAP_TYPE_afip_PointerTons3__FECAEACabResponse:
		return soap_in_PointerTons3__FECAEACabResponse(soap, tag, NULL, "ns3:FECAEACabResponse");
	case SOAP_TYPE_afip_PointerTons3__FECAEADetRequest:
		return soap_in_PointerTons3__FECAEADetRequest(soap, tag, NULL, "ns3:FECAEADetRequest");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfFECAEADetRequest:
		return soap_in_PointerTons3__ArrayOfFECAEADetRequest(soap, tag, NULL, "ns3:ArrayOfFECAEADetRequest");
	case SOAP_TYPE_afip_PointerTons3__FECAEACabRequest:
		return soap_in_PointerTons3__FECAEACabRequest(soap, tag, NULL, "ns3:FECAEACabRequest");
	case SOAP_TYPE_afip_PointerTons3__FECompConsResponse:
		return soap_in_PointerTons3__FECompConsResponse(soap, tag, NULL, "ns3:FECompConsResponse");
	case SOAP_TYPE_afip_PointerTons3__Err:
		return soap_in_PointerTons3__Err(soap, tag, NULL, "ns3:Err");
	case SOAP_TYPE_afip_PointerTons3__Evt:
		return soap_in_PointerTons3__Evt(soap, tag, NULL, "ns3:Evt");
	case SOAP_TYPE_afip_PointerTons3__Obs:
		return soap_in_PointerTons3__Obs(soap, tag, NULL, "ns3:Obs");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfObs:
		return soap_in_PointerTons3__ArrayOfObs(soap, tag, NULL, "ns3:ArrayOfObs");
	case SOAP_TYPE_afip_PointerTons3__FECAEDetResponse:
		return soap_in_PointerTons3__FECAEDetResponse(soap, tag, NULL, "ns3:FECAEDetResponse");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfErr:
		return soap_in_PointerTons3__ArrayOfErr(soap, tag, NULL, "ns3:ArrayOfErr");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfEvt:
		return soap_in_PointerTons3__ArrayOfEvt(soap, tag, NULL, "ns3:ArrayOfEvt");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfFECAEDetResponse:
		return soap_in_PointerTons3__ArrayOfFECAEDetResponse(soap, tag, NULL, "ns3:ArrayOfFECAEDetResponse");
	case SOAP_TYPE_afip_PointerTons3__FECAECabResponse:
		return soap_in_PointerTons3__FECAECabResponse(soap, tag, NULL, "ns3:FECAECabResponse");
	case SOAP_TYPE_afip_PointerTons3__Comprador:
		return soap_in_PointerTons3__Comprador(soap, tag, NULL, "ns3:Comprador");
	case SOAP_TYPE_afip_PointerTons3__Opcional:
		return soap_in_PointerTons3__Opcional(soap, tag, NULL, "ns3:Opcional");
	case SOAP_TYPE_afip_PointerTons3__AlicIva:
		return soap_in_PointerTons3__AlicIva(soap, tag, NULL, "ns3:AlicIva");
	case SOAP_TYPE_afip_PointerTons3__Tributo:
		return soap_in_PointerTons3__Tributo(soap, tag, NULL, "ns3:Tributo");
	case SOAP_TYPE_afip_PointerTons3__CbteAsoc:
		return soap_in_PointerTons3__CbteAsoc(soap, tag, NULL, "ns3:CbteAsoc");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfComprador:
		return soap_in_PointerTons3__ArrayOfComprador(soap, tag, NULL, "ns3:ArrayOfComprador");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfOpcional:
		return soap_in_PointerTons3__ArrayOfOpcional(soap, tag, NULL, "ns3:ArrayOfOpcional");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfAlicIva:
		return soap_in_PointerTons3__ArrayOfAlicIva(soap, tag, NULL, "ns3:ArrayOfAlicIva");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfTributo:
		return soap_in_PointerTons3__ArrayOfTributo(soap, tag, NULL, "ns3:ArrayOfTributo");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfCbteAsoc:
		return soap_in_PointerTons3__ArrayOfCbteAsoc(soap, tag, NULL, "ns3:ArrayOfCbteAsoc");
	case SOAP_TYPE_afip_PointerTons3__FECAEDetRequest:
		return soap_in_PointerTons3__FECAEDetRequest(soap, tag, NULL, "ns3:FECAEDetRequest");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfFECAEDetRequest:
		return soap_in_PointerTons3__ArrayOfFECAEDetRequest(soap, tag, NULL, "ns3:ArrayOfFECAEDetRequest");
	case SOAP_TYPE_afip_PointerTons3__FECAECabRequest:
		return soap_in_PointerTons3__FECAECabRequest(soap, tag, NULL, "ns3:FECAECabRequest");
	case SOAP_TYPE_afip_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_afip__QName:
	{	char **s;
		s = soap_in__QName(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_afip_string:
	{	char **s;
		s = soap_in_string(soap, tag, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_afip_std__string;
			return soap_in_std__string(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:PaisTipo"))
		{	*type = SOAP_TYPE_afip_ns3__PaisTipo;
			return soap_in_ns3__PaisTipo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfPaisTipo"))
		{	*type = SOAP_TYPE_afip_ns3__ArrayOfPaisTipo;
			return soap_in_ns3__ArrayOfPaisTipo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FEPaisResponse"))
		{	*type = SOAP_TYPE_afip_ns3__FEPaisResponse;
			return soap_in_ns3__FEPaisResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:DocTipo"))
		{	*type = SOAP_TYPE_afip_ns3__DocTipo;
			return soap_in_ns3__DocTipo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfDocTipo"))
		{	*type = SOAP_TYPE_afip_ns3__ArrayOfDocTipo;
			return soap_in_ns3__ArrayOfDocTipo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:DocTipoResponse"))
		{	*type = SOAP_TYPE_afip_ns3__DocTipoResponse;
			return soap_in_ns3__DocTipoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CbteTipo"))
		{	*type = SOAP_TYPE_afip_ns3__CbteTipo;
			return soap_in_ns3__CbteTipo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfCbteTipo"))
		{	*type = SOAP_TYPE_afip_ns3__ArrayOfCbteTipo;
			return soap_in_ns3__ArrayOfCbteTipo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CbteTipoResponse"))
		{	*type = SOAP_TYPE_afip_ns3__CbteTipoResponse;
			return soap_in_ns3__CbteTipoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:PtoVenta"))
		{	*type = SOAP_TYPE_afip_ns3__PtoVenta;
			return soap_in_ns3__PtoVenta(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfPtoVenta"))
		{	*type = SOAP_TYPE_afip_ns3__ArrayOfPtoVenta;
			return soap_in_ns3__ArrayOfPtoVenta(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FEPtoVentaResponse"))
		{	*type = SOAP_TYPE_afip_ns3__FEPtoVentaResponse;
			return soap_in_ns3__FEPtoVentaResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ConceptoTipo"))
		{	*type = SOAP_TYPE_afip_ns3__ConceptoTipo;
			return soap_in_ns3__ConceptoTipo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfConceptoTipo"))
		{	*type = SOAP_TYPE_afip_ns3__ArrayOfConceptoTipo;
			return soap_in_ns3__ArrayOfConceptoTipo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ConceptoTipoResponse"))
		{	*type = SOAP_TYPE_afip_ns3__ConceptoTipoResponse;
			return soap_in_ns3__ConceptoTipoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:OpcionalTipo"))
		{	*type = SOAP_TYPE_afip_ns3__OpcionalTipo;
			return soap_in_ns3__OpcionalTipo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfOpcionalTipo"))
		{	*type = SOAP_TYPE_afip_ns3__ArrayOfOpcionalTipo;
			return soap_in_ns3__ArrayOfOpcionalTipo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:OpcionalTipoResponse"))
		{	*type = SOAP_TYPE_afip_ns3__OpcionalTipoResponse;
			return soap_in_ns3__OpcionalTipoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:IvaTipo"))
		{	*type = SOAP_TYPE_afip_ns3__IvaTipo;
			return soap_in_ns3__IvaTipo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfIvaTipo"))
		{	*type = SOAP_TYPE_afip_ns3__ArrayOfIvaTipo;
			return soap_in_ns3__ArrayOfIvaTipo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:IvaTipoResponse"))
		{	*type = SOAP_TYPE_afip_ns3__IvaTipoResponse;
			return soap_in_ns3__IvaTipoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:Moneda"))
		{	*type = SOAP_TYPE_afip_ns3__Moneda;
			return soap_in_ns3__Moneda(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfMoneda"))
		{	*type = SOAP_TYPE_afip_ns3__ArrayOfMoneda;
			return soap_in_ns3__ArrayOfMoneda(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:MonedaResponse"))
		{	*type = SOAP_TYPE_afip_ns3__MonedaResponse;
			return soap_in_ns3__MonedaResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:TributoTipo"))
		{	*type = SOAP_TYPE_afip_ns3__TributoTipo;
			return soap_in_ns3__TributoTipo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfTributoTipo"))
		{	*type = SOAP_TYPE_afip_ns3__ArrayOfTributoTipo;
			return soap_in_ns3__ArrayOfTributoTipo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FETributoResponse"))
		{	*type = SOAP_TYPE_afip_ns3__FETributoResponse;
			return soap_in_ns3__FETributoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:Cotizacion"))
		{	*type = SOAP_TYPE_afip_ns3__Cotizacion;
			return soap_in_ns3__Cotizacion(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECotizacionResponse"))
		{	*type = SOAP_TYPE_afip_ns3__FECotizacionResponse;
			return soap_in_ns3__FECotizacionResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECAEASinMovResponse"))
		{	*type = SOAP_TYPE_afip_ns3__FECAEASinMovResponse;
			return soap_in_ns3__FECAEASinMovResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECAEASinMov"))
		{	*type = SOAP_TYPE_afip_ns3__FECAEASinMov;
			return soap_in_ns3__FECAEASinMov(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfFECAEASinMov"))
		{	*type = SOAP_TYPE_afip_ns3__ArrayOfFECAEASinMov;
			return soap_in_ns3__ArrayOfFECAEASinMov(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECAEASinMovConsResponse"))
		{	*type = SOAP_TYPE_afip_ns3__FECAEASinMovConsResponse;
			return soap_in_ns3__FECAEASinMovConsResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECAEAGet"))
		{	*type = SOAP_TYPE_afip_ns3__FECAEAGet;
			return soap_in_ns3__FECAEAGet(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECAEAGetResponse"))
		{	*type = SOAP_TYPE_afip_ns3__FECAEAGetResponse;
			return soap_in_ns3__FECAEAGetResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECAEADetResponse"))
		{	*type = SOAP_TYPE_afip_ns3__FECAEADetResponse;
			return soap_in_ns3__FECAEADetResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfFECAEADetResponse"))
		{	*type = SOAP_TYPE_afip_ns3__ArrayOfFECAEADetResponse;
			return soap_in_ns3__ArrayOfFECAEADetResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECAEACabResponse"))
		{	*type = SOAP_TYPE_afip_ns3__FECAEACabResponse;
			return soap_in_ns3__FECAEACabResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECAEAResponse"))
		{	*type = SOAP_TYPE_afip_ns3__FECAEAResponse;
			return soap_in_ns3__FECAEAResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECAEADetRequest"))
		{	*type = SOAP_TYPE_afip_ns3__FECAEADetRequest;
			return soap_in_ns3__FECAEADetRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfFECAEADetRequest"))
		{	*type = SOAP_TYPE_afip_ns3__ArrayOfFECAEADetRequest;
			return soap_in_ns3__ArrayOfFECAEADetRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECAEACabRequest"))
		{	*type = SOAP_TYPE_afip_ns3__FECAEACabRequest;
			return soap_in_ns3__FECAEACabRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECAEARequest"))
		{	*type = SOAP_TYPE_afip_ns3__FECAEARequest;
			return soap_in_ns3__FECAEARequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECompConsResponse"))
		{	*type = SOAP_TYPE_afip_ns3__FECompConsResponse;
			return soap_in_ns3__FECompConsResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECompConsultaResponse"))
		{	*type = SOAP_TYPE_afip_ns3__FECompConsultaResponse;
			return soap_in_ns3__FECompConsultaResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECompConsultaReq"))
		{	*type = SOAP_TYPE_afip_ns3__FECompConsultaReq;
			return soap_in_ns3__FECompConsultaReq(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FERecuperaLastCbteResponse"))
		{	*type = SOAP_TYPE_afip_ns3__FERecuperaLastCbteResponse;
			return soap_in_ns3__FERecuperaLastCbteResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:DummyResponse"))
		{	*type = SOAP_TYPE_afip_ns3__DummyResponse;
			return soap_in_ns3__DummyResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FERegXReqResponse"))
		{	*type = SOAP_TYPE_afip_ns3__FERegXReqResponse;
			return soap_in_ns3__FERegXReqResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:Err"))
		{	*type = SOAP_TYPE_afip_ns3__Err;
			return soap_in_ns3__Err(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfErr"))
		{	*type = SOAP_TYPE_afip_ns3__ArrayOfErr;
			return soap_in_ns3__ArrayOfErr(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:Evt"))
		{	*type = SOAP_TYPE_afip_ns3__Evt;
			return soap_in_ns3__Evt(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfEvt"))
		{	*type = SOAP_TYPE_afip_ns3__ArrayOfEvt;
			return soap_in_ns3__ArrayOfEvt(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:Obs"))
		{	*type = SOAP_TYPE_afip_ns3__Obs;
			return soap_in_ns3__Obs(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfObs"))
		{	*type = SOAP_TYPE_afip_ns3__ArrayOfObs;
			return soap_in_ns3__ArrayOfObs(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FEDetResponse"))
		{	*type = SOAP_TYPE_afip_ns3__FEDetResponse;
			return soap_in_ns3__FEDetResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECAEDetResponse"))
		{	*type = SOAP_TYPE_afip_ns3__FECAEDetResponse;
			return soap_in_ns3__FECAEDetResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfFECAEDetResponse"))
		{	*type = SOAP_TYPE_afip_ns3__ArrayOfFECAEDetResponse;
			return soap_in_ns3__ArrayOfFECAEDetResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECabResponse"))
		{	*type = SOAP_TYPE_afip_ns3__FECabResponse;
			return soap_in_ns3__FECabResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECAECabResponse"))
		{	*type = SOAP_TYPE_afip_ns3__FECAECabResponse;
			return soap_in_ns3__FECAECabResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECAEResponse"))
		{	*type = SOAP_TYPE_afip_ns3__FECAEResponse;
			return soap_in_ns3__FECAEResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:Comprador"))
		{	*type = SOAP_TYPE_afip_ns3__Comprador;
			return soap_in_ns3__Comprador(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfComprador"))
		{	*type = SOAP_TYPE_afip_ns3__ArrayOfComprador;
			return soap_in_ns3__ArrayOfComprador(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:Opcional"))
		{	*type = SOAP_TYPE_afip_ns3__Opcional;
			return soap_in_ns3__Opcional(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfOpcional"))
		{	*type = SOAP_TYPE_afip_ns3__ArrayOfOpcional;
			return soap_in_ns3__ArrayOfOpcional(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:AlicIva"))
		{	*type = SOAP_TYPE_afip_ns3__AlicIva;
			return soap_in_ns3__AlicIva(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfAlicIva"))
		{	*type = SOAP_TYPE_afip_ns3__ArrayOfAlicIva;
			return soap_in_ns3__ArrayOfAlicIva(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:Tributo"))
		{	*type = SOAP_TYPE_afip_ns3__Tributo;
			return soap_in_ns3__Tributo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfTributo"))
		{	*type = SOAP_TYPE_afip_ns3__ArrayOfTributo;
			return soap_in_ns3__ArrayOfTributo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CbteAsoc"))
		{	*type = SOAP_TYPE_afip_ns3__CbteAsoc;
			return soap_in_ns3__CbteAsoc(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfCbteAsoc"))
		{	*type = SOAP_TYPE_afip_ns3__ArrayOfCbteAsoc;
			return soap_in_ns3__ArrayOfCbteAsoc(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FEDetRequest"))
		{	*type = SOAP_TYPE_afip_ns3__FEDetRequest;
			return soap_in_ns3__FEDetRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECAEDetRequest"))
		{	*type = SOAP_TYPE_afip_ns3__FECAEDetRequest;
			return soap_in_ns3__FECAEDetRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfFECAEDetRequest"))
		{	*type = SOAP_TYPE_afip_ns3__ArrayOfFECAEDetRequest;
			return soap_in_ns3__ArrayOfFECAEDetRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECabRequest"))
		{	*type = SOAP_TYPE_afip_ns3__FECabRequest;
			return soap_in_ns3__FECabRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECAECabRequest"))
		{	*type = SOAP_TYPE_afip_ns3__FECAECabRequest;
			return soap_in_ns3__FECAECabRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECAERequest"))
		{	*type = SOAP_TYPE_afip_ns3__FECAERequest;
			return soap_in_ns3__FECAERequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FEAuthRequest"))
		{	*type = SOAP_TYPE_afip_ns3__FEAuthRequest;
			return soap_in_ns3__FEAuthRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:LoginFault"))
		{	*type = SOAP_TYPE_afip_ns2__LoginFault;
			return soap_in_ns2__LoginFault(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_afip_byte;
			return soap_in_byte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:short"))
		{	*type = SOAP_TYPE_afip_short;
			return soap_in_short(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_afip_int;
			return soap_in_int(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_afip_LONG64;
			return soap_in_LONG64(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_afip_double;
			return soap_in_double(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE_afip__QName;
			s = soap_in__QName(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_afip_string;
			s = soap_in_string(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns3:FEParamGetTiposPaisesResponse"))
		{	*type = SOAP_TYPE_afip__ns3__FEParamGetTiposPaisesResponse;
			return soap_in__ns3__FEParamGetTiposPaisesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FEParamGetTiposPaises"))
		{	*type = SOAP_TYPE_afip__ns3__FEParamGetTiposPaises;
			return soap_in__ns3__FEParamGetTiposPaises(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FEParamGetTiposDocResponse"))
		{	*type = SOAP_TYPE_afip__ns3__FEParamGetTiposDocResponse;
			return soap_in__ns3__FEParamGetTiposDocResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FEParamGetTiposDoc"))
		{	*type = SOAP_TYPE_afip__ns3__FEParamGetTiposDoc;
			return soap_in__ns3__FEParamGetTiposDoc(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FEParamGetTiposCbteResponse"))
		{	*type = SOAP_TYPE_afip__ns3__FEParamGetTiposCbteResponse;
			return soap_in__ns3__FEParamGetTiposCbteResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FEParamGetTiposCbte"))
		{	*type = SOAP_TYPE_afip__ns3__FEParamGetTiposCbte;
			return soap_in__ns3__FEParamGetTiposCbte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FEParamGetPtosVentaResponse"))
		{	*type = SOAP_TYPE_afip__ns3__FEParamGetPtosVentaResponse;
			return soap_in__ns3__FEParamGetPtosVentaResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FEParamGetPtosVenta"))
		{	*type = SOAP_TYPE_afip__ns3__FEParamGetPtosVenta;
			return soap_in__ns3__FEParamGetPtosVenta(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FEParamGetTiposConceptoResponse"))
		{	*type = SOAP_TYPE_afip__ns3__FEParamGetTiposConceptoResponse;
			return soap_in__ns3__FEParamGetTiposConceptoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FEParamGetTiposConcepto"))
		{	*type = SOAP_TYPE_afip__ns3__FEParamGetTiposConcepto;
			return soap_in__ns3__FEParamGetTiposConcepto(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FEParamGetTiposOpcionalResponse"))
		{	*type = SOAP_TYPE_afip__ns3__FEParamGetTiposOpcionalResponse;
			return soap_in__ns3__FEParamGetTiposOpcionalResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FEParamGetTiposOpcional"))
		{	*type = SOAP_TYPE_afip__ns3__FEParamGetTiposOpcional;
			return soap_in__ns3__FEParamGetTiposOpcional(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FEParamGetTiposIvaResponse"))
		{	*type = SOAP_TYPE_afip__ns3__FEParamGetTiposIvaResponse;
			return soap_in__ns3__FEParamGetTiposIvaResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FEParamGetTiposIva"))
		{	*type = SOAP_TYPE_afip__ns3__FEParamGetTiposIva;
			return soap_in__ns3__FEParamGetTiposIva(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FEParamGetTiposMonedasResponse"))
		{	*type = SOAP_TYPE_afip__ns3__FEParamGetTiposMonedasResponse;
			return soap_in__ns3__FEParamGetTiposMonedasResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FEParamGetTiposMonedas"))
		{	*type = SOAP_TYPE_afip__ns3__FEParamGetTiposMonedas;
			return soap_in__ns3__FEParamGetTiposMonedas(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FEParamGetTiposTributosResponse"))
		{	*type = SOAP_TYPE_afip__ns3__FEParamGetTiposTributosResponse;
			return soap_in__ns3__FEParamGetTiposTributosResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FEParamGetTiposTributos"))
		{	*type = SOAP_TYPE_afip__ns3__FEParamGetTiposTributos;
			return soap_in__ns3__FEParamGetTiposTributos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FEParamGetCotizacionResponse"))
		{	*type = SOAP_TYPE_afip__ns3__FEParamGetCotizacionResponse;
			return soap_in__ns3__FEParamGetCotizacionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FEParamGetCotizacion"))
		{	*type = SOAP_TYPE_afip__ns3__FEParamGetCotizacion;
			return soap_in__ns3__FEParamGetCotizacion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECAEAConsultarResponse"))
		{	*type = SOAP_TYPE_afip__ns3__FECAEAConsultarResponse;
			return soap_in__ns3__FECAEAConsultarResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECAEAConsultar"))
		{	*type = SOAP_TYPE_afip__ns3__FECAEAConsultar;
			return soap_in__ns3__FECAEAConsultar(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECAEASinMovimientoInformarResponse"))
		{	*type = SOAP_TYPE_afip__ns3__FECAEASinMovimientoInformarResponse;
			return soap_in__ns3__FECAEASinMovimientoInformarResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECAEASinMovimientoInformar"))
		{	*type = SOAP_TYPE_afip__ns3__FECAEASinMovimientoInformar;
			return soap_in__ns3__FECAEASinMovimientoInformar(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECAEASinMovimientoConsultarResponse"))
		{	*type = SOAP_TYPE_afip__ns3__FECAEASinMovimientoConsultarResponse;
			return soap_in__ns3__FECAEASinMovimientoConsultarResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECAEASinMovimientoConsultar"))
		{	*type = SOAP_TYPE_afip__ns3__FECAEASinMovimientoConsultar;
			return soap_in__ns3__FECAEASinMovimientoConsultar(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECAEASolicitarResponse"))
		{	*type = SOAP_TYPE_afip__ns3__FECAEASolicitarResponse;
			return soap_in__ns3__FECAEASolicitarResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECAEASolicitar"))
		{	*type = SOAP_TYPE_afip__ns3__FECAEASolicitar;
			return soap_in__ns3__FECAEASolicitar(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECAEARegInformativoResponse"))
		{	*type = SOAP_TYPE_afip__ns3__FECAEARegInformativoResponse;
			return soap_in__ns3__FECAEARegInformativoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECAEARegInformativo"))
		{	*type = SOAP_TYPE_afip__ns3__FECAEARegInformativo;
			return soap_in__ns3__FECAEARegInformativo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECompConsultarResponse"))
		{	*type = SOAP_TYPE_afip__ns3__FECompConsultarResponse;
			return soap_in__ns3__FECompConsultarResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECompConsultar"))
		{	*type = SOAP_TYPE_afip__ns3__FECompConsultar;
			return soap_in__ns3__FECompConsultar(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECompUltimoAutorizadoResponse"))
		{	*type = SOAP_TYPE_afip__ns3__FECompUltimoAutorizadoResponse;
			return soap_in__ns3__FECompUltimoAutorizadoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECompUltimoAutorizado"))
		{	*type = SOAP_TYPE_afip__ns3__FECompUltimoAutorizado;
			return soap_in__ns3__FECompUltimoAutorizado(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FEDummyResponse"))
		{	*type = SOAP_TYPE_afip__ns3__FEDummyResponse;
			return soap_in__ns3__FEDummyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FEDummy"))
		{	*type = SOAP_TYPE_afip__ns3__FEDummy;
			return soap_in__ns3__FEDummy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECompTotXRequestResponse"))
		{	*type = SOAP_TYPE_afip__ns3__FECompTotXRequestResponse;
			return soap_in__ns3__FECompTotXRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECompTotXRequest"))
		{	*type = SOAP_TYPE_afip__ns3__FECompTotXRequest;
			return soap_in__ns3__FECompTotXRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECAESolicitarResponse"))
		{	*type = SOAP_TYPE_afip__ns3__FECAESolicitarResponse;
			return soap_in__ns3__FECAESolicitarResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FECAESolicitar"))
		{	*type = SOAP_TYPE_afip__ns3__FECAESolicitar;
			return soap_in__ns3__FECAESolicitar(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:loginCmsResponse"))
		{	*type = SOAP_TYPE_afip__ns1__loginCmsResponse;
			return soap_in__ns1__loginCmsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:loginCms"))
		{	*type = SOAP_TYPE_afip__ns1__loginCms;
			return soap_in__ns1__loginCms(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && !soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, NULL, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_afip_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_afip_short:
		return soap_out_short(soap, tag, id, (const short *)ptr, "xsd:short");
	case SOAP_TYPE_afip_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_afip_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_afip_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_afip_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_afip__ns3__FEParamGetTiposPaisesResponse:
		return ((_ns3__FEParamGetTiposPaisesResponse *)ptr)->soap_out(soap, "ns3:FEParamGetTiposPaisesResponse", id, "");
	case SOAP_TYPE_afip__ns3__FEParamGetTiposPaises:
		return ((_ns3__FEParamGetTiposPaises *)ptr)->soap_out(soap, "ns3:FEParamGetTiposPaises", id, "");
	case SOAP_TYPE_afip__ns3__FEParamGetTiposDocResponse:
		return ((_ns3__FEParamGetTiposDocResponse *)ptr)->soap_out(soap, "ns3:FEParamGetTiposDocResponse", id, "");
	case SOAP_TYPE_afip__ns3__FEParamGetTiposDoc:
		return ((_ns3__FEParamGetTiposDoc *)ptr)->soap_out(soap, "ns3:FEParamGetTiposDoc", id, "");
	case SOAP_TYPE_afip__ns3__FEParamGetTiposCbteResponse:
		return ((_ns3__FEParamGetTiposCbteResponse *)ptr)->soap_out(soap, "ns3:FEParamGetTiposCbteResponse", id, "");
	case SOAP_TYPE_afip__ns3__FEParamGetTiposCbte:
		return ((_ns3__FEParamGetTiposCbte *)ptr)->soap_out(soap, "ns3:FEParamGetTiposCbte", id, "");
	case SOAP_TYPE_afip__ns3__FEParamGetPtosVentaResponse:
		return ((_ns3__FEParamGetPtosVentaResponse *)ptr)->soap_out(soap, "ns3:FEParamGetPtosVentaResponse", id, "");
	case SOAP_TYPE_afip__ns3__FEParamGetPtosVenta:
		return ((_ns3__FEParamGetPtosVenta *)ptr)->soap_out(soap, "ns3:FEParamGetPtosVenta", id, "");
	case SOAP_TYPE_afip__ns3__FEParamGetTiposConceptoResponse:
		return ((_ns3__FEParamGetTiposConceptoResponse *)ptr)->soap_out(soap, "ns3:FEParamGetTiposConceptoResponse", id, "");
	case SOAP_TYPE_afip__ns3__FEParamGetTiposConcepto:
		return ((_ns3__FEParamGetTiposConcepto *)ptr)->soap_out(soap, "ns3:FEParamGetTiposConcepto", id, "");
	case SOAP_TYPE_afip__ns3__FEParamGetTiposOpcionalResponse:
		return ((_ns3__FEParamGetTiposOpcionalResponse *)ptr)->soap_out(soap, "ns3:FEParamGetTiposOpcionalResponse", id, "");
	case SOAP_TYPE_afip__ns3__FEParamGetTiposOpcional:
		return ((_ns3__FEParamGetTiposOpcional *)ptr)->soap_out(soap, "ns3:FEParamGetTiposOpcional", id, "");
	case SOAP_TYPE_afip__ns3__FEParamGetTiposIvaResponse:
		return ((_ns3__FEParamGetTiposIvaResponse *)ptr)->soap_out(soap, "ns3:FEParamGetTiposIvaResponse", id, "");
	case SOAP_TYPE_afip__ns3__FEParamGetTiposIva:
		return ((_ns3__FEParamGetTiposIva *)ptr)->soap_out(soap, "ns3:FEParamGetTiposIva", id, "");
	case SOAP_TYPE_afip__ns3__FEParamGetTiposMonedasResponse:
		return ((_ns3__FEParamGetTiposMonedasResponse *)ptr)->soap_out(soap, "ns3:FEParamGetTiposMonedasResponse", id, "");
	case SOAP_TYPE_afip__ns3__FEParamGetTiposMonedas:
		return ((_ns3__FEParamGetTiposMonedas *)ptr)->soap_out(soap, "ns3:FEParamGetTiposMonedas", id, "");
	case SOAP_TYPE_afip__ns3__FEParamGetTiposTributosResponse:
		return ((_ns3__FEParamGetTiposTributosResponse *)ptr)->soap_out(soap, "ns3:FEParamGetTiposTributosResponse", id, "");
	case SOAP_TYPE_afip__ns3__FEParamGetTiposTributos:
		return ((_ns3__FEParamGetTiposTributos *)ptr)->soap_out(soap, "ns3:FEParamGetTiposTributos", id, "");
	case SOAP_TYPE_afip__ns3__FEParamGetCotizacionResponse:
		return ((_ns3__FEParamGetCotizacionResponse *)ptr)->soap_out(soap, "ns3:FEParamGetCotizacionResponse", id, "");
	case SOAP_TYPE_afip__ns3__FEParamGetCotizacion:
		return ((_ns3__FEParamGetCotizacion *)ptr)->soap_out(soap, "ns3:FEParamGetCotizacion", id, "");
	case SOAP_TYPE_afip__ns3__FECAEAConsultarResponse:
		return ((_ns3__FECAEAConsultarResponse *)ptr)->soap_out(soap, "ns3:FECAEAConsultarResponse", id, "");
	case SOAP_TYPE_afip__ns3__FECAEAConsultar:
		return ((_ns3__FECAEAConsultar *)ptr)->soap_out(soap, "ns3:FECAEAConsultar", id, "");
	case SOAP_TYPE_afip__ns3__FECAEASinMovimientoInformarResponse:
		return ((_ns3__FECAEASinMovimientoInformarResponse *)ptr)->soap_out(soap, "ns3:FECAEASinMovimientoInformarResponse", id, "");
	case SOAP_TYPE_afip__ns3__FECAEASinMovimientoInformar:
		return ((_ns3__FECAEASinMovimientoInformar *)ptr)->soap_out(soap, "ns3:FECAEASinMovimientoInformar", id, "");
	case SOAP_TYPE_afip__ns3__FECAEASinMovimientoConsultarResponse:
		return ((_ns3__FECAEASinMovimientoConsultarResponse *)ptr)->soap_out(soap, "ns3:FECAEASinMovimientoConsultarResponse", id, "");
	case SOAP_TYPE_afip__ns3__FECAEASinMovimientoConsultar:
		return ((_ns3__FECAEASinMovimientoConsultar *)ptr)->soap_out(soap, "ns3:FECAEASinMovimientoConsultar", id, "");
	case SOAP_TYPE_afip__ns3__FECAEASolicitarResponse:
		return ((_ns3__FECAEASolicitarResponse *)ptr)->soap_out(soap, "ns3:FECAEASolicitarResponse", id, "");
	case SOAP_TYPE_afip__ns3__FECAEASolicitar:
		return ((_ns3__FECAEASolicitar *)ptr)->soap_out(soap, "ns3:FECAEASolicitar", id, "");
	case SOAP_TYPE_afip__ns3__FECAEARegInformativoResponse:
		return ((_ns3__FECAEARegInformativoResponse *)ptr)->soap_out(soap, "ns3:FECAEARegInformativoResponse", id, "");
	case SOAP_TYPE_afip__ns3__FECAEARegInformativo:
		return ((_ns3__FECAEARegInformativo *)ptr)->soap_out(soap, "ns3:FECAEARegInformativo", id, "");
	case SOAP_TYPE_afip__ns3__FECompConsultarResponse:
		return ((_ns3__FECompConsultarResponse *)ptr)->soap_out(soap, "ns3:FECompConsultarResponse", id, "");
	case SOAP_TYPE_afip__ns3__FECompConsultar:
		return ((_ns3__FECompConsultar *)ptr)->soap_out(soap, "ns3:FECompConsultar", id, "");
	case SOAP_TYPE_afip__ns3__FECompUltimoAutorizadoResponse:
		return ((_ns3__FECompUltimoAutorizadoResponse *)ptr)->soap_out(soap, "ns3:FECompUltimoAutorizadoResponse", id, "");
	case SOAP_TYPE_afip__ns3__FECompUltimoAutorizado:
		return ((_ns3__FECompUltimoAutorizado *)ptr)->soap_out(soap, "ns3:FECompUltimoAutorizado", id, "");
	case SOAP_TYPE_afip__ns3__FEDummyResponse:
		return ((_ns3__FEDummyResponse *)ptr)->soap_out(soap, "ns3:FEDummyResponse", id, "");
	case SOAP_TYPE_afip__ns3__FEDummy:
		return ((_ns3__FEDummy *)ptr)->soap_out(soap, "ns3:FEDummy", id, "");
	case SOAP_TYPE_afip__ns3__FECompTotXRequestResponse:
		return ((_ns3__FECompTotXRequestResponse *)ptr)->soap_out(soap, "ns3:FECompTotXRequestResponse", id, "");
	case SOAP_TYPE_afip__ns3__FECompTotXRequest:
		return ((_ns3__FECompTotXRequest *)ptr)->soap_out(soap, "ns3:FECompTotXRequest", id, "");
	case SOAP_TYPE_afip__ns3__FECAESolicitarResponse:
		return ((_ns3__FECAESolicitarResponse *)ptr)->soap_out(soap, "ns3:FECAESolicitarResponse", id, "");
	case SOAP_TYPE_afip__ns3__FECAESolicitar:
		return ((_ns3__FECAESolicitar *)ptr)->soap_out(soap, "ns3:FECAESolicitar", id, "");
	case SOAP_TYPE_afip_ns3__PaisTipo:
		return ((ns3__PaisTipo *)ptr)->soap_out(soap, tag, id, "ns3:PaisTipo");
	case SOAP_TYPE_afip_ns3__ArrayOfPaisTipo:
		return ((ns3__ArrayOfPaisTipo *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfPaisTipo");
	case SOAP_TYPE_afip_ns3__FEPaisResponse:
		return ((ns3__FEPaisResponse *)ptr)->soap_out(soap, tag, id, "ns3:FEPaisResponse");
	case SOAP_TYPE_afip_ns3__DocTipo:
		return ((ns3__DocTipo *)ptr)->soap_out(soap, tag, id, "ns3:DocTipo");
	case SOAP_TYPE_afip_ns3__ArrayOfDocTipo:
		return ((ns3__ArrayOfDocTipo *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfDocTipo");
	case SOAP_TYPE_afip_ns3__DocTipoResponse:
		return ((ns3__DocTipoResponse *)ptr)->soap_out(soap, tag, id, "ns3:DocTipoResponse");
	case SOAP_TYPE_afip_ns3__CbteTipo:
		return ((ns3__CbteTipo *)ptr)->soap_out(soap, tag, id, "ns3:CbteTipo");
	case SOAP_TYPE_afip_ns3__ArrayOfCbteTipo:
		return ((ns3__ArrayOfCbteTipo *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfCbteTipo");
	case SOAP_TYPE_afip_ns3__CbteTipoResponse:
		return ((ns3__CbteTipoResponse *)ptr)->soap_out(soap, tag, id, "ns3:CbteTipoResponse");
	case SOAP_TYPE_afip_ns3__PtoVenta:
		return ((ns3__PtoVenta *)ptr)->soap_out(soap, tag, id, "ns3:PtoVenta");
	case SOAP_TYPE_afip_ns3__ArrayOfPtoVenta:
		return ((ns3__ArrayOfPtoVenta *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfPtoVenta");
	case SOAP_TYPE_afip_ns3__FEPtoVentaResponse:
		return ((ns3__FEPtoVentaResponse *)ptr)->soap_out(soap, tag, id, "ns3:FEPtoVentaResponse");
	case SOAP_TYPE_afip_ns3__ConceptoTipo:
		return ((ns3__ConceptoTipo *)ptr)->soap_out(soap, tag, id, "ns3:ConceptoTipo");
	case SOAP_TYPE_afip_ns3__ArrayOfConceptoTipo:
		return ((ns3__ArrayOfConceptoTipo *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfConceptoTipo");
	case SOAP_TYPE_afip_ns3__ConceptoTipoResponse:
		return ((ns3__ConceptoTipoResponse *)ptr)->soap_out(soap, tag, id, "ns3:ConceptoTipoResponse");
	case SOAP_TYPE_afip_ns3__OpcionalTipo:
		return ((ns3__OpcionalTipo *)ptr)->soap_out(soap, tag, id, "ns3:OpcionalTipo");
	case SOAP_TYPE_afip_ns3__ArrayOfOpcionalTipo:
		return ((ns3__ArrayOfOpcionalTipo *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfOpcionalTipo");
	case SOAP_TYPE_afip_ns3__OpcionalTipoResponse:
		return ((ns3__OpcionalTipoResponse *)ptr)->soap_out(soap, tag, id, "ns3:OpcionalTipoResponse");
	case SOAP_TYPE_afip_ns3__IvaTipo:
		return ((ns3__IvaTipo *)ptr)->soap_out(soap, tag, id, "ns3:IvaTipo");
	case SOAP_TYPE_afip_ns3__ArrayOfIvaTipo:
		return ((ns3__ArrayOfIvaTipo *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfIvaTipo");
	case SOAP_TYPE_afip_ns3__IvaTipoResponse:
		return ((ns3__IvaTipoResponse *)ptr)->soap_out(soap, tag, id, "ns3:IvaTipoResponse");
	case SOAP_TYPE_afip_ns3__Moneda:
		return ((ns3__Moneda *)ptr)->soap_out(soap, tag, id, "ns3:Moneda");
	case SOAP_TYPE_afip_ns3__ArrayOfMoneda:
		return ((ns3__ArrayOfMoneda *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfMoneda");
	case SOAP_TYPE_afip_ns3__MonedaResponse:
		return ((ns3__MonedaResponse *)ptr)->soap_out(soap, tag, id, "ns3:MonedaResponse");
	case SOAP_TYPE_afip_ns3__TributoTipo:
		return ((ns3__TributoTipo *)ptr)->soap_out(soap, tag, id, "ns3:TributoTipo");
	case SOAP_TYPE_afip_ns3__ArrayOfTributoTipo:
		return ((ns3__ArrayOfTributoTipo *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfTributoTipo");
	case SOAP_TYPE_afip_ns3__FETributoResponse:
		return ((ns3__FETributoResponse *)ptr)->soap_out(soap, tag, id, "ns3:FETributoResponse");
	case SOAP_TYPE_afip_ns3__Cotizacion:
		return ((ns3__Cotizacion *)ptr)->soap_out(soap, tag, id, "ns3:Cotizacion");
	case SOAP_TYPE_afip_ns3__FECotizacionResponse:
		return ((ns3__FECotizacionResponse *)ptr)->soap_out(soap, tag, id, "ns3:FECotizacionResponse");
	case SOAP_TYPE_afip_ns3__FECAEASinMovResponse:
		return ((ns3__FECAEASinMovResponse *)ptr)->soap_out(soap, tag, id, "ns3:FECAEASinMovResponse");
	case SOAP_TYPE_afip_ns3__FECAEASinMov:
		return ((ns3__FECAEASinMov *)ptr)->soap_out(soap, tag, id, "ns3:FECAEASinMov");
	case SOAP_TYPE_afip_ns3__ArrayOfFECAEASinMov:
		return ((ns3__ArrayOfFECAEASinMov *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfFECAEASinMov");
	case SOAP_TYPE_afip_ns3__FECAEASinMovConsResponse:
		return ((ns3__FECAEASinMovConsResponse *)ptr)->soap_out(soap, tag, id, "ns3:FECAEASinMovConsResponse");
	case SOAP_TYPE_afip_ns3__FECAEAGet:
		return ((ns3__FECAEAGet *)ptr)->soap_out(soap, tag, id, "ns3:FECAEAGet");
	case SOAP_TYPE_afip_ns3__FECAEAGetResponse:
		return ((ns3__FECAEAGetResponse *)ptr)->soap_out(soap, tag, id, "ns3:FECAEAGetResponse");
	case SOAP_TYPE_afip_ns3__FECAEADetResponse:
		return ((ns3__FECAEADetResponse *)ptr)->soap_out(soap, tag, id, "ns3:FECAEADetResponse");
	case SOAP_TYPE_afip_ns3__ArrayOfFECAEADetResponse:
		return ((ns3__ArrayOfFECAEADetResponse *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfFECAEADetResponse");
	case SOAP_TYPE_afip_ns3__FECAEACabResponse:
		return ((ns3__FECAEACabResponse *)ptr)->soap_out(soap, tag, id, "ns3:FECAEACabResponse");
	case SOAP_TYPE_afip_ns3__FECAEAResponse:
		return ((ns3__FECAEAResponse *)ptr)->soap_out(soap, tag, id, "ns3:FECAEAResponse");
	case SOAP_TYPE_afip_ns3__FECAEADetRequest:
		return ((ns3__FECAEADetRequest *)ptr)->soap_out(soap, tag, id, "ns3:FECAEADetRequest");
	case SOAP_TYPE_afip_ns3__ArrayOfFECAEADetRequest:
		return ((ns3__ArrayOfFECAEADetRequest *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfFECAEADetRequest");
	case SOAP_TYPE_afip_ns3__FECAEACabRequest:
		return ((ns3__FECAEACabRequest *)ptr)->soap_out(soap, tag, id, "ns3:FECAEACabRequest");
	case SOAP_TYPE_afip_ns3__FECAEARequest:
		return ((ns3__FECAEARequest *)ptr)->soap_out(soap, tag, id, "ns3:FECAEARequest");
	case SOAP_TYPE_afip_ns3__FECompConsResponse:
		return ((ns3__FECompConsResponse *)ptr)->soap_out(soap, tag, id, "ns3:FECompConsResponse");
	case SOAP_TYPE_afip_ns3__FECompConsultaResponse:
		return ((ns3__FECompConsultaResponse *)ptr)->soap_out(soap, tag, id, "ns3:FECompConsultaResponse");
	case SOAP_TYPE_afip_ns3__FECompConsultaReq:
		return ((ns3__FECompConsultaReq *)ptr)->soap_out(soap, tag, id, "ns3:FECompConsultaReq");
	case SOAP_TYPE_afip_ns3__FERecuperaLastCbteResponse:
		return ((ns3__FERecuperaLastCbteResponse *)ptr)->soap_out(soap, tag, id, "ns3:FERecuperaLastCbteResponse");
	case SOAP_TYPE_afip_ns3__DummyResponse:
		return ((ns3__DummyResponse *)ptr)->soap_out(soap, tag, id, "ns3:DummyResponse");
	case SOAP_TYPE_afip_ns3__FERegXReqResponse:
		return ((ns3__FERegXReqResponse *)ptr)->soap_out(soap, tag, id, "ns3:FERegXReqResponse");
	case SOAP_TYPE_afip_ns3__Err:
		return ((ns3__Err *)ptr)->soap_out(soap, tag, id, "ns3:Err");
	case SOAP_TYPE_afip_ns3__ArrayOfErr:
		return ((ns3__ArrayOfErr *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfErr");
	case SOAP_TYPE_afip_ns3__Evt:
		return ((ns3__Evt *)ptr)->soap_out(soap, tag, id, "ns3:Evt");
	case SOAP_TYPE_afip_ns3__ArrayOfEvt:
		return ((ns3__ArrayOfEvt *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfEvt");
	case SOAP_TYPE_afip_ns3__Obs:
		return ((ns3__Obs *)ptr)->soap_out(soap, tag, id, "ns3:Obs");
	case SOAP_TYPE_afip_ns3__ArrayOfObs:
		return ((ns3__ArrayOfObs *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfObs");
	case SOAP_TYPE_afip_ns3__FEDetResponse:
		return ((ns3__FEDetResponse *)ptr)->soap_out(soap, tag, id, "ns3:FEDetResponse");
	case SOAP_TYPE_afip_ns3__FECAEDetResponse:
		return ((ns3__FECAEDetResponse *)ptr)->soap_out(soap, tag, id, "ns3:FECAEDetResponse");
	case SOAP_TYPE_afip_ns3__ArrayOfFECAEDetResponse:
		return ((ns3__ArrayOfFECAEDetResponse *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfFECAEDetResponse");
	case SOAP_TYPE_afip_ns3__FECabResponse:
		return ((ns3__FECabResponse *)ptr)->soap_out(soap, tag, id, "ns3:FECabResponse");
	case SOAP_TYPE_afip_ns3__FECAECabResponse:
		return ((ns3__FECAECabResponse *)ptr)->soap_out(soap, tag, id, "ns3:FECAECabResponse");
	case SOAP_TYPE_afip_ns3__FECAEResponse:
		return ((ns3__FECAEResponse *)ptr)->soap_out(soap, tag, id, "ns3:FECAEResponse");
	case SOAP_TYPE_afip_ns3__Comprador:
		return ((ns3__Comprador *)ptr)->soap_out(soap, tag, id, "ns3:Comprador");
	case SOAP_TYPE_afip_ns3__ArrayOfComprador:
		return ((ns3__ArrayOfComprador *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfComprador");
	case SOAP_TYPE_afip_ns3__Opcional:
		return ((ns3__Opcional *)ptr)->soap_out(soap, tag, id, "ns3:Opcional");
	case SOAP_TYPE_afip_ns3__ArrayOfOpcional:
		return ((ns3__ArrayOfOpcional *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfOpcional");
	case SOAP_TYPE_afip_ns3__AlicIva:
		return ((ns3__AlicIva *)ptr)->soap_out(soap, tag, id, "ns3:AlicIva");
	case SOAP_TYPE_afip_ns3__ArrayOfAlicIva:
		return ((ns3__ArrayOfAlicIva *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfAlicIva");
	case SOAP_TYPE_afip_ns3__Tributo:
		return ((ns3__Tributo *)ptr)->soap_out(soap, tag, id, "ns3:Tributo");
	case SOAP_TYPE_afip_ns3__ArrayOfTributo:
		return ((ns3__ArrayOfTributo *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfTributo");
	case SOAP_TYPE_afip_ns3__CbteAsoc:
		return ((ns3__CbteAsoc *)ptr)->soap_out(soap, tag, id, "ns3:CbteAsoc");
	case SOAP_TYPE_afip_ns3__ArrayOfCbteAsoc:
		return ((ns3__ArrayOfCbteAsoc *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfCbteAsoc");
	case SOAP_TYPE_afip_ns3__FEDetRequest:
		return ((ns3__FEDetRequest *)ptr)->soap_out(soap, tag, id, "ns3:FEDetRequest");
	case SOAP_TYPE_afip_ns3__FECAEDetRequest:
		return ((ns3__FECAEDetRequest *)ptr)->soap_out(soap, tag, id, "ns3:FECAEDetRequest");
	case SOAP_TYPE_afip_ns3__ArrayOfFECAEDetRequest:
		return ((ns3__ArrayOfFECAEDetRequest *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfFECAEDetRequest");
	case SOAP_TYPE_afip_ns3__FECabRequest:
		return ((ns3__FECabRequest *)ptr)->soap_out(soap, tag, id, "ns3:FECabRequest");
	case SOAP_TYPE_afip_ns3__FECAECabRequest:
		return ((ns3__FECAECabRequest *)ptr)->soap_out(soap, tag, id, "ns3:FECAECabRequest");
	case SOAP_TYPE_afip_ns3__FECAERequest:
		return ((ns3__FECAERequest *)ptr)->soap_out(soap, tag, id, "ns3:FECAERequest");
	case SOAP_TYPE_afip_ns3__FEAuthRequest:
		return ((ns3__FEAuthRequest *)ptr)->soap_out(soap, tag, id, "ns3:FEAuthRequest");
	case SOAP_TYPE_afip_ns2__LoginFault:
		return ((ns2__LoginFault *)ptr)->soap_out(soap, tag, id, "ns2:LoginFault");
	case SOAP_TYPE_afip__ns1__loginCmsResponse:
		return ((_ns1__loginCmsResponse *)ptr)->soap_out(soap, "ns1:loginCmsResponse", id, "");
	case SOAP_TYPE_afip__ns1__loginCms:
		return ((_ns1__loginCms *)ptr)->soap_out(soap, "ns1:loginCms", id, "");
	case SOAP_TYPE_afip_PointerTo_ns3__FEParamGetTiposPaises:
		return soap_out_PointerTo_ns3__FEParamGetTiposPaises(soap, tag, id, (_ns3__FEParamGetTiposPaises *const*)ptr, "ns3:FEParamGetTiposPaises");
	case SOAP_TYPE_afip_PointerTo_ns3__FEParamGetTiposDoc:
		return soap_out_PointerTo_ns3__FEParamGetTiposDoc(soap, tag, id, (_ns3__FEParamGetTiposDoc *const*)ptr, "ns3:FEParamGetTiposDoc");
	case SOAP_TYPE_afip_PointerTo_ns3__FEParamGetTiposCbte:
		return soap_out_PointerTo_ns3__FEParamGetTiposCbte(soap, tag, id, (_ns3__FEParamGetTiposCbte *const*)ptr, "ns3:FEParamGetTiposCbte");
	case SOAP_TYPE_afip_PointerTo_ns3__FEParamGetPtosVenta:
		return soap_out_PointerTo_ns3__FEParamGetPtosVenta(soap, tag, id, (_ns3__FEParamGetPtosVenta *const*)ptr, "ns3:FEParamGetPtosVenta");
	case SOAP_TYPE_afip_PointerTo_ns3__FEParamGetTiposConcepto:
		return soap_out_PointerTo_ns3__FEParamGetTiposConcepto(soap, tag, id, (_ns3__FEParamGetTiposConcepto *const*)ptr, "ns3:FEParamGetTiposConcepto");
	case SOAP_TYPE_afip_PointerTo_ns3__FEParamGetTiposOpcional:
		return soap_out_PointerTo_ns3__FEParamGetTiposOpcional(soap, tag, id, (_ns3__FEParamGetTiposOpcional *const*)ptr, "ns3:FEParamGetTiposOpcional");
	case SOAP_TYPE_afip_PointerTo_ns3__FEParamGetTiposIva:
		return soap_out_PointerTo_ns3__FEParamGetTiposIva(soap, tag, id, (_ns3__FEParamGetTiposIva *const*)ptr, "ns3:FEParamGetTiposIva");
	case SOAP_TYPE_afip_PointerTo_ns3__FEParamGetTiposMonedas:
		return soap_out_PointerTo_ns3__FEParamGetTiposMonedas(soap, tag, id, (_ns3__FEParamGetTiposMonedas *const*)ptr, "ns3:FEParamGetTiposMonedas");
	case SOAP_TYPE_afip_PointerTo_ns3__FEParamGetTiposTributos:
		return soap_out_PointerTo_ns3__FEParamGetTiposTributos(soap, tag, id, (_ns3__FEParamGetTiposTributos *const*)ptr, "ns3:FEParamGetTiposTributos");
	case SOAP_TYPE_afip_PointerTo_ns3__FEParamGetCotizacion:
		return soap_out_PointerTo_ns3__FEParamGetCotizacion(soap, tag, id, (_ns3__FEParamGetCotizacion *const*)ptr, "ns3:FEParamGetCotizacion");
	case SOAP_TYPE_afip_PointerTo_ns3__FECAEAConsultar:
		return soap_out_PointerTo_ns3__FECAEAConsultar(soap, tag, id, (_ns3__FECAEAConsultar *const*)ptr, "ns3:FECAEAConsultar");
	case SOAP_TYPE_afip_PointerTo_ns3__FECAEASinMovimientoInformar:
		return soap_out_PointerTo_ns3__FECAEASinMovimientoInformar(soap, tag, id, (_ns3__FECAEASinMovimientoInformar *const*)ptr, "ns3:FECAEASinMovimientoInformar");
	case SOAP_TYPE_afip_PointerTo_ns3__FECAEASinMovimientoConsultar:
		return soap_out_PointerTo_ns3__FECAEASinMovimientoConsultar(soap, tag, id, (_ns3__FECAEASinMovimientoConsultar *const*)ptr, "ns3:FECAEASinMovimientoConsultar");
	case SOAP_TYPE_afip_PointerTo_ns3__FECAEASolicitar:
		return soap_out_PointerTo_ns3__FECAEASolicitar(soap, tag, id, (_ns3__FECAEASolicitar *const*)ptr, "ns3:FECAEASolicitar");
	case SOAP_TYPE_afip_PointerTo_ns3__FECAEARegInformativo:
		return soap_out_PointerTo_ns3__FECAEARegInformativo(soap, tag, id, (_ns3__FECAEARegInformativo *const*)ptr, "ns3:FECAEARegInformativo");
	case SOAP_TYPE_afip_PointerTo_ns3__FECompConsultar:
		return soap_out_PointerTo_ns3__FECompConsultar(soap, tag, id, (_ns3__FECompConsultar *const*)ptr, "ns3:FECompConsultar");
	case SOAP_TYPE_afip_PointerTo_ns3__FECompUltimoAutorizado:
		return soap_out_PointerTo_ns3__FECompUltimoAutorizado(soap, tag, id, (_ns3__FECompUltimoAutorizado *const*)ptr, "ns3:FECompUltimoAutorizado");
	case SOAP_TYPE_afip_PointerTo_ns3__FEDummy:
		return soap_out_PointerTo_ns3__FEDummy(soap, tag, id, (_ns3__FEDummy *const*)ptr, "ns3:FEDummy");
	case SOAP_TYPE_afip_PointerTo_ns3__FECompTotXRequest:
		return soap_out_PointerTo_ns3__FECompTotXRequest(soap, tag, id, (_ns3__FECompTotXRequest *const*)ptr, "ns3:FECompTotXRequest");
	case SOAP_TYPE_afip_PointerTo_ns3__FECAESolicitar:
		return soap_out_PointerTo_ns3__FECAESolicitar(soap, tag, id, (_ns3__FECAESolicitar *const*)ptr, "ns3:FECAESolicitar");
	case SOAP_TYPE_afip_PointerTo_ns1__loginCms:
		return soap_out_PointerTo_ns1__loginCms(soap, tag, id, (_ns1__loginCms *const*)ptr, "ns1:loginCms");
	case SOAP_TYPE_afip_PointerTons2__LoginFault:
		return soap_out_PointerTons2__LoginFault(soap, tag, id, (ns2__LoginFault *const*)ptr, "ns2:LoginFault");
	case SOAP_TYPE_afip_PointerTons3__FEPaisResponse:
		return soap_out_PointerTons3__FEPaisResponse(soap, tag, id, (ns3__FEPaisResponse *const*)ptr, "ns3:FEPaisResponse");
	case SOAP_TYPE_afip_PointerTons3__DocTipoResponse:
		return soap_out_PointerTons3__DocTipoResponse(soap, tag, id, (ns3__DocTipoResponse *const*)ptr, "ns3:DocTipoResponse");
	case SOAP_TYPE_afip_PointerTons3__CbteTipoResponse:
		return soap_out_PointerTons3__CbteTipoResponse(soap, tag, id, (ns3__CbteTipoResponse *const*)ptr, "ns3:CbteTipoResponse");
	case SOAP_TYPE_afip_PointerTons3__FEPtoVentaResponse:
		return soap_out_PointerTons3__FEPtoVentaResponse(soap, tag, id, (ns3__FEPtoVentaResponse *const*)ptr, "ns3:FEPtoVentaResponse");
	case SOAP_TYPE_afip_PointerTons3__ConceptoTipoResponse:
		return soap_out_PointerTons3__ConceptoTipoResponse(soap, tag, id, (ns3__ConceptoTipoResponse *const*)ptr, "ns3:ConceptoTipoResponse");
	case SOAP_TYPE_afip_PointerTons3__OpcionalTipoResponse:
		return soap_out_PointerTons3__OpcionalTipoResponse(soap, tag, id, (ns3__OpcionalTipoResponse *const*)ptr, "ns3:OpcionalTipoResponse");
	case SOAP_TYPE_afip_PointerTons3__IvaTipoResponse:
		return soap_out_PointerTons3__IvaTipoResponse(soap, tag, id, (ns3__IvaTipoResponse *const*)ptr, "ns3:IvaTipoResponse");
	case SOAP_TYPE_afip_PointerTons3__MonedaResponse:
		return soap_out_PointerTons3__MonedaResponse(soap, tag, id, (ns3__MonedaResponse *const*)ptr, "ns3:MonedaResponse");
	case SOAP_TYPE_afip_PointerTons3__FETributoResponse:
		return soap_out_PointerTons3__FETributoResponse(soap, tag, id, (ns3__FETributoResponse *const*)ptr, "ns3:FETributoResponse");
	case SOAP_TYPE_afip_PointerTons3__FECotizacionResponse:
		return soap_out_PointerTons3__FECotizacionResponse(soap, tag, id, (ns3__FECotizacionResponse *const*)ptr, "ns3:FECotizacionResponse");
	case SOAP_TYPE_afip_PointerTons3__FECAEASinMovResponse:
		return soap_out_PointerTons3__FECAEASinMovResponse(soap, tag, id, (ns3__FECAEASinMovResponse *const*)ptr, "ns3:FECAEASinMovResponse");
	case SOAP_TYPE_afip_PointerTons3__FECAEASinMovConsResponse:
		return soap_out_PointerTons3__FECAEASinMovConsResponse(soap, tag, id, (ns3__FECAEASinMovConsResponse *const*)ptr, "ns3:FECAEASinMovConsResponse");
	case SOAP_TYPE_afip_PointerTons3__FECAEAGetResponse:
		return soap_out_PointerTons3__FECAEAGetResponse(soap, tag, id, (ns3__FECAEAGetResponse *const*)ptr, "ns3:FECAEAGetResponse");
	case SOAP_TYPE_afip_PointerTons3__FECAEAResponse:
		return soap_out_PointerTons3__FECAEAResponse(soap, tag, id, (ns3__FECAEAResponse *const*)ptr, "ns3:FECAEAResponse");
	case SOAP_TYPE_afip_PointerTons3__FECAEARequest:
		return soap_out_PointerTons3__FECAEARequest(soap, tag, id, (ns3__FECAEARequest *const*)ptr, "ns3:FECAEARequest");
	case SOAP_TYPE_afip_PointerTons3__FECompConsultaResponse:
		return soap_out_PointerTons3__FECompConsultaResponse(soap, tag, id, (ns3__FECompConsultaResponse *const*)ptr, "ns3:FECompConsultaResponse");
	case SOAP_TYPE_afip_PointerTons3__FECompConsultaReq:
		return soap_out_PointerTons3__FECompConsultaReq(soap, tag, id, (ns3__FECompConsultaReq *const*)ptr, "ns3:FECompConsultaReq");
	case SOAP_TYPE_afip_PointerTons3__FERecuperaLastCbteResponse:
		return soap_out_PointerTons3__FERecuperaLastCbteResponse(soap, tag, id, (ns3__FERecuperaLastCbteResponse *const*)ptr, "ns3:FERecuperaLastCbteResponse");
	case SOAP_TYPE_afip_PointerTons3__DummyResponse:
		return soap_out_PointerTons3__DummyResponse(soap, tag, id, (ns3__DummyResponse *const*)ptr, "ns3:DummyResponse");
	case SOAP_TYPE_afip_PointerTons3__FERegXReqResponse:
		return soap_out_PointerTons3__FERegXReqResponse(soap, tag, id, (ns3__FERegXReqResponse *const*)ptr, "ns3:FERegXReqResponse");
	case SOAP_TYPE_afip_PointerTons3__FECAEResponse:
		return soap_out_PointerTons3__FECAEResponse(soap, tag, id, (ns3__FECAEResponse *const*)ptr, "ns3:FECAEResponse");
	case SOAP_TYPE_afip_PointerTons3__FECAERequest:
		return soap_out_PointerTons3__FECAERequest(soap, tag, id, (ns3__FECAERequest *const*)ptr, "ns3:FECAERequest");
	case SOAP_TYPE_afip_PointerTons3__FEAuthRequest:
		return soap_out_PointerTons3__FEAuthRequest(soap, tag, id, (ns3__FEAuthRequest *const*)ptr, "ns3:FEAuthRequest");
	case SOAP_TYPE_afip_PointerTons3__PaisTipo:
		return soap_out_PointerTons3__PaisTipo(soap, tag, id, (ns3__PaisTipo *const*)ptr, "ns3:PaisTipo");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfPaisTipo:
		return soap_out_PointerTons3__ArrayOfPaisTipo(soap, tag, id, (ns3__ArrayOfPaisTipo *const*)ptr, "ns3:ArrayOfPaisTipo");
	case SOAP_TYPE_afip_PointerTons3__DocTipo:
		return soap_out_PointerTons3__DocTipo(soap, tag, id, (ns3__DocTipo *const*)ptr, "ns3:DocTipo");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfDocTipo:
		return soap_out_PointerTons3__ArrayOfDocTipo(soap, tag, id, (ns3__ArrayOfDocTipo *const*)ptr, "ns3:ArrayOfDocTipo");
	case SOAP_TYPE_afip_PointerTons3__CbteTipo:
		return soap_out_PointerTons3__CbteTipo(soap, tag, id, (ns3__CbteTipo *const*)ptr, "ns3:CbteTipo");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfCbteTipo:
		return soap_out_PointerTons3__ArrayOfCbteTipo(soap, tag, id, (ns3__ArrayOfCbteTipo *const*)ptr, "ns3:ArrayOfCbteTipo");
	case SOAP_TYPE_afip_PointerTons3__PtoVenta:
		return soap_out_PointerTons3__PtoVenta(soap, tag, id, (ns3__PtoVenta *const*)ptr, "ns3:PtoVenta");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfPtoVenta:
		return soap_out_PointerTons3__ArrayOfPtoVenta(soap, tag, id, (ns3__ArrayOfPtoVenta *const*)ptr, "ns3:ArrayOfPtoVenta");
	case SOAP_TYPE_afip_PointerTons3__ConceptoTipo:
		return soap_out_PointerTons3__ConceptoTipo(soap, tag, id, (ns3__ConceptoTipo *const*)ptr, "ns3:ConceptoTipo");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfConceptoTipo:
		return soap_out_PointerTons3__ArrayOfConceptoTipo(soap, tag, id, (ns3__ArrayOfConceptoTipo *const*)ptr, "ns3:ArrayOfConceptoTipo");
	case SOAP_TYPE_afip_PointerTons3__OpcionalTipo:
		return soap_out_PointerTons3__OpcionalTipo(soap, tag, id, (ns3__OpcionalTipo *const*)ptr, "ns3:OpcionalTipo");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfOpcionalTipo:
		return soap_out_PointerTons3__ArrayOfOpcionalTipo(soap, tag, id, (ns3__ArrayOfOpcionalTipo *const*)ptr, "ns3:ArrayOfOpcionalTipo");
	case SOAP_TYPE_afip_PointerTons3__IvaTipo:
		return soap_out_PointerTons3__IvaTipo(soap, tag, id, (ns3__IvaTipo *const*)ptr, "ns3:IvaTipo");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfIvaTipo:
		return soap_out_PointerTons3__ArrayOfIvaTipo(soap, tag, id, (ns3__ArrayOfIvaTipo *const*)ptr, "ns3:ArrayOfIvaTipo");
	case SOAP_TYPE_afip_PointerTons3__Moneda:
		return soap_out_PointerTons3__Moneda(soap, tag, id, (ns3__Moneda *const*)ptr, "ns3:Moneda");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfMoneda:
		return soap_out_PointerTons3__ArrayOfMoneda(soap, tag, id, (ns3__ArrayOfMoneda *const*)ptr, "ns3:ArrayOfMoneda");
	case SOAP_TYPE_afip_PointerTons3__TributoTipo:
		return soap_out_PointerTons3__TributoTipo(soap, tag, id, (ns3__TributoTipo *const*)ptr, "ns3:TributoTipo");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfTributoTipo:
		return soap_out_PointerTons3__ArrayOfTributoTipo(soap, tag, id, (ns3__ArrayOfTributoTipo *const*)ptr, "ns3:ArrayOfTributoTipo");
	case SOAP_TYPE_afip_PointerTons3__Cotizacion:
		return soap_out_PointerTons3__Cotizacion(soap, tag, id, (ns3__Cotizacion *const*)ptr, "ns3:Cotizacion");
	case SOAP_TYPE_afip_PointerTons3__FECAEASinMov:
		return soap_out_PointerTons3__FECAEASinMov(soap, tag, id, (ns3__FECAEASinMov *const*)ptr, "ns3:FECAEASinMov");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfFECAEASinMov:
		return soap_out_PointerTons3__ArrayOfFECAEASinMov(soap, tag, id, (ns3__ArrayOfFECAEASinMov *const*)ptr, "ns3:ArrayOfFECAEASinMov");
	case SOAP_TYPE_afip_PointerTons3__FECAEAGet:
		return soap_out_PointerTons3__FECAEAGet(soap, tag, id, (ns3__FECAEAGet *const*)ptr, "ns3:FECAEAGet");
	case SOAP_TYPE_afip_PointerTons3__FECAEADetResponse:
		return soap_out_PointerTons3__FECAEADetResponse(soap, tag, id, (ns3__FECAEADetResponse *const*)ptr, "ns3:FECAEADetResponse");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfFECAEADetResponse:
		return soap_out_PointerTons3__ArrayOfFECAEADetResponse(soap, tag, id, (ns3__ArrayOfFECAEADetResponse *const*)ptr, "ns3:ArrayOfFECAEADetResponse");
	case SOAP_TYPE_afip_PointerTons3__FECAEACabResponse:
		return soap_out_PointerTons3__FECAEACabResponse(soap, tag, id, (ns3__FECAEACabResponse *const*)ptr, "ns3:FECAEACabResponse");
	case SOAP_TYPE_afip_PointerTons3__FECAEADetRequest:
		return soap_out_PointerTons3__FECAEADetRequest(soap, tag, id, (ns3__FECAEADetRequest *const*)ptr, "ns3:FECAEADetRequest");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfFECAEADetRequest:
		return soap_out_PointerTons3__ArrayOfFECAEADetRequest(soap, tag, id, (ns3__ArrayOfFECAEADetRequest *const*)ptr, "ns3:ArrayOfFECAEADetRequest");
	case SOAP_TYPE_afip_PointerTons3__FECAEACabRequest:
		return soap_out_PointerTons3__FECAEACabRequest(soap, tag, id, (ns3__FECAEACabRequest *const*)ptr, "ns3:FECAEACabRequest");
	case SOAP_TYPE_afip_PointerTons3__FECompConsResponse:
		return soap_out_PointerTons3__FECompConsResponse(soap, tag, id, (ns3__FECompConsResponse *const*)ptr, "ns3:FECompConsResponse");
	case SOAP_TYPE_afip_PointerTons3__Err:
		return soap_out_PointerTons3__Err(soap, tag, id, (ns3__Err *const*)ptr, "ns3:Err");
	case SOAP_TYPE_afip_PointerTons3__Evt:
		return soap_out_PointerTons3__Evt(soap, tag, id, (ns3__Evt *const*)ptr, "ns3:Evt");
	case SOAP_TYPE_afip_PointerTons3__Obs:
		return soap_out_PointerTons3__Obs(soap, tag, id, (ns3__Obs *const*)ptr, "ns3:Obs");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfObs:
		return soap_out_PointerTons3__ArrayOfObs(soap, tag, id, (ns3__ArrayOfObs *const*)ptr, "ns3:ArrayOfObs");
	case SOAP_TYPE_afip_PointerTons3__FECAEDetResponse:
		return soap_out_PointerTons3__FECAEDetResponse(soap, tag, id, (ns3__FECAEDetResponse *const*)ptr, "ns3:FECAEDetResponse");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfErr:
		return soap_out_PointerTons3__ArrayOfErr(soap, tag, id, (ns3__ArrayOfErr *const*)ptr, "ns3:ArrayOfErr");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfEvt:
		return soap_out_PointerTons3__ArrayOfEvt(soap, tag, id, (ns3__ArrayOfEvt *const*)ptr, "ns3:ArrayOfEvt");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfFECAEDetResponse:
		return soap_out_PointerTons3__ArrayOfFECAEDetResponse(soap, tag, id, (ns3__ArrayOfFECAEDetResponse *const*)ptr, "ns3:ArrayOfFECAEDetResponse");
	case SOAP_TYPE_afip_PointerTons3__FECAECabResponse:
		return soap_out_PointerTons3__FECAECabResponse(soap, tag, id, (ns3__FECAECabResponse *const*)ptr, "ns3:FECAECabResponse");
	case SOAP_TYPE_afip_PointerTons3__Comprador:
		return soap_out_PointerTons3__Comprador(soap, tag, id, (ns3__Comprador *const*)ptr, "ns3:Comprador");
	case SOAP_TYPE_afip_PointerTons3__Opcional:
		return soap_out_PointerTons3__Opcional(soap, tag, id, (ns3__Opcional *const*)ptr, "ns3:Opcional");
	case SOAP_TYPE_afip_PointerTons3__AlicIva:
		return soap_out_PointerTons3__AlicIva(soap, tag, id, (ns3__AlicIva *const*)ptr, "ns3:AlicIva");
	case SOAP_TYPE_afip_PointerTons3__Tributo:
		return soap_out_PointerTons3__Tributo(soap, tag, id, (ns3__Tributo *const*)ptr, "ns3:Tributo");
	case SOAP_TYPE_afip_PointerTons3__CbteAsoc:
		return soap_out_PointerTons3__CbteAsoc(soap, tag, id, (ns3__CbteAsoc *const*)ptr, "ns3:CbteAsoc");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfComprador:
		return soap_out_PointerTons3__ArrayOfComprador(soap, tag, id, (ns3__ArrayOfComprador *const*)ptr, "ns3:ArrayOfComprador");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfOpcional:
		return soap_out_PointerTons3__ArrayOfOpcional(soap, tag, id, (ns3__ArrayOfOpcional *const*)ptr, "ns3:ArrayOfOpcional");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfAlicIva:
		return soap_out_PointerTons3__ArrayOfAlicIva(soap, tag, id, (ns3__ArrayOfAlicIva *const*)ptr, "ns3:ArrayOfAlicIva");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfTributo:
		return soap_out_PointerTons3__ArrayOfTributo(soap, tag, id, (ns3__ArrayOfTributo *const*)ptr, "ns3:ArrayOfTributo");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfCbteAsoc:
		return soap_out_PointerTons3__ArrayOfCbteAsoc(soap, tag, id, (ns3__ArrayOfCbteAsoc *const*)ptr, "ns3:ArrayOfCbteAsoc");
	case SOAP_TYPE_afip_PointerTons3__FECAEDetRequest:
		return soap_out_PointerTons3__FECAEDetRequest(soap, tag, id, (ns3__FECAEDetRequest *const*)ptr, "ns3:FECAEDetRequest");
	case SOAP_TYPE_afip_PointerTons3__ArrayOfFECAEDetRequest:
		return soap_out_PointerTons3__ArrayOfFECAEDetRequest(soap, tag, id, (ns3__ArrayOfFECAEDetRequest *const*)ptr, "ns3:ArrayOfFECAEDetRequest");
	case SOAP_TYPE_afip_PointerTons3__FECAECabRequest:
		return soap_out_PointerTons3__FECAECabRequest(soap, tag, id, (ns3__FECAECabRequest *const*)ptr, "ns3:FECAECabRequest");
	case SOAP_TYPE_afip_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_afip__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_afip_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case 0:
		return SOAP_OK;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in AFIPServer/soap/afipC.cpp\n", tag ? tag : "", type));
	return soap_element_empty(soap, tag); /* unknown type to serialize */
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_afip_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposPaisesResponse:
		((_ns3__FEParamGetTiposPaisesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposPaises:
		((_ns3__FEParamGetTiposPaises *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposDocResponse:
		((_ns3__FEParamGetTiposDocResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposDoc:
		((_ns3__FEParamGetTiposDoc *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposCbteResponse:
		((_ns3__FEParamGetTiposCbteResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposCbte:
		((_ns3__FEParamGetTiposCbte *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetPtosVentaResponse:
		((_ns3__FEParamGetPtosVentaResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetPtosVenta:
		((_ns3__FEParamGetPtosVenta *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposConceptoResponse:
		((_ns3__FEParamGetTiposConceptoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposConcepto:
		((_ns3__FEParamGetTiposConcepto *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposOpcionalResponse:
		((_ns3__FEParamGetTiposOpcionalResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposOpcional:
		((_ns3__FEParamGetTiposOpcional *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposIvaResponse:
		((_ns3__FEParamGetTiposIvaResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposIva:
		((_ns3__FEParamGetTiposIva *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposMonedasResponse:
		((_ns3__FEParamGetTiposMonedasResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposMonedas:
		((_ns3__FEParamGetTiposMonedas *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposTributosResponse:
		((_ns3__FEParamGetTiposTributosResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposTributos:
		((_ns3__FEParamGetTiposTributos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetCotizacionResponse:
		((_ns3__FEParamGetCotizacionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetCotizacion:
		((_ns3__FEParamGetCotizacion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FECAEAConsultarResponse:
		((_ns3__FECAEAConsultarResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FECAEAConsultar:
		((_ns3__FECAEAConsultar *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FECAEASinMovimientoInformarResponse:
		((_ns3__FECAEASinMovimientoInformarResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FECAEASinMovimientoInformar:
		((_ns3__FECAEASinMovimientoInformar *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FECAEASinMovimientoConsultarResponse:
		((_ns3__FECAEASinMovimientoConsultarResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FECAEASinMovimientoConsultar:
		((_ns3__FECAEASinMovimientoConsultar *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FECAEASolicitarResponse:
		((_ns3__FECAEASolicitarResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FECAEASolicitar:
		((_ns3__FECAEASolicitar *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FECAEARegInformativoResponse:
		((_ns3__FECAEARegInformativoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FECAEARegInformativo:
		((_ns3__FECAEARegInformativo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FECompConsultarResponse:
		((_ns3__FECompConsultarResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FECompConsultar:
		((_ns3__FECompConsultar *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FECompUltimoAutorizadoResponse:
		((_ns3__FECompUltimoAutorizadoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FECompUltimoAutorizado:
		((_ns3__FECompUltimoAutorizado *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FEDummyResponse:
		((_ns3__FEDummyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FEDummy:
		((_ns3__FEDummy *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FECompTotXRequestResponse:
		((_ns3__FECompTotXRequestResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FECompTotXRequest:
		((_ns3__FECompTotXRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FECAESolicitarResponse:
		((_ns3__FECAESolicitarResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns3__FECAESolicitar:
		((_ns3__FECAESolicitar *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__PaisTipo:
		((ns3__PaisTipo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfPaisTipo:
		((ns3__ArrayOfPaisTipo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__FEPaisResponse:
		((ns3__FEPaisResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__DocTipo:
		((ns3__DocTipo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfDocTipo:
		((ns3__ArrayOfDocTipo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__DocTipoResponse:
		((ns3__DocTipoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__CbteTipo:
		((ns3__CbteTipo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfCbteTipo:
		((ns3__ArrayOfCbteTipo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__CbteTipoResponse:
		((ns3__CbteTipoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__PtoVenta:
		((ns3__PtoVenta *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfPtoVenta:
		((ns3__ArrayOfPtoVenta *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__FEPtoVentaResponse:
		((ns3__FEPtoVentaResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__ConceptoTipo:
		((ns3__ConceptoTipo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfConceptoTipo:
		((ns3__ArrayOfConceptoTipo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__ConceptoTipoResponse:
		((ns3__ConceptoTipoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__OpcionalTipo:
		((ns3__OpcionalTipo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfOpcionalTipo:
		((ns3__ArrayOfOpcionalTipo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__OpcionalTipoResponse:
		((ns3__OpcionalTipoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__IvaTipo:
		((ns3__IvaTipo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfIvaTipo:
		((ns3__ArrayOfIvaTipo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__IvaTipoResponse:
		((ns3__IvaTipoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__Moneda:
		((ns3__Moneda *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfMoneda:
		((ns3__ArrayOfMoneda *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__MonedaResponse:
		((ns3__MonedaResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__TributoTipo:
		((ns3__TributoTipo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfTributoTipo:
		((ns3__ArrayOfTributoTipo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__FETributoResponse:
		((ns3__FETributoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__Cotizacion:
		((ns3__Cotizacion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__FECotizacionResponse:
		((ns3__FECotizacionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__FECAEASinMovResponse:
		((ns3__FECAEASinMovResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__FECAEASinMov:
		((ns3__FECAEASinMov *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfFECAEASinMov:
		((ns3__ArrayOfFECAEASinMov *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__FECAEASinMovConsResponse:
		((ns3__FECAEASinMovConsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__FECAEAGet:
		((ns3__FECAEAGet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__FECAEAGetResponse:
		((ns3__FECAEAGetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__FECAEADetResponse:
		((ns3__FECAEADetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfFECAEADetResponse:
		((ns3__ArrayOfFECAEADetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__FECAEACabResponse:
		((ns3__FECAEACabResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__FECAEAResponse:
		((ns3__FECAEAResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__FECAEADetRequest:
		((ns3__FECAEADetRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfFECAEADetRequest:
		((ns3__ArrayOfFECAEADetRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__FECAEACabRequest:
		((ns3__FECAEACabRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__FECAEARequest:
		((ns3__FECAEARequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__FECompConsResponse:
		((ns3__FECompConsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__FECompConsultaResponse:
		((ns3__FECompConsultaResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__FECompConsultaReq:
		((ns3__FECompConsultaReq *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__FERecuperaLastCbteResponse:
		((ns3__FERecuperaLastCbteResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__DummyResponse:
		((ns3__DummyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__FERegXReqResponse:
		((ns3__FERegXReqResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__Err:
		((ns3__Err *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfErr:
		((ns3__ArrayOfErr *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__Evt:
		((ns3__Evt *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfEvt:
		((ns3__ArrayOfEvt *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__Obs:
		((ns3__Obs *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfObs:
		((ns3__ArrayOfObs *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__FEDetResponse:
		((ns3__FEDetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__FECAEDetResponse:
		((ns3__FECAEDetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfFECAEDetResponse:
		((ns3__ArrayOfFECAEDetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__FECabResponse:
		((ns3__FECabResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__FECAECabResponse:
		((ns3__FECAECabResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__FECAEResponse:
		((ns3__FECAEResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__Comprador:
		((ns3__Comprador *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfComprador:
		((ns3__ArrayOfComprador *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__Opcional:
		((ns3__Opcional *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfOpcional:
		((ns3__ArrayOfOpcional *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__AlicIva:
		((ns3__AlicIva *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfAlicIva:
		((ns3__ArrayOfAlicIva *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__Tributo:
		((ns3__Tributo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfTributo:
		((ns3__ArrayOfTributo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__CbteAsoc:
		((ns3__CbteAsoc *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfCbteAsoc:
		((ns3__ArrayOfCbteAsoc *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__FEDetRequest:
		((ns3__FEDetRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__FECAEDetRequest:
		((ns3__FECAEDetRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfFECAEDetRequest:
		((ns3__ArrayOfFECAEDetRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__FECabRequest:
		((ns3__FECabRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__FECAECabRequest:
		((ns3__FECAECabRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__FECAERequest:
		((ns3__FECAERequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns3__FEAuthRequest:
		((ns3__FEAuthRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip_ns2__LoginFault:
		((ns2__LoginFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns1__loginCmsResponse:
		((_ns1__loginCmsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip__ns1__loginCms:
		((_ns1__loginCms *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposPaises_:
		soap_serialize___ns3__FEParamGetTiposPaises_(soap, (const struct __ns3__FEParamGetTiposPaises_ *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposDoc_:
		soap_serialize___ns3__FEParamGetTiposDoc_(soap, (const struct __ns3__FEParamGetTiposDoc_ *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposCbte_:
		soap_serialize___ns3__FEParamGetTiposCbte_(soap, (const struct __ns3__FEParamGetTiposCbte_ *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetPtosVenta_:
		soap_serialize___ns3__FEParamGetPtosVenta_(soap, (const struct __ns3__FEParamGetPtosVenta_ *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposConcepto_:
		soap_serialize___ns3__FEParamGetTiposConcepto_(soap, (const struct __ns3__FEParamGetTiposConcepto_ *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposOpcional_:
		soap_serialize___ns3__FEParamGetTiposOpcional_(soap, (const struct __ns3__FEParamGetTiposOpcional_ *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposIva_:
		soap_serialize___ns3__FEParamGetTiposIva_(soap, (const struct __ns3__FEParamGetTiposIva_ *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposMonedas_:
		soap_serialize___ns3__FEParamGetTiposMonedas_(soap, (const struct __ns3__FEParamGetTiposMonedas_ *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposTributos_:
		soap_serialize___ns3__FEParamGetTiposTributos_(soap, (const struct __ns3__FEParamGetTiposTributos_ *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetCotizacion_:
		soap_serialize___ns3__FEParamGetCotizacion_(soap, (const struct __ns3__FEParamGetCotizacion_ *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FECAEAConsultar_:
		soap_serialize___ns3__FECAEAConsultar_(soap, (const struct __ns3__FECAEAConsultar_ *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FECAEASinMovimientoInformar_:
		soap_serialize___ns3__FECAEASinMovimientoInformar_(soap, (const struct __ns3__FECAEASinMovimientoInformar_ *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FECAEASinMovimientoConsultar_:
		soap_serialize___ns3__FECAEASinMovimientoConsultar_(soap, (const struct __ns3__FECAEASinMovimientoConsultar_ *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FECAEASolicitar_:
		soap_serialize___ns3__FECAEASolicitar_(soap, (const struct __ns3__FECAEASolicitar_ *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FECAEARegInformativo_:
		soap_serialize___ns3__FECAEARegInformativo_(soap, (const struct __ns3__FECAEARegInformativo_ *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FECompConsultar_:
		soap_serialize___ns3__FECompConsultar_(soap, (const struct __ns3__FECompConsultar_ *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FECompUltimoAutorizado_:
		soap_serialize___ns3__FECompUltimoAutorizado_(soap, (const struct __ns3__FECompUltimoAutorizado_ *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FEDummy_:
		soap_serialize___ns3__FEDummy_(soap, (const struct __ns3__FEDummy_ *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FECompTotXRequest_:
		soap_serialize___ns3__FECompTotXRequest_(soap, (const struct __ns3__FECompTotXRequest_ *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FECAESolicitar_:
		soap_serialize___ns3__FECAESolicitar_(soap, (const struct __ns3__FECAESolicitar_ *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposPaises:
		soap_serialize___ns3__FEParamGetTiposPaises(soap, (const struct __ns3__FEParamGetTiposPaises *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposDoc:
		soap_serialize___ns3__FEParamGetTiposDoc(soap, (const struct __ns3__FEParamGetTiposDoc *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposCbte:
		soap_serialize___ns3__FEParamGetTiposCbte(soap, (const struct __ns3__FEParamGetTiposCbte *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetPtosVenta:
		soap_serialize___ns3__FEParamGetPtosVenta(soap, (const struct __ns3__FEParamGetPtosVenta *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposConcepto:
		soap_serialize___ns3__FEParamGetTiposConcepto(soap, (const struct __ns3__FEParamGetTiposConcepto *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposOpcional:
		soap_serialize___ns3__FEParamGetTiposOpcional(soap, (const struct __ns3__FEParamGetTiposOpcional *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposIva:
		soap_serialize___ns3__FEParamGetTiposIva(soap, (const struct __ns3__FEParamGetTiposIva *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposMonedas:
		soap_serialize___ns3__FEParamGetTiposMonedas(soap, (const struct __ns3__FEParamGetTiposMonedas *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposTributos:
		soap_serialize___ns3__FEParamGetTiposTributos(soap, (const struct __ns3__FEParamGetTiposTributos *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetCotizacion:
		soap_serialize___ns3__FEParamGetCotizacion(soap, (const struct __ns3__FEParamGetCotizacion *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FECAEAConsultar:
		soap_serialize___ns3__FECAEAConsultar(soap, (const struct __ns3__FECAEAConsultar *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FECAEASinMovimientoInformar:
		soap_serialize___ns3__FECAEASinMovimientoInformar(soap, (const struct __ns3__FECAEASinMovimientoInformar *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FECAEASinMovimientoConsultar:
		soap_serialize___ns3__FECAEASinMovimientoConsultar(soap, (const struct __ns3__FECAEASinMovimientoConsultar *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FECAEASolicitar:
		soap_serialize___ns3__FECAEASolicitar(soap, (const struct __ns3__FECAEASolicitar *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FECAEARegInformativo:
		soap_serialize___ns3__FECAEARegInformativo(soap, (const struct __ns3__FECAEARegInformativo *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FECompConsultar:
		soap_serialize___ns3__FECompConsultar(soap, (const struct __ns3__FECompConsultar *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FECompUltimoAutorizado:
		soap_serialize___ns3__FECompUltimoAutorizado(soap, (const struct __ns3__FECompUltimoAutorizado *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FEDummy:
		soap_serialize___ns3__FEDummy(soap, (const struct __ns3__FEDummy *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FECompTotXRequest:
		soap_serialize___ns3__FECompTotXRequest(soap, (const struct __ns3__FECompTotXRequest *)ptr);
		break;
	case SOAP_TYPE_afip___ns3__FECAESolicitar:
		soap_serialize___ns3__FECAESolicitar(soap, (const struct __ns3__FECAESolicitar *)ptr);
		break;
	case SOAP_TYPE_afip___ns2__loginCms:
		soap_serialize___ns2__loginCms(soap, (const struct __ns2__loginCms *)ptr);
		break;
	case SOAP_TYPE_afip_PointerTo_ns3__FEParamGetTiposPaises:
		soap_serialize_PointerTo_ns3__FEParamGetTiposPaises(soap, (_ns3__FEParamGetTiposPaises *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTo_ns3__FEParamGetTiposDoc:
		soap_serialize_PointerTo_ns3__FEParamGetTiposDoc(soap, (_ns3__FEParamGetTiposDoc *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTo_ns3__FEParamGetTiposCbte:
		soap_serialize_PointerTo_ns3__FEParamGetTiposCbte(soap, (_ns3__FEParamGetTiposCbte *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTo_ns3__FEParamGetPtosVenta:
		soap_serialize_PointerTo_ns3__FEParamGetPtosVenta(soap, (_ns3__FEParamGetPtosVenta *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTo_ns3__FEParamGetTiposConcepto:
		soap_serialize_PointerTo_ns3__FEParamGetTiposConcepto(soap, (_ns3__FEParamGetTiposConcepto *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTo_ns3__FEParamGetTiposOpcional:
		soap_serialize_PointerTo_ns3__FEParamGetTiposOpcional(soap, (_ns3__FEParamGetTiposOpcional *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTo_ns3__FEParamGetTiposIva:
		soap_serialize_PointerTo_ns3__FEParamGetTiposIva(soap, (_ns3__FEParamGetTiposIva *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTo_ns3__FEParamGetTiposMonedas:
		soap_serialize_PointerTo_ns3__FEParamGetTiposMonedas(soap, (_ns3__FEParamGetTiposMonedas *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTo_ns3__FEParamGetTiposTributos:
		soap_serialize_PointerTo_ns3__FEParamGetTiposTributos(soap, (_ns3__FEParamGetTiposTributos *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTo_ns3__FEParamGetCotizacion:
		soap_serialize_PointerTo_ns3__FEParamGetCotizacion(soap, (_ns3__FEParamGetCotizacion *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTo_ns3__FECAEAConsultar:
		soap_serialize_PointerTo_ns3__FECAEAConsultar(soap, (_ns3__FECAEAConsultar *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTo_ns3__FECAEASinMovimientoInformar:
		soap_serialize_PointerTo_ns3__FECAEASinMovimientoInformar(soap, (_ns3__FECAEASinMovimientoInformar *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTo_ns3__FECAEASinMovimientoConsultar:
		soap_serialize_PointerTo_ns3__FECAEASinMovimientoConsultar(soap, (_ns3__FECAEASinMovimientoConsultar *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTo_ns3__FECAEASolicitar:
		soap_serialize_PointerTo_ns3__FECAEASolicitar(soap, (_ns3__FECAEASolicitar *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTo_ns3__FECAEARegInformativo:
		soap_serialize_PointerTo_ns3__FECAEARegInformativo(soap, (_ns3__FECAEARegInformativo *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTo_ns3__FECompConsultar:
		soap_serialize_PointerTo_ns3__FECompConsultar(soap, (_ns3__FECompConsultar *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTo_ns3__FECompUltimoAutorizado:
		soap_serialize_PointerTo_ns3__FECompUltimoAutorizado(soap, (_ns3__FECompUltimoAutorizado *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTo_ns3__FEDummy:
		soap_serialize_PointerTo_ns3__FEDummy(soap, (_ns3__FEDummy *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTo_ns3__FECompTotXRequest:
		soap_serialize_PointerTo_ns3__FECompTotXRequest(soap, (_ns3__FECompTotXRequest *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTo_ns3__FECAESolicitar:
		soap_serialize_PointerTo_ns3__FECAESolicitar(soap, (_ns3__FECAESolicitar *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTo_ns1__loginCms:
		soap_serialize_PointerTo_ns1__loginCms(soap, (_ns1__loginCms *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons2__LoginFault:
		soap_serialize_PointerTons2__LoginFault(soap, (ns2__LoginFault *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__FEPaisResponse:
		soap_serialize_PointerTons3__FEPaisResponse(soap, (ns3__FEPaisResponse *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__DocTipoResponse:
		soap_serialize_PointerTons3__DocTipoResponse(soap, (ns3__DocTipoResponse *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__CbteTipoResponse:
		soap_serialize_PointerTons3__CbteTipoResponse(soap, (ns3__CbteTipoResponse *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__FEPtoVentaResponse:
		soap_serialize_PointerTons3__FEPtoVentaResponse(soap, (ns3__FEPtoVentaResponse *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__ConceptoTipoResponse:
		soap_serialize_PointerTons3__ConceptoTipoResponse(soap, (ns3__ConceptoTipoResponse *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__OpcionalTipoResponse:
		soap_serialize_PointerTons3__OpcionalTipoResponse(soap, (ns3__OpcionalTipoResponse *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__IvaTipoResponse:
		soap_serialize_PointerTons3__IvaTipoResponse(soap, (ns3__IvaTipoResponse *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__MonedaResponse:
		soap_serialize_PointerTons3__MonedaResponse(soap, (ns3__MonedaResponse *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__FETributoResponse:
		soap_serialize_PointerTons3__FETributoResponse(soap, (ns3__FETributoResponse *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__FECotizacionResponse:
		soap_serialize_PointerTons3__FECotizacionResponse(soap, (ns3__FECotizacionResponse *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__FECAEASinMovResponse:
		soap_serialize_PointerTons3__FECAEASinMovResponse(soap, (ns3__FECAEASinMovResponse *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__FECAEASinMovConsResponse:
		soap_serialize_PointerTons3__FECAEASinMovConsResponse(soap, (ns3__FECAEASinMovConsResponse *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__FECAEAGetResponse:
		soap_serialize_PointerTons3__FECAEAGetResponse(soap, (ns3__FECAEAGetResponse *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__FECAEAResponse:
		soap_serialize_PointerTons3__FECAEAResponse(soap, (ns3__FECAEAResponse *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__FECAEARequest:
		soap_serialize_PointerTons3__FECAEARequest(soap, (ns3__FECAEARequest *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__FECompConsultaResponse:
		soap_serialize_PointerTons3__FECompConsultaResponse(soap, (ns3__FECompConsultaResponse *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__FECompConsultaReq:
		soap_serialize_PointerTons3__FECompConsultaReq(soap, (ns3__FECompConsultaReq *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__FERecuperaLastCbteResponse:
		soap_serialize_PointerTons3__FERecuperaLastCbteResponse(soap, (ns3__FERecuperaLastCbteResponse *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__DummyResponse:
		soap_serialize_PointerTons3__DummyResponse(soap, (ns3__DummyResponse *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__FERegXReqResponse:
		soap_serialize_PointerTons3__FERegXReqResponse(soap, (ns3__FERegXReqResponse *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__FECAEResponse:
		soap_serialize_PointerTons3__FECAEResponse(soap, (ns3__FECAEResponse *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__FECAERequest:
		soap_serialize_PointerTons3__FECAERequest(soap, (ns3__FECAERequest *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__FEAuthRequest:
		soap_serialize_PointerTons3__FEAuthRequest(soap, (ns3__FEAuthRequest *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__PaisTipo:
		soap_serialize_PointerTons3__PaisTipo(soap, (ns3__PaisTipo *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__ArrayOfPaisTipo:
		soap_serialize_PointerTons3__ArrayOfPaisTipo(soap, (ns3__ArrayOfPaisTipo *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__DocTipo:
		soap_serialize_PointerTons3__DocTipo(soap, (ns3__DocTipo *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__ArrayOfDocTipo:
		soap_serialize_PointerTons3__ArrayOfDocTipo(soap, (ns3__ArrayOfDocTipo *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__CbteTipo:
		soap_serialize_PointerTons3__CbteTipo(soap, (ns3__CbteTipo *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__ArrayOfCbteTipo:
		soap_serialize_PointerTons3__ArrayOfCbteTipo(soap, (ns3__ArrayOfCbteTipo *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__PtoVenta:
		soap_serialize_PointerTons3__PtoVenta(soap, (ns3__PtoVenta *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__ArrayOfPtoVenta:
		soap_serialize_PointerTons3__ArrayOfPtoVenta(soap, (ns3__ArrayOfPtoVenta *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__ConceptoTipo:
		soap_serialize_PointerTons3__ConceptoTipo(soap, (ns3__ConceptoTipo *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__ArrayOfConceptoTipo:
		soap_serialize_PointerTons3__ArrayOfConceptoTipo(soap, (ns3__ArrayOfConceptoTipo *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__OpcionalTipo:
		soap_serialize_PointerTons3__OpcionalTipo(soap, (ns3__OpcionalTipo *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__ArrayOfOpcionalTipo:
		soap_serialize_PointerTons3__ArrayOfOpcionalTipo(soap, (ns3__ArrayOfOpcionalTipo *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__IvaTipo:
		soap_serialize_PointerTons3__IvaTipo(soap, (ns3__IvaTipo *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__ArrayOfIvaTipo:
		soap_serialize_PointerTons3__ArrayOfIvaTipo(soap, (ns3__ArrayOfIvaTipo *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__Moneda:
		soap_serialize_PointerTons3__Moneda(soap, (ns3__Moneda *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__ArrayOfMoneda:
		soap_serialize_PointerTons3__ArrayOfMoneda(soap, (ns3__ArrayOfMoneda *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__TributoTipo:
		soap_serialize_PointerTons3__TributoTipo(soap, (ns3__TributoTipo *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__ArrayOfTributoTipo:
		soap_serialize_PointerTons3__ArrayOfTributoTipo(soap, (ns3__ArrayOfTributoTipo *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__Cotizacion:
		soap_serialize_PointerTons3__Cotizacion(soap, (ns3__Cotizacion *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__FECAEASinMov:
		soap_serialize_PointerTons3__FECAEASinMov(soap, (ns3__FECAEASinMov *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__ArrayOfFECAEASinMov:
		soap_serialize_PointerTons3__ArrayOfFECAEASinMov(soap, (ns3__ArrayOfFECAEASinMov *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__FECAEAGet:
		soap_serialize_PointerTons3__FECAEAGet(soap, (ns3__FECAEAGet *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__FECAEADetResponse:
		soap_serialize_PointerTons3__FECAEADetResponse(soap, (ns3__FECAEADetResponse *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__ArrayOfFECAEADetResponse:
		soap_serialize_PointerTons3__ArrayOfFECAEADetResponse(soap, (ns3__ArrayOfFECAEADetResponse *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__FECAEACabResponse:
		soap_serialize_PointerTons3__FECAEACabResponse(soap, (ns3__FECAEACabResponse *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__FECAEADetRequest:
		soap_serialize_PointerTons3__FECAEADetRequest(soap, (ns3__FECAEADetRequest *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__ArrayOfFECAEADetRequest:
		soap_serialize_PointerTons3__ArrayOfFECAEADetRequest(soap, (ns3__ArrayOfFECAEADetRequest *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__FECAEACabRequest:
		soap_serialize_PointerTons3__FECAEACabRequest(soap, (ns3__FECAEACabRequest *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__FECompConsResponse:
		soap_serialize_PointerTons3__FECompConsResponse(soap, (ns3__FECompConsResponse *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__Err:
		soap_serialize_PointerTons3__Err(soap, (ns3__Err *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__Evt:
		soap_serialize_PointerTons3__Evt(soap, (ns3__Evt *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__Obs:
		soap_serialize_PointerTons3__Obs(soap, (ns3__Obs *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__ArrayOfObs:
		soap_serialize_PointerTons3__ArrayOfObs(soap, (ns3__ArrayOfObs *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__FECAEDetResponse:
		soap_serialize_PointerTons3__FECAEDetResponse(soap, (ns3__FECAEDetResponse *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__ArrayOfErr:
		soap_serialize_PointerTons3__ArrayOfErr(soap, (ns3__ArrayOfErr *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__ArrayOfEvt:
		soap_serialize_PointerTons3__ArrayOfEvt(soap, (ns3__ArrayOfEvt *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__ArrayOfFECAEDetResponse:
		soap_serialize_PointerTons3__ArrayOfFECAEDetResponse(soap, (ns3__ArrayOfFECAEDetResponse *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__FECAECabResponse:
		soap_serialize_PointerTons3__FECAECabResponse(soap, (ns3__FECAECabResponse *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__Comprador:
		soap_serialize_PointerTons3__Comprador(soap, (ns3__Comprador *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__Opcional:
		soap_serialize_PointerTons3__Opcional(soap, (ns3__Opcional *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__AlicIva:
		soap_serialize_PointerTons3__AlicIva(soap, (ns3__AlicIva *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__Tributo:
		soap_serialize_PointerTons3__Tributo(soap, (ns3__Tributo *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__CbteAsoc:
		soap_serialize_PointerTons3__CbteAsoc(soap, (ns3__CbteAsoc *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__ArrayOfComprador:
		soap_serialize_PointerTons3__ArrayOfComprador(soap, (ns3__ArrayOfComprador *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__ArrayOfOpcional:
		soap_serialize_PointerTons3__ArrayOfOpcional(soap, (ns3__ArrayOfOpcional *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__ArrayOfAlicIva:
		soap_serialize_PointerTons3__ArrayOfAlicIva(soap, (ns3__ArrayOfAlicIva *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__ArrayOfTributo:
		soap_serialize_PointerTons3__ArrayOfTributo(soap, (ns3__ArrayOfTributo *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__ArrayOfCbteAsoc:
		soap_serialize_PointerTons3__ArrayOfCbteAsoc(soap, (ns3__ArrayOfCbteAsoc *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__FECAEDetRequest:
		soap_serialize_PointerTons3__FECAEDetRequest(soap, (ns3__FECAEDetRequest *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__ArrayOfFECAEDetRequest:
		soap_serialize_PointerTons3__ArrayOfFECAEDetRequest(soap, (ns3__ArrayOfFECAEDetRequest *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTons3__FECAECabRequest:
		soap_serialize_PointerTons3__FECAECabRequest(soap, (ns3__FECAECabRequest *const*)ptr);
		break;
	case SOAP_TYPE_afip_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_afip__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_afip_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}

SOAP_FMAC3 void * SOAP_FMAC4 afip_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_afip_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns1__loginCms:
		return (void*)soap_instantiate__ns1__loginCms(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns1__loginCmsResponse:
		return (void*)soap_instantiate__ns1__loginCmsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns2__LoginFault:
		return (void*)soap_instantiate_ns2__LoginFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__FEAuthRequest:
		return (void*)soap_instantiate_ns3__FEAuthRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__FECAERequest:
		return (void*)soap_instantiate_ns3__FECAERequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__FECabRequest:
		return (void*)soap_instantiate_ns3__FECabRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__ArrayOfFECAEDetRequest:
		return (void*)soap_instantiate_ns3__ArrayOfFECAEDetRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__FEDetRequest:
		return (void*)soap_instantiate_ns3__FEDetRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__ArrayOfCbteAsoc:
		return (void*)soap_instantiate_ns3__ArrayOfCbteAsoc(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__CbteAsoc:
		return (void*)soap_instantiate_ns3__CbteAsoc(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__ArrayOfTributo:
		return (void*)soap_instantiate_ns3__ArrayOfTributo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__Tributo:
		return (void*)soap_instantiate_ns3__Tributo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__ArrayOfAlicIva:
		return (void*)soap_instantiate_ns3__ArrayOfAlicIva(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__AlicIva:
		return (void*)soap_instantiate_ns3__AlicIva(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__ArrayOfOpcional:
		return (void*)soap_instantiate_ns3__ArrayOfOpcional(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__Opcional:
		return (void*)soap_instantiate_ns3__Opcional(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__ArrayOfComprador:
		return (void*)soap_instantiate_ns3__ArrayOfComprador(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__Comprador:
		return (void*)soap_instantiate_ns3__Comprador(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__FECAEResponse:
		return (void*)soap_instantiate_ns3__FECAEResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__FECabResponse:
		return (void*)soap_instantiate_ns3__FECabResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__ArrayOfFECAEDetResponse:
		return (void*)soap_instantiate_ns3__ArrayOfFECAEDetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__FEDetResponse:
		return (void*)soap_instantiate_ns3__FEDetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__ArrayOfObs:
		return (void*)soap_instantiate_ns3__ArrayOfObs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__Obs:
		return (void*)soap_instantiate_ns3__Obs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__ArrayOfEvt:
		return (void*)soap_instantiate_ns3__ArrayOfEvt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__Evt:
		return (void*)soap_instantiate_ns3__Evt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__ArrayOfErr:
		return (void*)soap_instantiate_ns3__ArrayOfErr(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__Err:
		return (void*)soap_instantiate_ns3__Err(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__FERegXReqResponse:
		return (void*)soap_instantiate_ns3__FERegXReqResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__DummyResponse:
		return (void*)soap_instantiate_ns3__DummyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__FERecuperaLastCbteResponse:
		return (void*)soap_instantiate_ns3__FERecuperaLastCbteResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__FECompConsultaReq:
		return (void*)soap_instantiate_ns3__FECompConsultaReq(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__FECompConsultaResponse:
		return (void*)soap_instantiate_ns3__FECompConsultaResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__FECAEARequest:
		return (void*)soap_instantiate_ns3__FECAEARequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__ArrayOfFECAEADetRequest:
		return (void*)soap_instantiate_ns3__ArrayOfFECAEADetRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__FECAEAResponse:
		return (void*)soap_instantiate_ns3__FECAEAResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__ArrayOfFECAEADetResponse:
		return (void*)soap_instantiate_ns3__ArrayOfFECAEADetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__FECAEAGetResponse:
		return (void*)soap_instantiate_ns3__FECAEAGetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__FECAEAGet:
		return (void*)soap_instantiate_ns3__FECAEAGet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__FECAEASinMovConsResponse:
		return (void*)soap_instantiate_ns3__FECAEASinMovConsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__ArrayOfFECAEASinMov:
		return (void*)soap_instantiate_ns3__ArrayOfFECAEASinMov(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__FECAEASinMov:
		return (void*)soap_instantiate_ns3__FECAEASinMov(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__FECotizacionResponse:
		return (void*)soap_instantiate_ns3__FECotizacionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__Cotizacion:
		return (void*)soap_instantiate_ns3__Cotizacion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__FETributoResponse:
		return (void*)soap_instantiate_ns3__FETributoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__ArrayOfTributoTipo:
		return (void*)soap_instantiate_ns3__ArrayOfTributoTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__TributoTipo:
		return (void*)soap_instantiate_ns3__TributoTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__MonedaResponse:
		return (void*)soap_instantiate_ns3__MonedaResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__ArrayOfMoneda:
		return (void*)soap_instantiate_ns3__ArrayOfMoneda(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__Moneda:
		return (void*)soap_instantiate_ns3__Moneda(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__IvaTipoResponse:
		return (void*)soap_instantiate_ns3__IvaTipoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__ArrayOfIvaTipo:
		return (void*)soap_instantiate_ns3__ArrayOfIvaTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__IvaTipo:
		return (void*)soap_instantiate_ns3__IvaTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__OpcionalTipoResponse:
		return (void*)soap_instantiate_ns3__OpcionalTipoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__ArrayOfOpcionalTipo:
		return (void*)soap_instantiate_ns3__ArrayOfOpcionalTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__OpcionalTipo:
		return (void*)soap_instantiate_ns3__OpcionalTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__ConceptoTipoResponse:
		return (void*)soap_instantiate_ns3__ConceptoTipoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__ArrayOfConceptoTipo:
		return (void*)soap_instantiate_ns3__ArrayOfConceptoTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__ConceptoTipo:
		return (void*)soap_instantiate_ns3__ConceptoTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__FEPtoVentaResponse:
		return (void*)soap_instantiate_ns3__FEPtoVentaResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__ArrayOfPtoVenta:
		return (void*)soap_instantiate_ns3__ArrayOfPtoVenta(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__PtoVenta:
		return (void*)soap_instantiate_ns3__PtoVenta(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__CbteTipoResponse:
		return (void*)soap_instantiate_ns3__CbteTipoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__ArrayOfCbteTipo:
		return (void*)soap_instantiate_ns3__ArrayOfCbteTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__CbteTipo:
		return (void*)soap_instantiate_ns3__CbteTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__DocTipoResponse:
		return (void*)soap_instantiate_ns3__DocTipoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__ArrayOfDocTipo:
		return (void*)soap_instantiate_ns3__ArrayOfDocTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__DocTipo:
		return (void*)soap_instantiate_ns3__DocTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__FEPaisResponse:
		return (void*)soap_instantiate_ns3__FEPaisResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__ArrayOfPaisTipo:
		return (void*)soap_instantiate_ns3__ArrayOfPaisTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__PaisTipo:
		return (void*)soap_instantiate_ns3__PaisTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FECAESolicitar:
		return (void*)soap_instantiate__ns3__FECAESolicitar(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FECAESolicitarResponse:
		return (void*)soap_instantiate__ns3__FECAESolicitarResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FECompTotXRequest:
		return (void*)soap_instantiate__ns3__FECompTotXRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FECompTotXRequestResponse:
		return (void*)soap_instantiate__ns3__FECompTotXRequestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FEDummy:
		return (void*)soap_instantiate__ns3__FEDummy(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FEDummyResponse:
		return (void*)soap_instantiate__ns3__FEDummyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FECompUltimoAutorizado:
		return (void*)soap_instantiate__ns3__FECompUltimoAutorizado(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FECompUltimoAutorizadoResponse:
		return (void*)soap_instantiate__ns3__FECompUltimoAutorizadoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FECompConsultar:
		return (void*)soap_instantiate__ns3__FECompConsultar(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FECompConsultarResponse:
		return (void*)soap_instantiate__ns3__FECompConsultarResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FECAEARegInformativo:
		return (void*)soap_instantiate__ns3__FECAEARegInformativo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FECAEARegInformativoResponse:
		return (void*)soap_instantiate__ns3__FECAEARegInformativoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FECAEASolicitar:
		return (void*)soap_instantiate__ns3__FECAEASolicitar(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FECAEASolicitarResponse:
		return (void*)soap_instantiate__ns3__FECAEASolicitarResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FECAEASinMovimientoConsultar:
		return (void*)soap_instantiate__ns3__FECAEASinMovimientoConsultar(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FECAEASinMovimientoConsultarResponse:
		return (void*)soap_instantiate__ns3__FECAEASinMovimientoConsultarResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FECAEASinMovimientoInformar:
		return (void*)soap_instantiate__ns3__FECAEASinMovimientoInformar(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FECAEASinMovimientoInformarResponse:
		return (void*)soap_instantiate__ns3__FECAEASinMovimientoInformarResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FECAEAConsultar:
		return (void*)soap_instantiate__ns3__FECAEAConsultar(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FECAEAConsultarResponse:
		return (void*)soap_instantiate__ns3__FECAEAConsultarResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FEParamGetCotizacion:
		return (void*)soap_instantiate__ns3__FEParamGetCotizacion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FEParamGetCotizacionResponse:
		return (void*)soap_instantiate__ns3__FEParamGetCotizacionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FEParamGetTiposTributos:
		return (void*)soap_instantiate__ns3__FEParamGetTiposTributos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FEParamGetTiposTributosResponse:
		return (void*)soap_instantiate__ns3__FEParamGetTiposTributosResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FEParamGetTiposMonedas:
		return (void*)soap_instantiate__ns3__FEParamGetTiposMonedas(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FEParamGetTiposMonedasResponse:
		return (void*)soap_instantiate__ns3__FEParamGetTiposMonedasResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FEParamGetTiposIva:
		return (void*)soap_instantiate__ns3__FEParamGetTiposIva(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FEParamGetTiposIvaResponse:
		return (void*)soap_instantiate__ns3__FEParamGetTiposIvaResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FEParamGetTiposOpcional:
		return (void*)soap_instantiate__ns3__FEParamGetTiposOpcional(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FEParamGetTiposOpcionalResponse:
		return (void*)soap_instantiate__ns3__FEParamGetTiposOpcionalResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FEParamGetTiposConcepto:
		return (void*)soap_instantiate__ns3__FEParamGetTiposConcepto(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FEParamGetTiposConceptoResponse:
		return (void*)soap_instantiate__ns3__FEParamGetTiposConceptoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FEParamGetPtosVenta:
		return (void*)soap_instantiate__ns3__FEParamGetPtosVenta(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FEParamGetPtosVentaResponse:
		return (void*)soap_instantiate__ns3__FEParamGetPtosVentaResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FEParamGetTiposCbte:
		return (void*)soap_instantiate__ns3__FEParamGetTiposCbte(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FEParamGetTiposCbteResponse:
		return (void*)soap_instantiate__ns3__FEParamGetTiposCbteResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FEParamGetTiposDoc:
		return (void*)soap_instantiate__ns3__FEParamGetTiposDoc(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FEParamGetTiposDocResponse:
		return (void*)soap_instantiate__ns3__FEParamGetTiposDocResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FEParamGetTiposPaises:
		return (void*)soap_instantiate__ns3__FEParamGetTiposPaises(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip__ns3__FEParamGetTiposPaisesResponse:
		return (void*)soap_instantiate__ns3__FEParamGetTiposPaisesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__FECAECabRequest:
		return (void*)soap_instantiate_ns3__FECAECabRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__FECAEDetRequest:
		return (void*)soap_instantiate_ns3__FECAEDetRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__FECAECabResponse:
		return (void*)soap_instantiate_ns3__FECAECabResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__FECAEDetResponse:
		return (void*)soap_instantiate_ns3__FECAEDetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__FECAEACabRequest:
		return (void*)soap_instantiate_ns3__FECAEACabRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__FECAEADetRequest:
		return (void*)soap_instantiate_ns3__FECAEADetRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__FECAEACabResponse:
		return (void*)soap_instantiate_ns3__FECAEACabResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__FECAEADetResponse:
		return (void*)soap_instantiate_ns3__FECAEADetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__FECAEASinMovResponse:
		return (void*)soap_instantiate_ns3__FECAEASinMovResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_ns3__FECompConsResponse:
		return (void*)soap_instantiate_ns3__FECompConsResponse(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_afip_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_afip___ns2__loginCms:
		return (void*)soap_instantiate___ns2__loginCms(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FECAESolicitar:
		return (void*)soap_instantiate___ns3__FECAESolicitar(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FECompTotXRequest:
		return (void*)soap_instantiate___ns3__FECompTotXRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FEDummy:
		return (void*)soap_instantiate___ns3__FEDummy(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FECompUltimoAutorizado:
		return (void*)soap_instantiate___ns3__FECompUltimoAutorizado(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FECompConsultar:
		return (void*)soap_instantiate___ns3__FECompConsultar(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FECAEARegInformativo:
		return (void*)soap_instantiate___ns3__FECAEARegInformativo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FECAEASolicitar:
		return (void*)soap_instantiate___ns3__FECAEASolicitar(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FECAEASinMovimientoConsultar:
		return (void*)soap_instantiate___ns3__FECAEASinMovimientoConsultar(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FECAEASinMovimientoInformar:
		return (void*)soap_instantiate___ns3__FECAEASinMovimientoInformar(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FECAEAConsultar:
		return (void*)soap_instantiate___ns3__FECAEAConsultar(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FEParamGetCotizacion:
		return (void*)soap_instantiate___ns3__FEParamGetCotizacion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FEParamGetTiposTributos:
		return (void*)soap_instantiate___ns3__FEParamGetTiposTributos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FEParamGetTiposMonedas:
		return (void*)soap_instantiate___ns3__FEParamGetTiposMonedas(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FEParamGetTiposIva:
		return (void*)soap_instantiate___ns3__FEParamGetTiposIva(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FEParamGetTiposOpcional:
		return (void*)soap_instantiate___ns3__FEParamGetTiposOpcional(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FEParamGetTiposConcepto:
		return (void*)soap_instantiate___ns3__FEParamGetTiposConcepto(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FEParamGetPtosVenta:
		return (void*)soap_instantiate___ns3__FEParamGetPtosVenta(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FEParamGetTiposCbte:
		return (void*)soap_instantiate___ns3__FEParamGetTiposCbte(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FEParamGetTiposDoc:
		return (void*)soap_instantiate___ns3__FEParamGetTiposDoc(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FEParamGetTiposPaises:
		return (void*)soap_instantiate___ns3__FEParamGetTiposPaises(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FECAESolicitar_:
		return (void*)soap_instantiate___ns3__FECAESolicitar_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FECompTotXRequest_:
		return (void*)soap_instantiate___ns3__FECompTotXRequest_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FEDummy_:
		return (void*)soap_instantiate___ns3__FEDummy_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FECompUltimoAutorizado_:
		return (void*)soap_instantiate___ns3__FECompUltimoAutorizado_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FECompConsultar_:
		return (void*)soap_instantiate___ns3__FECompConsultar_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FECAEARegInformativo_:
		return (void*)soap_instantiate___ns3__FECAEARegInformativo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FECAEASolicitar_:
		return (void*)soap_instantiate___ns3__FECAEASolicitar_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FECAEASinMovimientoConsultar_:
		return (void*)soap_instantiate___ns3__FECAEASinMovimientoConsultar_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FECAEASinMovimientoInformar_:
		return (void*)soap_instantiate___ns3__FECAEASinMovimientoInformar_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FECAEAConsultar_:
		return (void*)soap_instantiate___ns3__FECAEAConsultar_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FEParamGetCotizacion_:
		return (void*)soap_instantiate___ns3__FEParamGetCotizacion_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FEParamGetTiposTributos_:
		return (void*)soap_instantiate___ns3__FEParamGetTiposTributos_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FEParamGetTiposMonedas_:
		return (void*)soap_instantiate___ns3__FEParamGetTiposMonedas_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FEParamGetTiposIva_:
		return (void*)soap_instantiate___ns3__FEParamGetTiposIva_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FEParamGetTiposOpcional_:
		return (void*)soap_instantiate___ns3__FEParamGetTiposOpcional_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FEParamGetTiposConcepto_:
		return (void*)soap_instantiate___ns3__FEParamGetTiposConcepto_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FEParamGetPtosVenta_:
		return (void*)soap_instantiate___ns3__FEParamGetPtosVenta_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FEParamGetTiposCbte_:
		return (void*)soap_instantiate___ns3__FEParamGetTiposCbte_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FEParamGetTiposDoc_:
		return (void*)soap_instantiate___ns3__FEParamGetTiposDoc_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip___ns3__FEParamGetTiposPaises_:
		return (void*)soap_instantiate___ns3__FEParamGetTiposPaises_(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_afip_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_afip_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_afip_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_afip_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__PaisTipo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__PaisTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__DocTipo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__DocTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__CbteTipo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__CbteTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__PtoVenta:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__PtoVenta(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__ConceptoTipo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__ConceptoTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__OpcionalTipo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__OpcionalTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__IvaTipo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__IvaTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Moneda:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__Moneda(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__TributoTipo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__TributoTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__FECAEASinMov:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__FECAEASinMov(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__FECAEADetResponse:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__FECAEADetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__FECAEADetRequest:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__FECAEADetRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Err:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__Err(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Evt:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__Evt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Obs:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__Obs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__FECAEDetResponse:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__FECAEDetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Comprador:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__Comprador(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Opcional:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__Opcional(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__AlicIva:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__AlicIva(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Tributo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__Tributo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__CbteAsoc:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__CbteAsoc(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__FECAEDetRequest:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__FECAEDetRequest(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 afip_fdelete(struct soap *soap, struct soap_clist *p)
{
	(void)soap; /* appease -Wall -Werror */
	if (!p->ptr)
		return SOAP_OK;
	switch (p->type)
	{
	case SOAP_TYPE_afip_std__string:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_afip__ns1__loginCms:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__loginCms*>(p->ptr), _ns1__loginCms);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__loginCms*>(p->ptr), _ns1__loginCms);
		break;
	case SOAP_TYPE_afip__ns1__loginCmsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__loginCmsResponse*>(p->ptr), _ns1__loginCmsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__loginCmsResponse*>(p->ptr), _ns1__loginCmsResponse);
		break;
	case SOAP_TYPE_afip_ns2__LoginFault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns2__LoginFault*>(p->ptr), ns2__LoginFault);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns2__LoginFault*>(p->ptr), ns2__LoginFault);
		break;
	case SOAP_TYPE_afip_ns3__FEAuthRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__FEAuthRequest*>(p->ptr), ns3__FEAuthRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__FEAuthRequest*>(p->ptr), ns3__FEAuthRequest);
		break;
	case SOAP_TYPE_afip_ns3__FECAERequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__FECAERequest*>(p->ptr), ns3__FECAERequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__FECAERequest*>(p->ptr), ns3__FECAERequest);
		break;
	case SOAP_TYPE_afip_ns3__FECabRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__FECabRequest*>(p->ptr), ns3__FECabRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__FECabRequest*>(p->ptr), ns3__FECabRequest);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfFECAEDetRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__ArrayOfFECAEDetRequest*>(p->ptr), ns3__ArrayOfFECAEDetRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__ArrayOfFECAEDetRequest*>(p->ptr), ns3__ArrayOfFECAEDetRequest);
		break;
	case SOAP_TYPE_afip_ns3__FEDetRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__FEDetRequest*>(p->ptr), ns3__FEDetRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__FEDetRequest*>(p->ptr), ns3__FEDetRequest);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfCbteAsoc:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__ArrayOfCbteAsoc*>(p->ptr), ns3__ArrayOfCbteAsoc);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__ArrayOfCbteAsoc*>(p->ptr), ns3__ArrayOfCbteAsoc);
		break;
	case SOAP_TYPE_afip_ns3__CbteAsoc:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__CbteAsoc*>(p->ptr), ns3__CbteAsoc);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__CbteAsoc*>(p->ptr), ns3__CbteAsoc);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfTributo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__ArrayOfTributo*>(p->ptr), ns3__ArrayOfTributo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__ArrayOfTributo*>(p->ptr), ns3__ArrayOfTributo);
		break;
	case SOAP_TYPE_afip_ns3__Tributo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__Tributo*>(p->ptr), ns3__Tributo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__Tributo*>(p->ptr), ns3__Tributo);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfAlicIva:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__ArrayOfAlicIva*>(p->ptr), ns3__ArrayOfAlicIva);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__ArrayOfAlicIva*>(p->ptr), ns3__ArrayOfAlicIva);
		break;
	case SOAP_TYPE_afip_ns3__AlicIva:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__AlicIva*>(p->ptr), ns3__AlicIva);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__AlicIva*>(p->ptr), ns3__AlicIva);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfOpcional:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__ArrayOfOpcional*>(p->ptr), ns3__ArrayOfOpcional);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__ArrayOfOpcional*>(p->ptr), ns3__ArrayOfOpcional);
		break;
	case SOAP_TYPE_afip_ns3__Opcional:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__Opcional*>(p->ptr), ns3__Opcional);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__Opcional*>(p->ptr), ns3__Opcional);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfComprador:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__ArrayOfComprador*>(p->ptr), ns3__ArrayOfComprador);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__ArrayOfComprador*>(p->ptr), ns3__ArrayOfComprador);
		break;
	case SOAP_TYPE_afip_ns3__Comprador:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__Comprador*>(p->ptr), ns3__Comprador);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__Comprador*>(p->ptr), ns3__Comprador);
		break;
	case SOAP_TYPE_afip_ns3__FECAEResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__FECAEResponse*>(p->ptr), ns3__FECAEResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__FECAEResponse*>(p->ptr), ns3__FECAEResponse);
		break;
	case SOAP_TYPE_afip_ns3__FECabResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__FECabResponse*>(p->ptr), ns3__FECabResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__FECabResponse*>(p->ptr), ns3__FECabResponse);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfFECAEDetResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__ArrayOfFECAEDetResponse*>(p->ptr), ns3__ArrayOfFECAEDetResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__ArrayOfFECAEDetResponse*>(p->ptr), ns3__ArrayOfFECAEDetResponse);
		break;
	case SOAP_TYPE_afip_ns3__FEDetResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__FEDetResponse*>(p->ptr), ns3__FEDetResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__FEDetResponse*>(p->ptr), ns3__FEDetResponse);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfObs:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__ArrayOfObs*>(p->ptr), ns3__ArrayOfObs);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__ArrayOfObs*>(p->ptr), ns3__ArrayOfObs);
		break;
	case SOAP_TYPE_afip_ns3__Obs:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__Obs*>(p->ptr), ns3__Obs);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__Obs*>(p->ptr), ns3__Obs);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfEvt:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__ArrayOfEvt*>(p->ptr), ns3__ArrayOfEvt);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__ArrayOfEvt*>(p->ptr), ns3__ArrayOfEvt);
		break;
	case SOAP_TYPE_afip_ns3__Evt:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__Evt*>(p->ptr), ns3__Evt);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__Evt*>(p->ptr), ns3__Evt);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfErr:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__ArrayOfErr*>(p->ptr), ns3__ArrayOfErr);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__ArrayOfErr*>(p->ptr), ns3__ArrayOfErr);
		break;
	case SOAP_TYPE_afip_ns3__Err:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__Err*>(p->ptr), ns3__Err);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__Err*>(p->ptr), ns3__Err);
		break;
	case SOAP_TYPE_afip_ns3__FERegXReqResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__FERegXReqResponse*>(p->ptr), ns3__FERegXReqResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__FERegXReqResponse*>(p->ptr), ns3__FERegXReqResponse);
		break;
	case SOAP_TYPE_afip_ns3__DummyResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__DummyResponse*>(p->ptr), ns3__DummyResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__DummyResponse*>(p->ptr), ns3__DummyResponse);
		break;
	case SOAP_TYPE_afip_ns3__FERecuperaLastCbteResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__FERecuperaLastCbteResponse*>(p->ptr), ns3__FERecuperaLastCbteResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__FERecuperaLastCbteResponse*>(p->ptr), ns3__FERecuperaLastCbteResponse);
		break;
	case SOAP_TYPE_afip_ns3__FECompConsultaReq:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__FECompConsultaReq*>(p->ptr), ns3__FECompConsultaReq);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__FECompConsultaReq*>(p->ptr), ns3__FECompConsultaReq);
		break;
	case SOAP_TYPE_afip_ns3__FECompConsultaResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__FECompConsultaResponse*>(p->ptr), ns3__FECompConsultaResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__FECompConsultaResponse*>(p->ptr), ns3__FECompConsultaResponse);
		break;
	case SOAP_TYPE_afip_ns3__FECAEARequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__FECAEARequest*>(p->ptr), ns3__FECAEARequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__FECAEARequest*>(p->ptr), ns3__FECAEARequest);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfFECAEADetRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__ArrayOfFECAEADetRequest*>(p->ptr), ns3__ArrayOfFECAEADetRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__ArrayOfFECAEADetRequest*>(p->ptr), ns3__ArrayOfFECAEADetRequest);
		break;
	case SOAP_TYPE_afip_ns3__FECAEAResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__FECAEAResponse*>(p->ptr), ns3__FECAEAResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__FECAEAResponse*>(p->ptr), ns3__FECAEAResponse);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfFECAEADetResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__ArrayOfFECAEADetResponse*>(p->ptr), ns3__ArrayOfFECAEADetResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__ArrayOfFECAEADetResponse*>(p->ptr), ns3__ArrayOfFECAEADetResponse);
		break;
	case SOAP_TYPE_afip_ns3__FECAEAGetResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__FECAEAGetResponse*>(p->ptr), ns3__FECAEAGetResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__FECAEAGetResponse*>(p->ptr), ns3__FECAEAGetResponse);
		break;
	case SOAP_TYPE_afip_ns3__FECAEAGet:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__FECAEAGet*>(p->ptr), ns3__FECAEAGet);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__FECAEAGet*>(p->ptr), ns3__FECAEAGet);
		break;
	case SOAP_TYPE_afip_ns3__FECAEASinMovConsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__FECAEASinMovConsResponse*>(p->ptr), ns3__FECAEASinMovConsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__FECAEASinMovConsResponse*>(p->ptr), ns3__FECAEASinMovConsResponse);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfFECAEASinMov:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__ArrayOfFECAEASinMov*>(p->ptr), ns3__ArrayOfFECAEASinMov);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__ArrayOfFECAEASinMov*>(p->ptr), ns3__ArrayOfFECAEASinMov);
		break;
	case SOAP_TYPE_afip_ns3__FECAEASinMov:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__FECAEASinMov*>(p->ptr), ns3__FECAEASinMov);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__FECAEASinMov*>(p->ptr), ns3__FECAEASinMov);
		break;
	case SOAP_TYPE_afip_ns3__FECotizacionResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__FECotizacionResponse*>(p->ptr), ns3__FECotizacionResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__FECotizacionResponse*>(p->ptr), ns3__FECotizacionResponse);
		break;
	case SOAP_TYPE_afip_ns3__Cotizacion:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__Cotizacion*>(p->ptr), ns3__Cotizacion);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__Cotizacion*>(p->ptr), ns3__Cotizacion);
		break;
	case SOAP_TYPE_afip_ns3__FETributoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__FETributoResponse*>(p->ptr), ns3__FETributoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__FETributoResponse*>(p->ptr), ns3__FETributoResponse);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfTributoTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__ArrayOfTributoTipo*>(p->ptr), ns3__ArrayOfTributoTipo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__ArrayOfTributoTipo*>(p->ptr), ns3__ArrayOfTributoTipo);
		break;
	case SOAP_TYPE_afip_ns3__TributoTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__TributoTipo*>(p->ptr), ns3__TributoTipo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__TributoTipo*>(p->ptr), ns3__TributoTipo);
		break;
	case SOAP_TYPE_afip_ns3__MonedaResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__MonedaResponse*>(p->ptr), ns3__MonedaResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__MonedaResponse*>(p->ptr), ns3__MonedaResponse);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfMoneda:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__ArrayOfMoneda*>(p->ptr), ns3__ArrayOfMoneda);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__ArrayOfMoneda*>(p->ptr), ns3__ArrayOfMoneda);
		break;
	case SOAP_TYPE_afip_ns3__Moneda:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__Moneda*>(p->ptr), ns3__Moneda);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__Moneda*>(p->ptr), ns3__Moneda);
		break;
	case SOAP_TYPE_afip_ns3__IvaTipoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__IvaTipoResponse*>(p->ptr), ns3__IvaTipoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__IvaTipoResponse*>(p->ptr), ns3__IvaTipoResponse);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfIvaTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__ArrayOfIvaTipo*>(p->ptr), ns3__ArrayOfIvaTipo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__ArrayOfIvaTipo*>(p->ptr), ns3__ArrayOfIvaTipo);
		break;
	case SOAP_TYPE_afip_ns3__IvaTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__IvaTipo*>(p->ptr), ns3__IvaTipo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__IvaTipo*>(p->ptr), ns3__IvaTipo);
		break;
	case SOAP_TYPE_afip_ns3__OpcionalTipoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__OpcionalTipoResponse*>(p->ptr), ns3__OpcionalTipoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__OpcionalTipoResponse*>(p->ptr), ns3__OpcionalTipoResponse);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfOpcionalTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__ArrayOfOpcionalTipo*>(p->ptr), ns3__ArrayOfOpcionalTipo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__ArrayOfOpcionalTipo*>(p->ptr), ns3__ArrayOfOpcionalTipo);
		break;
	case SOAP_TYPE_afip_ns3__OpcionalTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__OpcionalTipo*>(p->ptr), ns3__OpcionalTipo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__OpcionalTipo*>(p->ptr), ns3__OpcionalTipo);
		break;
	case SOAP_TYPE_afip_ns3__ConceptoTipoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__ConceptoTipoResponse*>(p->ptr), ns3__ConceptoTipoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__ConceptoTipoResponse*>(p->ptr), ns3__ConceptoTipoResponse);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfConceptoTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__ArrayOfConceptoTipo*>(p->ptr), ns3__ArrayOfConceptoTipo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__ArrayOfConceptoTipo*>(p->ptr), ns3__ArrayOfConceptoTipo);
		break;
	case SOAP_TYPE_afip_ns3__ConceptoTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__ConceptoTipo*>(p->ptr), ns3__ConceptoTipo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__ConceptoTipo*>(p->ptr), ns3__ConceptoTipo);
		break;
	case SOAP_TYPE_afip_ns3__FEPtoVentaResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__FEPtoVentaResponse*>(p->ptr), ns3__FEPtoVentaResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__FEPtoVentaResponse*>(p->ptr), ns3__FEPtoVentaResponse);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfPtoVenta:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__ArrayOfPtoVenta*>(p->ptr), ns3__ArrayOfPtoVenta);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__ArrayOfPtoVenta*>(p->ptr), ns3__ArrayOfPtoVenta);
		break;
	case SOAP_TYPE_afip_ns3__PtoVenta:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__PtoVenta*>(p->ptr), ns3__PtoVenta);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__PtoVenta*>(p->ptr), ns3__PtoVenta);
		break;
	case SOAP_TYPE_afip_ns3__CbteTipoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__CbteTipoResponse*>(p->ptr), ns3__CbteTipoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__CbteTipoResponse*>(p->ptr), ns3__CbteTipoResponse);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfCbteTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__ArrayOfCbteTipo*>(p->ptr), ns3__ArrayOfCbteTipo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__ArrayOfCbteTipo*>(p->ptr), ns3__ArrayOfCbteTipo);
		break;
	case SOAP_TYPE_afip_ns3__CbteTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__CbteTipo*>(p->ptr), ns3__CbteTipo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__CbteTipo*>(p->ptr), ns3__CbteTipo);
		break;
	case SOAP_TYPE_afip_ns3__DocTipoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__DocTipoResponse*>(p->ptr), ns3__DocTipoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__DocTipoResponse*>(p->ptr), ns3__DocTipoResponse);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfDocTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__ArrayOfDocTipo*>(p->ptr), ns3__ArrayOfDocTipo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__ArrayOfDocTipo*>(p->ptr), ns3__ArrayOfDocTipo);
		break;
	case SOAP_TYPE_afip_ns3__DocTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__DocTipo*>(p->ptr), ns3__DocTipo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__DocTipo*>(p->ptr), ns3__DocTipo);
		break;
	case SOAP_TYPE_afip_ns3__FEPaisResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__FEPaisResponse*>(p->ptr), ns3__FEPaisResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__FEPaisResponse*>(p->ptr), ns3__FEPaisResponse);
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfPaisTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__ArrayOfPaisTipo*>(p->ptr), ns3__ArrayOfPaisTipo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__ArrayOfPaisTipo*>(p->ptr), ns3__ArrayOfPaisTipo);
		break;
	case SOAP_TYPE_afip_ns3__PaisTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__PaisTipo*>(p->ptr), ns3__PaisTipo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__PaisTipo*>(p->ptr), ns3__PaisTipo);
		break;
	case SOAP_TYPE_afip__ns3__FECAESolicitar:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FECAESolicitar*>(p->ptr), _ns3__FECAESolicitar);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FECAESolicitar*>(p->ptr), _ns3__FECAESolicitar);
		break;
	case SOAP_TYPE_afip__ns3__FECAESolicitarResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FECAESolicitarResponse*>(p->ptr), _ns3__FECAESolicitarResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FECAESolicitarResponse*>(p->ptr), _ns3__FECAESolicitarResponse);
		break;
	case SOAP_TYPE_afip__ns3__FECompTotXRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FECompTotXRequest*>(p->ptr), _ns3__FECompTotXRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FECompTotXRequest*>(p->ptr), _ns3__FECompTotXRequest);
		break;
	case SOAP_TYPE_afip__ns3__FECompTotXRequestResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FECompTotXRequestResponse*>(p->ptr), _ns3__FECompTotXRequestResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FECompTotXRequestResponse*>(p->ptr), _ns3__FECompTotXRequestResponse);
		break;
	case SOAP_TYPE_afip__ns3__FEDummy:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FEDummy*>(p->ptr), _ns3__FEDummy);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FEDummy*>(p->ptr), _ns3__FEDummy);
		break;
	case SOAP_TYPE_afip__ns3__FEDummyResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FEDummyResponse*>(p->ptr), _ns3__FEDummyResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FEDummyResponse*>(p->ptr), _ns3__FEDummyResponse);
		break;
	case SOAP_TYPE_afip__ns3__FECompUltimoAutorizado:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FECompUltimoAutorizado*>(p->ptr), _ns3__FECompUltimoAutorizado);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FECompUltimoAutorizado*>(p->ptr), _ns3__FECompUltimoAutorizado);
		break;
	case SOAP_TYPE_afip__ns3__FECompUltimoAutorizadoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FECompUltimoAutorizadoResponse*>(p->ptr), _ns3__FECompUltimoAutorizadoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FECompUltimoAutorizadoResponse*>(p->ptr), _ns3__FECompUltimoAutorizadoResponse);
		break;
	case SOAP_TYPE_afip__ns3__FECompConsultar:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FECompConsultar*>(p->ptr), _ns3__FECompConsultar);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FECompConsultar*>(p->ptr), _ns3__FECompConsultar);
		break;
	case SOAP_TYPE_afip__ns3__FECompConsultarResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FECompConsultarResponse*>(p->ptr), _ns3__FECompConsultarResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FECompConsultarResponse*>(p->ptr), _ns3__FECompConsultarResponse);
		break;
	case SOAP_TYPE_afip__ns3__FECAEARegInformativo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FECAEARegInformativo*>(p->ptr), _ns3__FECAEARegInformativo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FECAEARegInformativo*>(p->ptr), _ns3__FECAEARegInformativo);
		break;
	case SOAP_TYPE_afip__ns3__FECAEARegInformativoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FECAEARegInformativoResponse*>(p->ptr), _ns3__FECAEARegInformativoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FECAEARegInformativoResponse*>(p->ptr), _ns3__FECAEARegInformativoResponse);
		break;
	case SOAP_TYPE_afip__ns3__FECAEASolicitar:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FECAEASolicitar*>(p->ptr), _ns3__FECAEASolicitar);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FECAEASolicitar*>(p->ptr), _ns3__FECAEASolicitar);
		break;
	case SOAP_TYPE_afip__ns3__FECAEASolicitarResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FECAEASolicitarResponse*>(p->ptr), _ns3__FECAEASolicitarResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FECAEASolicitarResponse*>(p->ptr), _ns3__FECAEASolicitarResponse);
		break;
	case SOAP_TYPE_afip__ns3__FECAEASinMovimientoConsultar:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FECAEASinMovimientoConsultar*>(p->ptr), _ns3__FECAEASinMovimientoConsultar);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FECAEASinMovimientoConsultar*>(p->ptr), _ns3__FECAEASinMovimientoConsultar);
		break;
	case SOAP_TYPE_afip__ns3__FECAEASinMovimientoConsultarResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FECAEASinMovimientoConsultarResponse*>(p->ptr), _ns3__FECAEASinMovimientoConsultarResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FECAEASinMovimientoConsultarResponse*>(p->ptr), _ns3__FECAEASinMovimientoConsultarResponse);
		break;
	case SOAP_TYPE_afip__ns3__FECAEASinMovimientoInformar:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FECAEASinMovimientoInformar*>(p->ptr), _ns3__FECAEASinMovimientoInformar);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FECAEASinMovimientoInformar*>(p->ptr), _ns3__FECAEASinMovimientoInformar);
		break;
	case SOAP_TYPE_afip__ns3__FECAEASinMovimientoInformarResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FECAEASinMovimientoInformarResponse*>(p->ptr), _ns3__FECAEASinMovimientoInformarResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FECAEASinMovimientoInformarResponse*>(p->ptr), _ns3__FECAEASinMovimientoInformarResponse);
		break;
	case SOAP_TYPE_afip__ns3__FECAEAConsultar:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FECAEAConsultar*>(p->ptr), _ns3__FECAEAConsultar);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FECAEAConsultar*>(p->ptr), _ns3__FECAEAConsultar);
		break;
	case SOAP_TYPE_afip__ns3__FECAEAConsultarResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FECAEAConsultarResponse*>(p->ptr), _ns3__FECAEAConsultarResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FECAEAConsultarResponse*>(p->ptr), _ns3__FECAEAConsultarResponse);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetCotizacion:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FEParamGetCotizacion*>(p->ptr), _ns3__FEParamGetCotizacion);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FEParamGetCotizacion*>(p->ptr), _ns3__FEParamGetCotizacion);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetCotizacionResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FEParamGetCotizacionResponse*>(p->ptr), _ns3__FEParamGetCotizacionResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FEParamGetCotizacionResponse*>(p->ptr), _ns3__FEParamGetCotizacionResponse);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposTributos:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FEParamGetTiposTributos*>(p->ptr), _ns3__FEParamGetTiposTributos);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FEParamGetTiposTributos*>(p->ptr), _ns3__FEParamGetTiposTributos);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposTributosResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FEParamGetTiposTributosResponse*>(p->ptr), _ns3__FEParamGetTiposTributosResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FEParamGetTiposTributosResponse*>(p->ptr), _ns3__FEParamGetTiposTributosResponse);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposMonedas:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FEParamGetTiposMonedas*>(p->ptr), _ns3__FEParamGetTiposMonedas);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FEParamGetTiposMonedas*>(p->ptr), _ns3__FEParamGetTiposMonedas);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposMonedasResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FEParamGetTiposMonedasResponse*>(p->ptr), _ns3__FEParamGetTiposMonedasResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FEParamGetTiposMonedasResponse*>(p->ptr), _ns3__FEParamGetTiposMonedasResponse);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposIva:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FEParamGetTiposIva*>(p->ptr), _ns3__FEParamGetTiposIva);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FEParamGetTiposIva*>(p->ptr), _ns3__FEParamGetTiposIva);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposIvaResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FEParamGetTiposIvaResponse*>(p->ptr), _ns3__FEParamGetTiposIvaResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FEParamGetTiposIvaResponse*>(p->ptr), _ns3__FEParamGetTiposIvaResponse);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposOpcional:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FEParamGetTiposOpcional*>(p->ptr), _ns3__FEParamGetTiposOpcional);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FEParamGetTiposOpcional*>(p->ptr), _ns3__FEParamGetTiposOpcional);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposOpcionalResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FEParamGetTiposOpcionalResponse*>(p->ptr), _ns3__FEParamGetTiposOpcionalResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FEParamGetTiposOpcionalResponse*>(p->ptr), _ns3__FEParamGetTiposOpcionalResponse);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposConcepto:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FEParamGetTiposConcepto*>(p->ptr), _ns3__FEParamGetTiposConcepto);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FEParamGetTiposConcepto*>(p->ptr), _ns3__FEParamGetTiposConcepto);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposConceptoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FEParamGetTiposConceptoResponse*>(p->ptr), _ns3__FEParamGetTiposConceptoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FEParamGetTiposConceptoResponse*>(p->ptr), _ns3__FEParamGetTiposConceptoResponse);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetPtosVenta:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FEParamGetPtosVenta*>(p->ptr), _ns3__FEParamGetPtosVenta);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FEParamGetPtosVenta*>(p->ptr), _ns3__FEParamGetPtosVenta);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetPtosVentaResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FEParamGetPtosVentaResponse*>(p->ptr), _ns3__FEParamGetPtosVentaResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FEParamGetPtosVentaResponse*>(p->ptr), _ns3__FEParamGetPtosVentaResponse);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposCbte:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FEParamGetTiposCbte*>(p->ptr), _ns3__FEParamGetTiposCbte);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FEParamGetTiposCbte*>(p->ptr), _ns3__FEParamGetTiposCbte);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposCbteResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FEParamGetTiposCbteResponse*>(p->ptr), _ns3__FEParamGetTiposCbteResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FEParamGetTiposCbteResponse*>(p->ptr), _ns3__FEParamGetTiposCbteResponse);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposDoc:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FEParamGetTiposDoc*>(p->ptr), _ns3__FEParamGetTiposDoc);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FEParamGetTiposDoc*>(p->ptr), _ns3__FEParamGetTiposDoc);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposDocResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FEParamGetTiposDocResponse*>(p->ptr), _ns3__FEParamGetTiposDocResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FEParamGetTiposDocResponse*>(p->ptr), _ns3__FEParamGetTiposDocResponse);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposPaises:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FEParamGetTiposPaises*>(p->ptr), _ns3__FEParamGetTiposPaises);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FEParamGetTiposPaises*>(p->ptr), _ns3__FEParamGetTiposPaises);
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposPaisesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns3__FEParamGetTiposPaisesResponse*>(p->ptr), _ns3__FEParamGetTiposPaisesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns3__FEParamGetTiposPaisesResponse*>(p->ptr), _ns3__FEParamGetTiposPaisesResponse);
		break;
	case SOAP_TYPE_afip_ns3__FECAECabRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__FECAECabRequest*>(p->ptr), ns3__FECAECabRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__FECAECabRequest*>(p->ptr), ns3__FECAECabRequest);
		break;
	case SOAP_TYPE_afip_ns3__FECAEDetRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__FECAEDetRequest*>(p->ptr), ns3__FECAEDetRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__FECAEDetRequest*>(p->ptr), ns3__FECAEDetRequest);
		break;
	case SOAP_TYPE_afip_ns3__FECAECabResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__FECAECabResponse*>(p->ptr), ns3__FECAECabResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__FECAECabResponse*>(p->ptr), ns3__FECAECabResponse);
		break;
	case SOAP_TYPE_afip_ns3__FECAEDetResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__FECAEDetResponse*>(p->ptr), ns3__FECAEDetResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__FECAEDetResponse*>(p->ptr), ns3__FECAEDetResponse);
		break;
	case SOAP_TYPE_afip_ns3__FECAEACabRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__FECAEACabRequest*>(p->ptr), ns3__FECAEACabRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__FECAEACabRequest*>(p->ptr), ns3__FECAEACabRequest);
		break;
	case SOAP_TYPE_afip_ns3__FECAEADetRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__FECAEADetRequest*>(p->ptr), ns3__FECAEADetRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__FECAEADetRequest*>(p->ptr), ns3__FECAEADetRequest);
		break;
	case SOAP_TYPE_afip_ns3__FECAEACabResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__FECAEACabResponse*>(p->ptr), ns3__FECAEACabResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__FECAEACabResponse*>(p->ptr), ns3__FECAEACabResponse);
		break;
	case SOAP_TYPE_afip_ns3__FECAEADetResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__FECAEADetResponse*>(p->ptr), ns3__FECAEADetResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__FECAEADetResponse*>(p->ptr), ns3__FECAEADetResponse);
		break;
	case SOAP_TYPE_afip_ns3__FECAEASinMovResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__FECAEASinMovResponse*>(p->ptr), ns3__FECAEASinMovResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__FECAEASinMovResponse*>(p->ptr), ns3__FECAEASinMovResponse);
		break;
	case SOAP_TYPE_afip_ns3__FECompConsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns3__FECompConsResponse*>(p->ptr), ns3__FECompConsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns3__FECompConsResponse*>(p->ptr), ns3__FECompConsResponse);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_afip_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		break;
#endif
	case SOAP_TYPE_afip___ns2__loginCms:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns2__loginCms*>(p->ptr), struct __ns2__loginCms);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns2__loginCms*>(p->ptr), struct __ns2__loginCms);
		break;
	case SOAP_TYPE_afip___ns3__FECAESolicitar:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FECAESolicitar*>(p->ptr), struct __ns3__FECAESolicitar);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FECAESolicitar*>(p->ptr), struct __ns3__FECAESolicitar);
		break;
	case SOAP_TYPE_afip___ns3__FECompTotXRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FECompTotXRequest*>(p->ptr), struct __ns3__FECompTotXRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FECompTotXRequest*>(p->ptr), struct __ns3__FECompTotXRequest);
		break;
	case SOAP_TYPE_afip___ns3__FEDummy:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FEDummy*>(p->ptr), struct __ns3__FEDummy);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FEDummy*>(p->ptr), struct __ns3__FEDummy);
		break;
	case SOAP_TYPE_afip___ns3__FECompUltimoAutorizado:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FECompUltimoAutorizado*>(p->ptr), struct __ns3__FECompUltimoAutorizado);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FECompUltimoAutorizado*>(p->ptr), struct __ns3__FECompUltimoAutorizado);
		break;
	case SOAP_TYPE_afip___ns3__FECompConsultar:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FECompConsultar*>(p->ptr), struct __ns3__FECompConsultar);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FECompConsultar*>(p->ptr), struct __ns3__FECompConsultar);
		break;
	case SOAP_TYPE_afip___ns3__FECAEARegInformativo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FECAEARegInformativo*>(p->ptr), struct __ns3__FECAEARegInformativo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FECAEARegInformativo*>(p->ptr), struct __ns3__FECAEARegInformativo);
		break;
	case SOAP_TYPE_afip___ns3__FECAEASolicitar:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FECAEASolicitar*>(p->ptr), struct __ns3__FECAEASolicitar);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FECAEASolicitar*>(p->ptr), struct __ns3__FECAEASolicitar);
		break;
	case SOAP_TYPE_afip___ns3__FECAEASinMovimientoConsultar:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FECAEASinMovimientoConsultar*>(p->ptr), struct __ns3__FECAEASinMovimientoConsultar);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FECAEASinMovimientoConsultar*>(p->ptr), struct __ns3__FECAEASinMovimientoConsultar);
		break;
	case SOAP_TYPE_afip___ns3__FECAEASinMovimientoInformar:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FECAEASinMovimientoInformar*>(p->ptr), struct __ns3__FECAEASinMovimientoInformar);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FECAEASinMovimientoInformar*>(p->ptr), struct __ns3__FECAEASinMovimientoInformar);
		break;
	case SOAP_TYPE_afip___ns3__FECAEAConsultar:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FECAEAConsultar*>(p->ptr), struct __ns3__FECAEAConsultar);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FECAEAConsultar*>(p->ptr), struct __ns3__FECAEAConsultar);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetCotizacion:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FEParamGetCotizacion*>(p->ptr), struct __ns3__FEParamGetCotizacion);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FEParamGetCotizacion*>(p->ptr), struct __ns3__FEParamGetCotizacion);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposTributos:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FEParamGetTiposTributos*>(p->ptr), struct __ns3__FEParamGetTiposTributos);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FEParamGetTiposTributos*>(p->ptr), struct __ns3__FEParamGetTiposTributos);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposMonedas:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FEParamGetTiposMonedas*>(p->ptr), struct __ns3__FEParamGetTiposMonedas);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FEParamGetTiposMonedas*>(p->ptr), struct __ns3__FEParamGetTiposMonedas);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposIva:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FEParamGetTiposIva*>(p->ptr), struct __ns3__FEParamGetTiposIva);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FEParamGetTiposIva*>(p->ptr), struct __ns3__FEParamGetTiposIva);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposOpcional:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FEParamGetTiposOpcional*>(p->ptr), struct __ns3__FEParamGetTiposOpcional);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FEParamGetTiposOpcional*>(p->ptr), struct __ns3__FEParamGetTiposOpcional);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposConcepto:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FEParamGetTiposConcepto*>(p->ptr), struct __ns3__FEParamGetTiposConcepto);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FEParamGetTiposConcepto*>(p->ptr), struct __ns3__FEParamGetTiposConcepto);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetPtosVenta:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FEParamGetPtosVenta*>(p->ptr), struct __ns3__FEParamGetPtosVenta);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FEParamGetPtosVenta*>(p->ptr), struct __ns3__FEParamGetPtosVenta);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposCbte:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FEParamGetTiposCbte*>(p->ptr), struct __ns3__FEParamGetTiposCbte);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FEParamGetTiposCbte*>(p->ptr), struct __ns3__FEParamGetTiposCbte);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposDoc:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FEParamGetTiposDoc*>(p->ptr), struct __ns3__FEParamGetTiposDoc);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FEParamGetTiposDoc*>(p->ptr), struct __ns3__FEParamGetTiposDoc);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposPaises:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FEParamGetTiposPaises*>(p->ptr), struct __ns3__FEParamGetTiposPaises);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FEParamGetTiposPaises*>(p->ptr), struct __ns3__FEParamGetTiposPaises);
		break;
	case SOAP_TYPE_afip___ns3__FECAESolicitar_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FECAESolicitar_*>(p->ptr), struct __ns3__FECAESolicitar_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FECAESolicitar_*>(p->ptr), struct __ns3__FECAESolicitar_);
		break;
	case SOAP_TYPE_afip___ns3__FECompTotXRequest_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FECompTotXRequest_*>(p->ptr), struct __ns3__FECompTotXRequest_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FECompTotXRequest_*>(p->ptr), struct __ns3__FECompTotXRequest_);
		break;
	case SOAP_TYPE_afip___ns3__FEDummy_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FEDummy_*>(p->ptr), struct __ns3__FEDummy_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FEDummy_*>(p->ptr), struct __ns3__FEDummy_);
		break;
	case SOAP_TYPE_afip___ns3__FECompUltimoAutorizado_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FECompUltimoAutorizado_*>(p->ptr), struct __ns3__FECompUltimoAutorizado_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FECompUltimoAutorizado_*>(p->ptr), struct __ns3__FECompUltimoAutorizado_);
		break;
	case SOAP_TYPE_afip___ns3__FECompConsultar_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FECompConsultar_*>(p->ptr), struct __ns3__FECompConsultar_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FECompConsultar_*>(p->ptr), struct __ns3__FECompConsultar_);
		break;
	case SOAP_TYPE_afip___ns3__FECAEARegInformativo_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FECAEARegInformativo_*>(p->ptr), struct __ns3__FECAEARegInformativo_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FECAEARegInformativo_*>(p->ptr), struct __ns3__FECAEARegInformativo_);
		break;
	case SOAP_TYPE_afip___ns3__FECAEASolicitar_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FECAEASolicitar_*>(p->ptr), struct __ns3__FECAEASolicitar_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FECAEASolicitar_*>(p->ptr), struct __ns3__FECAEASolicitar_);
		break;
	case SOAP_TYPE_afip___ns3__FECAEASinMovimientoConsultar_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FECAEASinMovimientoConsultar_*>(p->ptr), struct __ns3__FECAEASinMovimientoConsultar_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FECAEASinMovimientoConsultar_*>(p->ptr), struct __ns3__FECAEASinMovimientoConsultar_);
		break;
	case SOAP_TYPE_afip___ns3__FECAEASinMovimientoInformar_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FECAEASinMovimientoInformar_*>(p->ptr), struct __ns3__FECAEASinMovimientoInformar_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FECAEASinMovimientoInformar_*>(p->ptr), struct __ns3__FECAEASinMovimientoInformar_);
		break;
	case SOAP_TYPE_afip___ns3__FECAEAConsultar_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FECAEAConsultar_*>(p->ptr), struct __ns3__FECAEAConsultar_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FECAEAConsultar_*>(p->ptr), struct __ns3__FECAEAConsultar_);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetCotizacion_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FEParamGetCotizacion_*>(p->ptr), struct __ns3__FEParamGetCotizacion_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FEParamGetCotizacion_*>(p->ptr), struct __ns3__FEParamGetCotizacion_);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposTributos_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FEParamGetTiposTributos_*>(p->ptr), struct __ns3__FEParamGetTiposTributos_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FEParamGetTiposTributos_*>(p->ptr), struct __ns3__FEParamGetTiposTributos_);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposMonedas_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FEParamGetTiposMonedas_*>(p->ptr), struct __ns3__FEParamGetTiposMonedas_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FEParamGetTiposMonedas_*>(p->ptr), struct __ns3__FEParamGetTiposMonedas_);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposIva_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FEParamGetTiposIva_*>(p->ptr), struct __ns3__FEParamGetTiposIva_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FEParamGetTiposIva_*>(p->ptr), struct __ns3__FEParamGetTiposIva_);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposOpcional_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FEParamGetTiposOpcional_*>(p->ptr), struct __ns3__FEParamGetTiposOpcional_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FEParamGetTiposOpcional_*>(p->ptr), struct __ns3__FEParamGetTiposOpcional_);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposConcepto_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FEParamGetTiposConcepto_*>(p->ptr), struct __ns3__FEParamGetTiposConcepto_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FEParamGetTiposConcepto_*>(p->ptr), struct __ns3__FEParamGetTiposConcepto_);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetPtosVenta_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FEParamGetPtosVenta_*>(p->ptr), struct __ns3__FEParamGetPtosVenta_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FEParamGetPtosVenta_*>(p->ptr), struct __ns3__FEParamGetPtosVenta_);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposCbte_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FEParamGetTiposCbte_*>(p->ptr), struct __ns3__FEParamGetTiposCbte_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FEParamGetTiposCbte_*>(p->ptr), struct __ns3__FEParamGetTiposCbte_);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposDoc_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FEParamGetTiposDoc_*>(p->ptr), struct __ns3__FEParamGetTiposDoc_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FEParamGetTiposDoc_*>(p->ptr), struct __ns3__FEParamGetTiposDoc_);
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposPaises_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns3__FEParamGetTiposPaises_*>(p->ptr), struct __ns3__FEParamGetTiposPaises_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns3__FEParamGetTiposPaises_*>(p->ptr), struct __ns3__FEParamGetTiposPaises_);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_afip_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_afip_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_afip_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_afip_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		break;
#endif
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__PaisTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns3__PaisTipo *> *>(p->ptr), std::vector<ns3__PaisTipo *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns3__PaisTipo *> *>(p->ptr), std::vector<ns3__PaisTipo *> );
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__DocTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns3__DocTipo *> *>(p->ptr), std::vector<ns3__DocTipo *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns3__DocTipo *> *>(p->ptr), std::vector<ns3__DocTipo *> );
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__CbteTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns3__CbteTipo *> *>(p->ptr), std::vector<ns3__CbteTipo *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns3__CbteTipo *> *>(p->ptr), std::vector<ns3__CbteTipo *> );
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__PtoVenta:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns3__PtoVenta *> *>(p->ptr), std::vector<ns3__PtoVenta *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns3__PtoVenta *> *>(p->ptr), std::vector<ns3__PtoVenta *> );
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__ConceptoTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns3__ConceptoTipo *> *>(p->ptr), std::vector<ns3__ConceptoTipo *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns3__ConceptoTipo *> *>(p->ptr), std::vector<ns3__ConceptoTipo *> );
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__OpcionalTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns3__OpcionalTipo *> *>(p->ptr), std::vector<ns3__OpcionalTipo *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns3__OpcionalTipo *> *>(p->ptr), std::vector<ns3__OpcionalTipo *> );
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__IvaTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns3__IvaTipo *> *>(p->ptr), std::vector<ns3__IvaTipo *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns3__IvaTipo *> *>(p->ptr), std::vector<ns3__IvaTipo *> );
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Moneda:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns3__Moneda *> *>(p->ptr), std::vector<ns3__Moneda *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns3__Moneda *> *>(p->ptr), std::vector<ns3__Moneda *> );
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__TributoTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns3__TributoTipo *> *>(p->ptr), std::vector<ns3__TributoTipo *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns3__TributoTipo *> *>(p->ptr), std::vector<ns3__TributoTipo *> );
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__FECAEASinMov:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns3__FECAEASinMov *> *>(p->ptr), std::vector<ns3__FECAEASinMov *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns3__FECAEASinMov *> *>(p->ptr), std::vector<ns3__FECAEASinMov *> );
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__FECAEADetResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns3__FECAEADetResponse *> *>(p->ptr), std::vector<ns3__FECAEADetResponse *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns3__FECAEADetResponse *> *>(p->ptr), std::vector<ns3__FECAEADetResponse *> );
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__FECAEADetRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns3__FECAEADetRequest *> *>(p->ptr), std::vector<ns3__FECAEADetRequest *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns3__FECAEADetRequest *> *>(p->ptr), std::vector<ns3__FECAEADetRequest *> );
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Err:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns3__Err *> *>(p->ptr), std::vector<ns3__Err *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns3__Err *> *>(p->ptr), std::vector<ns3__Err *> );
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Evt:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns3__Evt *> *>(p->ptr), std::vector<ns3__Evt *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns3__Evt *> *>(p->ptr), std::vector<ns3__Evt *> );
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Obs:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns3__Obs *> *>(p->ptr), std::vector<ns3__Obs *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns3__Obs *> *>(p->ptr), std::vector<ns3__Obs *> );
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__FECAEDetResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns3__FECAEDetResponse *> *>(p->ptr), std::vector<ns3__FECAEDetResponse *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns3__FECAEDetResponse *> *>(p->ptr), std::vector<ns3__FECAEDetResponse *> );
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Comprador:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns3__Comprador *> *>(p->ptr), std::vector<ns3__Comprador *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns3__Comprador *> *>(p->ptr), std::vector<ns3__Comprador *> );
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Opcional:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns3__Opcional *> *>(p->ptr), std::vector<ns3__Opcional *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns3__Opcional *> *>(p->ptr), std::vector<ns3__Opcional *> );
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__AlicIva:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns3__AlicIva *> *>(p->ptr), std::vector<ns3__AlicIva *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns3__AlicIva *> *>(p->ptr), std::vector<ns3__AlicIva *> );
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Tributo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns3__Tributo *> *>(p->ptr), std::vector<ns3__Tributo *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns3__Tributo *> *>(p->ptr), std::vector<ns3__Tributo *> );
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__CbteAsoc:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns3__CbteAsoc *> *>(p->ptr), std::vector<ns3__CbteAsoc *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns3__CbteAsoc *> *>(p->ptr), std::vector<ns3__CbteAsoc *> );
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__FECAEDetRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns3__FECAEDetRequest *> *>(p->ptr), std::vector<ns3__FECAEDetRequest *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns3__FECAEDetRequest *> *>(p->ptr), std::vector<ns3__FECAEDetRequest *> );
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 afip_fbase(int t, int b)
{
	do
	{	switch (t)
		{

		case SOAP_TYPE_afip_ns3__FECAECabRequest: t = SOAP_TYPE_afip_ns3__FECabRequest; break;
		case SOAP_TYPE_afip_ns3__FECAEDetRequest: t = SOAP_TYPE_afip_ns3__FEDetRequest; break;
		case SOAP_TYPE_afip_ns3__FECAECabResponse: t = SOAP_TYPE_afip_ns3__FECabResponse; break;
		case SOAP_TYPE_afip_ns3__FECAEDetResponse: t = SOAP_TYPE_afip_ns3__FEDetResponse; break;
		case SOAP_TYPE_afip_ns3__FECAEACabRequest: t = SOAP_TYPE_afip_ns3__FECabRequest; break;
		case SOAP_TYPE_afip_ns3__FECAEADetRequest: t = SOAP_TYPE_afip_ns3__FEDetRequest; break;
		case SOAP_TYPE_afip_ns3__FECAEACabResponse: t = SOAP_TYPE_afip_ns3__FECabResponse; break;
		case SOAP_TYPE_afip_ns3__FECAEADetResponse: t = SOAP_TYPE_afip_ns3__FEDetResponse; break;
		case SOAP_TYPE_afip_ns3__FECAEASinMovResponse: t = SOAP_TYPE_afip_ns3__FECAEASinMov; break;
		case SOAP_TYPE_afip_ns3__FECompConsResponse: t = SOAP_TYPE_afip_ns3__FECAEDetRequest; break;
		default: return 0;
		}
	}
	while (t != b);
	return 1;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 afip_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__PaisTipo:
		if (t == SOAP_TYPE_afip_ns3__PaisTipo || afip_fbase(t, SOAP_TYPE_afip_ns3__PaisTipo))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns3__PaisTipo *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns3__PaisTipo *> *)p)[index] = *(ns3__PaisTipo **)q;
		}
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__DocTipo:
		if (t == SOAP_TYPE_afip_ns3__DocTipo || afip_fbase(t, SOAP_TYPE_afip_ns3__DocTipo))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns3__DocTipo *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns3__DocTipo *> *)p)[index] = *(ns3__DocTipo **)q;
		}
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__CbteTipo:
		if (t == SOAP_TYPE_afip_ns3__CbteTipo || afip_fbase(t, SOAP_TYPE_afip_ns3__CbteTipo))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns3__CbteTipo *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns3__CbteTipo *> *)p)[index] = *(ns3__CbteTipo **)q;
		}
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__PtoVenta:
		if (t == SOAP_TYPE_afip_ns3__PtoVenta || afip_fbase(t, SOAP_TYPE_afip_ns3__PtoVenta))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns3__PtoVenta *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns3__PtoVenta *> *)p)[index] = *(ns3__PtoVenta **)q;
		}
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__ConceptoTipo:
		if (t == SOAP_TYPE_afip_ns3__ConceptoTipo || afip_fbase(t, SOAP_TYPE_afip_ns3__ConceptoTipo))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns3__ConceptoTipo *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns3__ConceptoTipo *> *)p)[index] = *(ns3__ConceptoTipo **)q;
		}
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__OpcionalTipo:
		if (t == SOAP_TYPE_afip_ns3__OpcionalTipo || afip_fbase(t, SOAP_TYPE_afip_ns3__OpcionalTipo))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns3__OpcionalTipo *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns3__OpcionalTipo *> *)p)[index] = *(ns3__OpcionalTipo **)q;
		}
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__IvaTipo:
		if (t == SOAP_TYPE_afip_ns3__IvaTipo || afip_fbase(t, SOAP_TYPE_afip_ns3__IvaTipo))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns3__IvaTipo *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns3__IvaTipo *> *)p)[index] = *(ns3__IvaTipo **)q;
		}
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Moneda:
		if (t == SOAP_TYPE_afip_ns3__Moneda || afip_fbase(t, SOAP_TYPE_afip_ns3__Moneda))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns3__Moneda *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns3__Moneda *> *)p)[index] = *(ns3__Moneda **)q;
		}
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__TributoTipo:
		if (t == SOAP_TYPE_afip_ns3__TributoTipo || afip_fbase(t, SOAP_TYPE_afip_ns3__TributoTipo))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns3__TributoTipo *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns3__TributoTipo *> *)p)[index] = *(ns3__TributoTipo **)q;
		}
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__FECAEASinMov:
		if (t == SOAP_TYPE_afip_ns3__FECAEASinMov || afip_fbase(t, SOAP_TYPE_afip_ns3__FECAEASinMov))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns3__FECAEASinMov *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns3__FECAEASinMov *> *)p)[index] = *(ns3__FECAEASinMov **)q;
		}
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__FECAEADetResponse:
		if (t == SOAP_TYPE_afip_ns3__FECAEADetResponse || afip_fbase(t, SOAP_TYPE_afip_ns3__FECAEADetResponse))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns3__FECAEADetResponse *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns3__FECAEADetResponse *> *)p)[index] = *(ns3__FECAEADetResponse **)q;
		}
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__FECAEADetRequest:
		if (t == SOAP_TYPE_afip_ns3__FECAEADetRequest || afip_fbase(t, SOAP_TYPE_afip_ns3__FECAEADetRequest))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns3__FECAEADetRequest *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns3__FECAEADetRequest *> *)p)[index] = *(ns3__FECAEADetRequest **)q;
		}
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Err:
		if (t == SOAP_TYPE_afip_ns3__Err || afip_fbase(t, SOAP_TYPE_afip_ns3__Err))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns3__Err *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns3__Err *> *)p)[index] = *(ns3__Err **)q;
		}
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Evt:
		if (t == SOAP_TYPE_afip_ns3__Evt || afip_fbase(t, SOAP_TYPE_afip_ns3__Evt))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns3__Evt *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns3__Evt *> *)p)[index] = *(ns3__Evt **)q;
		}
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Obs:
		if (t == SOAP_TYPE_afip_ns3__Obs || afip_fbase(t, SOAP_TYPE_afip_ns3__Obs))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns3__Obs *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns3__Obs *> *)p)[index] = *(ns3__Obs **)q;
		}
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__FECAEDetResponse:
		if (t == SOAP_TYPE_afip_ns3__FECAEDetResponse || afip_fbase(t, SOAP_TYPE_afip_ns3__FECAEDetResponse))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns3__FECAEDetResponse *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns3__FECAEDetResponse *> *)p)[index] = *(ns3__FECAEDetResponse **)q;
		}
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Comprador:
		if (t == SOAP_TYPE_afip_ns3__Comprador || afip_fbase(t, SOAP_TYPE_afip_ns3__Comprador))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns3__Comprador *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns3__Comprador *> *)p)[index] = *(ns3__Comprador **)q;
		}
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Opcional:
		if (t == SOAP_TYPE_afip_ns3__Opcional || afip_fbase(t, SOAP_TYPE_afip_ns3__Opcional))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns3__Opcional *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns3__Opcional *> *)p)[index] = *(ns3__Opcional **)q;
		}
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__AlicIva:
		if (t == SOAP_TYPE_afip_ns3__AlicIva || afip_fbase(t, SOAP_TYPE_afip_ns3__AlicIva))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns3__AlicIva *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns3__AlicIva *> *)p)[index] = *(ns3__AlicIva **)q;
		}
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Tributo:
		if (t == SOAP_TYPE_afip_ns3__Tributo || afip_fbase(t, SOAP_TYPE_afip_ns3__Tributo))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns3__Tributo *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns3__Tributo *> *)p)[index] = *(ns3__Tributo **)q;
		}
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__CbteAsoc:
		if (t == SOAP_TYPE_afip_ns3__CbteAsoc || afip_fbase(t, SOAP_TYPE_afip_ns3__CbteAsoc))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns3__CbteAsoc *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns3__CbteAsoc *> *)p)[index] = *(ns3__CbteAsoc **)q;
		}
		break;
	case SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__FECAEDetRequest:
		if (t == SOAP_TYPE_afip_ns3__FECAEDetRequest || afip_fbase(t, SOAP_TYPE_afip_ns3__FECAEDetRequest))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns3__FECAEDetRequest *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns3__FECAEDetRequest *> *)p)[index] = *(ns3__FECAEDetRequest **)q;
		}
		break;
	case SOAP_TYPE_afip_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_afip__ns1__loginCms:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__loginCms type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__loginCms*)p = *(_ns1__loginCms*)q;
		break;
	case SOAP_TYPE_afip__ns1__loginCmsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__loginCmsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__loginCmsResponse*)p = *(_ns1__loginCmsResponse*)q;
		break;
	case SOAP_TYPE_afip_ns2__LoginFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__LoginFault type=%d location=%p object=%p\n", t, p, q));
		*(ns2__LoginFault*)p = *(ns2__LoginFault*)q;
		break;
	case SOAP_TYPE_afip_ns3__FEAuthRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__FEAuthRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns3__FEAuthRequest*)p = *(ns3__FEAuthRequest*)q;
		break;
	case SOAP_TYPE_afip_ns3__FECAERequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__FECAERequest type=%d location=%p object=%p\n", t, p, q));
		*(ns3__FECAERequest*)p = *(ns3__FECAERequest*)q;
		break;
	case SOAP_TYPE_afip_ns3__FECabRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__FECabRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns3__FECabRequest*)p = *(ns3__FECabRequest*)q;
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfFECAEDetRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__ArrayOfFECAEDetRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns3__ArrayOfFECAEDetRequest*)p = *(ns3__ArrayOfFECAEDetRequest*)q;
		break;
	case SOAP_TYPE_afip_ns3__FEDetRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__FEDetRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns3__FEDetRequest*)p = *(ns3__FEDetRequest*)q;
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfCbteAsoc:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__ArrayOfCbteAsoc type=%d location=%p object=%p\n", t, p, q));
		*(ns3__ArrayOfCbteAsoc*)p = *(ns3__ArrayOfCbteAsoc*)q;
		break;
	case SOAP_TYPE_afip_ns3__CbteAsoc:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__CbteAsoc type=%d location=%p object=%p\n", t, p, q));
		*(ns3__CbteAsoc*)p = *(ns3__CbteAsoc*)q;
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfTributo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__ArrayOfTributo type=%d location=%p object=%p\n", t, p, q));
		*(ns3__ArrayOfTributo*)p = *(ns3__ArrayOfTributo*)q;
		break;
	case SOAP_TYPE_afip_ns3__Tributo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__Tributo type=%d location=%p object=%p\n", t, p, q));
		*(ns3__Tributo*)p = *(ns3__Tributo*)q;
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfAlicIva:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__ArrayOfAlicIva type=%d location=%p object=%p\n", t, p, q));
		*(ns3__ArrayOfAlicIva*)p = *(ns3__ArrayOfAlicIva*)q;
		break;
	case SOAP_TYPE_afip_ns3__AlicIva:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__AlicIva type=%d location=%p object=%p\n", t, p, q));
		*(ns3__AlicIva*)p = *(ns3__AlicIva*)q;
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfOpcional:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__ArrayOfOpcional type=%d location=%p object=%p\n", t, p, q));
		*(ns3__ArrayOfOpcional*)p = *(ns3__ArrayOfOpcional*)q;
		break;
	case SOAP_TYPE_afip_ns3__Opcional:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__Opcional type=%d location=%p object=%p\n", t, p, q));
		*(ns3__Opcional*)p = *(ns3__Opcional*)q;
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfComprador:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__ArrayOfComprador type=%d location=%p object=%p\n", t, p, q));
		*(ns3__ArrayOfComprador*)p = *(ns3__ArrayOfComprador*)q;
		break;
	case SOAP_TYPE_afip_ns3__Comprador:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__Comprador type=%d location=%p object=%p\n", t, p, q));
		*(ns3__Comprador*)p = *(ns3__Comprador*)q;
		break;
	case SOAP_TYPE_afip_ns3__FECAEResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__FECAEResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns3__FECAEResponse*)p = *(ns3__FECAEResponse*)q;
		break;
	case SOAP_TYPE_afip_ns3__FECabResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__FECabResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns3__FECabResponse*)p = *(ns3__FECabResponse*)q;
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfFECAEDetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__ArrayOfFECAEDetResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns3__ArrayOfFECAEDetResponse*)p = *(ns3__ArrayOfFECAEDetResponse*)q;
		break;
	case SOAP_TYPE_afip_ns3__FEDetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__FEDetResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns3__FEDetResponse*)p = *(ns3__FEDetResponse*)q;
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfObs:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__ArrayOfObs type=%d location=%p object=%p\n", t, p, q));
		*(ns3__ArrayOfObs*)p = *(ns3__ArrayOfObs*)q;
		break;
	case SOAP_TYPE_afip_ns3__Obs:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__Obs type=%d location=%p object=%p\n", t, p, q));
		*(ns3__Obs*)p = *(ns3__Obs*)q;
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfEvt:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__ArrayOfEvt type=%d location=%p object=%p\n", t, p, q));
		*(ns3__ArrayOfEvt*)p = *(ns3__ArrayOfEvt*)q;
		break;
	case SOAP_TYPE_afip_ns3__Evt:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__Evt type=%d location=%p object=%p\n", t, p, q));
		*(ns3__Evt*)p = *(ns3__Evt*)q;
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfErr:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__ArrayOfErr type=%d location=%p object=%p\n", t, p, q));
		*(ns3__ArrayOfErr*)p = *(ns3__ArrayOfErr*)q;
		break;
	case SOAP_TYPE_afip_ns3__Err:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__Err type=%d location=%p object=%p\n", t, p, q));
		*(ns3__Err*)p = *(ns3__Err*)q;
		break;
	case SOAP_TYPE_afip_ns3__FERegXReqResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__FERegXReqResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns3__FERegXReqResponse*)p = *(ns3__FERegXReqResponse*)q;
		break;
	case SOAP_TYPE_afip_ns3__DummyResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__DummyResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns3__DummyResponse*)p = *(ns3__DummyResponse*)q;
		break;
	case SOAP_TYPE_afip_ns3__FERecuperaLastCbteResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__FERecuperaLastCbteResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns3__FERecuperaLastCbteResponse*)p = *(ns3__FERecuperaLastCbteResponse*)q;
		break;
	case SOAP_TYPE_afip_ns3__FECompConsultaReq:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__FECompConsultaReq type=%d location=%p object=%p\n", t, p, q));
		*(ns3__FECompConsultaReq*)p = *(ns3__FECompConsultaReq*)q;
		break;
	case SOAP_TYPE_afip_ns3__FECompConsultaResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__FECompConsultaResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns3__FECompConsultaResponse*)p = *(ns3__FECompConsultaResponse*)q;
		break;
	case SOAP_TYPE_afip_ns3__FECAEARequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__FECAEARequest type=%d location=%p object=%p\n", t, p, q));
		*(ns3__FECAEARequest*)p = *(ns3__FECAEARequest*)q;
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfFECAEADetRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__ArrayOfFECAEADetRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns3__ArrayOfFECAEADetRequest*)p = *(ns3__ArrayOfFECAEADetRequest*)q;
		break;
	case SOAP_TYPE_afip_ns3__FECAEAResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__FECAEAResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns3__FECAEAResponse*)p = *(ns3__FECAEAResponse*)q;
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfFECAEADetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__ArrayOfFECAEADetResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns3__ArrayOfFECAEADetResponse*)p = *(ns3__ArrayOfFECAEADetResponse*)q;
		break;
	case SOAP_TYPE_afip_ns3__FECAEAGetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__FECAEAGetResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns3__FECAEAGetResponse*)p = *(ns3__FECAEAGetResponse*)q;
		break;
	case SOAP_TYPE_afip_ns3__FECAEAGet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__FECAEAGet type=%d location=%p object=%p\n", t, p, q));
		*(ns3__FECAEAGet*)p = *(ns3__FECAEAGet*)q;
		break;
	case SOAP_TYPE_afip_ns3__FECAEASinMovConsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__FECAEASinMovConsResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns3__FECAEASinMovConsResponse*)p = *(ns3__FECAEASinMovConsResponse*)q;
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfFECAEASinMov:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__ArrayOfFECAEASinMov type=%d location=%p object=%p\n", t, p, q));
		*(ns3__ArrayOfFECAEASinMov*)p = *(ns3__ArrayOfFECAEASinMov*)q;
		break;
	case SOAP_TYPE_afip_ns3__FECAEASinMov:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__FECAEASinMov type=%d location=%p object=%p\n", t, p, q));
		*(ns3__FECAEASinMov*)p = *(ns3__FECAEASinMov*)q;
		break;
	case SOAP_TYPE_afip_ns3__FECotizacionResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__FECotizacionResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns3__FECotizacionResponse*)p = *(ns3__FECotizacionResponse*)q;
		break;
	case SOAP_TYPE_afip_ns3__Cotizacion:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__Cotizacion type=%d location=%p object=%p\n", t, p, q));
		*(ns3__Cotizacion*)p = *(ns3__Cotizacion*)q;
		break;
	case SOAP_TYPE_afip_ns3__FETributoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__FETributoResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns3__FETributoResponse*)p = *(ns3__FETributoResponse*)q;
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfTributoTipo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__ArrayOfTributoTipo type=%d location=%p object=%p\n", t, p, q));
		*(ns3__ArrayOfTributoTipo*)p = *(ns3__ArrayOfTributoTipo*)q;
		break;
	case SOAP_TYPE_afip_ns3__TributoTipo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__TributoTipo type=%d location=%p object=%p\n", t, p, q));
		*(ns3__TributoTipo*)p = *(ns3__TributoTipo*)q;
		break;
	case SOAP_TYPE_afip_ns3__MonedaResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__MonedaResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns3__MonedaResponse*)p = *(ns3__MonedaResponse*)q;
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfMoneda:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__ArrayOfMoneda type=%d location=%p object=%p\n", t, p, q));
		*(ns3__ArrayOfMoneda*)p = *(ns3__ArrayOfMoneda*)q;
		break;
	case SOAP_TYPE_afip_ns3__Moneda:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__Moneda type=%d location=%p object=%p\n", t, p, q));
		*(ns3__Moneda*)p = *(ns3__Moneda*)q;
		break;
	case SOAP_TYPE_afip_ns3__IvaTipoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__IvaTipoResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns3__IvaTipoResponse*)p = *(ns3__IvaTipoResponse*)q;
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfIvaTipo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__ArrayOfIvaTipo type=%d location=%p object=%p\n", t, p, q));
		*(ns3__ArrayOfIvaTipo*)p = *(ns3__ArrayOfIvaTipo*)q;
		break;
	case SOAP_TYPE_afip_ns3__IvaTipo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__IvaTipo type=%d location=%p object=%p\n", t, p, q));
		*(ns3__IvaTipo*)p = *(ns3__IvaTipo*)q;
		break;
	case SOAP_TYPE_afip_ns3__OpcionalTipoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__OpcionalTipoResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns3__OpcionalTipoResponse*)p = *(ns3__OpcionalTipoResponse*)q;
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfOpcionalTipo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__ArrayOfOpcionalTipo type=%d location=%p object=%p\n", t, p, q));
		*(ns3__ArrayOfOpcionalTipo*)p = *(ns3__ArrayOfOpcionalTipo*)q;
		break;
	case SOAP_TYPE_afip_ns3__OpcionalTipo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__OpcionalTipo type=%d location=%p object=%p\n", t, p, q));
		*(ns3__OpcionalTipo*)p = *(ns3__OpcionalTipo*)q;
		break;
	case SOAP_TYPE_afip_ns3__ConceptoTipoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__ConceptoTipoResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns3__ConceptoTipoResponse*)p = *(ns3__ConceptoTipoResponse*)q;
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfConceptoTipo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__ArrayOfConceptoTipo type=%d location=%p object=%p\n", t, p, q));
		*(ns3__ArrayOfConceptoTipo*)p = *(ns3__ArrayOfConceptoTipo*)q;
		break;
	case SOAP_TYPE_afip_ns3__ConceptoTipo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__ConceptoTipo type=%d location=%p object=%p\n", t, p, q));
		*(ns3__ConceptoTipo*)p = *(ns3__ConceptoTipo*)q;
		break;
	case SOAP_TYPE_afip_ns3__FEPtoVentaResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__FEPtoVentaResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns3__FEPtoVentaResponse*)p = *(ns3__FEPtoVentaResponse*)q;
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfPtoVenta:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__ArrayOfPtoVenta type=%d location=%p object=%p\n", t, p, q));
		*(ns3__ArrayOfPtoVenta*)p = *(ns3__ArrayOfPtoVenta*)q;
		break;
	case SOAP_TYPE_afip_ns3__PtoVenta:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__PtoVenta type=%d location=%p object=%p\n", t, p, q));
		*(ns3__PtoVenta*)p = *(ns3__PtoVenta*)q;
		break;
	case SOAP_TYPE_afip_ns3__CbteTipoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__CbteTipoResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns3__CbteTipoResponse*)p = *(ns3__CbteTipoResponse*)q;
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfCbteTipo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__ArrayOfCbteTipo type=%d location=%p object=%p\n", t, p, q));
		*(ns3__ArrayOfCbteTipo*)p = *(ns3__ArrayOfCbteTipo*)q;
		break;
	case SOAP_TYPE_afip_ns3__CbteTipo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__CbteTipo type=%d location=%p object=%p\n", t, p, q));
		*(ns3__CbteTipo*)p = *(ns3__CbteTipo*)q;
		break;
	case SOAP_TYPE_afip_ns3__DocTipoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__DocTipoResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns3__DocTipoResponse*)p = *(ns3__DocTipoResponse*)q;
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfDocTipo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__ArrayOfDocTipo type=%d location=%p object=%p\n", t, p, q));
		*(ns3__ArrayOfDocTipo*)p = *(ns3__ArrayOfDocTipo*)q;
		break;
	case SOAP_TYPE_afip_ns3__DocTipo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__DocTipo type=%d location=%p object=%p\n", t, p, q));
		*(ns3__DocTipo*)p = *(ns3__DocTipo*)q;
		break;
	case SOAP_TYPE_afip_ns3__FEPaisResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__FEPaisResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns3__FEPaisResponse*)p = *(ns3__FEPaisResponse*)q;
		break;
	case SOAP_TYPE_afip_ns3__ArrayOfPaisTipo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__ArrayOfPaisTipo type=%d location=%p object=%p\n", t, p, q));
		*(ns3__ArrayOfPaisTipo*)p = *(ns3__ArrayOfPaisTipo*)q;
		break;
	case SOAP_TYPE_afip_ns3__PaisTipo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__PaisTipo type=%d location=%p object=%p\n", t, p, q));
		*(ns3__PaisTipo*)p = *(ns3__PaisTipo*)q;
		break;
	case SOAP_TYPE_afip__ns3__FECAESolicitar:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FECAESolicitar type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FECAESolicitar*)p = *(_ns3__FECAESolicitar*)q;
		break;
	case SOAP_TYPE_afip__ns3__FECAESolicitarResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FECAESolicitarResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FECAESolicitarResponse*)p = *(_ns3__FECAESolicitarResponse*)q;
		break;
	case SOAP_TYPE_afip__ns3__FECompTotXRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FECompTotXRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FECompTotXRequest*)p = *(_ns3__FECompTotXRequest*)q;
		break;
	case SOAP_TYPE_afip__ns3__FECompTotXRequestResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FECompTotXRequestResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FECompTotXRequestResponse*)p = *(_ns3__FECompTotXRequestResponse*)q;
		break;
	case SOAP_TYPE_afip__ns3__FEDummy:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FEDummy type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FEDummy*)p = *(_ns3__FEDummy*)q;
		break;
	case SOAP_TYPE_afip__ns3__FEDummyResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FEDummyResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FEDummyResponse*)p = *(_ns3__FEDummyResponse*)q;
		break;
	case SOAP_TYPE_afip__ns3__FECompUltimoAutorizado:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FECompUltimoAutorizado type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FECompUltimoAutorizado*)p = *(_ns3__FECompUltimoAutorizado*)q;
		break;
	case SOAP_TYPE_afip__ns3__FECompUltimoAutorizadoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FECompUltimoAutorizadoResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FECompUltimoAutorizadoResponse*)p = *(_ns3__FECompUltimoAutorizadoResponse*)q;
		break;
	case SOAP_TYPE_afip__ns3__FECompConsultar:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FECompConsultar type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FECompConsultar*)p = *(_ns3__FECompConsultar*)q;
		break;
	case SOAP_TYPE_afip__ns3__FECompConsultarResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FECompConsultarResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FECompConsultarResponse*)p = *(_ns3__FECompConsultarResponse*)q;
		break;
	case SOAP_TYPE_afip__ns3__FECAEARegInformativo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FECAEARegInformativo type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FECAEARegInformativo*)p = *(_ns3__FECAEARegInformativo*)q;
		break;
	case SOAP_TYPE_afip__ns3__FECAEARegInformativoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FECAEARegInformativoResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FECAEARegInformativoResponse*)p = *(_ns3__FECAEARegInformativoResponse*)q;
		break;
	case SOAP_TYPE_afip__ns3__FECAEASolicitar:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FECAEASolicitar type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FECAEASolicitar*)p = *(_ns3__FECAEASolicitar*)q;
		break;
	case SOAP_TYPE_afip__ns3__FECAEASolicitarResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FECAEASolicitarResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FECAEASolicitarResponse*)p = *(_ns3__FECAEASolicitarResponse*)q;
		break;
	case SOAP_TYPE_afip__ns3__FECAEASinMovimientoConsultar:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FECAEASinMovimientoConsultar type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FECAEASinMovimientoConsultar*)p = *(_ns3__FECAEASinMovimientoConsultar*)q;
		break;
	case SOAP_TYPE_afip__ns3__FECAEASinMovimientoConsultarResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FECAEASinMovimientoConsultarResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FECAEASinMovimientoConsultarResponse*)p = *(_ns3__FECAEASinMovimientoConsultarResponse*)q;
		break;
	case SOAP_TYPE_afip__ns3__FECAEASinMovimientoInformar:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FECAEASinMovimientoInformar type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FECAEASinMovimientoInformar*)p = *(_ns3__FECAEASinMovimientoInformar*)q;
		break;
	case SOAP_TYPE_afip__ns3__FECAEASinMovimientoInformarResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FECAEASinMovimientoInformarResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FECAEASinMovimientoInformarResponse*)p = *(_ns3__FECAEASinMovimientoInformarResponse*)q;
		break;
	case SOAP_TYPE_afip__ns3__FECAEAConsultar:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FECAEAConsultar type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FECAEAConsultar*)p = *(_ns3__FECAEAConsultar*)q;
		break;
	case SOAP_TYPE_afip__ns3__FECAEAConsultarResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FECAEAConsultarResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FECAEAConsultarResponse*)p = *(_ns3__FECAEAConsultarResponse*)q;
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetCotizacion:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FEParamGetCotizacion type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FEParamGetCotizacion*)p = *(_ns3__FEParamGetCotizacion*)q;
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetCotizacionResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FEParamGetCotizacionResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FEParamGetCotizacionResponse*)p = *(_ns3__FEParamGetCotizacionResponse*)q;
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposTributos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FEParamGetTiposTributos type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FEParamGetTiposTributos*)p = *(_ns3__FEParamGetTiposTributos*)q;
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposTributosResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FEParamGetTiposTributosResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FEParamGetTiposTributosResponse*)p = *(_ns3__FEParamGetTiposTributosResponse*)q;
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposMonedas:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FEParamGetTiposMonedas type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FEParamGetTiposMonedas*)p = *(_ns3__FEParamGetTiposMonedas*)q;
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposMonedasResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FEParamGetTiposMonedasResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FEParamGetTiposMonedasResponse*)p = *(_ns3__FEParamGetTiposMonedasResponse*)q;
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposIva:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FEParamGetTiposIva type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FEParamGetTiposIva*)p = *(_ns3__FEParamGetTiposIva*)q;
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposIvaResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FEParamGetTiposIvaResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FEParamGetTiposIvaResponse*)p = *(_ns3__FEParamGetTiposIvaResponse*)q;
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposOpcional:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FEParamGetTiposOpcional type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FEParamGetTiposOpcional*)p = *(_ns3__FEParamGetTiposOpcional*)q;
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposOpcionalResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FEParamGetTiposOpcionalResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FEParamGetTiposOpcionalResponse*)p = *(_ns3__FEParamGetTiposOpcionalResponse*)q;
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposConcepto:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FEParamGetTiposConcepto type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FEParamGetTiposConcepto*)p = *(_ns3__FEParamGetTiposConcepto*)q;
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposConceptoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FEParamGetTiposConceptoResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FEParamGetTiposConceptoResponse*)p = *(_ns3__FEParamGetTiposConceptoResponse*)q;
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetPtosVenta:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FEParamGetPtosVenta type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FEParamGetPtosVenta*)p = *(_ns3__FEParamGetPtosVenta*)q;
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetPtosVentaResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FEParamGetPtosVentaResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FEParamGetPtosVentaResponse*)p = *(_ns3__FEParamGetPtosVentaResponse*)q;
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposCbte:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FEParamGetTiposCbte type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FEParamGetTiposCbte*)p = *(_ns3__FEParamGetTiposCbte*)q;
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposCbteResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FEParamGetTiposCbteResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FEParamGetTiposCbteResponse*)p = *(_ns3__FEParamGetTiposCbteResponse*)q;
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposDoc:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FEParamGetTiposDoc type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FEParamGetTiposDoc*)p = *(_ns3__FEParamGetTiposDoc*)q;
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposDocResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FEParamGetTiposDocResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FEParamGetTiposDocResponse*)p = *(_ns3__FEParamGetTiposDocResponse*)q;
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposPaises:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FEParamGetTiposPaises type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FEParamGetTiposPaises*)p = *(_ns3__FEParamGetTiposPaises*)q;
		break;
	case SOAP_TYPE_afip__ns3__FEParamGetTiposPaisesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns3__FEParamGetTiposPaisesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns3__FEParamGetTiposPaisesResponse*)p = *(_ns3__FEParamGetTiposPaisesResponse*)q;
		break;
	case SOAP_TYPE_afip_ns3__FECAECabRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__FECAECabRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns3__FECAECabRequest*)p = *(ns3__FECAECabRequest*)q;
		break;
	case SOAP_TYPE_afip_ns3__FECAEDetRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__FECAEDetRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns3__FECAEDetRequest*)p = *(ns3__FECAEDetRequest*)q;
		break;
	case SOAP_TYPE_afip_ns3__FECAECabResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__FECAECabResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns3__FECAECabResponse*)p = *(ns3__FECAECabResponse*)q;
		break;
	case SOAP_TYPE_afip_ns3__FECAEDetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__FECAEDetResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns3__FECAEDetResponse*)p = *(ns3__FECAEDetResponse*)q;
		break;
	case SOAP_TYPE_afip_ns3__FECAEACabRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__FECAEACabRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns3__FECAEACabRequest*)p = *(ns3__FECAEACabRequest*)q;
		break;
	case SOAP_TYPE_afip_ns3__FECAEADetRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__FECAEADetRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns3__FECAEADetRequest*)p = *(ns3__FECAEADetRequest*)q;
		break;
	case SOAP_TYPE_afip_ns3__FECAEACabResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__FECAEACabResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns3__FECAEACabResponse*)p = *(ns3__FECAEACabResponse*)q;
		break;
	case SOAP_TYPE_afip_ns3__FECAEADetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__FECAEADetResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns3__FECAEADetResponse*)p = *(ns3__FECAEADetResponse*)q;
		break;
	case SOAP_TYPE_afip_ns3__FECAEASinMovResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__FECAEASinMovResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns3__FECAEASinMovResponse*)p = *(ns3__FECAEASinMovResponse*)q;
		break;
	case SOAP_TYPE_afip_ns3__FECompConsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__FECompConsResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns3__FECompConsResponse*)p = *(ns3__FECompConsResponse*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_afip_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
	case SOAP_TYPE_afip___ns2__loginCms:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns2__loginCms type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns2__loginCms*)p = *(struct __ns2__loginCms*)q;
		break;
	case SOAP_TYPE_afip___ns3__FECAESolicitar:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FECAESolicitar type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FECAESolicitar*)p = *(struct __ns3__FECAESolicitar*)q;
		break;
	case SOAP_TYPE_afip___ns3__FECompTotXRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FECompTotXRequest type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FECompTotXRequest*)p = *(struct __ns3__FECompTotXRequest*)q;
		break;
	case SOAP_TYPE_afip___ns3__FEDummy:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FEDummy type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FEDummy*)p = *(struct __ns3__FEDummy*)q;
		break;
	case SOAP_TYPE_afip___ns3__FECompUltimoAutorizado:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FECompUltimoAutorizado type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FECompUltimoAutorizado*)p = *(struct __ns3__FECompUltimoAutorizado*)q;
		break;
	case SOAP_TYPE_afip___ns3__FECompConsultar:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FECompConsultar type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FECompConsultar*)p = *(struct __ns3__FECompConsultar*)q;
		break;
	case SOAP_TYPE_afip___ns3__FECAEARegInformativo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FECAEARegInformativo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FECAEARegInformativo*)p = *(struct __ns3__FECAEARegInformativo*)q;
		break;
	case SOAP_TYPE_afip___ns3__FECAEASolicitar:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FECAEASolicitar type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FECAEASolicitar*)p = *(struct __ns3__FECAEASolicitar*)q;
		break;
	case SOAP_TYPE_afip___ns3__FECAEASinMovimientoConsultar:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FECAEASinMovimientoConsultar type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FECAEASinMovimientoConsultar*)p = *(struct __ns3__FECAEASinMovimientoConsultar*)q;
		break;
	case SOAP_TYPE_afip___ns3__FECAEASinMovimientoInformar:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FECAEASinMovimientoInformar type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FECAEASinMovimientoInformar*)p = *(struct __ns3__FECAEASinMovimientoInformar*)q;
		break;
	case SOAP_TYPE_afip___ns3__FECAEAConsultar:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FECAEAConsultar type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FECAEAConsultar*)p = *(struct __ns3__FECAEAConsultar*)q;
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetCotizacion:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FEParamGetCotizacion type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FEParamGetCotizacion*)p = *(struct __ns3__FEParamGetCotizacion*)q;
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposTributos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FEParamGetTiposTributos type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FEParamGetTiposTributos*)p = *(struct __ns3__FEParamGetTiposTributos*)q;
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposMonedas:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FEParamGetTiposMonedas type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FEParamGetTiposMonedas*)p = *(struct __ns3__FEParamGetTiposMonedas*)q;
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposIva:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FEParamGetTiposIva type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FEParamGetTiposIva*)p = *(struct __ns3__FEParamGetTiposIva*)q;
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposOpcional:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FEParamGetTiposOpcional type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FEParamGetTiposOpcional*)p = *(struct __ns3__FEParamGetTiposOpcional*)q;
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposConcepto:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FEParamGetTiposConcepto type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FEParamGetTiposConcepto*)p = *(struct __ns3__FEParamGetTiposConcepto*)q;
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetPtosVenta:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FEParamGetPtosVenta type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FEParamGetPtosVenta*)p = *(struct __ns3__FEParamGetPtosVenta*)q;
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposCbte:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FEParamGetTiposCbte type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FEParamGetTiposCbte*)p = *(struct __ns3__FEParamGetTiposCbte*)q;
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposDoc:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FEParamGetTiposDoc type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FEParamGetTiposDoc*)p = *(struct __ns3__FEParamGetTiposDoc*)q;
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposPaises:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FEParamGetTiposPaises type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FEParamGetTiposPaises*)p = *(struct __ns3__FEParamGetTiposPaises*)q;
		break;
	case SOAP_TYPE_afip___ns3__FECAESolicitar_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FECAESolicitar_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FECAESolicitar_*)p = *(struct __ns3__FECAESolicitar_*)q;
		break;
	case SOAP_TYPE_afip___ns3__FECompTotXRequest_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FECompTotXRequest_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FECompTotXRequest_*)p = *(struct __ns3__FECompTotXRequest_*)q;
		break;
	case SOAP_TYPE_afip___ns3__FEDummy_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FEDummy_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FEDummy_*)p = *(struct __ns3__FEDummy_*)q;
		break;
	case SOAP_TYPE_afip___ns3__FECompUltimoAutorizado_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FECompUltimoAutorizado_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FECompUltimoAutorizado_*)p = *(struct __ns3__FECompUltimoAutorizado_*)q;
		break;
	case SOAP_TYPE_afip___ns3__FECompConsultar_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FECompConsultar_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FECompConsultar_*)p = *(struct __ns3__FECompConsultar_*)q;
		break;
	case SOAP_TYPE_afip___ns3__FECAEARegInformativo_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FECAEARegInformativo_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FECAEARegInformativo_*)p = *(struct __ns3__FECAEARegInformativo_*)q;
		break;
	case SOAP_TYPE_afip___ns3__FECAEASolicitar_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FECAEASolicitar_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FECAEASolicitar_*)p = *(struct __ns3__FECAEASolicitar_*)q;
		break;
	case SOAP_TYPE_afip___ns3__FECAEASinMovimientoConsultar_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FECAEASinMovimientoConsultar_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FECAEASinMovimientoConsultar_*)p = *(struct __ns3__FECAEASinMovimientoConsultar_*)q;
		break;
	case SOAP_TYPE_afip___ns3__FECAEASinMovimientoInformar_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FECAEASinMovimientoInformar_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FECAEASinMovimientoInformar_*)p = *(struct __ns3__FECAEASinMovimientoInformar_*)q;
		break;
	case SOAP_TYPE_afip___ns3__FECAEAConsultar_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FECAEAConsultar_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FECAEAConsultar_*)p = *(struct __ns3__FECAEAConsultar_*)q;
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetCotizacion_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FEParamGetCotizacion_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FEParamGetCotizacion_*)p = *(struct __ns3__FEParamGetCotizacion_*)q;
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposTributos_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FEParamGetTiposTributos_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FEParamGetTiposTributos_*)p = *(struct __ns3__FEParamGetTiposTributos_*)q;
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposMonedas_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FEParamGetTiposMonedas_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FEParamGetTiposMonedas_*)p = *(struct __ns3__FEParamGetTiposMonedas_*)q;
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposIva_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FEParamGetTiposIva_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FEParamGetTiposIva_*)p = *(struct __ns3__FEParamGetTiposIva_*)q;
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposOpcional_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FEParamGetTiposOpcional_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FEParamGetTiposOpcional_*)p = *(struct __ns3__FEParamGetTiposOpcional_*)q;
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposConcepto_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FEParamGetTiposConcepto_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FEParamGetTiposConcepto_*)p = *(struct __ns3__FEParamGetTiposConcepto_*)q;
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetPtosVenta_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FEParamGetPtosVenta_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FEParamGetPtosVenta_*)p = *(struct __ns3__FEParamGetPtosVenta_*)q;
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposCbte_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FEParamGetTiposCbte_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FEParamGetTiposCbte_*)p = *(struct __ns3__FEParamGetTiposCbte_*)q;
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposDoc_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FEParamGetTiposDoc_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FEParamGetTiposDoc_*)p = *(struct __ns3__FEParamGetTiposDoc_*)q;
		break;
	case SOAP_TYPE_afip___ns3__FEParamGetTiposPaises_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns3__FEParamGetTiposPaises_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns3__FEParamGetTiposPaises_*)p = *(struct __ns3__FEParamGetTiposPaises_*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_afip_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_afip_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_afip_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_afip_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_afip_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_afip_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_short(struct soap *soap, const char *tag, int id, const short *a, const char *type)
{
	return soap_outshort(soap, tag, id, a, type, SOAP_TYPE_afip_short);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_in_short(struct soap *soap, const char *tag, short *a, const char *type)
{
	a = soap_inshort(soap, tag, a, type, SOAP_TYPE_afip_short);
	return a;
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_new_short(struct soap *soap, int n)
{
	short *a = static_cast<short *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(short)));
	for (short *p = a; p && n--; ++p)
		soap_default_short(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_short(struct soap *soap, const short *a, const char *tag, const char *type)
{
	if (soap_out_short(soap, tag ? tag : "short", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_get_short(struct soap *soap, short *p, const char *tag, const char *type)
{
	if ((p = soap_in_short(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_afip_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_afip_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_afip_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	a = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_afip_LONG64);
	return a;
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_new_LONG64(struct soap *soap, int n)
{
	LONG64 *a = static_cast<LONG64 *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(LONG64)));
	for (LONG64 *p = a; p && n--; ++p)
		soap_default_LONG64(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	if (soap_out_LONG64(soap, tag ? tag : "long", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_afip_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	a = soap_indouble(soap, tag, a, type, SOAP_TYPE_afip_double);
	return a;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_new_double(struct soap *soap, int n)
{
	double *a = static_cast<double *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(double)));
	for (double *p = a; p && n--; ++p)
		soap_default_double(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	if (soap_out_double(soap, tag ? tag : "double", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_afip_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_afip_std__string, sizeof(std::string), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_afip_std__string, sizeof(std::string), soap->type, soap->arrayType, afip_instantiate, afip_fbase), 0, SOAP_TYPE_afip_std__string, SOAP_TYPE_afip_std__string, sizeof(std::string), 0, afip_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_std__string, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FEParamGetTiposPaisesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FEParamGetTiposPaisesResponse::FEParamGetTiposPaisesResult = NULL;
}

void _ns3__FEParamGetTiposPaisesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FEPaisResponse(soap, &this->_ns3__FEParamGetTiposPaisesResponse::FEParamGetTiposPaisesResult);
#endif
}

int _ns3__FEParamGetTiposPaisesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FEParamGetTiposPaisesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FEParamGetTiposPaisesResponse(struct soap *soap, const char *tag, int id, const _ns3__FEParamGetTiposPaisesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FEParamGetTiposPaisesResponse), type))
		return soap->error;
	if (a->FEParamGetTiposPaisesResult)
		soap_element_result(soap, "ns3:FEParamGetTiposPaisesResult");
	if (soap_out_PointerTons3__FEPaisResponse(soap, "ns3:FEParamGetTiposPaisesResult", -1, &a->_ns3__FEParamGetTiposPaisesResponse::FEParamGetTiposPaisesResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FEParamGetTiposPaisesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FEParamGetTiposPaisesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FEParamGetTiposPaisesResponse * SOAP_FMAC4 soap_in__ns3__FEParamGetTiposPaisesResponse(struct soap *soap, const char *tag, _ns3__FEParamGetTiposPaisesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FEParamGetTiposPaisesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FEParamGetTiposPaisesResponse, sizeof(_ns3__FEParamGetTiposPaisesResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FEParamGetTiposPaisesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FEParamGetTiposPaisesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FEParamGetTiposPaisesResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FEParamGetTiposPaisesResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FEPaisResponse(soap, "ns3:FEParamGetTiposPaisesResult", &a->_ns3__FEParamGetTiposPaisesResponse::FEParamGetTiposPaisesResult, "ns3:FEPaisResponse"))
				{	soap_flag_FEParamGetTiposPaisesResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns3:FEParamGetTiposPaisesResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FEParamGetTiposPaisesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FEParamGetTiposPaisesResponse, SOAP_TYPE_afip__ns3__FEParamGetTiposPaisesResponse, sizeof(_ns3__FEParamGetTiposPaisesResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FEParamGetTiposPaisesResponse * SOAP_FMAC2 soap_instantiate__ns3__FEParamGetTiposPaisesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FEParamGetTiposPaisesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FEParamGetTiposPaisesResponse *p;
	size_t k = sizeof(_ns3__FEParamGetTiposPaisesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FEParamGetTiposPaisesResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FEParamGetTiposPaisesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FEParamGetTiposPaisesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FEParamGetTiposPaisesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FEParamGetTiposPaisesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FEParamGetTiposPaisesResponse(soap, tag ? tag : "ns3:FEParamGetTiposPaisesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FEParamGetTiposPaisesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FEParamGetTiposPaisesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FEParamGetTiposPaisesResponse * SOAP_FMAC4 soap_get__ns3__FEParamGetTiposPaisesResponse(struct soap *soap, _ns3__FEParamGetTiposPaisesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FEParamGetTiposPaisesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FEParamGetTiposPaises::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FEParamGetTiposPaises::Auth = NULL;
}

void _ns3__FEParamGetTiposPaises::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FEAuthRequest(soap, &this->_ns3__FEParamGetTiposPaises::Auth);
#endif
}

int _ns3__FEParamGetTiposPaises::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FEParamGetTiposPaises(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FEParamGetTiposPaises(struct soap *soap, const char *tag, int id, const _ns3__FEParamGetTiposPaises *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FEParamGetTiposPaises), type))
		return soap->error;
	if (soap_out_PointerTons3__FEAuthRequest(soap, "ns3:Auth", -1, &a->_ns3__FEParamGetTiposPaises::Auth, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FEParamGetTiposPaises::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FEParamGetTiposPaises(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FEParamGetTiposPaises * SOAP_FMAC4 soap_in__ns3__FEParamGetTiposPaises(struct soap *soap, const char *tag, _ns3__FEParamGetTiposPaises *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FEParamGetTiposPaises*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FEParamGetTiposPaises, sizeof(_ns3__FEParamGetTiposPaises), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FEParamGetTiposPaises)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FEParamGetTiposPaises *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FEAuthRequest(soap, "ns3:Auth", &a->_ns3__FEParamGetTiposPaises::Auth, "ns3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FEParamGetTiposPaises *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FEParamGetTiposPaises, SOAP_TYPE_afip__ns3__FEParamGetTiposPaises, sizeof(_ns3__FEParamGetTiposPaises), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FEParamGetTiposPaises * SOAP_FMAC2 soap_instantiate__ns3__FEParamGetTiposPaises(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FEParamGetTiposPaises(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FEParamGetTiposPaises *p;
	size_t k = sizeof(_ns3__FEParamGetTiposPaises);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FEParamGetTiposPaises, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FEParamGetTiposPaises);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FEParamGetTiposPaises, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FEParamGetTiposPaises location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FEParamGetTiposPaises::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FEParamGetTiposPaises(soap, tag ? tag : "ns3:FEParamGetTiposPaises", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FEParamGetTiposPaises::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FEParamGetTiposPaises(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FEParamGetTiposPaises * SOAP_FMAC4 soap_get__ns3__FEParamGetTiposPaises(struct soap *soap, _ns3__FEParamGetTiposPaises *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FEParamGetTiposPaises(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FEParamGetTiposDocResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FEParamGetTiposDocResponse::FEParamGetTiposDocResult = NULL;
}

void _ns3__FEParamGetTiposDocResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__DocTipoResponse(soap, &this->_ns3__FEParamGetTiposDocResponse::FEParamGetTiposDocResult);
#endif
}

int _ns3__FEParamGetTiposDocResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FEParamGetTiposDocResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FEParamGetTiposDocResponse(struct soap *soap, const char *tag, int id, const _ns3__FEParamGetTiposDocResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FEParamGetTiposDocResponse), type))
		return soap->error;
	if (a->FEParamGetTiposDocResult)
		soap_element_result(soap, "ns3:FEParamGetTiposDocResult");
	if (soap_out_PointerTons3__DocTipoResponse(soap, "ns3:FEParamGetTiposDocResult", -1, &a->_ns3__FEParamGetTiposDocResponse::FEParamGetTiposDocResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FEParamGetTiposDocResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FEParamGetTiposDocResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FEParamGetTiposDocResponse * SOAP_FMAC4 soap_in__ns3__FEParamGetTiposDocResponse(struct soap *soap, const char *tag, _ns3__FEParamGetTiposDocResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FEParamGetTiposDocResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FEParamGetTiposDocResponse, sizeof(_ns3__FEParamGetTiposDocResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FEParamGetTiposDocResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FEParamGetTiposDocResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FEParamGetTiposDocResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FEParamGetTiposDocResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__DocTipoResponse(soap, "ns3:FEParamGetTiposDocResult", &a->_ns3__FEParamGetTiposDocResponse::FEParamGetTiposDocResult, "ns3:DocTipoResponse"))
				{	soap_flag_FEParamGetTiposDocResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns3:FEParamGetTiposDocResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FEParamGetTiposDocResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FEParamGetTiposDocResponse, SOAP_TYPE_afip__ns3__FEParamGetTiposDocResponse, sizeof(_ns3__FEParamGetTiposDocResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FEParamGetTiposDocResponse * SOAP_FMAC2 soap_instantiate__ns3__FEParamGetTiposDocResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FEParamGetTiposDocResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FEParamGetTiposDocResponse *p;
	size_t k = sizeof(_ns3__FEParamGetTiposDocResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FEParamGetTiposDocResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FEParamGetTiposDocResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FEParamGetTiposDocResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FEParamGetTiposDocResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FEParamGetTiposDocResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FEParamGetTiposDocResponse(soap, tag ? tag : "ns3:FEParamGetTiposDocResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FEParamGetTiposDocResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FEParamGetTiposDocResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FEParamGetTiposDocResponse * SOAP_FMAC4 soap_get__ns3__FEParamGetTiposDocResponse(struct soap *soap, _ns3__FEParamGetTiposDocResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FEParamGetTiposDocResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FEParamGetTiposDoc::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FEParamGetTiposDoc::Auth = NULL;
}

void _ns3__FEParamGetTiposDoc::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FEAuthRequest(soap, &this->_ns3__FEParamGetTiposDoc::Auth);
#endif
}

int _ns3__FEParamGetTiposDoc::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FEParamGetTiposDoc(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FEParamGetTiposDoc(struct soap *soap, const char *tag, int id, const _ns3__FEParamGetTiposDoc *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FEParamGetTiposDoc), type))
		return soap->error;
	if (soap_out_PointerTons3__FEAuthRequest(soap, "ns3:Auth", -1, &a->_ns3__FEParamGetTiposDoc::Auth, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FEParamGetTiposDoc::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FEParamGetTiposDoc(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FEParamGetTiposDoc * SOAP_FMAC4 soap_in__ns3__FEParamGetTiposDoc(struct soap *soap, const char *tag, _ns3__FEParamGetTiposDoc *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FEParamGetTiposDoc*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FEParamGetTiposDoc, sizeof(_ns3__FEParamGetTiposDoc), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FEParamGetTiposDoc)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FEParamGetTiposDoc *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FEAuthRequest(soap, "ns3:Auth", &a->_ns3__FEParamGetTiposDoc::Auth, "ns3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FEParamGetTiposDoc *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FEParamGetTiposDoc, SOAP_TYPE_afip__ns3__FEParamGetTiposDoc, sizeof(_ns3__FEParamGetTiposDoc), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FEParamGetTiposDoc * SOAP_FMAC2 soap_instantiate__ns3__FEParamGetTiposDoc(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FEParamGetTiposDoc(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FEParamGetTiposDoc *p;
	size_t k = sizeof(_ns3__FEParamGetTiposDoc);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FEParamGetTiposDoc, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FEParamGetTiposDoc);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FEParamGetTiposDoc, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FEParamGetTiposDoc location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FEParamGetTiposDoc::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FEParamGetTiposDoc(soap, tag ? tag : "ns3:FEParamGetTiposDoc", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FEParamGetTiposDoc::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FEParamGetTiposDoc(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FEParamGetTiposDoc * SOAP_FMAC4 soap_get__ns3__FEParamGetTiposDoc(struct soap *soap, _ns3__FEParamGetTiposDoc *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FEParamGetTiposDoc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FEParamGetTiposCbteResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FEParamGetTiposCbteResponse::FEParamGetTiposCbteResult = NULL;
}

void _ns3__FEParamGetTiposCbteResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__CbteTipoResponse(soap, &this->_ns3__FEParamGetTiposCbteResponse::FEParamGetTiposCbteResult);
#endif
}

int _ns3__FEParamGetTiposCbteResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FEParamGetTiposCbteResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FEParamGetTiposCbteResponse(struct soap *soap, const char *tag, int id, const _ns3__FEParamGetTiposCbteResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FEParamGetTiposCbteResponse), type))
		return soap->error;
	if (a->FEParamGetTiposCbteResult)
		soap_element_result(soap, "ns3:FEParamGetTiposCbteResult");
	if (soap_out_PointerTons3__CbteTipoResponse(soap, "ns3:FEParamGetTiposCbteResult", -1, &a->_ns3__FEParamGetTiposCbteResponse::FEParamGetTiposCbteResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FEParamGetTiposCbteResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FEParamGetTiposCbteResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FEParamGetTiposCbteResponse * SOAP_FMAC4 soap_in__ns3__FEParamGetTiposCbteResponse(struct soap *soap, const char *tag, _ns3__FEParamGetTiposCbteResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FEParamGetTiposCbteResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FEParamGetTiposCbteResponse, sizeof(_ns3__FEParamGetTiposCbteResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FEParamGetTiposCbteResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FEParamGetTiposCbteResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FEParamGetTiposCbteResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FEParamGetTiposCbteResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__CbteTipoResponse(soap, "ns3:FEParamGetTiposCbteResult", &a->_ns3__FEParamGetTiposCbteResponse::FEParamGetTiposCbteResult, "ns3:CbteTipoResponse"))
				{	soap_flag_FEParamGetTiposCbteResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns3:FEParamGetTiposCbteResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FEParamGetTiposCbteResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FEParamGetTiposCbteResponse, SOAP_TYPE_afip__ns3__FEParamGetTiposCbteResponse, sizeof(_ns3__FEParamGetTiposCbteResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FEParamGetTiposCbteResponse * SOAP_FMAC2 soap_instantiate__ns3__FEParamGetTiposCbteResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FEParamGetTiposCbteResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FEParamGetTiposCbteResponse *p;
	size_t k = sizeof(_ns3__FEParamGetTiposCbteResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FEParamGetTiposCbteResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FEParamGetTiposCbteResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FEParamGetTiposCbteResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FEParamGetTiposCbteResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FEParamGetTiposCbteResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FEParamGetTiposCbteResponse(soap, tag ? tag : "ns3:FEParamGetTiposCbteResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FEParamGetTiposCbteResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FEParamGetTiposCbteResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FEParamGetTiposCbteResponse * SOAP_FMAC4 soap_get__ns3__FEParamGetTiposCbteResponse(struct soap *soap, _ns3__FEParamGetTiposCbteResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FEParamGetTiposCbteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FEParamGetTiposCbte::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FEParamGetTiposCbte::Auth = NULL;
}

void _ns3__FEParamGetTiposCbte::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FEAuthRequest(soap, &this->_ns3__FEParamGetTiposCbte::Auth);
#endif
}

int _ns3__FEParamGetTiposCbte::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FEParamGetTiposCbte(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FEParamGetTiposCbte(struct soap *soap, const char *tag, int id, const _ns3__FEParamGetTiposCbte *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FEParamGetTiposCbte), type))
		return soap->error;
	if (soap_out_PointerTons3__FEAuthRequest(soap, "ns3:Auth", -1, &a->_ns3__FEParamGetTiposCbte::Auth, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FEParamGetTiposCbte::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FEParamGetTiposCbte(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FEParamGetTiposCbte * SOAP_FMAC4 soap_in__ns3__FEParamGetTiposCbte(struct soap *soap, const char *tag, _ns3__FEParamGetTiposCbte *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FEParamGetTiposCbte*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FEParamGetTiposCbte, sizeof(_ns3__FEParamGetTiposCbte), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FEParamGetTiposCbte)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FEParamGetTiposCbte *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FEAuthRequest(soap, "ns3:Auth", &a->_ns3__FEParamGetTiposCbte::Auth, "ns3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FEParamGetTiposCbte *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FEParamGetTiposCbte, SOAP_TYPE_afip__ns3__FEParamGetTiposCbte, sizeof(_ns3__FEParamGetTiposCbte), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FEParamGetTiposCbte * SOAP_FMAC2 soap_instantiate__ns3__FEParamGetTiposCbte(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FEParamGetTiposCbte(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FEParamGetTiposCbte *p;
	size_t k = sizeof(_ns3__FEParamGetTiposCbte);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FEParamGetTiposCbte, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FEParamGetTiposCbte);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FEParamGetTiposCbte, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FEParamGetTiposCbte location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FEParamGetTiposCbte::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FEParamGetTiposCbte(soap, tag ? tag : "ns3:FEParamGetTiposCbte", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FEParamGetTiposCbte::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FEParamGetTiposCbte(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FEParamGetTiposCbte * SOAP_FMAC4 soap_get__ns3__FEParamGetTiposCbte(struct soap *soap, _ns3__FEParamGetTiposCbte *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FEParamGetTiposCbte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FEParamGetPtosVentaResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FEParamGetPtosVentaResponse::FEParamGetPtosVentaResult = NULL;
}

void _ns3__FEParamGetPtosVentaResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FEPtoVentaResponse(soap, &this->_ns3__FEParamGetPtosVentaResponse::FEParamGetPtosVentaResult);
#endif
}

int _ns3__FEParamGetPtosVentaResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FEParamGetPtosVentaResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FEParamGetPtosVentaResponse(struct soap *soap, const char *tag, int id, const _ns3__FEParamGetPtosVentaResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FEParamGetPtosVentaResponse), type))
		return soap->error;
	if (a->FEParamGetPtosVentaResult)
		soap_element_result(soap, "ns3:FEParamGetPtosVentaResult");
	if (soap_out_PointerTons3__FEPtoVentaResponse(soap, "ns3:FEParamGetPtosVentaResult", -1, &a->_ns3__FEParamGetPtosVentaResponse::FEParamGetPtosVentaResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FEParamGetPtosVentaResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FEParamGetPtosVentaResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FEParamGetPtosVentaResponse * SOAP_FMAC4 soap_in__ns3__FEParamGetPtosVentaResponse(struct soap *soap, const char *tag, _ns3__FEParamGetPtosVentaResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FEParamGetPtosVentaResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FEParamGetPtosVentaResponse, sizeof(_ns3__FEParamGetPtosVentaResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FEParamGetPtosVentaResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FEParamGetPtosVentaResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FEParamGetPtosVentaResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FEParamGetPtosVentaResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FEPtoVentaResponse(soap, "ns3:FEParamGetPtosVentaResult", &a->_ns3__FEParamGetPtosVentaResponse::FEParamGetPtosVentaResult, "ns3:FEPtoVentaResponse"))
				{	soap_flag_FEParamGetPtosVentaResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns3:FEParamGetPtosVentaResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FEParamGetPtosVentaResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FEParamGetPtosVentaResponse, SOAP_TYPE_afip__ns3__FEParamGetPtosVentaResponse, sizeof(_ns3__FEParamGetPtosVentaResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FEParamGetPtosVentaResponse * SOAP_FMAC2 soap_instantiate__ns3__FEParamGetPtosVentaResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FEParamGetPtosVentaResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FEParamGetPtosVentaResponse *p;
	size_t k = sizeof(_ns3__FEParamGetPtosVentaResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FEParamGetPtosVentaResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FEParamGetPtosVentaResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FEParamGetPtosVentaResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FEParamGetPtosVentaResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FEParamGetPtosVentaResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FEParamGetPtosVentaResponse(soap, tag ? tag : "ns3:FEParamGetPtosVentaResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FEParamGetPtosVentaResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FEParamGetPtosVentaResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FEParamGetPtosVentaResponse * SOAP_FMAC4 soap_get__ns3__FEParamGetPtosVentaResponse(struct soap *soap, _ns3__FEParamGetPtosVentaResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FEParamGetPtosVentaResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FEParamGetPtosVenta::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FEParamGetPtosVenta::Auth = NULL;
}

void _ns3__FEParamGetPtosVenta::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FEAuthRequest(soap, &this->_ns3__FEParamGetPtosVenta::Auth);
#endif
}

int _ns3__FEParamGetPtosVenta::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FEParamGetPtosVenta(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FEParamGetPtosVenta(struct soap *soap, const char *tag, int id, const _ns3__FEParamGetPtosVenta *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FEParamGetPtosVenta), type))
		return soap->error;
	if (soap_out_PointerTons3__FEAuthRequest(soap, "ns3:Auth", -1, &a->_ns3__FEParamGetPtosVenta::Auth, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FEParamGetPtosVenta::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FEParamGetPtosVenta(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FEParamGetPtosVenta * SOAP_FMAC4 soap_in__ns3__FEParamGetPtosVenta(struct soap *soap, const char *tag, _ns3__FEParamGetPtosVenta *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FEParamGetPtosVenta*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FEParamGetPtosVenta, sizeof(_ns3__FEParamGetPtosVenta), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FEParamGetPtosVenta)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FEParamGetPtosVenta *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FEAuthRequest(soap, "ns3:Auth", &a->_ns3__FEParamGetPtosVenta::Auth, "ns3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FEParamGetPtosVenta *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FEParamGetPtosVenta, SOAP_TYPE_afip__ns3__FEParamGetPtosVenta, sizeof(_ns3__FEParamGetPtosVenta), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FEParamGetPtosVenta * SOAP_FMAC2 soap_instantiate__ns3__FEParamGetPtosVenta(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FEParamGetPtosVenta(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FEParamGetPtosVenta *p;
	size_t k = sizeof(_ns3__FEParamGetPtosVenta);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FEParamGetPtosVenta, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FEParamGetPtosVenta);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FEParamGetPtosVenta, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FEParamGetPtosVenta location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FEParamGetPtosVenta::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FEParamGetPtosVenta(soap, tag ? tag : "ns3:FEParamGetPtosVenta", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FEParamGetPtosVenta::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FEParamGetPtosVenta(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FEParamGetPtosVenta * SOAP_FMAC4 soap_get__ns3__FEParamGetPtosVenta(struct soap *soap, _ns3__FEParamGetPtosVenta *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FEParamGetPtosVenta(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FEParamGetTiposConceptoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FEParamGetTiposConceptoResponse::FEParamGetTiposConceptoResult = NULL;
}

void _ns3__FEParamGetTiposConceptoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__ConceptoTipoResponse(soap, &this->_ns3__FEParamGetTiposConceptoResponse::FEParamGetTiposConceptoResult);
#endif
}

int _ns3__FEParamGetTiposConceptoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FEParamGetTiposConceptoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FEParamGetTiposConceptoResponse(struct soap *soap, const char *tag, int id, const _ns3__FEParamGetTiposConceptoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FEParamGetTiposConceptoResponse), type))
		return soap->error;
	if (a->FEParamGetTiposConceptoResult)
		soap_element_result(soap, "ns3:FEParamGetTiposConceptoResult");
	if (soap_out_PointerTons3__ConceptoTipoResponse(soap, "ns3:FEParamGetTiposConceptoResult", -1, &a->_ns3__FEParamGetTiposConceptoResponse::FEParamGetTiposConceptoResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FEParamGetTiposConceptoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FEParamGetTiposConceptoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FEParamGetTiposConceptoResponse * SOAP_FMAC4 soap_in__ns3__FEParamGetTiposConceptoResponse(struct soap *soap, const char *tag, _ns3__FEParamGetTiposConceptoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FEParamGetTiposConceptoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FEParamGetTiposConceptoResponse, sizeof(_ns3__FEParamGetTiposConceptoResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FEParamGetTiposConceptoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FEParamGetTiposConceptoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FEParamGetTiposConceptoResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FEParamGetTiposConceptoResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ConceptoTipoResponse(soap, "ns3:FEParamGetTiposConceptoResult", &a->_ns3__FEParamGetTiposConceptoResponse::FEParamGetTiposConceptoResult, "ns3:ConceptoTipoResponse"))
				{	soap_flag_FEParamGetTiposConceptoResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns3:FEParamGetTiposConceptoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FEParamGetTiposConceptoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FEParamGetTiposConceptoResponse, SOAP_TYPE_afip__ns3__FEParamGetTiposConceptoResponse, sizeof(_ns3__FEParamGetTiposConceptoResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FEParamGetTiposConceptoResponse * SOAP_FMAC2 soap_instantiate__ns3__FEParamGetTiposConceptoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FEParamGetTiposConceptoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FEParamGetTiposConceptoResponse *p;
	size_t k = sizeof(_ns3__FEParamGetTiposConceptoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FEParamGetTiposConceptoResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FEParamGetTiposConceptoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FEParamGetTiposConceptoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FEParamGetTiposConceptoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FEParamGetTiposConceptoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FEParamGetTiposConceptoResponse(soap, tag ? tag : "ns3:FEParamGetTiposConceptoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FEParamGetTiposConceptoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FEParamGetTiposConceptoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FEParamGetTiposConceptoResponse * SOAP_FMAC4 soap_get__ns3__FEParamGetTiposConceptoResponse(struct soap *soap, _ns3__FEParamGetTiposConceptoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FEParamGetTiposConceptoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FEParamGetTiposConcepto::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FEParamGetTiposConcepto::Auth = NULL;
}

void _ns3__FEParamGetTiposConcepto::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FEAuthRequest(soap, &this->_ns3__FEParamGetTiposConcepto::Auth);
#endif
}

int _ns3__FEParamGetTiposConcepto::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FEParamGetTiposConcepto(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FEParamGetTiposConcepto(struct soap *soap, const char *tag, int id, const _ns3__FEParamGetTiposConcepto *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FEParamGetTiposConcepto), type))
		return soap->error;
	if (soap_out_PointerTons3__FEAuthRequest(soap, "ns3:Auth", -1, &a->_ns3__FEParamGetTiposConcepto::Auth, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FEParamGetTiposConcepto::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FEParamGetTiposConcepto(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FEParamGetTiposConcepto * SOAP_FMAC4 soap_in__ns3__FEParamGetTiposConcepto(struct soap *soap, const char *tag, _ns3__FEParamGetTiposConcepto *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FEParamGetTiposConcepto*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FEParamGetTiposConcepto, sizeof(_ns3__FEParamGetTiposConcepto), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FEParamGetTiposConcepto)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FEParamGetTiposConcepto *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FEAuthRequest(soap, "ns3:Auth", &a->_ns3__FEParamGetTiposConcepto::Auth, "ns3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FEParamGetTiposConcepto *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FEParamGetTiposConcepto, SOAP_TYPE_afip__ns3__FEParamGetTiposConcepto, sizeof(_ns3__FEParamGetTiposConcepto), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FEParamGetTiposConcepto * SOAP_FMAC2 soap_instantiate__ns3__FEParamGetTiposConcepto(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FEParamGetTiposConcepto(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FEParamGetTiposConcepto *p;
	size_t k = sizeof(_ns3__FEParamGetTiposConcepto);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FEParamGetTiposConcepto, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FEParamGetTiposConcepto);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FEParamGetTiposConcepto, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FEParamGetTiposConcepto location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FEParamGetTiposConcepto::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FEParamGetTiposConcepto(soap, tag ? tag : "ns3:FEParamGetTiposConcepto", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FEParamGetTiposConcepto::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FEParamGetTiposConcepto(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FEParamGetTiposConcepto * SOAP_FMAC4 soap_get__ns3__FEParamGetTiposConcepto(struct soap *soap, _ns3__FEParamGetTiposConcepto *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FEParamGetTiposConcepto(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FEParamGetTiposOpcionalResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FEParamGetTiposOpcionalResponse::FEParamGetTiposOpcionalResult = NULL;
}

void _ns3__FEParamGetTiposOpcionalResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__OpcionalTipoResponse(soap, &this->_ns3__FEParamGetTiposOpcionalResponse::FEParamGetTiposOpcionalResult);
#endif
}

int _ns3__FEParamGetTiposOpcionalResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FEParamGetTiposOpcionalResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FEParamGetTiposOpcionalResponse(struct soap *soap, const char *tag, int id, const _ns3__FEParamGetTiposOpcionalResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FEParamGetTiposOpcionalResponse), type))
		return soap->error;
	if (a->FEParamGetTiposOpcionalResult)
		soap_element_result(soap, "ns3:FEParamGetTiposOpcionalResult");
	if (soap_out_PointerTons3__OpcionalTipoResponse(soap, "ns3:FEParamGetTiposOpcionalResult", -1, &a->_ns3__FEParamGetTiposOpcionalResponse::FEParamGetTiposOpcionalResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FEParamGetTiposOpcionalResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FEParamGetTiposOpcionalResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FEParamGetTiposOpcionalResponse * SOAP_FMAC4 soap_in__ns3__FEParamGetTiposOpcionalResponse(struct soap *soap, const char *tag, _ns3__FEParamGetTiposOpcionalResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FEParamGetTiposOpcionalResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FEParamGetTiposOpcionalResponse, sizeof(_ns3__FEParamGetTiposOpcionalResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FEParamGetTiposOpcionalResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FEParamGetTiposOpcionalResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FEParamGetTiposOpcionalResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FEParamGetTiposOpcionalResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__OpcionalTipoResponse(soap, "ns3:FEParamGetTiposOpcionalResult", &a->_ns3__FEParamGetTiposOpcionalResponse::FEParamGetTiposOpcionalResult, "ns3:OpcionalTipoResponse"))
				{	soap_flag_FEParamGetTiposOpcionalResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns3:FEParamGetTiposOpcionalResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FEParamGetTiposOpcionalResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FEParamGetTiposOpcionalResponse, SOAP_TYPE_afip__ns3__FEParamGetTiposOpcionalResponse, sizeof(_ns3__FEParamGetTiposOpcionalResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FEParamGetTiposOpcionalResponse * SOAP_FMAC2 soap_instantiate__ns3__FEParamGetTiposOpcionalResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FEParamGetTiposOpcionalResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FEParamGetTiposOpcionalResponse *p;
	size_t k = sizeof(_ns3__FEParamGetTiposOpcionalResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FEParamGetTiposOpcionalResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FEParamGetTiposOpcionalResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FEParamGetTiposOpcionalResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FEParamGetTiposOpcionalResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FEParamGetTiposOpcionalResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FEParamGetTiposOpcionalResponse(soap, tag ? tag : "ns3:FEParamGetTiposOpcionalResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FEParamGetTiposOpcionalResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FEParamGetTiposOpcionalResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FEParamGetTiposOpcionalResponse * SOAP_FMAC4 soap_get__ns3__FEParamGetTiposOpcionalResponse(struct soap *soap, _ns3__FEParamGetTiposOpcionalResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FEParamGetTiposOpcionalResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FEParamGetTiposOpcional::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FEParamGetTiposOpcional::Auth = NULL;
}

void _ns3__FEParamGetTiposOpcional::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FEAuthRequest(soap, &this->_ns3__FEParamGetTiposOpcional::Auth);
#endif
}

int _ns3__FEParamGetTiposOpcional::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FEParamGetTiposOpcional(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FEParamGetTiposOpcional(struct soap *soap, const char *tag, int id, const _ns3__FEParamGetTiposOpcional *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FEParamGetTiposOpcional), type))
		return soap->error;
	if (soap_out_PointerTons3__FEAuthRequest(soap, "ns3:Auth", -1, &a->_ns3__FEParamGetTiposOpcional::Auth, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FEParamGetTiposOpcional::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FEParamGetTiposOpcional(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FEParamGetTiposOpcional * SOAP_FMAC4 soap_in__ns3__FEParamGetTiposOpcional(struct soap *soap, const char *tag, _ns3__FEParamGetTiposOpcional *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FEParamGetTiposOpcional*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FEParamGetTiposOpcional, sizeof(_ns3__FEParamGetTiposOpcional), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FEParamGetTiposOpcional)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FEParamGetTiposOpcional *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FEAuthRequest(soap, "ns3:Auth", &a->_ns3__FEParamGetTiposOpcional::Auth, "ns3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FEParamGetTiposOpcional *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FEParamGetTiposOpcional, SOAP_TYPE_afip__ns3__FEParamGetTiposOpcional, sizeof(_ns3__FEParamGetTiposOpcional), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FEParamGetTiposOpcional * SOAP_FMAC2 soap_instantiate__ns3__FEParamGetTiposOpcional(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FEParamGetTiposOpcional(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FEParamGetTiposOpcional *p;
	size_t k = sizeof(_ns3__FEParamGetTiposOpcional);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FEParamGetTiposOpcional, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FEParamGetTiposOpcional);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FEParamGetTiposOpcional, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FEParamGetTiposOpcional location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FEParamGetTiposOpcional::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FEParamGetTiposOpcional(soap, tag ? tag : "ns3:FEParamGetTiposOpcional", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FEParamGetTiposOpcional::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FEParamGetTiposOpcional(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FEParamGetTiposOpcional * SOAP_FMAC4 soap_get__ns3__FEParamGetTiposOpcional(struct soap *soap, _ns3__FEParamGetTiposOpcional *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FEParamGetTiposOpcional(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FEParamGetTiposIvaResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FEParamGetTiposIvaResponse::FEParamGetTiposIvaResult = NULL;
}

void _ns3__FEParamGetTiposIvaResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__IvaTipoResponse(soap, &this->_ns3__FEParamGetTiposIvaResponse::FEParamGetTiposIvaResult);
#endif
}

int _ns3__FEParamGetTiposIvaResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FEParamGetTiposIvaResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FEParamGetTiposIvaResponse(struct soap *soap, const char *tag, int id, const _ns3__FEParamGetTiposIvaResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FEParamGetTiposIvaResponse), type))
		return soap->error;
	if (a->FEParamGetTiposIvaResult)
		soap_element_result(soap, "ns3:FEParamGetTiposIvaResult");
	if (soap_out_PointerTons3__IvaTipoResponse(soap, "ns3:FEParamGetTiposIvaResult", -1, &a->_ns3__FEParamGetTiposIvaResponse::FEParamGetTiposIvaResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FEParamGetTiposIvaResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FEParamGetTiposIvaResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FEParamGetTiposIvaResponse * SOAP_FMAC4 soap_in__ns3__FEParamGetTiposIvaResponse(struct soap *soap, const char *tag, _ns3__FEParamGetTiposIvaResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FEParamGetTiposIvaResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FEParamGetTiposIvaResponse, sizeof(_ns3__FEParamGetTiposIvaResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FEParamGetTiposIvaResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FEParamGetTiposIvaResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FEParamGetTiposIvaResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FEParamGetTiposIvaResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__IvaTipoResponse(soap, "ns3:FEParamGetTiposIvaResult", &a->_ns3__FEParamGetTiposIvaResponse::FEParamGetTiposIvaResult, "ns3:IvaTipoResponse"))
				{	soap_flag_FEParamGetTiposIvaResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns3:FEParamGetTiposIvaResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FEParamGetTiposIvaResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FEParamGetTiposIvaResponse, SOAP_TYPE_afip__ns3__FEParamGetTiposIvaResponse, sizeof(_ns3__FEParamGetTiposIvaResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FEParamGetTiposIvaResponse * SOAP_FMAC2 soap_instantiate__ns3__FEParamGetTiposIvaResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FEParamGetTiposIvaResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FEParamGetTiposIvaResponse *p;
	size_t k = sizeof(_ns3__FEParamGetTiposIvaResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FEParamGetTiposIvaResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FEParamGetTiposIvaResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FEParamGetTiposIvaResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FEParamGetTiposIvaResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FEParamGetTiposIvaResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FEParamGetTiposIvaResponse(soap, tag ? tag : "ns3:FEParamGetTiposIvaResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FEParamGetTiposIvaResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FEParamGetTiposIvaResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FEParamGetTiposIvaResponse * SOAP_FMAC4 soap_get__ns3__FEParamGetTiposIvaResponse(struct soap *soap, _ns3__FEParamGetTiposIvaResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FEParamGetTiposIvaResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FEParamGetTiposIva::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FEParamGetTiposIva::Auth = NULL;
}

void _ns3__FEParamGetTiposIva::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FEAuthRequest(soap, &this->_ns3__FEParamGetTiposIva::Auth);
#endif
}

int _ns3__FEParamGetTiposIva::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FEParamGetTiposIva(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FEParamGetTiposIva(struct soap *soap, const char *tag, int id, const _ns3__FEParamGetTiposIva *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FEParamGetTiposIva), type))
		return soap->error;
	if (soap_out_PointerTons3__FEAuthRequest(soap, "ns3:Auth", -1, &a->_ns3__FEParamGetTiposIva::Auth, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FEParamGetTiposIva::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FEParamGetTiposIva(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FEParamGetTiposIva * SOAP_FMAC4 soap_in__ns3__FEParamGetTiposIva(struct soap *soap, const char *tag, _ns3__FEParamGetTiposIva *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FEParamGetTiposIva*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FEParamGetTiposIva, sizeof(_ns3__FEParamGetTiposIva), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FEParamGetTiposIva)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FEParamGetTiposIva *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FEAuthRequest(soap, "ns3:Auth", &a->_ns3__FEParamGetTiposIva::Auth, "ns3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FEParamGetTiposIva *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FEParamGetTiposIva, SOAP_TYPE_afip__ns3__FEParamGetTiposIva, sizeof(_ns3__FEParamGetTiposIva), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FEParamGetTiposIva * SOAP_FMAC2 soap_instantiate__ns3__FEParamGetTiposIva(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FEParamGetTiposIva(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FEParamGetTiposIva *p;
	size_t k = sizeof(_ns3__FEParamGetTiposIva);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FEParamGetTiposIva, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FEParamGetTiposIva);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FEParamGetTiposIva, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FEParamGetTiposIva location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FEParamGetTiposIva::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FEParamGetTiposIva(soap, tag ? tag : "ns3:FEParamGetTiposIva", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FEParamGetTiposIva::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FEParamGetTiposIva(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FEParamGetTiposIva * SOAP_FMAC4 soap_get__ns3__FEParamGetTiposIva(struct soap *soap, _ns3__FEParamGetTiposIva *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FEParamGetTiposIva(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FEParamGetTiposMonedasResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FEParamGetTiposMonedasResponse::FEParamGetTiposMonedasResult = NULL;
}

void _ns3__FEParamGetTiposMonedasResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__MonedaResponse(soap, &this->_ns3__FEParamGetTiposMonedasResponse::FEParamGetTiposMonedasResult);
#endif
}

int _ns3__FEParamGetTiposMonedasResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FEParamGetTiposMonedasResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FEParamGetTiposMonedasResponse(struct soap *soap, const char *tag, int id, const _ns3__FEParamGetTiposMonedasResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FEParamGetTiposMonedasResponse), type))
		return soap->error;
	if (a->FEParamGetTiposMonedasResult)
		soap_element_result(soap, "ns3:FEParamGetTiposMonedasResult");
	if (soap_out_PointerTons3__MonedaResponse(soap, "ns3:FEParamGetTiposMonedasResult", -1, &a->_ns3__FEParamGetTiposMonedasResponse::FEParamGetTiposMonedasResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FEParamGetTiposMonedasResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FEParamGetTiposMonedasResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FEParamGetTiposMonedasResponse * SOAP_FMAC4 soap_in__ns3__FEParamGetTiposMonedasResponse(struct soap *soap, const char *tag, _ns3__FEParamGetTiposMonedasResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FEParamGetTiposMonedasResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FEParamGetTiposMonedasResponse, sizeof(_ns3__FEParamGetTiposMonedasResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FEParamGetTiposMonedasResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FEParamGetTiposMonedasResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FEParamGetTiposMonedasResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FEParamGetTiposMonedasResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__MonedaResponse(soap, "ns3:FEParamGetTiposMonedasResult", &a->_ns3__FEParamGetTiposMonedasResponse::FEParamGetTiposMonedasResult, "ns3:MonedaResponse"))
				{	soap_flag_FEParamGetTiposMonedasResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns3:FEParamGetTiposMonedasResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FEParamGetTiposMonedasResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FEParamGetTiposMonedasResponse, SOAP_TYPE_afip__ns3__FEParamGetTiposMonedasResponse, sizeof(_ns3__FEParamGetTiposMonedasResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FEParamGetTiposMonedasResponse * SOAP_FMAC2 soap_instantiate__ns3__FEParamGetTiposMonedasResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FEParamGetTiposMonedasResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FEParamGetTiposMonedasResponse *p;
	size_t k = sizeof(_ns3__FEParamGetTiposMonedasResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FEParamGetTiposMonedasResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FEParamGetTiposMonedasResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FEParamGetTiposMonedasResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FEParamGetTiposMonedasResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FEParamGetTiposMonedasResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FEParamGetTiposMonedasResponse(soap, tag ? tag : "ns3:FEParamGetTiposMonedasResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FEParamGetTiposMonedasResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FEParamGetTiposMonedasResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FEParamGetTiposMonedasResponse * SOAP_FMAC4 soap_get__ns3__FEParamGetTiposMonedasResponse(struct soap *soap, _ns3__FEParamGetTiposMonedasResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FEParamGetTiposMonedasResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FEParamGetTiposMonedas::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FEParamGetTiposMonedas::Auth = NULL;
}

void _ns3__FEParamGetTiposMonedas::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FEAuthRequest(soap, &this->_ns3__FEParamGetTiposMonedas::Auth);
#endif
}

int _ns3__FEParamGetTiposMonedas::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FEParamGetTiposMonedas(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FEParamGetTiposMonedas(struct soap *soap, const char *tag, int id, const _ns3__FEParamGetTiposMonedas *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FEParamGetTiposMonedas), type))
		return soap->error;
	if (soap_out_PointerTons3__FEAuthRequest(soap, "ns3:Auth", -1, &a->_ns3__FEParamGetTiposMonedas::Auth, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FEParamGetTiposMonedas::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FEParamGetTiposMonedas(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FEParamGetTiposMonedas * SOAP_FMAC4 soap_in__ns3__FEParamGetTiposMonedas(struct soap *soap, const char *tag, _ns3__FEParamGetTiposMonedas *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FEParamGetTiposMonedas*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FEParamGetTiposMonedas, sizeof(_ns3__FEParamGetTiposMonedas), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FEParamGetTiposMonedas)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FEParamGetTiposMonedas *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FEAuthRequest(soap, "ns3:Auth", &a->_ns3__FEParamGetTiposMonedas::Auth, "ns3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FEParamGetTiposMonedas *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FEParamGetTiposMonedas, SOAP_TYPE_afip__ns3__FEParamGetTiposMonedas, sizeof(_ns3__FEParamGetTiposMonedas), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FEParamGetTiposMonedas * SOAP_FMAC2 soap_instantiate__ns3__FEParamGetTiposMonedas(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FEParamGetTiposMonedas(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FEParamGetTiposMonedas *p;
	size_t k = sizeof(_ns3__FEParamGetTiposMonedas);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FEParamGetTiposMonedas, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FEParamGetTiposMonedas);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FEParamGetTiposMonedas, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FEParamGetTiposMonedas location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FEParamGetTiposMonedas::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FEParamGetTiposMonedas(soap, tag ? tag : "ns3:FEParamGetTiposMonedas", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FEParamGetTiposMonedas::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FEParamGetTiposMonedas(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FEParamGetTiposMonedas * SOAP_FMAC4 soap_get__ns3__FEParamGetTiposMonedas(struct soap *soap, _ns3__FEParamGetTiposMonedas *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FEParamGetTiposMonedas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FEParamGetTiposTributosResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FEParamGetTiposTributosResponse::FEParamGetTiposTributosResult = NULL;
}

void _ns3__FEParamGetTiposTributosResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FETributoResponse(soap, &this->_ns3__FEParamGetTiposTributosResponse::FEParamGetTiposTributosResult);
#endif
}

int _ns3__FEParamGetTiposTributosResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FEParamGetTiposTributosResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FEParamGetTiposTributosResponse(struct soap *soap, const char *tag, int id, const _ns3__FEParamGetTiposTributosResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FEParamGetTiposTributosResponse), type))
		return soap->error;
	if (a->FEParamGetTiposTributosResult)
		soap_element_result(soap, "ns3:FEParamGetTiposTributosResult");
	if (soap_out_PointerTons3__FETributoResponse(soap, "ns3:FEParamGetTiposTributosResult", -1, &a->_ns3__FEParamGetTiposTributosResponse::FEParamGetTiposTributosResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FEParamGetTiposTributosResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FEParamGetTiposTributosResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FEParamGetTiposTributosResponse * SOAP_FMAC4 soap_in__ns3__FEParamGetTiposTributosResponse(struct soap *soap, const char *tag, _ns3__FEParamGetTiposTributosResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FEParamGetTiposTributosResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FEParamGetTiposTributosResponse, sizeof(_ns3__FEParamGetTiposTributosResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FEParamGetTiposTributosResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FEParamGetTiposTributosResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FEParamGetTiposTributosResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FEParamGetTiposTributosResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FETributoResponse(soap, "ns3:FEParamGetTiposTributosResult", &a->_ns3__FEParamGetTiposTributosResponse::FEParamGetTiposTributosResult, "ns3:FETributoResponse"))
				{	soap_flag_FEParamGetTiposTributosResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns3:FEParamGetTiposTributosResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FEParamGetTiposTributosResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FEParamGetTiposTributosResponse, SOAP_TYPE_afip__ns3__FEParamGetTiposTributosResponse, sizeof(_ns3__FEParamGetTiposTributosResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FEParamGetTiposTributosResponse * SOAP_FMAC2 soap_instantiate__ns3__FEParamGetTiposTributosResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FEParamGetTiposTributosResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FEParamGetTiposTributosResponse *p;
	size_t k = sizeof(_ns3__FEParamGetTiposTributosResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FEParamGetTiposTributosResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FEParamGetTiposTributosResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FEParamGetTiposTributosResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FEParamGetTiposTributosResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FEParamGetTiposTributosResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FEParamGetTiposTributosResponse(soap, tag ? tag : "ns3:FEParamGetTiposTributosResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FEParamGetTiposTributosResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FEParamGetTiposTributosResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FEParamGetTiposTributosResponse * SOAP_FMAC4 soap_get__ns3__FEParamGetTiposTributosResponse(struct soap *soap, _ns3__FEParamGetTiposTributosResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FEParamGetTiposTributosResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FEParamGetTiposTributos::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FEParamGetTiposTributos::Auth = NULL;
}

void _ns3__FEParamGetTiposTributos::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FEAuthRequest(soap, &this->_ns3__FEParamGetTiposTributos::Auth);
#endif
}

int _ns3__FEParamGetTiposTributos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FEParamGetTiposTributos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FEParamGetTiposTributos(struct soap *soap, const char *tag, int id, const _ns3__FEParamGetTiposTributos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FEParamGetTiposTributos), type))
		return soap->error;
	if (soap_out_PointerTons3__FEAuthRequest(soap, "ns3:Auth", -1, &a->_ns3__FEParamGetTiposTributos::Auth, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FEParamGetTiposTributos::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FEParamGetTiposTributos(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FEParamGetTiposTributos * SOAP_FMAC4 soap_in__ns3__FEParamGetTiposTributos(struct soap *soap, const char *tag, _ns3__FEParamGetTiposTributos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FEParamGetTiposTributos*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FEParamGetTiposTributos, sizeof(_ns3__FEParamGetTiposTributos), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FEParamGetTiposTributos)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FEParamGetTiposTributos *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FEAuthRequest(soap, "ns3:Auth", &a->_ns3__FEParamGetTiposTributos::Auth, "ns3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FEParamGetTiposTributos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FEParamGetTiposTributos, SOAP_TYPE_afip__ns3__FEParamGetTiposTributos, sizeof(_ns3__FEParamGetTiposTributos), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FEParamGetTiposTributos * SOAP_FMAC2 soap_instantiate__ns3__FEParamGetTiposTributos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FEParamGetTiposTributos(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FEParamGetTiposTributos *p;
	size_t k = sizeof(_ns3__FEParamGetTiposTributos);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FEParamGetTiposTributos, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FEParamGetTiposTributos);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FEParamGetTiposTributos, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FEParamGetTiposTributos location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FEParamGetTiposTributos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FEParamGetTiposTributos(soap, tag ? tag : "ns3:FEParamGetTiposTributos", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FEParamGetTiposTributos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FEParamGetTiposTributos(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FEParamGetTiposTributos * SOAP_FMAC4 soap_get__ns3__FEParamGetTiposTributos(struct soap *soap, _ns3__FEParamGetTiposTributos *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FEParamGetTiposTributos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FEParamGetCotizacionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FEParamGetCotizacionResponse::FEParamGetCotizacionResult = NULL;
}

void _ns3__FEParamGetCotizacionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FECotizacionResponse(soap, &this->_ns3__FEParamGetCotizacionResponse::FEParamGetCotizacionResult);
#endif
}

int _ns3__FEParamGetCotizacionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FEParamGetCotizacionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FEParamGetCotizacionResponse(struct soap *soap, const char *tag, int id, const _ns3__FEParamGetCotizacionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FEParamGetCotizacionResponse), type))
		return soap->error;
	if (a->FEParamGetCotizacionResult)
		soap_element_result(soap, "ns3:FEParamGetCotizacionResult");
	if (soap_out_PointerTons3__FECotizacionResponse(soap, "ns3:FEParamGetCotizacionResult", -1, &a->_ns3__FEParamGetCotizacionResponse::FEParamGetCotizacionResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FEParamGetCotizacionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FEParamGetCotizacionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FEParamGetCotizacionResponse * SOAP_FMAC4 soap_in__ns3__FEParamGetCotizacionResponse(struct soap *soap, const char *tag, _ns3__FEParamGetCotizacionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FEParamGetCotizacionResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FEParamGetCotizacionResponse, sizeof(_ns3__FEParamGetCotizacionResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FEParamGetCotizacionResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FEParamGetCotizacionResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FEParamGetCotizacionResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FEParamGetCotizacionResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FECotizacionResponse(soap, "ns3:FEParamGetCotizacionResult", &a->_ns3__FEParamGetCotizacionResponse::FEParamGetCotizacionResult, "ns3:FECotizacionResponse"))
				{	soap_flag_FEParamGetCotizacionResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns3:FEParamGetCotizacionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FEParamGetCotizacionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FEParamGetCotizacionResponse, SOAP_TYPE_afip__ns3__FEParamGetCotizacionResponse, sizeof(_ns3__FEParamGetCotizacionResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FEParamGetCotizacionResponse * SOAP_FMAC2 soap_instantiate__ns3__FEParamGetCotizacionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FEParamGetCotizacionResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FEParamGetCotizacionResponse *p;
	size_t k = sizeof(_ns3__FEParamGetCotizacionResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FEParamGetCotizacionResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FEParamGetCotizacionResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FEParamGetCotizacionResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FEParamGetCotizacionResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FEParamGetCotizacionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FEParamGetCotizacionResponse(soap, tag ? tag : "ns3:FEParamGetCotizacionResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FEParamGetCotizacionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FEParamGetCotizacionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FEParamGetCotizacionResponse * SOAP_FMAC4 soap_get__ns3__FEParamGetCotizacionResponse(struct soap *soap, _ns3__FEParamGetCotizacionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FEParamGetCotizacionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FEParamGetCotizacion::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FEParamGetCotizacion::Auth = NULL;
	this->_ns3__FEParamGetCotizacion::MonId = NULL;
}

void _ns3__FEParamGetCotizacion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FEAuthRequest(soap, &this->_ns3__FEParamGetCotizacion::Auth);
	soap_serialize_PointerTostd__string(soap, &this->_ns3__FEParamGetCotizacion::MonId);
#endif
}

int _ns3__FEParamGetCotizacion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FEParamGetCotizacion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FEParamGetCotizacion(struct soap *soap, const char *tag, int id, const _ns3__FEParamGetCotizacion *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FEParamGetCotizacion), type))
		return soap->error;
	if (soap_out_PointerTons3__FEAuthRequest(soap, "ns3:Auth", -1, &a->_ns3__FEParamGetCotizacion::Auth, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:MonId", -1, &a->_ns3__FEParamGetCotizacion::MonId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FEParamGetCotizacion::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FEParamGetCotizacion(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FEParamGetCotizacion * SOAP_FMAC4 soap_in__ns3__FEParamGetCotizacion(struct soap *soap, const char *tag, _ns3__FEParamGetCotizacion *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FEParamGetCotizacion*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FEParamGetCotizacion, sizeof(_ns3__FEParamGetCotizacion), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FEParamGetCotizacion)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FEParamGetCotizacion *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	size_t soap_flag_MonId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FEAuthRequest(soap, "ns3:Auth", &a->_ns3__FEParamGetCotizacion::Auth, "ns3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap_flag_MonId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:MonId", &a->_ns3__FEParamGetCotizacion::MonId, "xsd:string"))
				{	soap_flag_MonId1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FEParamGetCotizacion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FEParamGetCotizacion, SOAP_TYPE_afip__ns3__FEParamGetCotizacion, sizeof(_ns3__FEParamGetCotizacion), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FEParamGetCotizacion * SOAP_FMAC2 soap_instantiate__ns3__FEParamGetCotizacion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FEParamGetCotizacion(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FEParamGetCotizacion *p;
	size_t k = sizeof(_ns3__FEParamGetCotizacion);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FEParamGetCotizacion, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FEParamGetCotizacion);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FEParamGetCotizacion, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FEParamGetCotizacion location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FEParamGetCotizacion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FEParamGetCotizacion(soap, tag ? tag : "ns3:FEParamGetCotizacion", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FEParamGetCotizacion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FEParamGetCotizacion(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FEParamGetCotizacion * SOAP_FMAC4 soap_get__ns3__FEParamGetCotizacion(struct soap *soap, _ns3__FEParamGetCotizacion *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FEParamGetCotizacion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FECAEAConsultarResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FECAEAConsultarResponse::FECAEAConsultarResult = NULL;
}

void _ns3__FECAEAConsultarResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FECAEAGetResponse(soap, &this->_ns3__FECAEAConsultarResponse::FECAEAConsultarResult);
#endif
}

int _ns3__FECAEAConsultarResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FECAEAConsultarResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FECAEAConsultarResponse(struct soap *soap, const char *tag, int id, const _ns3__FECAEAConsultarResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FECAEAConsultarResponse), type))
		return soap->error;
	if (a->FECAEAConsultarResult)
		soap_element_result(soap, "ns3:FECAEAConsultarResult");
	if (soap_out_PointerTons3__FECAEAGetResponse(soap, "ns3:FECAEAConsultarResult", -1, &a->_ns3__FECAEAConsultarResponse::FECAEAConsultarResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FECAEAConsultarResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FECAEAConsultarResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FECAEAConsultarResponse * SOAP_FMAC4 soap_in__ns3__FECAEAConsultarResponse(struct soap *soap, const char *tag, _ns3__FECAEAConsultarResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FECAEAConsultarResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FECAEAConsultarResponse, sizeof(_ns3__FECAEAConsultarResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FECAEAConsultarResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FECAEAConsultarResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FECAEAConsultarResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FECAEAConsultarResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FECAEAGetResponse(soap, "ns3:FECAEAConsultarResult", &a->_ns3__FECAEAConsultarResponse::FECAEAConsultarResult, "ns3:FECAEAGetResponse"))
				{	soap_flag_FECAEAConsultarResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns3:FECAEAConsultarResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FECAEAConsultarResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FECAEAConsultarResponse, SOAP_TYPE_afip__ns3__FECAEAConsultarResponse, sizeof(_ns3__FECAEAConsultarResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FECAEAConsultarResponse * SOAP_FMAC2 soap_instantiate__ns3__FECAEAConsultarResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FECAEAConsultarResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FECAEAConsultarResponse *p;
	size_t k = sizeof(_ns3__FECAEAConsultarResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FECAEAConsultarResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FECAEAConsultarResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FECAEAConsultarResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FECAEAConsultarResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FECAEAConsultarResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FECAEAConsultarResponse(soap, tag ? tag : "ns3:FECAEAConsultarResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FECAEAConsultarResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FECAEAConsultarResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FECAEAConsultarResponse * SOAP_FMAC4 soap_get__ns3__FECAEAConsultarResponse(struct soap *soap, _ns3__FECAEAConsultarResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FECAEAConsultarResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FECAEAConsultar::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FECAEAConsultar::Auth = NULL;
	soap_default_int(soap, &this->_ns3__FECAEAConsultar::Periodo);
	soap_default_short(soap, &this->_ns3__FECAEAConsultar::Orden);
}

void _ns3__FECAEAConsultar::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FEAuthRequest(soap, &this->_ns3__FECAEAConsultar::Auth);
#endif
}

int _ns3__FECAEAConsultar::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FECAEAConsultar(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FECAEAConsultar(struct soap *soap, const char *tag, int id, const _ns3__FECAEAConsultar *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FECAEAConsultar), type))
		return soap->error;
	if (soap_out_PointerTons3__FEAuthRequest(soap, "ns3:Auth", -1, &a->_ns3__FECAEAConsultar::Auth, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:Periodo", -1, &a->_ns3__FECAEAConsultar::Periodo, ""))
		return soap->error;
	if (soap_out_short(soap, "ns3:Orden", -1, &a->_ns3__FECAEAConsultar::Orden, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FECAEAConsultar::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FECAEAConsultar(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FECAEAConsultar * SOAP_FMAC4 soap_in__ns3__FECAEAConsultar(struct soap *soap, const char *tag, _ns3__FECAEAConsultar *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FECAEAConsultar*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FECAEAConsultar, sizeof(_ns3__FECAEAConsultar), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FECAEAConsultar)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FECAEAConsultar *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	size_t soap_flag_Periodo1 = 1;
	size_t soap_flag_Orden1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FEAuthRequest(soap, "ns3:Auth", &a->_ns3__FECAEAConsultar::Auth, "ns3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap_flag_Periodo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:Periodo", &a->_ns3__FECAEAConsultar::Periodo, "xsd:int"))
				{	soap_flag_Periodo1--;
					continue;
				}
			}
			if (soap_flag_Orden1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_short(soap, "ns3:Orden", &a->_ns3__FECAEAConsultar::Orden, "xsd:short"))
				{	soap_flag_Orden1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Periodo1 > 0 || soap_flag_Orden1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns3__FECAEAConsultar *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FECAEAConsultar, SOAP_TYPE_afip__ns3__FECAEAConsultar, sizeof(_ns3__FECAEAConsultar), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FECAEAConsultar * SOAP_FMAC2 soap_instantiate__ns3__FECAEAConsultar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FECAEAConsultar(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FECAEAConsultar *p;
	size_t k = sizeof(_ns3__FECAEAConsultar);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FECAEAConsultar, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FECAEAConsultar);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FECAEAConsultar, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FECAEAConsultar location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FECAEAConsultar::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FECAEAConsultar(soap, tag ? tag : "ns3:FECAEAConsultar", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FECAEAConsultar::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FECAEAConsultar(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FECAEAConsultar * SOAP_FMAC4 soap_get__ns3__FECAEAConsultar(struct soap *soap, _ns3__FECAEAConsultar *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FECAEAConsultar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FECAEASinMovimientoInformarResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FECAEASinMovimientoInformarResponse::FECAEASinMovimientoInformarResult = NULL;
}

void _ns3__FECAEASinMovimientoInformarResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FECAEASinMovResponse(soap, &this->_ns3__FECAEASinMovimientoInformarResponse::FECAEASinMovimientoInformarResult);
#endif
}

int _ns3__FECAEASinMovimientoInformarResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FECAEASinMovimientoInformarResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FECAEASinMovimientoInformarResponse(struct soap *soap, const char *tag, int id, const _ns3__FECAEASinMovimientoInformarResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FECAEASinMovimientoInformarResponse), type))
		return soap->error;
	if (a->FECAEASinMovimientoInformarResult)
		soap_element_result(soap, "ns3:FECAEASinMovimientoInformarResult");
	if (soap_out_PointerTons3__FECAEASinMovResponse(soap, "ns3:FECAEASinMovimientoInformarResult", -1, &a->_ns3__FECAEASinMovimientoInformarResponse::FECAEASinMovimientoInformarResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FECAEASinMovimientoInformarResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FECAEASinMovimientoInformarResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FECAEASinMovimientoInformarResponse * SOAP_FMAC4 soap_in__ns3__FECAEASinMovimientoInformarResponse(struct soap *soap, const char *tag, _ns3__FECAEASinMovimientoInformarResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FECAEASinMovimientoInformarResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FECAEASinMovimientoInformarResponse, sizeof(_ns3__FECAEASinMovimientoInformarResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FECAEASinMovimientoInformarResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FECAEASinMovimientoInformarResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FECAEASinMovimientoInformarResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FECAEASinMovimientoInformarResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FECAEASinMovResponse(soap, "ns3:FECAEASinMovimientoInformarResult", &a->_ns3__FECAEASinMovimientoInformarResponse::FECAEASinMovimientoInformarResult, "ns3:FECAEASinMovResponse"))
				{	soap_flag_FECAEASinMovimientoInformarResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns3:FECAEASinMovimientoInformarResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FECAEASinMovimientoInformarResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FECAEASinMovimientoInformarResponse, SOAP_TYPE_afip__ns3__FECAEASinMovimientoInformarResponse, sizeof(_ns3__FECAEASinMovimientoInformarResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FECAEASinMovimientoInformarResponse * SOAP_FMAC2 soap_instantiate__ns3__FECAEASinMovimientoInformarResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FECAEASinMovimientoInformarResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FECAEASinMovimientoInformarResponse *p;
	size_t k = sizeof(_ns3__FECAEASinMovimientoInformarResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FECAEASinMovimientoInformarResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FECAEASinMovimientoInformarResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FECAEASinMovimientoInformarResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FECAEASinMovimientoInformarResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FECAEASinMovimientoInformarResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FECAEASinMovimientoInformarResponse(soap, tag ? tag : "ns3:FECAEASinMovimientoInformarResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FECAEASinMovimientoInformarResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FECAEASinMovimientoInformarResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FECAEASinMovimientoInformarResponse * SOAP_FMAC4 soap_get__ns3__FECAEASinMovimientoInformarResponse(struct soap *soap, _ns3__FECAEASinMovimientoInformarResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FECAEASinMovimientoInformarResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FECAEASinMovimientoInformar::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FECAEASinMovimientoInformar::Auth = NULL;
	soap_default_int(soap, &this->_ns3__FECAEASinMovimientoInformar::PtoVta);
	this->_ns3__FECAEASinMovimientoInformar::CAEA = NULL;
}

void _ns3__FECAEASinMovimientoInformar::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FEAuthRequest(soap, &this->_ns3__FECAEASinMovimientoInformar::Auth);
	soap_serialize_PointerTostd__string(soap, &this->_ns3__FECAEASinMovimientoInformar::CAEA);
#endif
}

int _ns3__FECAEASinMovimientoInformar::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FECAEASinMovimientoInformar(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FECAEASinMovimientoInformar(struct soap *soap, const char *tag, int id, const _ns3__FECAEASinMovimientoInformar *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FECAEASinMovimientoInformar), type))
		return soap->error;
	if (soap_out_PointerTons3__FEAuthRequest(soap, "ns3:Auth", -1, &a->_ns3__FECAEASinMovimientoInformar::Auth, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:PtoVta", -1, &a->_ns3__FECAEASinMovimientoInformar::PtoVta, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:CAEA", -1, &a->_ns3__FECAEASinMovimientoInformar::CAEA, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FECAEASinMovimientoInformar::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FECAEASinMovimientoInformar(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FECAEASinMovimientoInformar * SOAP_FMAC4 soap_in__ns3__FECAEASinMovimientoInformar(struct soap *soap, const char *tag, _ns3__FECAEASinMovimientoInformar *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FECAEASinMovimientoInformar*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FECAEASinMovimientoInformar, sizeof(_ns3__FECAEASinMovimientoInformar), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FECAEASinMovimientoInformar)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FECAEASinMovimientoInformar *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	size_t soap_flag_PtoVta1 = 1;
	size_t soap_flag_CAEA1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FEAuthRequest(soap, "ns3:Auth", &a->_ns3__FECAEASinMovimientoInformar::Auth, "ns3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap_flag_PtoVta1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:PtoVta", &a->_ns3__FECAEASinMovimientoInformar::PtoVta, "xsd:int"))
				{	soap_flag_PtoVta1--;
					continue;
				}
			}
			if (soap_flag_CAEA1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:CAEA", &a->_ns3__FECAEASinMovimientoInformar::CAEA, "xsd:string"))
				{	soap_flag_CAEA1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PtoVta1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns3__FECAEASinMovimientoInformar *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FECAEASinMovimientoInformar, SOAP_TYPE_afip__ns3__FECAEASinMovimientoInformar, sizeof(_ns3__FECAEASinMovimientoInformar), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FECAEASinMovimientoInformar * SOAP_FMAC2 soap_instantiate__ns3__FECAEASinMovimientoInformar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FECAEASinMovimientoInformar(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FECAEASinMovimientoInformar *p;
	size_t k = sizeof(_ns3__FECAEASinMovimientoInformar);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FECAEASinMovimientoInformar, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FECAEASinMovimientoInformar);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FECAEASinMovimientoInformar, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FECAEASinMovimientoInformar location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FECAEASinMovimientoInformar::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FECAEASinMovimientoInformar(soap, tag ? tag : "ns3:FECAEASinMovimientoInformar", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FECAEASinMovimientoInformar::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FECAEASinMovimientoInformar(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FECAEASinMovimientoInformar * SOAP_FMAC4 soap_get__ns3__FECAEASinMovimientoInformar(struct soap *soap, _ns3__FECAEASinMovimientoInformar *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FECAEASinMovimientoInformar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FECAEASinMovimientoConsultarResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FECAEASinMovimientoConsultarResponse::FECAEASinMovimientoConsultarResult = NULL;
}

void _ns3__FECAEASinMovimientoConsultarResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FECAEASinMovConsResponse(soap, &this->_ns3__FECAEASinMovimientoConsultarResponse::FECAEASinMovimientoConsultarResult);
#endif
}

int _ns3__FECAEASinMovimientoConsultarResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FECAEASinMovimientoConsultarResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FECAEASinMovimientoConsultarResponse(struct soap *soap, const char *tag, int id, const _ns3__FECAEASinMovimientoConsultarResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FECAEASinMovimientoConsultarResponse), type))
		return soap->error;
	if (a->FECAEASinMovimientoConsultarResult)
		soap_element_result(soap, "ns3:FECAEASinMovimientoConsultarResult");
	if (soap_out_PointerTons3__FECAEASinMovConsResponse(soap, "ns3:FECAEASinMovimientoConsultarResult", -1, &a->_ns3__FECAEASinMovimientoConsultarResponse::FECAEASinMovimientoConsultarResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FECAEASinMovimientoConsultarResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FECAEASinMovimientoConsultarResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FECAEASinMovimientoConsultarResponse * SOAP_FMAC4 soap_in__ns3__FECAEASinMovimientoConsultarResponse(struct soap *soap, const char *tag, _ns3__FECAEASinMovimientoConsultarResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FECAEASinMovimientoConsultarResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FECAEASinMovimientoConsultarResponse, sizeof(_ns3__FECAEASinMovimientoConsultarResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FECAEASinMovimientoConsultarResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FECAEASinMovimientoConsultarResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FECAEASinMovimientoConsultarResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FECAEASinMovimientoConsultarResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FECAEASinMovConsResponse(soap, "ns3:FECAEASinMovimientoConsultarResult", &a->_ns3__FECAEASinMovimientoConsultarResponse::FECAEASinMovimientoConsultarResult, "ns3:FECAEASinMovConsResponse"))
				{	soap_flag_FECAEASinMovimientoConsultarResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns3:FECAEASinMovimientoConsultarResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FECAEASinMovimientoConsultarResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FECAEASinMovimientoConsultarResponse, SOAP_TYPE_afip__ns3__FECAEASinMovimientoConsultarResponse, sizeof(_ns3__FECAEASinMovimientoConsultarResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FECAEASinMovimientoConsultarResponse * SOAP_FMAC2 soap_instantiate__ns3__FECAEASinMovimientoConsultarResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FECAEASinMovimientoConsultarResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FECAEASinMovimientoConsultarResponse *p;
	size_t k = sizeof(_ns3__FECAEASinMovimientoConsultarResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FECAEASinMovimientoConsultarResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FECAEASinMovimientoConsultarResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FECAEASinMovimientoConsultarResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FECAEASinMovimientoConsultarResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FECAEASinMovimientoConsultarResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FECAEASinMovimientoConsultarResponse(soap, tag ? tag : "ns3:FECAEASinMovimientoConsultarResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FECAEASinMovimientoConsultarResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FECAEASinMovimientoConsultarResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FECAEASinMovimientoConsultarResponse * SOAP_FMAC4 soap_get__ns3__FECAEASinMovimientoConsultarResponse(struct soap *soap, _ns3__FECAEASinMovimientoConsultarResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FECAEASinMovimientoConsultarResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FECAEASinMovimientoConsultar::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FECAEASinMovimientoConsultar::Auth = NULL;
	this->_ns3__FECAEASinMovimientoConsultar::CAEA = NULL;
	soap_default_int(soap, &this->_ns3__FECAEASinMovimientoConsultar::PtoVta);
}

void _ns3__FECAEASinMovimientoConsultar::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FEAuthRequest(soap, &this->_ns3__FECAEASinMovimientoConsultar::Auth);
	soap_serialize_PointerTostd__string(soap, &this->_ns3__FECAEASinMovimientoConsultar::CAEA);
#endif
}

int _ns3__FECAEASinMovimientoConsultar::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FECAEASinMovimientoConsultar(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FECAEASinMovimientoConsultar(struct soap *soap, const char *tag, int id, const _ns3__FECAEASinMovimientoConsultar *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FECAEASinMovimientoConsultar), type))
		return soap->error;
	if (soap_out_PointerTons3__FEAuthRequest(soap, "ns3:Auth", -1, &a->_ns3__FECAEASinMovimientoConsultar::Auth, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:CAEA", -1, &a->_ns3__FECAEASinMovimientoConsultar::CAEA, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:PtoVta", -1, &a->_ns3__FECAEASinMovimientoConsultar::PtoVta, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FECAEASinMovimientoConsultar::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FECAEASinMovimientoConsultar(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FECAEASinMovimientoConsultar * SOAP_FMAC4 soap_in__ns3__FECAEASinMovimientoConsultar(struct soap *soap, const char *tag, _ns3__FECAEASinMovimientoConsultar *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FECAEASinMovimientoConsultar*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FECAEASinMovimientoConsultar, sizeof(_ns3__FECAEASinMovimientoConsultar), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FECAEASinMovimientoConsultar)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FECAEASinMovimientoConsultar *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	size_t soap_flag_CAEA1 = 1;
	size_t soap_flag_PtoVta1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FEAuthRequest(soap, "ns3:Auth", &a->_ns3__FECAEASinMovimientoConsultar::Auth, "ns3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap_flag_CAEA1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:CAEA", &a->_ns3__FECAEASinMovimientoConsultar::CAEA, "xsd:string"))
				{	soap_flag_CAEA1--;
					continue;
				}
			}
			if (soap_flag_PtoVta1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:PtoVta", &a->_ns3__FECAEASinMovimientoConsultar::PtoVta, "xsd:int"))
				{	soap_flag_PtoVta1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PtoVta1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns3__FECAEASinMovimientoConsultar *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FECAEASinMovimientoConsultar, SOAP_TYPE_afip__ns3__FECAEASinMovimientoConsultar, sizeof(_ns3__FECAEASinMovimientoConsultar), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FECAEASinMovimientoConsultar * SOAP_FMAC2 soap_instantiate__ns3__FECAEASinMovimientoConsultar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FECAEASinMovimientoConsultar(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FECAEASinMovimientoConsultar *p;
	size_t k = sizeof(_ns3__FECAEASinMovimientoConsultar);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FECAEASinMovimientoConsultar, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FECAEASinMovimientoConsultar);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FECAEASinMovimientoConsultar, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FECAEASinMovimientoConsultar location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FECAEASinMovimientoConsultar::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FECAEASinMovimientoConsultar(soap, tag ? tag : "ns3:FECAEASinMovimientoConsultar", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FECAEASinMovimientoConsultar::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FECAEASinMovimientoConsultar(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FECAEASinMovimientoConsultar * SOAP_FMAC4 soap_get__ns3__FECAEASinMovimientoConsultar(struct soap *soap, _ns3__FECAEASinMovimientoConsultar *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FECAEASinMovimientoConsultar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FECAEASolicitarResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FECAEASolicitarResponse::FECAEASolicitarResult = NULL;
}

void _ns3__FECAEASolicitarResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FECAEAGetResponse(soap, &this->_ns3__FECAEASolicitarResponse::FECAEASolicitarResult);
#endif
}

int _ns3__FECAEASolicitarResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FECAEASolicitarResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FECAEASolicitarResponse(struct soap *soap, const char *tag, int id, const _ns3__FECAEASolicitarResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FECAEASolicitarResponse), type))
		return soap->error;
	if (a->FECAEASolicitarResult)
		soap_element_result(soap, "ns3:FECAEASolicitarResult");
	if (soap_out_PointerTons3__FECAEAGetResponse(soap, "ns3:FECAEASolicitarResult", -1, &a->_ns3__FECAEASolicitarResponse::FECAEASolicitarResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FECAEASolicitarResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FECAEASolicitarResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FECAEASolicitarResponse * SOAP_FMAC4 soap_in__ns3__FECAEASolicitarResponse(struct soap *soap, const char *tag, _ns3__FECAEASolicitarResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FECAEASolicitarResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FECAEASolicitarResponse, sizeof(_ns3__FECAEASolicitarResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FECAEASolicitarResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FECAEASolicitarResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FECAEASolicitarResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FECAEASolicitarResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FECAEAGetResponse(soap, "ns3:FECAEASolicitarResult", &a->_ns3__FECAEASolicitarResponse::FECAEASolicitarResult, "ns3:FECAEAGetResponse"))
				{	soap_flag_FECAEASolicitarResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns3:FECAEASolicitarResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FECAEASolicitarResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FECAEASolicitarResponse, SOAP_TYPE_afip__ns3__FECAEASolicitarResponse, sizeof(_ns3__FECAEASolicitarResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FECAEASolicitarResponse * SOAP_FMAC2 soap_instantiate__ns3__FECAEASolicitarResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FECAEASolicitarResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FECAEASolicitarResponse *p;
	size_t k = sizeof(_ns3__FECAEASolicitarResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FECAEASolicitarResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FECAEASolicitarResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FECAEASolicitarResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FECAEASolicitarResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FECAEASolicitarResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FECAEASolicitarResponse(soap, tag ? tag : "ns3:FECAEASolicitarResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FECAEASolicitarResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FECAEASolicitarResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FECAEASolicitarResponse * SOAP_FMAC4 soap_get__ns3__FECAEASolicitarResponse(struct soap *soap, _ns3__FECAEASolicitarResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FECAEASolicitarResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FECAEASolicitar::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FECAEASolicitar::Auth = NULL;
	soap_default_int(soap, &this->_ns3__FECAEASolicitar::Periodo);
	soap_default_short(soap, &this->_ns3__FECAEASolicitar::Orden);
}

void _ns3__FECAEASolicitar::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FEAuthRequest(soap, &this->_ns3__FECAEASolicitar::Auth);
#endif
}

int _ns3__FECAEASolicitar::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FECAEASolicitar(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FECAEASolicitar(struct soap *soap, const char *tag, int id, const _ns3__FECAEASolicitar *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FECAEASolicitar), type))
		return soap->error;
	if (soap_out_PointerTons3__FEAuthRequest(soap, "ns3:Auth", -1, &a->_ns3__FECAEASolicitar::Auth, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:Periodo", -1, &a->_ns3__FECAEASolicitar::Periodo, ""))
		return soap->error;
	if (soap_out_short(soap, "ns3:Orden", -1, &a->_ns3__FECAEASolicitar::Orden, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FECAEASolicitar::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FECAEASolicitar(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FECAEASolicitar * SOAP_FMAC4 soap_in__ns3__FECAEASolicitar(struct soap *soap, const char *tag, _ns3__FECAEASolicitar *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FECAEASolicitar*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FECAEASolicitar, sizeof(_ns3__FECAEASolicitar), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FECAEASolicitar)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FECAEASolicitar *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	size_t soap_flag_Periodo1 = 1;
	size_t soap_flag_Orden1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FEAuthRequest(soap, "ns3:Auth", &a->_ns3__FECAEASolicitar::Auth, "ns3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap_flag_Periodo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:Periodo", &a->_ns3__FECAEASolicitar::Periodo, "xsd:int"))
				{	soap_flag_Periodo1--;
					continue;
				}
			}
			if (soap_flag_Orden1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_short(soap, "ns3:Orden", &a->_ns3__FECAEASolicitar::Orden, "xsd:short"))
				{	soap_flag_Orden1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Periodo1 > 0 || soap_flag_Orden1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns3__FECAEASolicitar *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FECAEASolicitar, SOAP_TYPE_afip__ns3__FECAEASolicitar, sizeof(_ns3__FECAEASolicitar), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FECAEASolicitar * SOAP_FMAC2 soap_instantiate__ns3__FECAEASolicitar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FECAEASolicitar(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FECAEASolicitar *p;
	size_t k = sizeof(_ns3__FECAEASolicitar);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FECAEASolicitar, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FECAEASolicitar);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FECAEASolicitar, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FECAEASolicitar location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FECAEASolicitar::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FECAEASolicitar(soap, tag ? tag : "ns3:FECAEASolicitar", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FECAEASolicitar::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FECAEASolicitar(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FECAEASolicitar * SOAP_FMAC4 soap_get__ns3__FECAEASolicitar(struct soap *soap, _ns3__FECAEASolicitar *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FECAEASolicitar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FECAEARegInformativoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FECAEARegInformativoResponse::FECAEARegInformativoResult = NULL;
}

void _ns3__FECAEARegInformativoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FECAEAResponse(soap, &this->_ns3__FECAEARegInformativoResponse::FECAEARegInformativoResult);
#endif
}

int _ns3__FECAEARegInformativoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FECAEARegInformativoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FECAEARegInformativoResponse(struct soap *soap, const char *tag, int id, const _ns3__FECAEARegInformativoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FECAEARegInformativoResponse), type))
		return soap->error;
	if (a->FECAEARegInformativoResult)
		soap_element_result(soap, "ns3:FECAEARegInformativoResult");
	if (soap_out_PointerTons3__FECAEAResponse(soap, "ns3:FECAEARegInformativoResult", -1, &a->_ns3__FECAEARegInformativoResponse::FECAEARegInformativoResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FECAEARegInformativoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FECAEARegInformativoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FECAEARegInformativoResponse * SOAP_FMAC4 soap_in__ns3__FECAEARegInformativoResponse(struct soap *soap, const char *tag, _ns3__FECAEARegInformativoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FECAEARegInformativoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FECAEARegInformativoResponse, sizeof(_ns3__FECAEARegInformativoResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FECAEARegInformativoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FECAEARegInformativoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FECAEARegInformativoResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FECAEARegInformativoResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FECAEAResponse(soap, "ns3:FECAEARegInformativoResult", &a->_ns3__FECAEARegInformativoResponse::FECAEARegInformativoResult, "ns3:FECAEAResponse"))
				{	soap_flag_FECAEARegInformativoResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns3:FECAEARegInformativoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FECAEARegInformativoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FECAEARegInformativoResponse, SOAP_TYPE_afip__ns3__FECAEARegInformativoResponse, sizeof(_ns3__FECAEARegInformativoResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FECAEARegInformativoResponse * SOAP_FMAC2 soap_instantiate__ns3__FECAEARegInformativoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FECAEARegInformativoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FECAEARegInformativoResponse *p;
	size_t k = sizeof(_ns3__FECAEARegInformativoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FECAEARegInformativoResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FECAEARegInformativoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FECAEARegInformativoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FECAEARegInformativoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FECAEARegInformativoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FECAEARegInformativoResponse(soap, tag ? tag : "ns3:FECAEARegInformativoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FECAEARegInformativoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FECAEARegInformativoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FECAEARegInformativoResponse * SOAP_FMAC4 soap_get__ns3__FECAEARegInformativoResponse(struct soap *soap, _ns3__FECAEARegInformativoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FECAEARegInformativoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FECAEARegInformativo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FECAEARegInformativo::Auth = NULL;
	this->_ns3__FECAEARegInformativo::FeCAEARegInfReq = NULL;
}

void _ns3__FECAEARegInformativo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FEAuthRequest(soap, &this->_ns3__FECAEARegInformativo::Auth);
	soap_serialize_PointerTons3__FECAEARequest(soap, &this->_ns3__FECAEARegInformativo::FeCAEARegInfReq);
#endif
}

int _ns3__FECAEARegInformativo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FECAEARegInformativo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FECAEARegInformativo(struct soap *soap, const char *tag, int id, const _ns3__FECAEARegInformativo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FECAEARegInformativo), type))
		return soap->error;
	if (soap_out_PointerTons3__FEAuthRequest(soap, "ns3:Auth", -1, &a->_ns3__FECAEARegInformativo::Auth, ""))
		return soap->error;
	if (soap_out_PointerTons3__FECAEARequest(soap, "ns3:FeCAEARegInfReq", -1, &a->_ns3__FECAEARegInformativo::FeCAEARegInfReq, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FECAEARegInformativo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FECAEARegInformativo(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FECAEARegInformativo * SOAP_FMAC4 soap_in__ns3__FECAEARegInformativo(struct soap *soap, const char *tag, _ns3__FECAEARegInformativo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FECAEARegInformativo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FECAEARegInformativo, sizeof(_ns3__FECAEARegInformativo), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FECAEARegInformativo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FECAEARegInformativo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	size_t soap_flag_FeCAEARegInfReq1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FEAuthRequest(soap, "ns3:Auth", &a->_ns3__FECAEARegInformativo::Auth, "ns3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap_flag_FeCAEARegInfReq1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FECAEARequest(soap, "ns3:FeCAEARegInfReq", &a->_ns3__FECAEARegInformativo::FeCAEARegInfReq, "ns3:FECAEARequest"))
				{	soap_flag_FeCAEARegInfReq1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FECAEARegInformativo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FECAEARegInformativo, SOAP_TYPE_afip__ns3__FECAEARegInformativo, sizeof(_ns3__FECAEARegInformativo), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FECAEARegInformativo * SOAP_FMAC2 soap_instantiate__ns3__FECAEARegInformativo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FECAEARegInformativo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FECAEARegInformativo *p;
	size_t k = sizeof(_ns3__FECAEARegInformativo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FECAEARegInformativo, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FECAEARegInformativo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FECAEARegInformativo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FECAEARegInformativo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FECAEARegInformativo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FECAEARegInformativo(soap, tag ? tag : "ns3:FECAEARegInformativo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FECAEARegInformativo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FECAEARegInformativo(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FECAEARegInformativo * SOAP_FMAC4 soap_get__ns3__FECAEARegInformativo(struct soap *soap, _ns3__FECAEARegInformativo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FECAEARegInformativo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FECompConsultarResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FECompConsultarResponse::FECompConsultarResult = NULL;
}

void _ns3__FECompConsultarResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FECompConsultaResponse(soap, &this->_ns3__FECompConsultarResponse::FECompConsultarResult);
#endif
}

int _ns3__FECompConsultarResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FECompConsultarResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FECompConsultarResponse(struct soap *soap, const char *tag, int id, const _ns3__FECompConsultarResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FECompConsultarResponse), type))
		return soap->error;
	if (a->FECompConsultarResult)
		soap_element_result(soap, "ns3:FECompConsultarResult");
	if (soap_out_PointerTons3__FECompConsultaResponse(soap, "ns3:FECompConsultarResult", -1, &a->_ns3__FECompConsultarResponse::FECompConsultarResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FECompConsultarResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FECompConsultarResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FECompConsultarResponse * SOAP_FMAC4 soap_in__ns3__FECompConsultarResponse(struct soap *soap, const char *tag, _ns3__FECompConsultarResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FECompConsultarResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FECompConsultarResponse, sizeof(_ns3__FECompConsultarResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FECompConsultarResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FECompConsultarResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FECompConsultarResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FECompConsultarResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FECompConsultaResponse(soap, "ns3:FECompConsultarResult", &a->_ns3__FECompConsultarResponse::FECompConsultarResult, "ns3:FECompConsultaResponse"))
				{	soap_flag_FECompConsultarResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns3:FECompConsultarResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FECompConsultarResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FECompConsultarResponse, SOAP_TYPE_afip__ns3__FECompConsultarResponse, sizeof(_ns3__FECompConsultarResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FECompConsultarResponse * SOAP_FMAC2 soap_instantiate__ns3__FECompConsultarResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FECompConsultarResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FECompConsultarResponse *p;
	size_t k = sizeof(_ns3__FECompConsultarResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FECompConsultarResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FECompConsultarResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FECompConsultarResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FECompConsultarResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FECompConsultarResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FECompConsultarResponse(soap, tag ? tag : "ns3:FECompConsultarResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FECompConsultarResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FECompConsultarResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FECompConsultarResponse * SOAP_FMAC4 soap_get__ns3__FECompConsultarResponse(struct soap *soap, _ns3__FECompConsultarResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FECompConsultarResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FECompConsultar::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FECompConsultar::Auth = NULL;
	this->_ns3__FECompConsultar::FeCompConsReq = NULL;
}

void _ns3__FECompConsultar::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FEAuthRequest(soap, &this->_ns3__FECompConsultar::Auth);
	soap_serialize_PointerTons3__FECompConsultaReq(soap, &this->_ns3__FECompConsultar::FeCompConsReq);
#endif
}

int _ns3__FECompConsultar::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FECompConsultar(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FECompConsultar(struct soap *soap, const char *tag, int id, const _ns3__FECompConsultar *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FECompConsultar), type))
		return soap->error;
	if (soap_out_PointerTons3__FEAuthRequest(soap, "ns3:Auth", -1, &a->_ns3__FECompConsultar::Auth, ""))
		return soap->error;
	if (soap_out_PointerTons3__FECompConsultaReq(soap, "ns3:FeCompConsReq", -1, &a->_ns3__FECompConsultar::FeCompConsReq, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FECompConsultar::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FECompConsultar(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FECompConsultar * SOAP_FMAC4 soap_in__ns3__FECompConsultar(struct soap *soap, const char *tag, _ns3__FECompConsultar *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FECompConsultar*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FECompConsultar, sizeof(_ns3__FECompConsultar), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FECompConsultar)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FECompConsultar *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	size_t soap_flag_FeCompConsReq1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FEAuthRequest(soap, "ns3:Auth", &a->_ns3__FECompConsultar::Auth, "ns3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap_flag_FeCompConsReq1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FECompConsultaReq(soap, "ns3:FeCompConsReq", &a->_ns3__FECompConsultar::FeCompConsReq, "ns3:FECompConsultaReq"))
				{	soap_flag_FeCompConsReq1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FECompConsultar *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FECompConsultar, SOAP_TYPE_afip__ns3__FECompConsultar, sizeof(_ns3__FECompConsultar), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FECompConsultar * SOAP_FMAC2 soap_instantiate__ns3__FECompConsultar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FECompConsultar(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FECompConsultar *p;
	size_t k = sizeof(_ns3__FECompConsultar);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FECompConsultar, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FECompConsultar);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FECompConsultar, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FECompConsultar location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FECompConsultar::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FECompConsultar(soap, tag ? tag : "ns3:FECompConsultar", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FECompConsultar::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FECompConsultar(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FECompConsultar * SOAP_FMAC4 soap_get__ns3__FECompConsultar(struct soap *soap, _ns3__FECompConsultar *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FECompConsultar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FECompUltimoAutorizadoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FECompUltimoAutorizadoResponse::FECompUltimoAutorizadoResult = NULL;
}

void _ns3__FECompUltimoAutorizadoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FERecuperaLastCbteResponse(soap, &this->_ns3__FECompUltimoAutorizadoResponse::FECompUltimoAutorizadoResult);
#endif
}

int _ns3__FECompUltimoAutorizadoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FECompUltimoAutorizadoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FECompUltimoAutorizadoResponse(struct soap *soap, const char *tag, int id, const _ns3__FECompUltimoAutorizadoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FECompUltimoAutorizadoResponse), type))
		return soap->error;
	if (a->FECompUltimoAutorizadoResult)
		soap_element_result(soap, "ns3:FECompUltimoAutorizadoResult");
	if (soap_out_PointerTons3__FERecuperaLastCbteResponse(soap, "ns3:FECompUltimoAutorizadoResult", -1, &a->_ns3__FECompUltimoAutorizadoResponse::FECompUltimoAutorizadoResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FECompUltimoAutorizadoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FECompUltimoAutorizadoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FECompUltimoAutorizadoResponse * SOAP_FMAC4 soap_in__ns3__FECompUltimoAutorizadoResponse(struct soap *soap, const char *tag, _ns3__FECompUltimoAutorizadoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FECompUltimoAutorizadoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FECompUltimoAutorizadoResponse, sizeof(_ns3__FECompUltimoAutorizadoResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FECompUltimoAutorizadoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FECompUltimoAutorizadoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FECompUltimoAutorizadoResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FECompUltimoAutorizadoResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FERecuperaLastCbteResponse(soap, "ns3:FECompUltimoAutorizadoResult", &a->_ns3__FECompUltimoAutorizadoResponse::FECompUltimoAutorizadoResult, "ns3:FERecuperaLastCbteResponse"))
				{	soap_flag_FECompUltimoAutorizadoResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns3:FECompUltimoAutorizadoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FECompUltimoAutorizadoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FECompUltimoAutorizadoResponse, SOAP_TYPE_afip__ns3__FECompUltimoAutorizadoResponse, sizeof(_ns3__FECompUltimoAutorizadoResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FECompUltimoAutorizadoResponse * SOAP_FMAC2 soap_instantiate__ns3__FECompUltimoAutorizadoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FECompUltimoAutorizadoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FECompUltimoAutorizadoResponse *p;
	size_t k = sizeof(_ns3__FECompUltimoAutorizadoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FECompUltimoAutorizadoResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FECompUltimoAutorizadoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FECompUltimoAutorizadoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FECompUltimoAutorizadoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FECompUltimoAutorizadoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FECompUltimoAutorizadoResponse(soap, tag ? tag : "ns3:FECompUltimoAutorizadoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FECompUltimoAutorizadoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FECompUltimoAutorizadoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FECompUltimoAutorizadoResponse * SOAP_FMAC4 soap_get__ns3__FECompUltimoAutorizadoResponse(struct soap *soap, _ns3__FECompUltimoAutorizadoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FECompUltimoAutorizadoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FECompUltimoAutorizado::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FECompUltimoAutorizado::Auth = NULL;
	soap_default_int(soap, &this->_ns3__FECompUltimoAutorizado::PtoVta);
	soap_default_int(soap, &this->_ns3__FECompUltimoAutorizado::CbteTipo);
}

void _ns3__FECompUltimoAutorizado::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FEAuthRequest(soap, &this->_ns3__FECompUltimoAutorizado::Auth);
#endif
}

int _ns3__FECompUltimoAutorizado::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FECompUltimoAutorizado(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FECompUltimoAutorizado(struct soap *soap, const char *tag, int id, const _ns3__FECompUltimoAutorizado *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FECompUltimoAutorizado), type))
		return soap->error;
	if (soap_out_PointerTons3__FEAuthRequest(soap, "ns3:Auth", -1, &a->_ns3__FECompUltimoAutorizado::Auth, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:PtoVta", -1, &a->_ns3__FECompUltimoAutorizado::PtoVta, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:CbteTipo", -1, &a->_ns3__FECompUltimoAutorizado::CbteTipo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FECompUltimoAutorizado::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FECompUltimoAutorizado(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FECompUltimoAutorizado * SOAP_FMAC4 soap_in__ns3__FECompUltimoAutorizado(struct soap *soap, const char *tag, _ns3__FECompUltimoAutorizado *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FECompUltimoAutorizado*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FECompUltimoAutorizado, sizeof(_ns3__FECompUltimoAutorizado), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FECompUltimoAutorizado)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FECompUltimoAutorizado *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	size_t soap_flag_PtoVta1 = 1;
	size_t soap_flag_CbteTipo1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FEAuthRequest(soap, "ns3:Auth", &a->_ns3__FECompUltimoAutorizado::Auth, "ns3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap_flag_PtoVta1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:PtoVta", &a->_ns3__FECompUltimoAutorizado::PtoVta, "xsd:int"))
				{	soap_flag_PtoVta1--;
					continue;
				}
			}
			if (soap_flag_CbteTipo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:CbteTipo", &a->_ns3__FECompUltimoAutorizado::CbteTipo, "xsd:int"))
				{	soap_flag_CbteTipo1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PtoVta1 > 0 || soap_flag_CbteTipo1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns3__FECompUltimoAutorizado *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FECompUltimoAutorizado, SOAP_TYPE_afip__ns3__FECompUltimoAutorizado, sizeof(_ns3__FECompUltimoAutorizado), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FECompUltimoAutorizado * SOAP_FMAC2 soap_instantiate__ns3__FECompUltimoAutorizado(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FECompUltimoAutorizado(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FECompUltimoAutorizado *p;
	size_t k = sizeof(_ns3__FECompUltimoAutorizado);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FECompUltimoAutorizado, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FECompUltimoAutorizado);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FECompUltimoAutorizado, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FECompUltimoAutorizado location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FECompUltimoAutorizado::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FECompUltimoAutorizado(soap, tag ? tag : "ns3:FECompUltimoAutorizado", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FECompUltimoAutorizado::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FECompUltimoAutorizado(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FECompUltimoAutorizado * SOAP_FMAC4 soap_get__ns3__FECompUltimoAutorizado(struct soap *soap, _ns3__FECompUltimoAutorizado *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FECompUltimoAutorizado(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FEDummyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FEDummyResponse::FEDummyResult = NULL;
}

void _ns3__FEDummyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__DummyResponse(soap, &this->_ns3__FEDummyResponse::FEDummyResult);
#endif
}

int _ns3__FEDummyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FEDummyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FEDummyResponse(struct soap *soap, const char *tag, int id, const _ns3__FEDummyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FEDummyResponse), type))
		return soap->error;
	if (a->FEDummyResult)
		soap_element_result(soap, "ns3:FEDummyResult");
	if (soap_out_PointerTons3__DummyResponse(soap, "ns3:FEDummyResult", -1, &a->_ns3__FEDummyResponse::FEDummyResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FEDummyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FEDummyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FEDummyResponse * SOAP_FMAC4 soap_in__ns3__FEDummyResponse(struct soap *soap, const char *tag, _ns3__FEDummyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FEDummyResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FEDummyResponse, sizeof(_ns3__FEDummyResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FEDummyResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FEDummyResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FEDummyResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FEDummyResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__DummyResponse(soap, "ns3:FEDummyResult", &a->_ns3__FEDummyResponse::FEDummyResult, "ns3:DummyResponse"))
				{	soap_flag_FEDummyResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns3:FEDummyResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FEDummyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FEDummyResponse, SOAP_TYPE_afip__ns3__FEDummyResponse, sizeof(_ns3__FEDummyResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FEDummyResponse * SOAP_FMAC2 soap_instantiate__ns3__FEDummyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FEDummyResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FEDummyResponse *p;
	size_t k = sizeof(_ns3__FEDummyResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FEDummyResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FEDummyResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FEDummyResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FEDummyResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FEDummyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FEDummyResponse(soap, tag ? tag : "ns3:FEDummyResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FEDummyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FEDummyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FEDummyResponse * SOAP_FMAC4 soap_get__ns3__FEDummyResponse(struct soap *soap, _ns3__FEDummyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FEDummyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FEDummy::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _ns3__FEDummy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns3__FEDummy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FEDummy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FEDummy(struct soap *soap, const char *tag, int id, const _ns3__FEDummy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FEDummy), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FEDummy::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FEDummy(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FEDummy * SOAP_FMAC4 soap_in__ns3__FEDummy(struct soap *soap, const char *tag, _ns3__FEDummy *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FEDummy*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FEDummy, sizeof(_ns3__FEDummy), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FEDummy)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FEDummy *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FEDummy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FEDummy, SOAP_TYPE_afip__ns3__FEDummy, sizeof(_ns3__FEDummy), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FEDummy * SOAP_FMAC2 soap_instantiate__ns3__FEDummy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FEDummy(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FEDummy *p;
	size_t k = sizeof(_ns3__FEDummy);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FEDummy, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FEDummy);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FEDummy, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FEDummy location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FEDummy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FEDummy(soap, tag ? tag : "ns3:FEDummy", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FEDummy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FEDummy(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FEDummy * SOAP_FMAC4 soap_get__ns3__FEDummy(struct soap *soap, _ns3__FEDummy *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FEDummy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FECompTotXRequestResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FECompTotXRequestResponse::FECompTotXRequestResult = NULL;
}

void _ns3__FECompTotXRequestResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FERegXReqResponse(soap, &this->_ns3__FECompTotXRequestResponse::FECompTotXRequestResult);
#endif
}

int _ns3__FECompTotXRequestResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FECompTotXRequestResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FECompTotXRequestResponse(struct soap *soap, const char *tag, int id, const _ns3__FECompTotXRequestResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FECompTotXRequestResponse), type))
		return soap->error;
	if (a->FECompTotXRequestResult)
		soap_element_result(soap, "ns3:FECompTotXRequestResult");
	if (soap_out_PointerTons3__FERegXReqResponse(soap, "ns3:FECompTotXRequestResult", -1, &a->_ns3__FECompTotXRequestResponse::FECompTotXRequestResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FECompTotXRequestResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FECompTotXRequestResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FECompTotXRequestResponse * SOAP_FMAC4 soap_in__ns3__FECompTotXRequestResponse(struct soap *soap, const char *tag, _ns3__FECompTotXRequestResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FECompTotXRequestResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FECompTotXRequestResponse, sizeof(_ns3__FECompTotXRequestResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FECompTotXRequestResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FECompTotXRequestResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FECompTotXRequestResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FECompTotXRequestResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FERegXReqResponse(soap, "ns3:FECompTotXRequestResult", &a->_ns3__FECompTotXRequestResponse::FECompTotXRequestResult, "ns3:FERegXReqResponse"))
				{	soap_flag_FECompTotXRequestResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns3:FECompTotXRequestResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FECompTotXRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FECompTotXRequestResponse, SOAP_TYPE_afip__ns3__FECompTotXRequestResponse, sizeof(_ns3__FECompTotXRequestResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FECompTotXRequestResponse * SOAP_FMAC2 soap_instantiate__ns3__FECompTotXRequestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FECompTotXRequestResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FECompTotXRequestResponse *p;
	size_t k = sizeof(_ns3__FECompTotXRequestResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FECompTotXRequestResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FECompTotXRequestResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FECompTotXRequestResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FECompTotXRequestResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FECompTotXRequestResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FECompTotXRequestResponse(soap, tag ? tag : "ns3:FECompTotXRequestResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FECompTotXRequestResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FECompTotXRequestResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FECompTotXRequestResponse * SOAP_FMAC4 soap_get__ns3__FECompTotXRequestResponse(struct soap *soap, _ns3__FECompTotXRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FECompTotXRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FECompTotXRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FECompTotXRequest::Auth = NULL;
}

void _ns3__FECompTotXRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FEAuthRequest(soap, &this->_ns3__FECompTotXRequest::Auth);
#endif
}

int _ns3__FECompTotXRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FECompTotXRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FECompTotXRequest(struct soap *soap, const char *tag, int id, const _ns3__FECompTotXRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FECompTotXRequest), type))
		return soap->error;
	if (soap_out_PointerTons3__FEAuthRequest(soap, "ns3:Auth", -1, &a->_ns3__FECompTotXRequest::Auth, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FECompTotXRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FECompTotXRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FECompTotXRequest * SOAP_FMAC4 soap_in__ns3__FECompTotXRequest(struct soap *soap, const char *tag, _ns3__FECompTotXRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FECompTotXRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FECompTotXRequest, sizeof(_ns3__FECompTotXRequest), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FECompTotXRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FECompTotXRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FEAuthRequest(soap, "ns3:Auth", &a->_ns3__FECompTotXRequest::Auth, "ns3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FECompTotXRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FECompTotXRequest, SOAP_TYPE_afip__ns3__FECompTotXRequest, sizeof(_ns3__FECompTotXRequest), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FECompTotXRequest * SOAP_FMAC2 soap_instantiate__ns3__FECompTotXRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FECompTotXRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FECompTotXRequest *p;
	size_t k = sizeof(_ns3__FECompTotXRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FECompTotXRequest, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FECompTotXRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FECompTotXRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FECompTotXRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FECompTotXRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FECompTotXRequest(soap, tag ? tag : "ns3:FECompTotXRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FECompTotXRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FECompTotXRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FECompTotXRequest * SOAP_FMAC4 soap_get__ns3__FECompTotXRequest(struct soap *soap, _ns3__FECompTotXRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FECompTotXRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FECAESolicitarResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FECAESolicitarResponse::FECAESolicitarResult = NULL;
}

void _ns3__FECAESolicitarResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FECAEResponse(soap, &this->_ns3__FECAESolicitarResponse::FECAESolicitarResult);
#endif
}

int _ns3__FECAESolicitarResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FECAESolicitarResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FECAESolicitarResponse(struct soap *soap, const char *tag, int id, const _ns3__FECAESolicitarResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FECAESolicitarResponse), type))
		return soap->error;
	if (a->FECAESolicitarResult)
		soap_element_result(soap, "ns3:FECAESolicitarResult");
	if (soap_out_PointerTons3__FECAEResponse(soap, "ns3:FECAESolicitarResult", -1, &a->_ns3__FECAESolicitarResponse::FECAESolicitarResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FECAESolicitarResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FECAESolicitarResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FECAESolicitarResponse * SOAP_FMAC4 soap_in__ns3__FECAESolicitarResponse(struct soap *soap, const char *tag, _ns3__FECAESolicitarResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FECAESolicitarResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FECAESolicitarResponse, sizeof(_ns3__FECAESolicitarResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FECAESolicitarResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FECAESolicitarResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FECAESolicitarResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FECAESolicitarResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FECAEResponse(soap, "ns3:FECAESolicitarResult", &a->_ns3__FECAESolicitarResponse::FECAESolicitarResult, "ns3:FECAEResponse"))
				{	soap_flag_FECAESolicitarResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns3:FECAESolicitarResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FECAESolicitarResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FECAESolicitarResponse, SOAP_TYPE_afip__ns3__FECAESolicitarResponse, sizeof(_ns3__FECAESolicitarResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FECAESolicitarResponse * SOAP_FMAC2 soap_instantiate__ns3__FECAESolicitarResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FECAESolicitarResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FECAESolicitarResponse *p;
	size_t k = sizeof(_ns3__FECAESolicitarResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FECAESolicitarResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FECAESolicitarResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FECAESolicitarResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FECAESolicitarResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FECAESolicitarResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FECAESolicitarResponse(soap, tag ? tag : "ns3:FECAESolicitarResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FECAESolicitarResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FECAESolicitarResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FECAESolicitarResponse * SOAP_FMAC4 soap_get__ns3__FECAESolicitarResponse(struct soap *soap, _ns3__FECAESolicitarResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FECAESolicitarResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns3__FECAESolicitar::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__FECAESolicitar::Auth = NULL;
	this->_ns3__FECAESolicitar::FeCAEReq = NULL;
}

void _ns3__FECAESolicitar::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FEAuthRequest(soap, &this->_ns3__FECAESolicitar::Auth);
	soap_serialize_PointerTons3__FECAERequest(soap, &this->_ns3__FECAESolicitar::FeCAEReq);
#endif
}

int _ns3__FECAESolicitar::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__FECAESolicitar(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__FECAESolicitar(struct soap *soap, const char *tag, int id, const _ns3__FECAESolicitar *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns3__FECAESolicitar), type))
		return soap->error;
	if (soap_out_PointerTons3__FEAuthRequest(soap, "ns3:Auth", -1, &a->_ns3__FECAESolicitar::Auth, ""))
		return soap->error;
	if (soap_out_PointerTons3__FECAERequest(soap, "ns3:FeCAEReq", -1, &a->_ns3__FECAESolicitar::FeCAEReq, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns3__FECAESolicitar::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns3__FECAESolicitar(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__FECAESolicitar * SOAP_FMAC4 soap_in__ns3__FECAESolicitar(struct soap *soap, const char *tag, _ns3__FECAESolicitar *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__FECAESolicitar*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns3__FECAESolicitar, sizeof(_ns3__FECAESolicitar), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns3__FECAESolicitar)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns3__FECAESolicitar *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	size_t soap_flag_FeCAEReq1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FEAuthRequest(soap, "ns3:Auth", &a->_ns3__FECAESolicitar::Auth, "ns3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap_flag_FeCAEReq1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FECAERequest(soap, "ns3:FeCAEReq", &a->_ns3__FECAESolicitar::FeCAEReq, "ns3:FECAERequest"))
				{	soap_flag_FeCAEReq1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__FECAESolicitar *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns3__FECAESolicitar, SOAP_TYPE_afip__ns3__FECAESolicitar, sizeof(_ns3__FECAESolicitar), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns3__FECAESolicitar * SOAP_FMAC2 soap_instantiate__ns3__FECAESolicitar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__FECAESolicitar(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns3__FECAESolicitar *p;
	size_t k = sizeof(_ns3__FECAESolicitar);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns3__FECAESolicitar, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns3__FECAESolicitar);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns3__FECAESolicitar, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns3__FECAESolicitar location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns3__FECAESolicitar::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns3__FECAESolicitar(soap, tag ? tag : "ns3:FECAESolicitar", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__FECAESolicitar::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__FECAESolicitar(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__FECAESolicitar * SOAP_FMAC4 soap_get__ns3__FECAESolicitar(struct soap *soap, _ns3__FECAESolicitar *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__FECAESolicitar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__PaisTipo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_short(soap, &this->ns3__PaisTipo::Id);
	this->ns3__PaisTipo::Desc = NULL;
}

void ns3__PaisTipo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns3__PaisTipo::Desc);
#endif
}

int ns3__PaisTipo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__PaisTipo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__PaisTipo(struct soap *soap, const char *tag, int id, const ns3__PaisTipo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__PaisTipo), type))
		return soap->error;
	if (soap_out_short(soap, "ns3:Id", -1, &a->ns3__PaisTipo::Id, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Desc", -1, &a->ns3__PaisTipo::Desc, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__PaisTipo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__PaisTipo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__PaisTipo * SOAP_FMAC4 soap_in_ns3__PaisTipo(struct soap *soap, const char *tag, ns3__PaisTipo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__PaisTipo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__PaisTipo, sizeof(ns3__PaisTipo), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__PaisTipo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__PaisTipo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_Desc1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_short(soap, "ns3:Id", &a->ns3__PaisTipo::Id, "xsd:short"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_Desc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Desc", &a->ns3__PaisTipo::Desc, "xsd:string"))
				{	soap_flag_Desc1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__PaisTipo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__PaisTipo, SOAP_TYPE_afip_ns3__PaisTipo, sizeof(ns3__PaisTipo), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__PaisTipo * SOAP_FMAC2 soap_instantiate_ns3__PaisTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__PaisTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__PaisTipo *p;
	size_t k = sizeof(ns3__PaisTipo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__PaisTipo, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__PaisTipo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__PaisTipo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__PaisTipo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__PaisTipo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__PaisTipo(soap, tag ? tag : "ns3:PaisTipo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__PaisTipo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__PaisTipo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__PaisTipo * SOAP_FMAC4 soap_get_ns3__PaisTipo(struct soap *soap, ns3__PaisTipo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__PaisTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__ArrayOfPaisTipo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__PaisTipo(soap, &this->ns3__ArrayOfPaisTipo::PaisTipo);
}

void ns3__ArrayOfPaisTipo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons3__PaisTipo(soap, &this->ns3__ArrayOfPaisTipo::PaisTipo);
#endif
}

int ns3__ArrayOfPaisTipo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfPaisTipo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfPaisTipo(struct soap *soap, const char *tag, int id, const ns3__ArrayOfPaisTipo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__ArrayOfPaisTipo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__PaisTipo(soap, "ns3:PaisTipo", -1, &a->ns3__ArrayOfPaisTipo::PaisTipo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfPaisTipo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__ArrayOfPaisTipo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfPaisTipo * SOAP_FMAC4 soap_in_ns3__ArrayOfPaisTipo(struct soap *soap, const char *tag, ns3__ArrayOfPaisTipo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfPaisTipo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__ArrayOfPaisTipo, sizeof(ns3__ArrayOfPaisTipo), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__ArrayOfPaisTipo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__ArrayOfPaisTipo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__PaisTipo(soap, "ns3:PaisTipo", &a->ns3__ArrayOfPaisTipo::PaisTipo, "ns3:PaisTipo"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfPaisTipo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__ArrayOfPaisTipo, SOAP_TYPE_afip_ns3__ArrayOfPaisTipo, sizeof(ns3__ArrayOfPaisTipo), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__ArrayOfPaisTipo * SOAP_FMAC2 soap_instantiate_ns3__ArrayOfPaisTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfPaisTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__ArrayOfPaisTipo *p;
	size_t k = sizeof(ns3__ArrayOfPaisTipo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__ArrayOfPaisTipo, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__ArrayOfPaisTipo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__ArrayOfPaisTipo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__ArrayOfPaisTipo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__ArrayOfPaisTipo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__ArrayOfPaisTipo(soap, tag ? tag : "ns3:ArrayOfPaisTipo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ArrayOfPaisTipo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfPaisTipo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfPaisTipo * SOAP_FMAC4 soap_get_ns3__ArrayOfPaisTipo(struct soap *soap, ns3__ArrayOfPaisTipo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfPaisTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__FEPaisResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__FEPaisResponse::ResultGet = NULL;
	this->ns3__FEPaisResponse::Errors = NULL;
	this->ns3__FEPaisResponse::Events = NULL;
}

void ns3__FEPaisResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__ArrayOfPaisTipo(soap, &this->ns3__FEPaisResponse::ResultGet);
	soap_serialize_PointerTons3__ArrayOfErr(soap, &this->ns3__FEPaisResponse::Errors);
	soap_serialize_PointerTons3__ArrayOfEvt(soap, &this->ns3__FEPaisResponse::Events);
#endif
}

int ns3__FEPaisResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__FEPaisResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FEPaisResponse(struct soap *soap, const char *tag, int id, const ns3__FEPaisResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__FEPaisResponse), type))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfPaisTipo(soap, "ns3:ResultGet", -1, &a->ns3__FEPaisResponse::ResultGet, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfErr(soap, "ns3:Errors", -1, &a->ns3__FEPaisResponse::Errors, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfEvt(soap, "ns3:Events", -1, &a->ns3__FEPaisResponse::Events, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__FEPaisResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__FEPaisResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns3__FEPaisResponse * SOAP_FMAC4 soap_in_ns3__FEPaisResponse(struct soap *soap, const char *tag, ns3__FEPaisResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__FEPaisResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__FEPaisResponse, sizeof(ns3__FEPaisResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__FEPaisResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__FEPaisResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResultGet1 = 1;
	size_t soap_flag_Errors1 = 1;
	size_t soap_flag_Events1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultGet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfPaisTipo(soap, "ns3:ResultGet", &a->ns3__FEPaisResponse::ResultGet, "ns3:ArrayOfPaisTipo"))
				{	soap_flag_ResultGet1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfErr(soap, "ns3:Errors", &a->ns3__FEPaisResponse::Errors, "ns3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfEvt(soap, "ns3:Events", &a->ns3__FEPaisResponse::Events, "ns3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__FEPaisResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__FEPaisResponse, SOAP_TYPE_afip_ns3__FEPaisResponse, sizeof(ns3__FEPaisResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__FEPaisResponse * SOAP_FMAC2 soap_instantiate_ns3__FEPaisResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__FEPaisResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__FEPaisResponse *p;
	size_t k = sizeof(ns3__FEPaisResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FEPaisResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__FEPaisResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__FEPaisResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__FEPaisResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__FEPaisResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__FEPaisResponse(soap, tag ? tag : "ns3:FEPaisResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__FEPaisResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__FEPaisResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns3__FEPaisResponse * SOAP_FMAC4 soap_get_ns3__FEPaisResponse(struct soap *soap, ns3__FEPaisResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__FEPaisResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__DocTipo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns3__DocTipo::Id);
	this->ns3__DocTipo::Desc = NULL;
	this->ns3__DocTipo::FchDesde = NULL;
	this->ns3__DocTipo::FchHasta = NULL;
}

void ns3__DocTipo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns3__DocTipo::Desc);
	soap_serialize_PointerTostd__string(soap, &this->ns3__DocTipo::FchDesde);
	soap_serialize_PointerTostd__string(soap, &this->ns3__DocTipo::FchHasta);
#endif
}

int ns3__DocTipo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__DocTipo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__DocTipo(struct soap *soap, const char *tag, int id, const ns3__DocTipo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__DocTipo), type))
		return soap->error;
	if (soap_out_int(soap, "ns3:Id", -1, &a->ns3__DocTipo::Id, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Desc", -1, &a->ns3__DocTipo::Desc, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchDesde", -1, &a->ns3__DocTipo::FchDesde, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchHasta", -1, &a->ns3__DocTipo::FchHasta, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__DocTipo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__DocTipo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__DocTipo * SOAP_FMAC4 soap_in_ns3__DocTipo(struct soap *soap, const char *tag, ns3__DocTipo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__DocTipo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__DocTipo, sizeof(ns3__DocTipo), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__DocTipo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__DocTipo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_Desc1 = 1;
	size_t soap_flag_FchDesde1 = 1;
	size_t soap_flag_FchHasta1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:Id", &a->ns3__DocTipo::Id, "xsd:int"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_Desc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Desc", &a->ns3__DocTipo::Desc, "xsd:string"))
				{	soap_flag_Desc1--;
					continue;
				}
			}
			if (soap_flag_FchDesde1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchDesde", &a->ns3__DocTipo::FchDesde, "xsd:string"))
				{	soap_flag_FchDesde1--;
					continue;
				}
			}
			if (soap_flag_FchHasta1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchHasta", &a->ns3__DocTipo::FchHasta, "xsd:string"))
				{	soap_flag_FchHasta1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__DocTipo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__DocTipo, SOAP_TYPE_afip_ns3__DocTipo, sizeof(ns3__DocTipo), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__DocTipo * SOAP_FMAC2 soap_instantiate_ns3__DocTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__DocTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__DocTipo *p;
	size_t k = sizeof(ns3__DocTipo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__DocTipo, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__DocTipo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__DocTipo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__DocTipo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__DocTipo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__DocTipo(soap, tag ? tag : "ns3:DocTipo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__DocTipo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__DocTipo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__DocTipo * SOAP_FMAC4 soap_get_ns3__DocTipo(struct soap *soap, ns3__DocTipo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__DocTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__ArrayOfDocTipo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__DocTipo(soap, &this->ns3__ArrayOfDocTipo::DocTipo);
}

void ns3__ArrayOfDocTipo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons3__DocTipo(soap, &this->ns3__ArrayOfDocTipo::DocTipo);
#endif
}

int ns3__ArrayOfDocTipo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfDocTipo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfDocTipo(struct soap *soap, const char *tag, int id, const ns3__ArrayOfDocTipo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__ArrayOfDocTipo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__DocTipo(soap, "ns3:DocTipo", -1, &a->ns3__ArrayOfDocTipo::DocTipo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfDocTipo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__ArrayOfDocTipo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfDocTipo * SOAP_FMAC4 soap_in_ns3__ArrayOfDocTipo(struct soap *soap, const char *tag, ns3__ArrayOfDocTipo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfDocTipo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__ArrayOfDocTipo, sizeof(ns3__ArrayOfDocTipo), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__ArrayOfDocTipo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__ArrayOfDocTipo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__DocTipo(soap, "ns3:DocTipo", &a->ns3__ArrayOfDocTipo::DocTipo, "ns3:DocTipo"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfDocTipo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__ArrayOfDocTipo, SOAP_TYPE_afip_ns3__ArrayOfDocTipo, sizeof(ns3__ArrayOfDocTipo), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__ArrayOfDocTipo * SOAP_FMAC2 soap_instantiate_ns3__ArrayOfDocTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfDocTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__ArrayOfDocTipo *p;
	size_t k = sizeof(ns3__ArrayOfDocTipo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__ArrayOfDocTipo, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__ArrayOfDocTipo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__ArrayOfDocTipo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__ArrayOfDocTipo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__ArrayOfDocTipo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__ArrayOfDocTipo(soap, tag ? tag : "ns3:ArrayOfDocTipo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ArrayOfDocTipo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfDocTipo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfDocTipo * SOAP_FMAC4 soap_get_ns3__ArrayOfDocTipo(struct soap *soap, ns3__ArrayOfDocTipo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfDocTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__DocTipoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__DocTipoResponse::ResultGet = NULL;
	this->ns3__DocTipoResponse::Errors = NULL;
	this->ns3__DocTipoResponse::Events = NULL;
}

void ns3__DocTipoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__ArrayOfDocTipo(soap, &this->ns3__DocTipoResponse::ResultGet);
	soap_serialize_PointerTons3__ArrayOfErr(soap, &this->ns3__DocTipoResponse::Errors);
	soap_serialize_PointerTons3__ArrayOfEvt(soap, &this->ns3__DocTipoResponse::Events);
#endif
}

int ns3__DocTipoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__DocTipoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__DocTipoResponse(struct soap *soap, const char *tag, int id, const ns3__DocTipoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__DocTipoResponse), type))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfDocTipo(soap, "ns3:ResultGet", -1, &a->ns3__DocTipoResponse::ResultGet, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfErr(soap, "ns3:Errors", -1, &a->ns3__DocTipoResponse::Errors, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfEvt(soap, "ns3:Events", -1, &a->ns3__DocTipoResponse::Events, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__DocTipoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__DocTipoResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns3__DocTipoResponse * SOAP_FMAC4 soap_in_ns3__DocTipoResponse(struct soap *soap, const char *tag, ns3__DocTipoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__DocTipoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__DocTipoResponse, sizeof(ns3__DocTipoResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__DocTipoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__DocTipoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResultGet1 = 1;
	size_t soap_flag_Errors1 = 1;
	size_t soap_flag_Events1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultGet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfDocTipo(soap, "ns3:ResultGet", &a->ns3__DocTipoResponse::ResultGet, "ns3:ArrayOfDocTipo"))
				{	soap_flag_ResultGet1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfErr(soap, "ns3:Errors", &a->ns3__DocTipoResponse::Errors, "ns3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfEvt(soap, "ns3:Events", &a->ns3__DocTipoResponse::Events, "ns3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__DocTipoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__DocTipoResponse, SOAP_TYPE_afip_ns3__DocTipoResponse, sizeof(ns3__DocTipoResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__DocTipoResponse * SOAP_FMAC2 soap_instantiate_ns3__DocTipoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__DocTipoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__DocTipoResponse *p;
	size_t k = sizeof(ns3__DocTipoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__DocTipoResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__DocTipoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__DocTipoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__DocTipoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__DocTipoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__DocTipoResponse(soap, tag ? tag : "ns3:DocTipoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__DocTipoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__DocTipoResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns3__DocTipoResponse * SOAP_FMAC4 soap_get_ns3__DocTipoResponse(struct soap *soap, ns3__DocTipoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__DocTipoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__CbteTipo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns3__CbteTipo::Id);
	this->ns3__CbteTipo::Desc = NULL;
	this->ns3__CbteTipo::FchDesde = NULL;
	this->ns3__CbteTipo::FchHasta = NULL;
}

void ns3__CbteTipo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns3__CbteTipo::Desc);
	soap_serialize_PointerTostd__string(soap, &this->ns3__CbteTipo::FchDesde);
	soap_serialize_PointerTostd__string(soap, &this->ns3__CbteTipo::FchHasta);
#endif
}

int ns3__CbteTipo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__CbteTipo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__CbteTipo(struct soap *soap, const char *tag, int id, const ns3__CbteTipo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__CbteTipo), type))
		return soap->error;
	if (soap_out_int(soap, "ns3:Id", -1, &a->ns3__CbteTipo::Id, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Desc", -1, &a->ns3__CbteTipo::Desc, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchDesde", -1, &a->ns3__CbteTipo::FchDesde, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchHasta", -1, &a->ns3__CbteTipo::FchHasta, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__CbteTipo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__CbteTipo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__CbteTipo * SOAP_FMAC4 soap_in_ns3__CbteTipo(struct soap *soap, const char *tag, ns3__CbteTipo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__CbteTipo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__CbteTipo, sizeof(ns3__CbteTipo), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__CbteTipo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__CbteTipo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_Desc1 = 1;
	size_t soap_flag_FchDesde1 = 1;
	size_t soap_flag_FchHasta1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:Id", &a->ns3__CbteTipo::Id, "xsd:int"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_Desc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Desc", &a->ns3__CbteTipo::Desc, "xsd:string"))
				{	soap_flag_Desc1--;
					continue;
				}
			}
			if (soap_flag_FchDesde1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchDesde", &a->ns3__CbteTipo::FchDesde, "xsd:string"))
				{	soap_flag_FchDesde1--;
					continue;
				}
			}
			if (soap_flag_FchHasta1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchHasta", &a->ns3__CbteTipo::FchHasta, "xsd:string"))
				{	soap_flag_FchHasta1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__CbteTipo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__CbteTipo, SOAP_TYPE_afip_ns3__CbteTipo, sizeof(ns3__CbteTipo), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__CbteTipo * SOAP_FMAC2 soap_instantiate_ns3__CbteTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__CbteTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__CbteTipo *p;
	size_t k = sizeof(ns3__CbteTipo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__CbteTipo, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__CbteTipo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__CbteTipo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__CbteTipo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__CbteTipo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__CbteTipo(soap, tag ? tag : "ns3:CbteTipo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__CbteTipo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__CbteTipo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__CbteTipo * SOAP_FMAC4 soap_get_ns3__CbteTipo(struct soap *soap, ns3__CbteTipo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__CbteTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__ArrayOfCbteTipo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__CbteTipo(soap, &this->ns3__ArrayOfCbteTipo::CbteTipo);
}

void ns3__ArrayOfCbteTipo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons3__CbteTipo(soap, &this->ns3__ArrayOfCbteTipo::CbteTipo);
#endif
}

int ns3__ArrayOfCbteTipo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfCbteTipo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfCbteTipo(struct soap *soap, const char *tag, int id, const ns3__ArrayOfCbteTipo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__ArrayOfCbteTipo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__CbteTipo(soap, "ns3:CbteTipo", -1, &a->ns3__ArrayOfCbteTipo::CbteTipo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfCbteTipo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__ArrayOfCbteTipo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfCbteTipo * SOAP_FMAC4 soap_in_ns3__ArrayOfCbteTipo(struct soap *soap, const char *tag, ns3__ArrayOfCbteTipo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfCbteTipo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__ArrayOfCbteTipo, sizeof(ns3__ArrayOfCbteTipo), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__ArrayOfCbteTipo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__ArrayOfCbteTipo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__CbteTipo(soap, "ns3:CbteTipo", &a->ns3__ArrayOfCbteTipo::CbteTipo, "ns3:CbteTipo"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfCbteTipo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__ArrayOfCbteTipo, SOAP_TYPE_afip_ns3__ArrayOfCbteTipo, sizeof(ns3__ArrayOfCbteTipo), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__ArrayOfCbteTipo * SOAP_FMAC2 soap_instantiate_ns3__ArrayOfCbteTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfCbteTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__ArrayOfCbteTipo *p;
	size_t k = sizeof(ns3__ArrayOfCbteTipo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__ArrayOfCbteTipo, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__ArrayOfCbteTipo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__ArrayOfCbteTipo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__ArrayOfCbteTipo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__ArrayOfCbteTipo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__ArrayOfCbteTipo(soap, tag ? tag : "ns3:ArrayOfCbteTipo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ArrayOfCbteTipo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfCbteTipo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfCbteTipo * SOAP_FMAC4 soap_get_ns3__ArrayOfCbteTipo(struct soap *soap, ns3__ArrayOfCbteTipo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfCbteTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__CbteTipoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__CbteTipoResponse::ResultGet = NULL;
	this->ns3__CbteTipoResponse::Errors = NULL;
	this->ns3__CbteTipoResponse::Events = NULL;
}

void ns3__CbteTipoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__ArrayOfCbteTipo(soap, &this->ns3__CbteTipoResponse::ResultGet);
	soap_serialize_PointerTons3__ArrayOfErr(soap, &this->ns3__CbteTipoResponse::Errors);
	soap_serialize_PointerTons3__ArrayOfEvt(soap, &this->ns3__CbteTipoResponse::Events);
#endif
}

int ns3__CbteTipoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__CbteTipoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__CbteTipoResponse(struct soap *soap, const char *tag, int id, const ns3__CbteTipoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__CbteTipoResponse), type))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfCbteTipo(soap, "ns3:ResultGet", -1, &a->ns3__CbteTipoResponse::ResultGet, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfErr(soap, "ns3:Errors", -1, &a->ns3__CbteTipoResponse::Errors, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfEvt(soap, "ns3:Events", -1, &a->ns3__CbteTipoResponse::Events, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__CbteTipoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__CbteTipoResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns3__CbteTipoResponse * SOAP_FMAC4 soap_in_ns3__CbteTipoResponse(struct soap *soap, const char *tag, ns3__CbteTipoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__CbteTipoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__CbteTipoResponse, sizeof(ns3__CbteTipoResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__CbteTipoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__CbteTipoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResultGet1 = 1;
	size_t soap_flag_Errors1 = 1;
	size_t soap_flag_Events1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultGet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfCbteTipo(soap, "ns3:ResultGet", &a->ns3__CbteTipoResponse::ResultGet, "ns3:ArrayOfCbteTipo"))
				{	soap_flag_ResultGet1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfErr(soap, "ns3:Errors", &a->ns3__CbteTipoResponse::Errors, "ns3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfEvt(soap, "ns3:Events", &a->ns3__CbteTipoResponse::Events, "ns3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__CbteTipoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__CbteTipoResponse, SOAP_TYPE_afip_ns3__CbteTipoResponse, sizeof(ns3__CbteTipoResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__CbteTipoResponse * SOAP_FMAC2 soap_instantiate_ns3__CbteTipoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__CbteTipoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__CbteTipoResponse *p;
	size_t k = sizeof(ns3__CbteTipoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__CbteTipoResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__CbteTipoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__CbteTipoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__CbteTipoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__CbteTipoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__CbteTipoResponse(soap, tag ? tag : "ns3:CbteTipoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__CbteTipoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__CbteTipoResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns3__CbteTipoResponse * SOAP_FMAC4 soap_get_ns3__CbteTipoResponse(struct soap *soap, ns3__CbteTipoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__CbteTipoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__PtoVenta::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns3__PtoVenta::Nro);
	this->ns3__PtoVenta::EmisionTipo = NULL;
	this->ns3__PtoVenta::Bloqueado = NULL;
	this->ns3__PtoVenta::FchBaja = NULL;
}

void ns3__PtoVenta::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns3__PtoVenta::EmisionTipo);
	soap_serialize_PointerTostd__string(soap, &this->ns3__PtoVenta::Bloqueado);
	soap_serialize_PointerTostd__string(soap, &this->ns3__PtoVenta::FchBaja);
#endif
}

int ns3__PtoVenta::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__PtoVenta(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__PtoVenta(struct soap *soap, const char *tag, int id, const ns3__PtoVenta *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__PtoVenta), type))
		return soap->error;
	if (soap_out_int(soap, "ns3:Nro", -1, &a->ns3__PtoVenta::Nro, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:EmisionTipo", -1, &a->ns3__PtoVenta::EmisionTipo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Bloqueado", -1, &a->ns3__PtoVenta::Bloqueado, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchBaja", -1, &a->ns3__PtoVenta::FchBaja, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__PtoVenta::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__PtoVenta(soap, tag, this, type);
}

SOAP_FMAC3 ns3__PtoVenta * SOAP_FMAC4 soap_in_ns3__PtoVenta(struct soap *soap, const char *tag, ns3__PtoVenta *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__PtoVenta*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__PtoVenta, sizeof(ns3__PtoVenta), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__PtoVenta)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__PtoVenta *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Nro1 = 1;
	size_t soap_flag_EmisionTipo1 = 1;
	size_t soap_flag_Bloqueado1 = 1;
	size_t soap_flag_FchBaja1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Nro1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:Nro", &a->ns3__PtoVenta::Nro, "xsd:int"))
				{	soap_flag_Nro1--;
					continue;
				}
			}
			if (soap_flag_EmisionTipo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:EmisionTipo", &a->ns3__PtoVenta::EmisionTipo, "xsd:string"))
				{	soap_flag_EmisionTipo1--;
					continue;
				}
			}
			if (soap_flag_Bloqueado1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Bloqueado", &a->ns3__PtoVenta::Bloqueado, "xsd:string"))
				{	soap_flag_Bloqueado1--;
					continue;
				}
			}
			if (soap_flag_FchBaja1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchBaja", &a->ns3__PtoVenta::FchBaja, "xsd:string"))
				{	soap_flag_FchBaja1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Nro1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__PtoVenta *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__PtoVenta, SOAP_TYPE_afip_ns3__PtoVenta, sizeof(ns3__PtoVenta), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__PtoVenta * SOAP_FMAC2 soap_instantiate_ns3__PtoVenta(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__PtoVenta(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__PtoVenta *p;
	size_t k = sizeof(ns3__PtoVenta);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__PtoVenta, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__PtoVenta);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__PtoVenta, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__PtoVenta location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__PtoVenta::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__PtoVenta(soap, tag ? tag : "ns3:PtoVenta", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__PtoVenta::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__PtoVenta(soap, this, tag, type);
}

SOAP_FMAC3 ns3__PtoVenta * SOAP_FMAC4 soap_get_ns3__PtoVenta(struct soap *soap, ns3__PtoVenta *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__PtoVenta(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__ArrayOfPtoVenta::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__PtoVenta(soap, &this->ns3__ArrayOfPtoVenta::PtoVenta);
}

void ns3__ArrayOfPtoVenta::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons3__PtoVenta(soap, &this->ns3__ArrayOfPtoVenta::PtoVenta);
#endif
}

int ns3__ArrayOfPtoVenta::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfPtoVenta(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfPtoVenta(struct soap *soap, const char *tag, int id, const ns3__ArrayOfPtoVenta *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__ArrayOfPtoVenta), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__PtoVenta(soap, "ns3:PtoVenta", -1, &a->ns3__ArrayOfPtoVenta::PtoVenta, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfPtoVenta::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__ArrayOfPtoVenta(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfPtoVenta * SOAP_FMAC4 soap_in_ns3__ArrayOfPtoVenta(struct soap *soap, const char *tag, ns3__ArrayOfPtoVenta *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfPtoVenta*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__ArrayOfPtoVenta, sizeof(ns3__ArrayOfPtoVenta), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__ArrayOfPtoVenta)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__ArrayOfPtoVenta *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__PtoVenta(soap, "ns3:PtoVenta", &a->ns3__ArrayOfPtoVenta::PtoVenta, "ns3:PtoVenta"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfPtoVenta *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__ArrayOfPtoVenta, SOAP_TYPE_afip_ns3__ArrayOfPtoVenta, sizeof(ns3__ArrayOfPtoVenta), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__ArrayOfPtoVenta * SOAP_FMAC2 soap_instantiate_ns3__ArrayOfPtoVenta(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfPtoVenta(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__ArrayOfPtoVenta *p;
	size_t k = sizeof(ns3__ArrayOfPtoVenta);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__ArrayOfPtoVenta, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__ArrayOfPtoVenta);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__ArrayOfPtoVenta, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__ArrayOfPtoVenta location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__ArrayOfPtoVenta::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__ArrayOfPtoVenta(soap, tag ? tag : "ns3:ArrayOfPtoVenta", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ArrayOfPtoVenta::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfPtoVenta(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfPtoVenta * SOAP_FMAC4 soap_get_ns3__ArrayOfPtoVenta(struct soap *soap, ns3__ArrayOfPtoVenta *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfPtoVenta(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__FEPtoVentaResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__FEPtoVentaResponse::ResultGet = NULL;
	this->ns3__FEPtoVentaResponse::Errors = NULL;
	this->ns3__FEPtoVentaResponse::Events = NULL;
}

void ns3__FEPtoVentaResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__ArrayOfPtoVenta(soap, &this->ns3__FEPtoVentaResponse::ResultGet);
	soap_serialize_PointerTons3__ArrayOfErr(soap, &this->ns3__FEPtoVentaResponse::Errors);
	soap_serialize_PointerTons3__ArrayOfEvt(soap, &this->ns3__FEPtoVentaResponse::Events);
#endif
}

int ns3__FEPtoVentaResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__FEPtoVentaResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FEPtoVentaResponse(struct soap *soap, const char *tag, int id, const ns3__FEPtoVentaResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__FEPtoVentaResponse), type))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfPtoVenta(soap, "ns3:ResultGet", -1, &a->ns3__FEPtoVentaResponse::ResultGet, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfErr(soap, "ns3:Errors", -1, &a->ns3__FEPtoVentaResponse::Errors, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfEvt(soap, "ns3:Events", -1, &a->ns3__FEPtoVentaResponse::Events, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__FEPtoVentaResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__FEPtoVentaResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns3__FEPtoVentaResponse * SOAP_FMAC4 soap_in_ns3__FEPtoVentaResponse(struct soap *soap, const char *tag, ns3__FEPtoVentaResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__FEPtoVentaResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__FEPtoVentaResponse, sizeof(ns3__FEPtoVentaResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__FEPtoVentaResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__FEPtoVentaResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResultGet1 = 1;
	size_t soap_flag_Errors1 = 1;
	size_t soap_flag_Events1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultGet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfPtoVenta(soap, "ns3:ResultGet", &a->ns3__FEPtoVentaResponse::ResultGet, "ns3:ArrayOfPtoVenta"))
				{	soap_flag_ResultGet1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfErr(soap, "ns3:Errors", &a->ns3__FEPtoVentaResponse::Errors, "ns3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfEvt(soap, "ns3:Events", &a->ns3__FEPtoVentaResponse::Events, "ns3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__FEPtoVentaResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__FEPtoVentaResponse, SOAP_TYPE_afip_ns3__FEPtoVentaResponse, sizeof(ns3__FEPtoVentaResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__FEPtoVentaResponse * SOAP_FMAC2 soap_instantiate_ns3__FEPtoVentaResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__FEPtoVentaResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__FEPtoVentaResponse *p;
	size_t k = sizeof(ns3__FEPtoVentaResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FEPtoVentaResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__FEPtoVentaResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__FEPtoVentaResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__FEPtoVentaResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__FEPtoVentaResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__FEPtoVentaResponse(soap, tag ? tag : "ns3:FEPtoVentaResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__FEPtoVentaResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__FEPtoVentaResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns3__FEPtoVentaResponse * SOAP_FMAC4 soap_get_ns3__FEPtoVentaResponse(struct soap *soap, ns3__FEPtoVentaResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__FEPtoVentaResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__ConceptoTipo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns3__ConceptoTipo::Id);
	this->ns3__ConceptoTipo::Desc = NULL;
	this->ns3__ConceptoTipo::FchDesde = NULL;
	this->ns3__ConceptoTipo::FchHasta = NULL;
}

void ns3__ConceptoTipo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns3__ConceptoTipo::Desc);
	soap_serialize_PointerTostd__string(soap, &this->ns3__ConceptoTipo::FchDesde);
	soap_serialize_PointerTostd__string(soap, &this->ns3__ConceptoTipo::FchHasta);
#endif
}

int ns3__ConceptoTipo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ConceptoTipo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ConceptoTipo(struct soap *soap, const char *tag, int id, const ns3__ConceptoTipo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__ConceptoTipo), type))
		return soap->error;
	if (soap_out_int(soap, "ns3:Id", -1, &a->ns3__ConceptoTipo::Id, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Desc", -1, &a->ns3__ConceptoTipo::Desc, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchDesde", -1, &a->ns3__ConceptoTipo::FchDesde, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchHasta", -1, &a->ns3__ConceptoTipo::FchHasta, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__ConceptoTipo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__ConceptoTipo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ConceptoTipo * SOAP_FMAC4 soap_in_ns3__ConceptoTipo(struct soap *soap, const char *tag, ns3__ConceptoTipo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ConceptoTipo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__ConceptoTipo, sizeof(ns3__ConceptoTipo), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__ConceptoTipo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__ConceptoTipo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_Desc1 = 1;
	size_t soap_flag_FchDesde1 = 1;
	size_t soap_flag_FchHasta1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:Id", &a->ns3__ConceptoTipo::Id, "xsd:int"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_Desc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Desc", &a->ns3__ConceptoTipo::Desc, "xsd:string"))
				{	soap_flag_Desc1--;
					continue;
				}
			}
			if (soap_flag_FchDesde1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchDesde", &a->ns3__ConceptoTipo::FchDesde, "xsd:string"))
				{	soap_flag_FchDesde1--;
					continue;
				}
			}
			if (soap_flag_FchHasta1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchHasta", &a->ns3__ConceptoTipo::FchHasta, "xsd:string"))
				{	soap_flag_FchHasta1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__ConceptoTipo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__ConceptoTipo, SOAP_TYPE_afip_ns3__ConceptoTipo, sizeof(ns3__ConceptoTipo), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__ConceptoTipo * SOAP_FMAC2 soap_instantiate_ns3__ConceptoTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ConceptoTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__ConceptoTipo *p;
	size_t k = sizeof(ns3__ConceptoTipo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__ConceptoTipo, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__ConceptoTipo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__ConceptoTipo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__ConceptoTipo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__ConceptoTipo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__ConceptoTipo(soap, tag ? tag : "ns3:ConceptoTipo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ConceptoTipo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ConceptoTipo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ConceptoTipo * SOAP_FMAC4 soap_get_ns3__ConceptoTipo(struct soap *soap, ns3__ConceptoTipo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ConceptoTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__ArrayOfConceptoTipo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__ConceptoTipo(soap, &this->ns3__ArrayOfConceptoTipo::ConceptoTipo);
}

void ns3__ArrayOfConceptoTipo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons3__ConceptoTipo(soap, &this->ns3__ArrayOfConceptoTipo::ConceptoTipo);
#endif
}

int ns3__ArrayOfConceptoTipo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfConceptoTipo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfConceptoTipo(struct soap *soap, const char *tag, int id, const ns3__ArrayOfConceptoTipo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__ArrayOfConceptoTipo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__ConceptoTipo(soap, "ns3:ConceptoTipo", -1, &a->ns3__ArrayOfConceptoTipo::ConceptoTipo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfConceptoTipo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__ArrayOfConceptoTipo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfConceptoTipo * SOAP_FMAC4 soap_in_ns3__ArrayOfConceptoTipo(struct soap *soap, const char *tag, ns3__ArrayOfConceptoTipo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfConceptoTipo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__ArrayOfConceptoTipo, sizeof(ns3__ArrayOfConceptoTipo), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__ArrayOfConceptoTipo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__ArrayOfConceptoTipo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__ConceptoTipo(soap, "ns3:ConceptoTipo", &a->ns3__ArrayOfConceptoTipo::ConceptoTipo, "ns3:ConceptoTipo"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfConceptoTipo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__ArrayOfConceptoTipo, SOAP_TYPE_afip_ns3__ArrayOfConceptoTipo, sizeof(ns3__ArrayOfConceptoTipo), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__ArrayOfConceptoTipo * SOAP_FMAC2 soap_instantiate_ns3__ArrayOfConceptoTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfConceptoTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__ArrayOfConceptoTipo *p;
	size_t k = sizeof(ns3__ArrayOfConceptoTipo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__ArrayOfConceptoTipo, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__ArrayOfConceptoTipo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__ArrayOfConceptoTipo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__ArrayOfConceptoTipo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__ArrayOfConceptoTipo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__ArrayOfConceptoTipo(soap, tag ? tag : "ns3:ArrayOfConceptoTipo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ArrayOfConceptoTipo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfConceptoTipo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfConceptoTipo * SOAP_FMAC4 soap_get_ns3__ArrayOfConceptoTipo(struct soap *soap, ns3__ArrayOfConceptoTipo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfConceptoTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__ConceptoTipoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__ConceptoTipoResponse::ResultGet = NULL;
	this->ns3__ConceptoTipoResponse::Errors = NULL;
	this->ns3__ConceptoTipoResponse::Events = NULL;
}

void ns3__ConceptoTipoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__ArrayOfConceptoTipo(soap, &this->ns3__ConceptoTipoResponse::ResultGet);
	soap_serialize_PointerTons3__ArrayOfErr(soap, &this->ns3__ConceptoTipoResponse::Errors);
	soap_serialize_PointerTons3__ArrayOfEvt(soap, &this->ns3__ConceptoTipoResponse::Events);
#endif
}

int ns3__ConceptoTipoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ConceptoTipoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ConceptoTipoResponse(struct soap *soap, const char *tag, int id, const ns3__ConceptoTipoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__ConceptoTipoResponse), type))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfConceptoTipo(soap, "ns3:ResultGet", -1, &a->ns3__ConceptoTipoResponse::ResultGet, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfErr(soap, "ns3:Errors", -1, &a->ns3__ConceptoTipoResponse::Errors, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfEvt(soap, "ns3:Events", -1, &a->ns3__ConceptoTipoResponse::Events, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__ConceptoTipoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__ConceptoTipoResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ConceptoTipoResponse * SOAP_FMAC4 soap_in_ns3__ConceptoTipoResponse(struct soap *soap, const char *tag, ns3__ConceptoTipoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ConceptoTipoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__ConceptoTipoResponse, sizeof(ns3__ConceptoTipoResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__ConceptoTipoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__ConceptoTipoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResultGet1 = 1;
	size_t soap_flag_Errors1 = 1;
	size_t soap_flag_Events1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultGet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfConceptoTipo(soap, "ns3:ResultGet", &a->ns3__ConceptoTipoResponse::ResultGet, "ns3:ArrayOfConceptoTipo"))
				{	soap_flag_ResultGet1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfErr(soap, "ns3:Errors", &a->ns3__ConceptoTipoResponse::Errors, "ns3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfEvt(soap, "ns3:Events", &a->ns3__ConceptoTipoResponse::Events, "ns3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ConceptoTipoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__ConceptoTipoResponse, SOAP_TYPE_afip_ns3__ConceptoTipoResponse, sizeof(ns3__ConceptoTipoResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__ConceptoTipoResponse * SOAP_FMAC2 soap_instantiate_ns3__ConceptoTipoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ConceptoTipoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__ConceptoTipoResponse *p;
	size_t k = sizeof(ns3__ConceptoTipoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__ConceptoTipoResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__ConceptoTipoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__ConceptoTipoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__ConceptoTipoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__ConceptoTipoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__ConceptoTipoResponse(soap, tag ? tag : "ns3:ConceptoTipoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ConceptoTipoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ConceptoTipoResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ConceptoTipoResponse * SOAP_FMAC4 soap_get_ns3__ConceptoTipoResponse(struct soap *soap, ns3__ConceptoTipoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ConceptoTipoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__OpcionalTipo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__OpcionalTipo::Id = NULL;
	this->ns3__OpcionalTipo::Desc = NULL;
	this->ns3__OpcionalTipo::FchDesde = NULL;
	this->ns3__OpcionalTipo::FchHasta = NULL;
}

void ns3__OpcionalTipo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns3__OpcionalTipo::Id);
	soap_serialize_PointerTostd__string(soap, &this->ns3__OpcionalTipo::Desc);
	soap_serialize_PointerTostd__string(soap, &this->ns3__OpcionalTipo::FchDesde);
	soap_serialize_PointerTostd__string(soap, &this->ns3__OpcionalTipo::FchHasta);
#endif
}

int ns3__OpcionalTipo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__OpcionalTipo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__OpcionalTipo(struct soap *soap, const char *tag, int id, const ns3__OpcionalTipo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__OpcionalTipo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Id", -1, &a->ns3__OpcionalTipo::Id, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Desc", -1, &a->ns3__OpcionalTipo::Desc, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchDesde", -1, &a->ns3__OpcionalTipo::FchDesde, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchHasta", -1, &a->ns3__OpcionalTipo::FchHasta, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__OpcionalTipo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__OpcionalTipo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__OpcionalTipo * SOAP_FMAC4 soap_in_ns3__OpcionalTipo(struct soap *soap, const char *tag, ns3__OpcionalTipo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__OpcionalTipo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__OpcionalTipo, sizeof(ns3__OpcionalTipo), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__OpcionalTipo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__OpcionalTipo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_Desc1 = 1;
	size_t soap_flag_FchDesde1 = 1;
	size_t soap_flag_FchHasta1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Id", &a->ns3__OpcionalTipo::Id, "xsd:string"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_Desc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Desc", &a->ns3__OpcionalTipo::Desc, "xsd:string"))
				{	soap_flag_Desc1--;
					continue;
				}
			}
			if (soap_flag_FchDesde1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchDesde", &a->ns3__OpcionalTipo::FchDesde, "xsd:string"))
				{	soap_flag_FchDesde1--;
					continue;
				}
			}
			if (soap_flag_FchHasta1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchHasta", &a->ns3__OpcionalTipo::FchHasta, "xsd:string"))
				{	soap_flag_FchHasta1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__OpcionalTipo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__OpcionalTipo, SOAP_TYPE_afip_ns3__OpcionalTipo, sizeof(ns3__OpcionalTipo), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__OpcionalTipo * SOAP_FMAC2 soap_instantiate_ns3__OpcionalTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__OpcionalTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__OpcionalTipo *p;
	size_t k = sizeof(ns3__OpcionalTipo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__OpcionalTipo, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__OpcionalTipo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__OpcionalTipo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__OpcionalTipo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__OpcionalTipo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__OpcionalTipo(soap, tag ? tag : "ns3:OpcionalTipo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__OpcionalTipo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__OpcionalTipo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__OpcionalTipo * SOAP_FMAC4 soap_get_ns3__OpcionalTipo(struct soap *soap, ns3__OpcionalTipo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__OpcionalTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__ArrayOfOpcionalTipo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__OpcionalTipo(soap, &this->ns3__ArrayOfOpcionalTipo::OpcionalTipo);
}

void ns3__ArrayOfOpcionalTipo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons3__OpcionalTipo(soap, &this->ns3__ArrayOfOpcionalTipo::OpcionalTipo);
#endif
}

int ns3__ArrayOfOpcionalTipo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfOpcionalTipo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfOpcionalTipo(struct soap *soap, const char *tag, int id, const ns3__ArrayOfOpcionalTipo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__ArrayOfOpcionalTipo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__OpcionalTipo(soap, "ns3:OpcionalTipo", -1, &a->ns3__ArrayOfOpcionalTipo::OpcionalTipo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfOpcionalTipo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__ArrayOfOpcionalTipo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfOpcionalTipo * SOAP_FMAC4 soap_in_ns3__ArrayOfOpcionalTipo(struct soap *soap, const char *tag, ns3__ArrayOfOpcionalTipo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfOpcionalTipo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__ArrayOfOpcionalTipo, sizeof(ns3__ArrayOfOpcionalTipo), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__ArrayOfOpcionalTipo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__ArrayOfOpcionalTipo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__OpcionalTipo(soap, "ns3:OpcionalTipo", &a->ns3__ArrayOfOpcionalTipo::OpcionalTipo, "ns3:OpcionalTipo"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfOpcionalTipo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__ArrayOfOpcionalTipo, SOAP_TYPE_afip_ns3__ArrayOfOpcionalTipo, sizeof(ns3__ArrayOfOpcionalTipo), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__ArrayOfOpcionalTipo * SOAP_FMAC2 soap_instantiate_ns3__ArrayOfOpcionalTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfOpcionalTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__ArrayOfOpcionalTipo *p;
	size_t k = sizeof(ns3__ArrayOfOpcionalTipo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__ArrayOfOpcionalTipo, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__ArrayOfOpcionalTipo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__ArrayOfOpcionalTipo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__ArrayOfOpcionalTipo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__ArrayOfOpcionalTipo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__ArrayOfOpcionalTipo(soap, tag ? tag : "ns3:ArrayOfOpcionalTipo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ArrayOfOpcionalTipo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfOpcionalTipo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfOpcionalTipo * SOAP_FMAC4 soap_get_ns3__ArrayOfOpcionalTipo(struct soap *soap, ns3__ArrayOfOpcionalTipo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfOpcionalTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__OpcionalTipoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__OpcionalTipoResponse::ResultGet = NULL;
	this->ns3__OpcionalTipoResponse::Errors = NULL;
	this->ns3__OpcionalTipoResponse::Events = NULL;
}

void ns3__OpcionalTipoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__ArrayOfOpcionalTipo(soap, &this->ns3__OpcionalTipoResponse::ResultGet);
	soap_serialize_PointerTons3__ArrayOfErr(soap, &this->ns3__OpcionalTipoResponse::Errors);
	soap_serialize_PointerTons3__ArrayOfEvt(soap, &this->ns3__OpcionalTipoResponse::Events);
#endif
}

int ns3__OpcionalTipoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__OpcionalTipoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__OpcionalTipoResponse(struct soap *soap, const char *tag, int id, const ns3__OpcionalTipoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__OpcionalTipoResponse), type))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfOpcionalTipo(soap, "ns3:ResultGet", -1, &a->ns3__OpcionalTipoResponse::ResultGet, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfErr(soap, "ns3:Errors", -1, &a->ns3__OpcionalTipoResponse::Errors, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfEvt(soap, "ns3:Events", -1, &a->ns3__OpcionalTipoResponse::Events, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__OpcionalTipoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__OpcionalTipoResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns3__OpcionalTipoResponse * SOAP_FMAC4 soap_in_ns3__OpcionalTipoResponse(struct soap *soap, const char *tag, ns3__OpcionalTipoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__OpcionalTipoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__OpcionalTipoResponse, sizeof(ns3__OpcionalTipoResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__OpcionalTipoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__OpcionalTipoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResultGet1 = 1;
	size_t soap_flag_Errors1 = 1;
	size_t soap_flag_Events1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultGet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfOpcionalTipo(soap, "ns3:ResultGet", &a->ns3__OpcionalTipoResponse::ResultGet, "ns3:ArrayOfOpcionalTipo"))
				{	soap_flag_ResultGet1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfErr(soap, "ns3:Errors", &a->ns3__OpcionalTipoResponse::Errors, "ns3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfEvt(soap, "ns3:Events", &a->ns3__OpcionalTipoResponse::Events, "ns3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__OpcionalTipoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__OpcionalTipoResponse, SOAP_TYPE_afip_ns3__OpcionalTipoResponse, sizeof(ns3__OpcionalTipoResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__OpcionalTipoResponse * SOAP_FMAC2 soap_instantiate_ns3__OpcionalTipoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__OpcionalTipoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__OpcionalTipoResponse *p;
	size_t k = sizeof(ns3__OpcionalTipoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__OpcionalTipoResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__OpcionalTipoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__OpcionalTipoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__OpcionalTipoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__OpcionalTipoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__OpcionalTipoResponse(soap, tag ? tag : "ns3:OpcionalTipoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__OpcionalTipoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__OpcionalTipoResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns3__OpcionalTipoResponse * SOAP_FMAC4 soap_get_ns3__OpcionalTipoResponse(struct soap *soap, ns3__OpcionalTipoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__OpcionalTipoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__IvaTipo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__IvaTipo::Id = NULL;
	this->ns3__IvaTipo::Desc = NULL;
	this->ns3__IvaTipo::FchDesde = NULL;
	this->ns3__IvaTipo::FchHasta = NULL;
}

void ns3__IvaTipo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns3__IvaTipo::Id);
	soap_serialize_PointerTostd__string(soap, &this->ns3__IvaTipo::Desc);
	soap_serialize_PointerTostd__string(soap, &this->ns3__IvaTipo::FchDesde);
	soap_serialize_PointerTostd__string(soap, &this->ns3__IvaTipo::FchHasta);
#endif
}

int ns3__IvaTipo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__IvaTipo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__IvaTipo(struct soap *soap, const char *tag, int id, const ns3__IvaTipo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__IvaTipo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Id", -1, &a->ns3__IvaTipo::Id, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Desc", -1, &a->ns3__IvaTipo::Desc, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchDesde", -1, &a->ns3__IvaTipo::FchDesde, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchHasta", -1, &a->ns3__IvaTipo::FchHasta, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__IvaTipo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__IvaTipo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__IvaTipo * SOAP_FMAC4 soap_in_ns3__IvaTipo(struct soap *soap, const char *tag, ns3__IvaTipo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__IvaTipo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__IvaTipo, sizeof(ns3__IvaTipo), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__IvaTipo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__IvaTipo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_Desc1 = 1;
	size_t soap_flag_FchDesde1 = 1;
	size_t soap_flag_FchHasta1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Id", &a->ns3__IvaTipo::Id, "xsd:string"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_Desc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Desc", &a->ns3__IvaTipo::Desc, "xsd:string"))
				{	soap_flag_Desc1--;
					continue;
				}
			}
			if (soap_flag_FchDesde1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchDesde", &a->ns3__IvaTipo::FchDesde, "xsd:string"))
				{	soap_flag_FchDesde1--;
					continue;
				}
			}
			if (soap_flag_FchHasta1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchHasta", &a->ns3__IvaTipo::FchHasta, "xsd:string"))
				{	soap_flag_FchHasta1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__IvaTipo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__IvaTipo, SOAP_TYPE_afip_ns3__IvaTipo, sizeof(ns3__IvaTipo), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__IvaTipo * SOAP_FMAC2 soap_instantiate_ns3__IvaTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__IvaTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__IvaTipo *p;
	size_t k = sizeof(ns3__IvaTipo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__IvaTipo, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__IvaTipo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__IvaTipo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__IvaTipo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__IvaTipo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__IvaTipo(soap, tag ? tag : "ns3:IvaTipo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__IvaTipo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__IvaTipo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__IvaTipo * SOAP_FMAC4 soap_get_ns3__IvaTipo(struct soap *soap, ns3__IvaTipo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__IvaTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__ArrayOfIvaTipo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__IvaTipo(soap, &this->ns3__ArrayOfIvaTipo::IvaTipo);
}

void ns3__ArrayOfIvaTipo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons3__IvaTipo(soap, &this->ns3__ArrayOfIvaTipo::IvaTipo);
#endif
}

int ns3__ArrayOfIvaTipo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfIvaTipo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfIvaTipo(struct soap *soap, const char *tag, int id, const ns3__ArrayOfIvaTipo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__ArrayOfIvaTipo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__IvaTipo(soap, "ns3:IvaTipo", -1, &a->ns3__ArrayOfIvaTipo::IvaTipo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfIvaTipo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__ArrayOfIvaTipo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfIvaTipo * SOAP_FMAC4 soap_in_ns3__ArrayOfIvaTipo(struct soap *soap, const char *tag, ns3__ArrayOfIvaTipo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfIvaTipo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__ArrayOfIvaTipo, sizeof(ns3__ArrayOfIvaTipo), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__ArrayOfIvaTipo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__ArrayOfIvaTipo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__IvaTipo(soap, "ns3:IvaTipo", &a->ns3__ArrayOfIvaTipo::IvaTipo, "ns3:IvaTipo"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfIvaTipo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__ArrayOfIvaTipo, SOAP_TYPE_afip_ns3__ArrayOfIvaTipo, sizeof(ns3__ArrayOfIvaTipo), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__ArrayOfIvaTipo * SOAP_FMAC2 soap_instantiate_ns3__ArrayOfIvaTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfIvaTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__ArrayOfIvaTipo *p;
	size_t k = sizeof(ns3__ArrayOfIvaTipo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__ArrayOfIvaTipo, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__ArrayOfIvaTipo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__ArrayOfIvaTipo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__ArrayOfIvaTipo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__ArrayOfIvaTipo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__ArrayOfIvaTipo(soap, tag ? tag : "ns3:ArrayOfIvaTipo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ArrayOfIvaTipo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfIvaTipo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfIvaTipo * SOAP_FMAC4 soap_get_ns3__ArrayOfIvaTipo(struct soap *soap, ns3__ArrayOfIvaTipo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfIvaTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__IvaTipoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__IvaTipoResponse::ResultGet = NULL;
	this->ns3__IvaTipoResponse::Errors = NULL;
	this->ns3__IvaTipoResponse::Events = NULL;
}

void ns3__IvaTipoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__ArrayOfIvaTipo(soap, &this->ns3__IvaTipoResponse::ResultGet);
	soap_serialize_PointerTons3__ArrayOfErr(soap, &this->ns3__IvaTipoResponse::Errors);
	soap_serialize_PointerTons3__ArrayOfEvt(soap, &this->ns3__IvaTipoResponse::Events);
#endif
}

int ns3__IvaTipoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__IvaTipoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__IvaTipoResponse(struct soap *soap, const char *tag, int id, const ns3__IvaTipoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__IvaTipoResponse), type))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfIvaTipo(soap, "ns3:ResultGet", -1, &a->ns3__IvaTipoResponse::ResultGet, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfErr(soap, "ns3:Errors", -1, &a->ns3__IvaTipoResponse::Errors, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfEvt(soap, "ns3:Events", -1, &a->ns3__IvaTipoResponse::Events, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__IvaTipoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__IvaTipoResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns3__IvaTipoResponse * SOAP_FMAC4 soap_in_ns3__IvaTipoResponse(struct soap *soap, const char *tag, ns3__IvaTipoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__IvaTipoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__IvaTipoResponse, sizeof(ns3__IvaTipoResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__IvaTipoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__IvaTipoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResultGet1 = 1;
	size_t soap_flag_Errors1 = 1;
	size_t soap_flag_Events1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultGet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfIvaTipo(soap, "ns3:ResultGet", &a->ns3__IvaTipoResponse::ResultGet, "ns3:ArrayOfIvaTipo"))
				{	soap_flag_ResultGet1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfErr(soap, "ns3:Errors", &a->ns3__IvaTipoResponse::Errors, "ns3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfEvt(soap, "ns3:Events", &a->ns3__IvaTipoResponse::Events, "ns3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__IvaTipoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__IvaTipoResponse, SOAP_TYPE_afip_ns3__IvaTipoResponse, sizeof(ns3__IvaTipoResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__IvaTipoResponse * SOAP_FMAC2 soap_instantiate_ns3__IvaTipoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__IvaTipoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__IvaTipoResponse *p;
	size_t k = sizeof(ns3__IvaTipoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__IvaTipoResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__IvaTipoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__IvaTipoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__IvaTipoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__IvaTipoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__IvaTipoResponse(soap, tag ? tag : "ns3:IvaTipoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__IvaTipoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__IvaTipoResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns3__IvaTipoResponse * SOAP_FMAC4 soap_get_ns3__IvaTipoResponse(struct soap *soap, ns3__IvaTipoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__IvaTipoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__Moneda::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__Moneda::Id = NULL;
	this->ns3__Moneda::Desc = NULL;
	this->ns3__Moneda::FchDesde = NULL;
	this->ns3__Moneda::FchHasta = NULL;
}

void ns3__Moneda::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns3__Moneda::Id);
	soap_serialize_PointerTostd__string(soap, &this->ns3__Moneda::Desc);
	soap_serialize_PointerTostd__string(soap, &this->ns3__Moneda::FchDesde);
	soap_serialize_PointerTostd__string(soap, &this->ns3__Moneda::FchHasta);
#endif
}

int ns3__Moneda::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__Moneda(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__Moneda(struct soap *soap, const char *tag, int id, const ns3__Moneda *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__Moneda), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Id", -1, &a->ns3__Moneda::Id, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Desc", -1, &a->ns3__Moneda::Desc, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchDesde", -1, &a->ns3__Moneda::FchDesde, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchHasta", -1, &a->ns3__Moneda::FchHasta, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__Moneda::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__Moneda(soap, tag, this, type);
}

SOAP_FMAC3 ns3__Moneda * SOAP_FMAC4 soap_in_ns3__Moneda(struct soap *soap, const char *tag, ns3__Moneda *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__Moneda*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__Moneda, sizeof(ns3__Moneda), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__Moneda)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__Moneda *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_Desc1 = 1;
	size_t soap_flag_FchDesde1 = 1;
	size_t soap_flag_FchHasta1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Id", &a->ns3__Moneda::Id, "xsd:string"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_Desc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Desc", &a->ns3__Moneda::Desc, "xsd:string"))
				{	soap_flag_Desc1--;
					continue;
				}
			}
			if (soap_flag_FchDesde1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchDesde", &a->ns3__Moneda::FchDesde, "xsd:string"))
				{	soap_flag_FchDesde1--;
					continue;
				}
			}
			if (soap_flag_FchHasta1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchHasta", &a->ns3__Moneda::FchHasta, "xsd:string"))
				{	soap_flag_FchHasta1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__Moneda *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__Moneda, SOAP_TYPE_afip_ns3__Moneda, sizeof(ns3__Moneda), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__Moneda * SOAP_FMAC2 soap_instantiate_ns3__Moneda(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__Moneda(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__Moneda *p;
	size_t k = sizeof(ns3__Moneda);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__Moneda, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__Moneda);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__Moneda, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__Moneda location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__Moneda::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__Moneda(soap, tag ? tag : "ns3:Moneda", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__Moneda::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__Moneda(soap, this, tag, type);
}

SOAP_FMAC3 ns3__Moneda * SOAP_FMAC4 soap_get_ns3__Moneda(struct soap *soap, ns3__Moneda *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__Moneda(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__ArrayOfMoneda::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__Moneda(soap, &this->ns3__ArrayOfMoneda::Moneda);
}

void ns3__ArrayOfMoneda::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons3__Moneda(soap, &this->ns3__ArrayOfMoneda::Moneda);
#endif
}

int ns3__ArrayOfMoneda::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfMoneda(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfMoneda(struct soap *soap, const char *tag, int id, const ns3__ArrayOfMoneda *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__ArrayOfMoneda), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__Moneda(soap, "ns3:Moneda", -1, &a->ns3__ArrayOfMoneda::Moneda, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfMoneda::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__ArrayOfMoneda(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfMoneda * SOAP_FMAC4 soap_in_ns3__ArrayOfMoneda(struct soap *soap, const char *tag, ns3__ArrayOfMoneda *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfMoneda*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__ArrayOfMoneda, sizeof(ns3__ArrayOfMoneda), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__ArrayOfMoneda)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__ArrayOfMoneda *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__Moneda(soap, "ns3:Moneda", &a->ns3__ArrayOfMoneda::Moneda, "ns3:Moneda"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfMoneda *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__ArrayOfMoneda, SOAP_TYPE_afip_ns3__ArrayOfMoneda, sizeof(ns3__ArrayOfMoneda), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__ArrayOfMoneda * SOAP_FMAC2 soap_instantiate_ns3__ArrayOfMoneda(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfMoneda(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__ArrayOfMoneda *p;
	size_t k = sizeof(ns3__ArrayOfMoneda);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__ArrayOfMoneda, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__ArrayOfMoneda);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__ArrayOfMoneda, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__ArrayOfMoneda location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__ArrayOfMoneda::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__ArrayOfMoneda(soap, tag ? tag : "ns3:ArrayOfMoneda", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ArrayOfMoneda::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfMoneda(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfMoneda * SOAP_FMAC4 soap_get_ns3__ArrayOfMoneda(struct soap *soap, ns3__ArrayOfMoneda *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfMoneda(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__MonedaResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__MonedaResponse::ResultGet = NULL;
	this->ns3__MonedaResponse::Errors = NULL;
	this->ns3__MonedaResponse::Events = NULL;
}

void ns3__MonedaResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__ArrayOfMoneda(soap, &this->ns3__MonedaResponse::ResultGet);
	soap_serialize_PointerTons3__ArrayOfErr(soap, &this->ns3__MonedaResponse::Errors);
	soap_serialize_PointerTons3__ArrayOfEvt(soap, &this->ns3__MonedaResponse::Events);
#endif
}

int ns3__MonedaResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__MonedaResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__MonedaResponse(struct soap *soap, const char *tag, int id, const ns3__MonedaResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__MonedaResponse), type))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfMoneda(soap, "ns3:ResultGet", -1, &a->ns3__MonedaResponse::ResultGet, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfErr(soap, "ns3:Errors", -1, &a->ns3__MonedaResponse::Errors, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfEvt(soap, "ns3:Events", -1, &a->ns3__MonedaResponse::Events, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__MonedaResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__MonedaResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns3__MonedaResponse * SOAP_FMAC4 soap_in_ns3__MonedaResponse(struct soap *soap, const char *tag, ns3__MonedaResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__MonedaResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__MonedaResponse, sizeof(ns3__MonedaResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__MonedaResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__MonedaResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResultGet1 = 1;
	size_t soap_flag_Errors1 = 1;
	size_t soap_flag_Events1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultGet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfMoneda(soap, "ns3:ResultGet", &a->ns3__MonedaResponse::ResultGet, "ns3:ArrayOfMoneda"))
				{	soap_flag_ResultGet1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfErr(soap, "ns3:Errors", &a->ns3__MonedaResponse::Errors, "ns3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfEvt(soap, "ns3:Events", &a->ns3__MonedaResponse::Events, "ns3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__MonedaResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__MonedaResponse, SOAP_TYPE_afip_ns3__MonedaResponse, sizeof(ns3__MonedaResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__MonedaResponse * SOAP_FMAC2 soap_instantiate_ns3__MonedaResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__MonedaResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__MonedaResponse *p;
	size_t k = sizeof(ns3__MonedaResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__MonedaResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__MonedaResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__MonedaResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__MonedaResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__MonedaResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__MonedaResponse(soap, tag ? tag : "ns3:MonedaResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__MonedaResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__MonedaResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns3__MonedaResponse * SOAP_FMAC4 soap_get_ns3__MonedaResponse(struct soap *soap, ns3__MonedaResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__MonedaResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__TributoTipo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_short(soap, &this->ns3__TributoTipo::Id);
	this->ns3__TributoTipo::Desc = NULL;
	this->ns3__TributoTipo::FchDesde = NULL;
	this->ns3__TributoTipo::FchHasta = NULL;
}

void ns3__TributoTipo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns3__TributoTipo::Desc);
	soap_serialize_PointerTostd__string(soap, &this->ns3__TributoTipo::FchDesde);
	soap_serialize_PointerTostd__string(soap, &this->ns3__TributoTipo::FchHasta);
#endif
}

int ns3__TributoTipo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__TributoTipo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TributoTipo(struct soap *soap, const char *tag, int id, const ns3__TributoTipo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__TributoTipo), type))
		return soap->error;
	if (soap_out_short(soap, "ns3:Id", -1, &a->ns3__TributoTipo::Id, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Desc", -1, &a->ns3__TributoTipo::Desc, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchDesde", -1, &a->ns3__TributoTipo::FchDesde, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchHasta", -1, &a->ns3__TributoTipo::FchHasta, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__TributoTipo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__TributoTipo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__TributoTipo * SOAP_FMAC4 soap_in_ns3__TributoTipo(struct soap *soap, const char *tag, ns3__TributoTipo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__TributoTipo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__TributoTipo, sizeof(ns3__TributoTipo), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__TributoTipo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__TributoTipo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_Desc1 = 1;
	size_t soap_flag_FchDesde1 = 1;
	size_t soap_flag_FchHasta1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_short(soap, "ns3:Id", &a->ns3__TributoTipo::Id, "xsd:short"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_Desc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Desc", &a->ns3__TributoTipo::Desc, "xsd:string"))
				{	soap_flag_Desc1--;
					continue;
				}
			}
			if (soap_flag_FchDesde1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchDesde", &a->ns3__TributoTipo::FchDesde, "xsd:string"))
				{	soap_flag_FchDesde1--;
					continue;
				}
			}
			if (soap_flag_FchHasta1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchHasta", &a->ns3__TributoTipo::FchHasta, "xsd:string"))
				{	soap_flag_FchHasta1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__TributoTipo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__TributoTipo, SOAP_TYPE_afip_ns3__TributoTipo, sizeof(ns3__TributoTipo), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__TributoTipo * SOAP_FMAC2 soap_instantiate_ns3__TributoTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__TributoTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__TributoTipo *p;
	size_t k = sizeof(ns3__TributoTipo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__TributoTipo, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__TributoTipo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__TributoTipo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__TributoTipo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__TributoTipo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__TributoTipo(soap, tag ? tag : "ns3:TributoTipo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__TributoTipo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__TributoTipo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__TributoTipo * SOAP_FMAC4 soap_get_ns3__TributoTipo(struct soap *soap, ns3__TributoTipo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__TributoTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__ArrayOfTributoTipo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__TributoTipo(soap, &this->ns3__ArrayOfTributoTipo::TributoTipo);
}

void ns3__ArrayOfTributoTipo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons3__TributoTipo(soap, &this->ns3__ArrayOfTributoTipo::TributoTipo);
#endif
}

int ns3__ArrayOfTributoTipo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfTributoTipo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfTributoTipo(struct soap *soap, const char *tag, int id, const ns3__ArrayOfTributoTipo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__ArrayOfTributoTipo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__TributoTipo(soap, "ns3:TributoTipo", -1, &a->ns3__ArrayOfTributoTipo::TributoTipo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfTributoTipo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__ArrayOfTributoTipo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfTributoTipo * SOAP_FMAC4 soap_in_ns3__ArrayOfTributoTipo(struct soap *soap, const char *tag, ns3__ArrayOfTributoTipo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfTributoTipo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__ArrayOfTributoTipo, sizeof(ns3__ArrayOfTributoTipo), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__ArrayOfTributoTipo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__ArrayOfTributoTipo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__TributoTipo(soap, "ns3:TributoTipo", &a->ns3__ArrayOfTributoTipo::TributoTipo, "ns3:TributoTipo"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfTributoTipo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__ArrayOfTributoTipo, SOAP_TYPE_afip_ns3__ArrayOfTributoTipo, sizeof(ns3__ArrayOfTributoTipo), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__ArrayOfTributoTipo * SOAP_FMAC2 soap_instantiate_ns3__ArrayOfTributoTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfTributoTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__ArrayOfTributoTipo *p;
	size_t k = sizeof(ns3__ArrayOfTributoTipo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__ArrayOfTributoTipo, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__ArrayOfTributoTipo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__ArrayOfTributoTipo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__ArrayOfTributoTipo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__ArrayOfTributoTipo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__ArrayOfTributoTipo(soap, tag ? tag : "ns3:ArrayOfTributoTipo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ArrayOfTributoTipo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfTributoTipo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfTributoTipo * SOAP_FMAC4 soap_get_ns3__ArrayOfTributoTipo(struct soap *soap, ns3__ArrayOfTributoTipo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfTributoTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__FETributoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__FETributoResponse::ResultGet = NULL;
	this->ns3__FETributoResponse::Errors = NULL;
	this->ns3__FETributoResponse::Events = NULL;
}

void ns3__FETributoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__ArrayOfTributoTipo(soap, &this->ns3__FETributoResponse::ResultGet);
	soap_serialize_PointerTons3__ArrayOfErr(soap, &this->ns3__FETributoResponse::Errors);
	soap_serialize_PointerTons3__ArrayOfEvt(soap, &this->ns3__FETributoResponse::Events);
#endif
}

int ns3__FETributoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__FETributoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FETributoResponse(struct soap *soap, const char *tag, int id, const ns3__FETributoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__FETributoResponse), type))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfTributoTipo(soap, "ns3:ResultGet", -1, &a->ns3__FETributoResponse::ResultGet, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfErr(soap, "ns3:Errors", -1, &a->ns3__FETributoResponse::Errors, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfEvt(soap, "ns3:Events", -1, &a->ns3__FETributoResponse::Events, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__FETributoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__FETributoResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns3__FETributoResponse * SOAP_FMAC4 soap_in_ns3__FETributoResponse(struct soap *soap, const char *tag, ns3__FETributoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__FETributoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__FETributoResponse, sizeof(ns3__FETributoResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__FETributoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__FETributoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResultGet1 = 1;
	size_t soap_flag_Errors1 = 1;
	size_t soap_flag_Events1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultGet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfTributoTipo(soap, "ns3:ResultGet", &a->ns3__FETributoResponse::ResultGet, "ns3:ArrayOfTributoTipo"))
				{	soap_flag_ResultGet1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfErr(soap, "ns3:Errors", &a->ns3__FETributoResponse::Errors, "ns3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfEvt(soap, "ns3:Events", &a->ns3__FETributoResponse::Events, "ns3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__FETributoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__FETributoResponse, SOAP_TYPE_afip_ns3__FETributoResponse, sizeof(ns3__FETributoResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__FETributoResponse * SOAP_FMAC2 soap_instantiate_ns3__FETributoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__FETributoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__FETributoResponse *p;
	size_t k = sizeof(ns3__FETributoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FETributoResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__FETributoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__FETributoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__FETributoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__FETributoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__FETributoResponse(soap, tag ? tag : "ns3:FETributoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__FETributoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__FETributoResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns3__FETributoResponse * SOAP_FMAC4 soap_get_ns3__FETributoResponse(struct soap *soap, ns3__FETributoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__FETributoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__Cotizacion::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__Cotizacion::MonId = NULL;
	soap_default_double(soap, &this->ns3__Cotizacion::MonCotiz);
	this->ns3__Cotizacion::FchCotiz = NULL;
}

void ns3__Cotizacion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns3__Cotizacion::MonId);
	soap_serialize_PointerTostd__string(soap, &this->ns3__Cotizacion::FchCotiz);
#endif
}

int ns3__Cotizacion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__Cotizacion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__Cotizacion(struct soap *soap, const char *tag, int id, const ns3__Cotizacion *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__Cotizacion), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:MonId", -1, &a->ns3__Cotizacion::MonId, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:MonCotiz", -1, &a->ns3__Cotizacion::MonCotiz, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchCotiz", -1, &a->ns3__Cotizacion::FchCotiz, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__Cotizacion::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__Cotizacion(soap, tag, this, type);
}

SOAP_FMAC3 ns3__Cotizacion * SOAP_FMAC4 soap_in_ns3__Cotizacion(struct soap *soap, const char *tag, ns3__Cotizacion *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__Cotizacion*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__Cotizacion, sizeof(ns3__Cotizacion), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__Cotizacion)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__Cotizacion *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MonId1 = 1;
	size_t soap_flag_MonCotiz1 = 1;
	size_t soap_flag_FchCotiz1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MonId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:MonId", &a->ns3__Cotizacion::MonId, "xsd:string"))
				{	soap_flag_MonId1--;
					continue;
				}
			}
			if (soap_flag_MonCotiz1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:MonCotiz", &a->ns3__Cotizacion::MonCotiz, "xsd:double"))
				{	soap_flag_MonCotiz1--;
					continue;
				}
			}
			if (soap_flag_FchCotiz1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchCotiz", &a->ns3__Cotizacion::FchCotiz, "xsd:string"))
				{	soap_flag_FchCotiz1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MonCotiz1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__Cotizacion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__Cotizacion, SOAP_TYPE_afip_ns3__Cotizacion, sizeof(ns3__Cotizacion), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__Cotizacion * SOAP_FMAC2 soap_instantiate_ns3__Cotizacion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__Cotizacion(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__Cotizacion *p;
	size_t k = sizeof(ns3__Cotizacion);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__Cotizacion, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__Cotizacion);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__Cotizacion, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__Cotizacion location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__Cotizacion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__Cotizacion(soap, tag ? tag : "ns3:Cotizacion", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__Cotizacion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__Cotizacion(soap, this, tag, type);
}

SOAP_FMAC3 ns3__Cotizacion * SOAP_FMAC4 soap_get_ns3__Cotizacion(struct soap *soap, ns3__Cotizacion *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__Cotizacion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__FECotizacionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__FECotizacionResponse::ResultGet = NULL;
	this->ns3__FECotizacionResponse::Errors = NULL;
	this->ns3__FECotizacionResponse::Events = NULL;
}

void ns3__FECotizacionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__Cotizacion(soap, &this->ns3__FECotizacionResponse::ResultGet);
	soap_serialize_PointerTons3__ArrayOfErr(soap, &this->ns3__FECotizacionResponse::Errors);
	soap_serialize_PointerTons3__ArrayOfEvt(soap, &this->ns3__FECotizacionResponse::Events);
#endif
}

int ns3__FECotizacionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__FECotizacionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FECotizacionResponse(struct soap *soap, const char *tag, int id, const ns3__FECotizacionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__FECotizacionResponse), type))
		return soap->error;
	if (soap_out_PointerTons3__Cotizacion(soap, "ns3:ResultGet", -1, &a->ns3__FECotizacionResponse::ResultGet, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfErr(soap, "ns3:Errors", -1, &a->ns3__FECotizacionResponse::Errors, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfEvt(soap, "ns3:Events", -1, &a->ns3__FECotizacionResponse::Events, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__FECotizacionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__FECotizacionResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns3__FECotizacionResponse * SOAP_FMAC4 soap_in_ns3__FECotizacionResponse(struct soap *soap, const char *tag, ns3__FECotizacionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__FECotizacionResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__FECotizacionResponse, sizeof(ns3__FECotizacionResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__FECotizacionResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__FECotizacionResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResultGet1 = 1;
	size_t soap_flag_Errors1 = 1;
	size_t soap_flag_Events1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultGet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__Cotizacion(soap, "ns3:ResultGet", &a->ns3__FECotizacionResponse::ResultGet, "ns3:Cotizacion"))
				{	soap_flag_ResultGet1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfErr(soap, "ns3:Errors", &a->ns3__FECotizacionResponse::Errors, "ns3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfEvt(soap, "ns3:Events", &a->ns3__FECotizacionResponse::Events, "ns3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__FECotizacionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__FECotizacionResponse, SOAP_TYPE_afip_ns3__FECotizacionResponse, sizeof(ns3__FECotizacionResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__FECotizacionResponse * SOAP_FMAC2 soap_instantiate_ns3__FECotizacionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__FECotizacionResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__FECotizacionResponse *p;
	size_t k = sizeof(ns3__FECotizacionResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FECotizacionResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__FECotizacionResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__FECotizacionResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__FECotizacionResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__FECotizacionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__FECotizacionResponse(soap, tag ? tag : "ns3:FECotizacionResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__FECotizacionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__FECotizacionResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns3__FECotizacionResponse * SOAP_FMAC4 soap_get_ns3__FECotizacionResponse(struct soap *soap, ns3__FECotizacionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__FECotizacionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__FECAEASinMovResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__FECAEASinMov::soap_default(soap);
	this->ns3__FECAEASinMovResponse::Resultado = NULL;
	this->ns3__FECAEASinMovResponse::Errors = NULL;
	this->ns3__FECAEASinMovResponse::Events = NULL;
}

void ns3__FECAEASinMovResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns3__FECAEASinMovResponse::Resultado);
	soap_serialize_PointerTons3__ArrayOfErr(soap, &this->ns3__FECAEASinMovResponse::Errors);
	soap_serialize_PointerTons3__ArrayOfEvt(soap, &this->ns3__FECAEASinMovResponse::Events);
	this->ns3__FECAEASinMov::soap_serialize(soap);
#endif
}

int ns3__FECAEASinMovResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__FECAEASinMovResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FECAEASinMovResponse(struct soap *soap, const char *tag, int id, const ns3__FECAEASinMovResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__FECAEASinMovResponse), type ? type : "ns3:FECAEASinMovResponse"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:CAEA", -1, &a->ns3__FECAEASinMov::CAEA, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchProceso", -1, &a->ns3__FECAEASinMov::FchProceso, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:PtoVta", -1, &a->ns3__FECAEASinMov::PtoVta, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Resultado", -1, &a->ns3__FECAEASinMovResponse::Resultado, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfErr(soap, "ns3:Errors", -1, &a->ns3__FECAEASinMovResponse::Errors, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfEvt(soap, "ns3:Events", -1, &a->ns3__FECAEASinMovResponse::Events, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__FECAEASinMovResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__FECAEASinMovResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns3__FECAEASinMovResponse * SOAP_FMAC4 soap_in_ns3__FECAEASinMovResponse(struct soap *soap, const char *tag, ns3__FECAEASinMovResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__FECAEASinMovResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__FECAEASinMovResponse, sizeof(ns3__FECAEASinMovResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__FECAEASinMovResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__FECAEASinMovResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CAEA2 = 1;
	size_t soap_flag_FchProceso2 = 1;
	size_t soap_flag_PtoVta2 = 1;
	size_t soap_flag_Resultado1 = 1;
	size_t soap_flag_Errors1 = 1;
	size_t soap_flag_Events1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CAEA2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:CAEA", &a->ns3__FECAEASinMov::CAEA, "xsd:string"))
				{	soap_flag_CAEA2--;
					continue;
				}
			}
			if (soap_flag_FchProceso2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchProceso", &a->ns3__FECAEASinMov::FchProceso, "xsd:string"))
				{	soap_flag_FchProceso2--;
					continue;
				}
			}
			if (soap_flag_PtoVta2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:PtoVta", &a->ns3__FECAEASinMov::PtoVta, "xsd:int"))
				{	soap_flag_PtoVta2--;
					continue;
				}
			}
			if (soap_flag_Resultado1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Resultado", &a->ns3__FECAEASinMovResponse::Resultado, "xsd:string"))
				{	soap_flag_Resultado1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfErr(soap, "ns3:Errors", &a->ns3__FECAEASinMovResponse::Errors, "ns3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfEvt(soap, "ns3:Events", &a->ns3__FECAEASinMovResponse::Events, "ns3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PtoVta2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__FECAEASinMovResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__FECAEASinMovResponse, SOAP_TYPE_afip_ns3__FECAEASinMovResponse, sizeof(ns3__FECAEASinMovResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__FECAEASinMovResponse * SOAP_FMAC2 soap_instantiate_ns3__FECAEASinMovResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__FECAEASinMovResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__FECAEASinMovResponse *p;
	size_t k = sizeof(ns3__FECAEASinMovResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FECAEASinMovResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__FECAEASinMovResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__FECAEASinMovResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__FECAEASinMovResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__FECAEASinMovResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__FECAEASinMovResponse(soap, tag ? tag : "ns3:FECAEASinMovResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__FECAEASinMovResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__FECAEASinMovResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns3__FECAEASinMovResponse * SOAP_FMAC4 soap_get_ns3__FECAEASinMovResponse(struct soap *soap, ns3__FECAEASinMovResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__FECAEASinMovResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__FECAEASinMov::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__FECAEASinMov::CAEA = NULL;
	this->ns3__FECAEASinMov::FchProceso = NULL;
	soap_default_int(soap, &this->ns3__FECAEASinMov::PtoVta);
}

void ns3__FECAEASinMov::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns3__FECAEASinMov::CAEA);
	soap_serialize_PointerTostd__string(soap, &this->ns3__FECAEASinMov::FchProceso);
#endif
}

int ns3__FECAEASinMov::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__FECAEASinMov(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FECAEASinMov(struct soap *soap, const char *tag, int id, const ns3__FECAEASinMov *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__FECAEASinMov), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:CAEA", -1, &a->ns3__FECAEASinMov::CAEA, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchProceso", -1, &a->ns3__FECAEASinMov::FchProceso, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:PtoVta", -1, &a->ns3__FECAEASinMov::PtoVta, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__FECAEASinMov::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__FECAEASinMov(soap, tag, this, type);
}

SOAP_FMAC3 ns3__FECAEASinMov * SOAP_FMAC4 soap_in_ns3__FECAEASinMov(struct soap *soap, const char *tag, ns3__FECAEASinMov *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__FECAEASinMov*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__FECAEASinMov, sizeof(ns3__FECAEASinMov), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__FECAEASinMov)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__FECAEASinMov *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CAEA1 = 1;
	size_t soap_flag_FchProceso1 = 1;
	size_t soap_flag_PtoVta1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CAEA1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:CAEA", &a->ns3__FECAEASinMov::CAEA, "xsd:string"))
				{	soap_flag_CAEA1--;
					continue;
				}
			}
			if (soap_flag_FchProceso1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchProceso", &a->ns3__FECAEASinMov::FchProceso, "xsd:string"))
				{	soap_flag_FchProceso1--;
					continue;
				}
			}
			if (soap_flag_PtoVta1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:PtoVta", &a->ns3__FECAEASinMov::PtoVta, "xsd:int"))
				{	soap_flag_PtoVta1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PtoVta1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__FECAEASinMov *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__FECAEASinMov, SOAP_TYPE_afip_ns3__FECAEASinMov, sizeof(ns3__FECAEASinMov), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__FECAEASinMov * SOAP_FMAC2 soap_instantiate_ns3__FECAEASinMov(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__FECAEASinMov(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "ns3:FECAEASinMovResponse"))
		return soap_instantiate_ns3__FECAEASinMovResponse(soap, n, NULL, NULL, size);
	ns3__FECAEASinMov *p;
	size_t k = sizeof(ns3__FECAEASinMov);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FECAEASinMov, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__FECAEASinMov);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__FECAEASinMov, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__FECAEASinMov location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__FECAEASinMov::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__FECAEASinMov(soap, tag ? tag : "ns3:FECAEASinMov", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__FECAEASinMov::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__FECAEASinMov(soap, this, tag, type);
}

SOAP_FMAC3 ns3__FECAEASinMov * SOAP_FMAC4 soap_get_ns3__FECAEASinMov(struct soap *soap, ns3__FECAEASinMov *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__FECAEASinMov(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__ArrayOfFECAEASinMov::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__FECAEASinMov(soap, &this->ns3__ArrayOfFECAEASinMov::FECAEASinMov);
}

void ns3__ArrayOfFECAEASinMov::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons3__FECAEASinMov(soap, &this->ns3__ArrayOfFECAEASinMov::FECAEASinMov);
#endif
}

int ns3__ArrayOfFECAEASinMov::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfFECAEASinMov(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfFECAEASinMov(struct soap *soap, const char *tag, int id, const ns3__ArrayOfFECAEASinMov *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__ArrayOfFECAEASinMov), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__FECAEASinMov(soap, "ns3:FECAEASinMov", -1, &a->ns3__ArrayOfFECAEASinMov::FECAEASinMov, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfFECAEASinMov::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__ArrayOfFECAEASinMov(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfFECAEASinMov * SOAP_FMAC4 soap_in_ns3__ArrayOfFECAEASinMov(struct soap *soap, const char *tag, ns3__ArrayOfFECAEASinMov *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfFECAEASinMov*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__ArrayOfFECAEASinMov, sizeof(ns3__ArrayOfFECAEASinMov), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__ArrayOfFECAEASinMov)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__ArrayOfFECAEASinMov *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__FECAEASinMov(soap, "ns3:FECAEASinMov", &a->ns3__ArrayOfFECAEASinMov::FECAEASinMov, "ns3:FECAEASinMov"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfFECAEASinMov *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__ArrayOfFECAEASinMov, SOAP_TYPE_afip_ns3__ArrayOfFECAEASinMov, sizeof(ns3__ArrayOfFECAEASinMov), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__ArrayOfFECAEASinMov * SOAP_FMAC2 soap_instantiate_ns3__ArrayOfFECAEASinMov(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfFECAEASinMov(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__ArrayOfFECAEASinMov *p;
	size_t k = sizeof(ns3__ArrayOfFECAEASinMov);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__ArrayOfFECAEASinMov, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__ArrayOfFECAEASinMov);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__ArrayOfFECAEASinMov, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__ArrayOfFECAEASinMov location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__ArrayOfFECAEASinMov::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__ArrayOfFECAEASinMov(soap, tag ? tag : "ns3:ArrayOfFECAEASinMov", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ArrayOfFECAEASinMov::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfFECAEASinMov(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfFECAEASinMov * SOAP_FMAC4 soap_get_ns3__ArrayOfFECAEASinMov(struct soap *soap, ns3__ArrayOfFECAEASinMov *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfFECAEASinMov(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__FECAEASinMovConsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__FECAEASinMovConsResponse::ResultGet = NULL;
	this->ns3__FECAEASinMovConsResponse::Errors = NULL;
	this->ns3__FECAEASinMovConsResponse::Events = NULL;
}

void ns3__FECAEASinMovConsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__ArrayOfFECAEASinMov(soap, &this->ns3__FECAEASinMovConsResponse::ResultGet);
	soap_serialize_PointerTons3__ArrayOfErr(soap, &this->ns3__FECAEASinMovConsResponse::Errors);
	soap_serialize_PointerTons3__ArrayOfEvt(soap, &this->ns3__FECAEASinMovConsResponse::Events);
#endif
}

int ns3__FECAEASinMovConsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__FECAEASinMovConsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FECAEASinMovConsResponse(struct soap *soap, const char *tag, int id, const ns3__FECAEASinMovConsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__FECAEASinMovConsResponse), type))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfFECAEASinMov(soap, "ns3:ResultGet", -1, &a->ns3__FECAEASinMovConsResponse::ResultGet, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfErr(soap, "ns3:Errors", -1, &a->ns3__FECAEASinMovConsResponse::Errors, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfEvt(soap, "ns3:Events", -1, &a->ns3__FECAEASinMovConsResponse::Events, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__FECAEASinMovConsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__FECAEASinMovConsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns3__FECAEASinMovConsResponse * SOAP_FMAC4 soap_in_ns3__FECAEASinMovConsResponse(struct soap *soap, const char *tag, ns3__FECAEASinMovConsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__FECAEASinMovConsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__FECAEASinMovConsResponse, sizeof(ns3__FECAEASinMovConsResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__FECAEASinMovConsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__FECAEASinMovConsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResultGet1 = 1;
	size_t soap_flag_Errors1 = 1;
	size_t soap_flag_Events1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultGet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfFECAEASinMov(soap, "ns3:ResultGet", &a->ns3__FECAEASinMovConsResponse::ResultGet, "ns3:ArrayOfFECAEASinMov"))
				{	soap_flag_ResultGet1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfErr(soap, "ns3:Errors", &a->ns3__FECAEASinMovConsResponse::Errors, "ns3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfEvt(soap, "ns3:Events", &a->ns3__FECAEASinMovConsResponse::Events, "ns3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__FECAEASinMovConsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__FECAEASinMovConsResponse, SOAP_TYPE_afip_ns3__FECAEASinMovConsResponse, sizeof(ns3__FECAEASinMovConsResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__FECAEASinMovConsResponse * SOAP_FMAC2 soap_instantiate_ns3__FECAEASinMovConsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__FECAEASinMovConsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__FECAEASinMovConsResponse *p;
	size_t k = sizeof(ns3__FECAEASinMovConsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FECAEASinMovConsResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__FECAEASinMovConsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__FECAEASinMovConsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__FECAEASinMovConsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__FECAEASinMovConsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__FECAEASinMovConsResponse(soap, tag ? tag : "ns3:FECAEASinMovConsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__FECAEASinMovConsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__FECAEASinMovConsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns3__FECAEASinMovConsResponse * SOAP_FMAC4 soap_get_ns3__FECAEASinMovConsResponse(struct soap *soap, ns3__FECAEASinMovConsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__FECAEASinMovConsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__FECAEAGet::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__FECAEAGet::CAEA = NULL;
	soap_default_int(soap, &this->ns3__FECAEAGet::Periodo);
	soap_default_short(soap, &this->ns3__FECAEAGet::Orden);
	this->ns3__FECAEAGet::FchVigDesde = NULL;
	this->ns3__FECAEAGet::FchVigHasta = NULL;
	this->ns3__FECAEAGet::FchTopeInf = NULL;
	this->ns3__FECAEAGet::FchProceso = NULL;
	this->ns3__FECAEAGet::Observaciones = NULL;
}

void ns3__FECAEAGet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns3__FECAEAGet::CAEA);
	soap_serialize_PointerTostd__string(soap, &this->ns3__FECAEAGet::FchVigDesde);
	soap_serialize_PointerTostd__string(soap, &this->ns3__FECAEAGet::FchVigHasta);
	soap_serialize_PointerTostd__string(soap, &this->ns3__FECAEAGet::FchTopeInf);
	soap_serialize_PointerTostd__string(soap, &this->ns3__FECAEAGet::FchProceso);
	soap_serialize_PointerTons3__ArrayOfObs(soap, &this->ns3__FECAEAGet::Observaciones);
#endif
}

int ns3__FECAEAGet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__FECAEAGet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FECAEAGet(struct soap *soap, const char *tag, int id, const ns3__FECAEAGet *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__FECAEAGet), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:CAEA", -1, &a->ns3__FECAEAGet::CAEA, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:Periodo", -1, &a->ns3__FECAEAGet::Periodo, ""))
		return soap->error;
	if (soap_out_short(soap, "ns3:Orden", -1, &a->ns3__FECAEAGet::Orden, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchVigDesde", -1, &a->ns3__FECAEAGet::FchVigDesde, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchVigHasta", -1, &a->ns3__FECAEAGet::FchVigHasta, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchTopeInf", -1, &a->ns3__FECAEAGet::FchTopeInf, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchProceso", -1, &a->ns3__FECAEAGet::FchProceso, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfObs(soap, "ns3:Observaciones", -1, &a->ns3__FECAEAGet::Observaciones, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__FECAEAGet::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__FECAEAGet(soap, tag, this, type);
}

SOAP_FMAC3 ns3__FECAEAGet * SOAP_FMAC4 soap_in_ns3__FECAEAGet(struct soap *soap, const char *tag, ns3__FECAEAGet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__FECAEAGet*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__FECAEAGet, sizeof(ns3__FECAEAGet), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__FECAEAGet)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__FECAEAGet *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CAEA1 = 1;
	size_t soap_flag_Periodo1 = 1;
	size_t soap_flag_Orden1 = 1;
	size_t soap_flag_FchVigDesde1 = 1;
	size_t soap_flag_FchVigHasta1 = 1;
	size_t soap_flag_FchTopeInf1 = 1;
	size_t soap_flag_FchProceso1 = 1;
	size_t soap_flag_Observaciones1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CAEA1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:CAEA", &a->ns3__FECAEAGet::CAEA, "xsd:string"))
				{	soap_flag_CAEA1--;
					continue;
				}
			}
			if (soap_flag_Periodo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:Periodo", &a->ns3__FECAEAGet::Periodo, "xsd:int"))
				{	soap_flag_Periodo1--;
					continue;
				}
			}
			if (soap_flag_Orden1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_short(soap, "ns3:Orden", &a->ns3__FECAEAGet::Orden, "xsd:short"))
				{	soap_flag_Orden1--;
					continue;
				}
			}
			if (soap_flag_FchVigDesde1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchVigDesde", &a->ns3__FECAEAGet::FchVigDesde, "xsd:string"))
				{	soap_flag_FchVigDesde1--;
					continue;
				}
			}
			if (soap_flag_FchVigHasta1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchVigHasta", &a->ns3__FECAEAGet::FchVigHasta, "xsd:string"))
				{	soap_flag_FchVigHasta1--;
					continue;
				}
			}
			if (soap_flag_FchTopeInf1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchTopeInf", &a->ns3__FECAEAGet::FchTopeInf, "xsd:string"))
				{	soap_flag_FchTopeInf1--;
					continue;
				}
			}
			if (soap_flag_FchProceso1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchProceso", &a->ns3__FECAEAGet::FchProceso, "xsd:string"))
				{	soap_flag_FchProceso1--;
					continue;
				}
			}
			if (soap_flag_Observaciones1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfObs(soap, "ns3:Observaciones", &a->ns3__FECAEAGet::Observaciones, "ns3:ArrayOfObs"))
				{	soap_flag_Observaciones1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Periodo1 > 0 || soap_flag_Orden1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__FECAEAGet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__FECAEAGet, SOAP_TYPE_afip_ns3__FECAEAGet, sizeof(ns3__FECAEAGet), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__FECAEAGet * SOAP_FMAC2 soap_instantiate_ns3__FECAEAGet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__FECAEAGet(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__FECAEAGet *p;
	size_t k = sizeof(ns3__FECAEAGet);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FECAEAGet, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__FECAEAGet);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__FECAEAGet, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__FECAEAGet location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__FECAEAGet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__FECAEAGet(soap, tag ? tag : "ns3:FECAEAGet", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__FECAEAGet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__FECAEAGet(soap, this, tag, type);
}

SOAP_FMAC3 ns3__FECAEAGet * SOAP_FMAC4 soap_get_ns3__FECAEAGet(struct soap *soap, ns3__FECAEAGet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__FECAEAGet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__FECAEAGetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__FECAEAGetResponse::ResultGet = NULL;
	this->ns3__FECAEAGetResponse::Errors = NULL;
	this->ns3__FECAEAGetResponse::Events = NULL;
}

void ns3__FECAEAGetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FECAEAGet(soap, &this->ns3__FECAEAGetResponse::ResultGet);
	soap_serialize_PointerTons3__ArrayOfErr(soap, &this->ns3__FECAEAGetResponse::Errors);
	soap_serialize_PointerTons3__ArrayOfEvt(soap, &this->ns3__FECAEAGetResponse::Events);
#endif
}

int ns3__FECAEAGetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__FECAEAGetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FECAEAGetResponse(struct soap *soap, const char *tag, int id, const ns3__FECAEAGetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__FECAEAGetResponse), type))
		return soap->error;
	if (soap_out_PointerTons3__FECAEAGet(soap, "ns3:ResultGet", -1, &a->ns3__FECAEAGetResponse::ResultGet, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfErr(soap, "ns3:Errors", -1, &a->ns3__FECAEAGetResponse::Errors, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfEvt(soap, "ns3:Events", -1, &a->ns3__FECAEAGetResponse::Events, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__FECAEAGetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__FECAEAGetResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns3__FECAEAGetResponse * SOAP_FMAC4 soap_in_ns3__FECAEAGetResponse(struct soap *soap, const char *tag, ns3__FECAEAGetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__FECAEAGetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__FECAEAGetResponse, sizeof(ns3__FECAEAGetResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__FECAEAGetResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__FECAEAGetResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResultGet1 = 1;
	size_t soap_flag_Errors1 = 1;
	size_t soap_flag_Events1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultGet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FECAEAGet(soap, "ns3:ResultGet", &a->ns3__FECAEAGetResponse::ResultGet, "ns3:FECAEAGet"))
				{	soap_flag_ResultGet1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfErr(soap, "ns3:Errors", &a->ns3__FECAEAGetResponse::Errors, "ns3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfEvt(soap, "ns3:Events", &a->ns3__FECAEAGetResponse::Events, "ns3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__FECAEAGetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__FECAEAGetResponse, SOAP_TYPE_afip_ns3__FECAEAGetResponse, sizeof(ns3__FECAEAGetResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__FECAEAGetResponse * SOAP_FMAC2 soap_instantiate_ns3__FECAEAGetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__FECAEAGetResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__FECAEAGetResponse *p;
	size_t k = sizeof(ns3__FECAEAGetResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FECAEAGetResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__FECAEAGetResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__FECAEAGetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__FECAEAGetResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__FECAEAGetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__FECAEAGetResponse(soap, tag ? tag : "ns3:FECAEAGetResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__FECAEAGetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__FECAEAGetResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns3__FECAEAGetResponse * SOAP_FMAC4 soap_get_ns3__FECAEAGetResponse(struct soap *soap, ns3__FECAEAGetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__FECAEAGetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__FECAEADetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__FEDetResponse::soap_default(soap);
	this->ns3__FECAEADetResponse::CAEA = NULL;
}

void ns3__FECAEADetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns3__FECAEADetResponse::CAEA);
	this->ns3__FEDetResponse::soap_serialize(soap);
#endif
}

int ns3__FECAEADetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__FECAEADetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FECAEADetResponse(struct soap *soap, const char *tag, int id, const ns3__FECAEADetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__FECAEADetResponse), type ? type : "ns3:FECAEADetResponse"))
		return soap->error;
	if (soap_out_int(soap, "ns3:Concepto", -1, &a->ns3__FEDetResponse::Concepto, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:DocTipo", -1, &a->ns3__FEDetResponse::DocTipo, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns3:DocNro", -1, &a->ns3__FEDetResponse::DocNro, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns3:CbteDesde", -1, &a->ns3__FEDetResponse::CbteDesde, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns3:CbteHasta", -1, &a->ns3__FEDetResponse::CbteHasta, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:CbteFch", -1, &a->ns3__FEDetResponse::CbteFch, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Resultado", -1, &a->ns3__FEDetResponse::Resultado, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfObs(soap, "ns3:Observaciones", -1, &a->ns3__FEDetResponse::Observaciones, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:CAEA", -1, &a->ns3__FECAEADetResponse::CAEA, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__FECAEADetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__FECAEADetResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns3__FECAEADetResponse * SOAP_FMAC4 soap_in_ns3__FECAEADetResponse(struct soap *soap, const char *tag, ns3__FECAEADetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__FECAEADetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__FECAEADetResponse, sizeof(ns3__FECAEADetResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__FECAEADetResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__FECAEADetResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Concepto2 = 1;
	size_t soap_flag_DocTipo2 = 1;
	size_t soap_flag_DocNro2 = 1;
	size_t soap_flag_CbteDesde2 = 1;
	size_t soap_flag_CbteHasta2 = 1;
	size_t soap_flag_CbteFch2 = 1;
	size_t soap_flag_Resultado2 = 1;
	size_t soap_flag_Observaciones2 = 1;
	size_t soap_flag_CAEA1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Concepto2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:Concepto", &a->ns3__FEDetResponse::Concepto, "xsd:int"))
				{	soap_flag_Concepto2--;
					continue;
				}
			}
			if (soap_flag_DocTipo2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:DocTipo", &a->ns3__FEDetResponse::DocTipo, "xsd:int"))
				{	soap_flag_DocTipo2--;
					continue;
				}
			}
			if (soap_flag_DocNro2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "ns3:DocNro", &a->ns3__FEDetResponse::DocNro, "xsd:long"))
				{	soap_flag_DocNro2--;
					continue;
				}
			}
			if (soap_flag_CbteDesde2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "ns3:CbteDesde", &a->ns3__FEDetResponse::CbteDesde, "xsd:long"))
				{	soap_flag_CbteDesde2--;
					continue;
				}
			}
			if (soap_flag_CbteHasta2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "ns3:CbteHasta", &a->ns3__FEDetResponse::CbteHasta, "xsd:long"))
				{	soap_flag_CbteHasta2--;
					continue;
				}
			}
			if (soap_flag_CbteFch2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:CbteFch", &a->ns3__FEDetResponse::CbteFch, "xsd:string"))
				{	soap_flag_CbteFch2--;
					continue;
				}
			}
			if (soap_flag_Resultado2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Resultado", &a->ns3__FEDetResponse::Resultado, "xsd:string"))
				{	soap_flag_Resultado2--;
					continue;
				}
			}
			if (soap_flag_Observaciones2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfObs(soap, "ns3:Observaciones", &a->ns3__FEDetResponse::Observaciones, "ns3:ArrayOfObs"))
				{	soap_flag_Observaciones2--;
					continue;
				}
			}
			if (soap_flag_CAEA1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:CAEA", &a->ns3__FECAEADetResponse::CAEA, "xsd:string"))
				{	soap_flag_CAEA1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Concepto2 > 0 || soap_flag_DocTipo2 > 0 || soap_flag_DocNro2 > 0 || soap_flag_CbteDesde2 > 0 || soap_flag_CbteHasta2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__FECAEADetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__FECAEADetResponse, SOAP_TYPE_afip_ns3__FECAEADetResponse, sizeof(ns3__FECAEADetResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__FECAEADetResponse * SOAP_FMAC2 soap_instantiate_ns3__FECAEADetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__FECAEADetResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__FECAEADetResponse *p;
	size_t k = sizeof(ns3__FECAEADetResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FECAEADetResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__FECAEADetResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__FECAEADetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__FECAEADetResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__FECAEADetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__FECAEADetResponse(soap, tag ? tag : "ns3:FECAEADetResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__FECAEADetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__FECAEADetResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns3__FECAEADetResponse * SOAP_FMAC4 soap_get_ns3__FECAEADetResponse(struct soap *soap, ns3__FECAEADetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__FECAEADetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__ArrayOfFECAEADetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__FECAEADetResponse(soap, &this->ns3__ArrayOfFECAEADetResponse::FECAEADetResponse);
}

void ns3__ArrayOfFECAEADetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons3__FECAEADetResponse(soap, &this->ns3__ArrayOfFECAEADetResponse::FECAEADetResponse);
#endif
}

int ns3__ArrayOfFECAEADetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfFECAEADetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfFECAEADetResponse(struct soap *soap, const char *tag, int id, const ns3__ArrayOfFECAEADetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__ArrayOfFECAEADetResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__FECAEADetResponse(soap, "ns3:FECAEADetResponse", -1, &a->ns3__ArrayOfFECAEADetResponse::FECAEADetResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfFECAEADetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__ArrayOfFECAEADetResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfFECAEADetResponse * SOAP_FMAC4 soap_in_ns3__ArrayOfFECAEADetResponse(struct soap *soap, const char *tag, ns3__ArrayOfFECAEADetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfFECAEADetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__ArrayOfFECAEADetResponse, sizeof(ns3__ArrayOfFECAEADetResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__ArrayOfFECAEADetResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__ArrayOfFECAEADetResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__FECAEADetResponse(soap, "ns3:FECAEADetResponse", &a->ns3__ArrayOfFECAEADetResponse::FECAEADetResponse, "ns3:FECAEADetResponse"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfFECAEADetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__ArrayOfFECAEADetResponse, SOAP_TYPE_afip_ns3__ArrayOfFECAEADetResponse, sizeof(ns3__ArrayOfFECAEADetResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__ArrayOfFECAEADetResponse * SOAP_FMAC2 soap_instantiate_ns3__ArrayOfFECAEADetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfFECAEADetResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__ArrayOfFECAEADetResponse *p;
	size_t k = sizeof(ns3__ArrayOfFECAEADetResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__ArrayOfFECAEADetResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__ArrayOfFECAEADetResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__ArrayOfFECAEADetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__ArrayOfFECAEADetResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__ArrayOfFECAEADetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__ArrayOfFECAEADetResponse(soap, tag ? tag : "ns3:ArrayOfFECAEADetResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ArrayOfFECAEADetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfFECAEADetResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfFECAEADetResponse * SOAP_FMAC4 soap_get_ns3__ArrayOfFECAEADetResponse(struct soap *soap, ns3__ArrayOfFECAEADetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfFECAEADetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__FECAEACabResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__FECabResponse::soap_default(soap);
}

void ns3__FECAEACabResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns3__FECabResponse::soap_serialize(soap);
#endif
}

int ns3__FECAEACabResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__FECAEACabResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FECAEACabResponse(struct soap *soap, const char *tag, int id, const ns3__FECAEACabResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__FECAEACabResponse), type ? type : "ns3:FECAEACabResponse"))
		return soap->error;
	if (soap_out_LONG64(soap, "ns3:Cuit", -1, &a->ns3__FECabResponse::Cuit, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:PtoVta", -1, &a->ns3__FECabResponse::PtoVta, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:CbteTipo", -1, &a->ns3__FECabResponse::CbteTipo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchProceso", -1, &a->ns3__FECabResponse::FchProceso, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:CantReg", -1, &a->ns3__FECabResponse::CantReg, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Resultado", -1, &a->ns3__FECabResponse::Resultado, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Reproceso", -1, &a->ns3__FECabResponse::Reproceso, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__FECAEACabResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__FECAEACabResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns3__FECAEACabResponse * SOAP_FMAC4 soap_in_ns3__FECAEACabResponse(struct soap *soap, const char *tag, ns3__FECAEACabResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__FECAEACabResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__FECAEACabResponse, sizeof(ns3__FECAEACabResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__FECAEACabResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__FECAEACabResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Cuit2 = 1;
	size_t soap_flag_PtoVta2 = 1;
	size_t soap_flag_CbteTipo2 = 1;
	size_t soap_flag_FchProceso2 = 1;
	size_t soap_flag_CantReg2 = 1;
	size_t soap_flag_Resultado2 = 1;
	size_t soap_flag_Reproceso2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Cuit2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "ns3:Cuit", &a->ns3__FECabResponse::Cuit, "xsd:long"))
				{	soap_flag_Cuit2--;
					continue;
				}
			}
			if (soap_flag_PtoVta2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:PtoVta", &a->ns3__FECabResponse::PtoVta, "xsd:int"))
				{	soap_flag_PtoVta2--;
					continue;
				}
			}
			if (soap_flag_CbteTipo2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:CbteTipo", &a->ns3__FECabResponse::CbteTipo, "xsd:int"))
				{	soap_flag_CbteTipo2--;
					continue;
				}
			}
			if (soap_flag_FchProceso2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchProceso", &a->ns3__FECabResponse::FchProceso, "xsd:string"))
				{	soap_flag_FchProceso2--;
					continue;
				}
			}
			if (soap_flag_CantReg2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:CantReg", &a->ns3__FECabResponse::CantReg, "xsd:int"))
				{	soap_flag_CantReg2--;
					continue;
				}
			}
			if (soap_flag_Resultado2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Resultado", &a->ns3__FECabResponse::Resultado, "xsd:string"))
				{	soap_flag_Resultado2--;
					continue;
				}
			}
			if (soap_flag_Reproceso2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Reproceso", &a->ns3__FECabResponse::Reproceso, "xsd:string"))
				{	soap_flag_Reproceso2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Cuit2 > 0 || soap_flag_PtoVta2 > 0 || soap_flag_CbteTipo2 > 0 || soap_flag_CantReg2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__FECAEACabResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__FECAEACabResponse, SOAP_TYPE_afip_ns3__FECAEACabResponse, sizeof(ns3__FECAEACabResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__FECAEACabResponse * SOAP_FMAC2 soap_instantiate_ns3__FECAEACabResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__FECAEACabResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__FECAEACabResponse *p;
	size_t k = sizeof(ns3__FECAEACabResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FECAEACabResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__FECAEACabResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__FECAEACabResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__FECAEACabResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__FECAEACabResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__FECAEACabResponse(soap, tag ? tag : "ns3:FECAEACabResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__FECAEACabResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__FECAEACabResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns3__FECAEACabResponse * SOAP_FMAC4 soap_get_ns3__FECAEACabResponse(struct soap *soap, ns3__FECAEACabResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__FECAEACabResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__FECAEAResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__FECAEAResponse::FeCabResp = NULL;
	this->ns3__FECAEAResponse::FeDetResp = NULL;
	this->ns3__FECAEAResponse::Events = NULL;
	this->ns3__FECAEAResponse::Errors = NULL;
}

void ns3__FECAEAResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FECAEACabResponse(soap, &this->ns3__FECAEAResponse::FeCabResp);
	soap_serialize_PointerTons3__ArrayOfFECAEADetResponse(soap, &this->ns3__FECAEAResponse::FeDetResp);
	soap_serialize_PointerTons3__ArrayOfEvt(soap, &this->ns3__FECAEAResponse::Events);
	soap_serialize_PointerTons3__ArrayOfErr(soap, &this->ns3__FECAEAResponse::Errors);
#endif
}

int ns3__FECAEAResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__FECAEAResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FECAEAResponse(struct soap *soap, const char *tag, int id, const ns3__FECAEAResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__FECAEAResponse), type))
		return soap->error;
	if (soap_out_PointerTons3__FECAEACabResponse(soap, "ns3:FeCabResp", -1, &a->ns3__FECAEAResponse::FeCabResp, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfFECAEADetResponse(soap, "ns3:FeDetResp", -1, &a->ns3__FECAEAResponse::FeDetResp, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfEvt(soap, "ns3:Events", -1, &a->ns3__FECAEAResponse::Events, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfErr(soap, "ns3:Errors", -1, &a->ns3__FECAEAResponse::Errors, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__FECAEAResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__FECAEAResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns3__FECAEAResponse * SOAP_FMAC4 soap_in_ns3__FECAEAResponse(struct soap *soap, const char *tag, ns3__FECAEAResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__FECAEAResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__FECAEAResponse, sizeof(ns3__FECAEAResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__FECAEAResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__FECAEAResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FeCabResp1 = 1;
	size_t soap_flag_FeDetResp1 = 1;
	size_t soap_flag_Events1 = 1;
	size_t soap_flag_Errors1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FeCabResp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FECAEACabResponse(soap, "ns3:FeCabResp", &a->ns3__FECAEAResponse::FeCabResp, "ns3:FECAEACabResponse"))
				{	soap_flag_FeCabResp1--;
					continue;
				}
			}
			if (soap_flag_FeDetResp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfFECAEADetResponse(soap, "ns3:FeDetResp", &a->ns3__FECAEAResponse::FeDetResp, "ns3:ArrayOfFECAEADetResponse"))
				{	soap_flag_FeDetResp1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfEvt(soap, "ns3:Events", &a->ns3__FECAEAResponse::Events, "ns3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfErr(soap, "ns3:Errors", &a->ns3__FECAEAResponse::Errors, "ns3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__FECAEAResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__FECAEAResponse, SOAP_TYPE_afip_ns3__FECAEAResponse, sizeof(ns3__FECAEAResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__FECAEAResponse * SOAP_FMAC2 soap_instantiate_ns3__FECAEAResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__FECAEAResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__FECAEAResponse *p;
	size_t k = sizeof(ns3__FECAEAResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FECAEAResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__FECAEAResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__FECAEAResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__FECAEAResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__FECAEAResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__FECAEAResponse(soap, tag ? tag : "ns3:FECAEAResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__FECAEAResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__FECAEAResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns3__FECAEAResponse * SOAP_FMAC4 soap_get_ns3__FECAEAResponse(struct soap *soap, ns3__FECAEAResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__FECAEAResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__FECAEADetRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__FEDetRequest::soap_default(soap);
	this->ns3__FECAEADetRequest::CAEA = NULL;
	this->ns3__FECAEADetRequest::CbteFchHsGen = NULL;
}

void ns3__FECAEADetRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns3__FECAEADetRequest::CAEA);
	soap_serialize_PointerTostd__string(soap, &this->ns3__FECAEADetRequest::CbteFchHsGen);
	this->ns3__FEDetRequest::soap_serialize(soap);
#endif
}

int ns3__FECAEADetRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__FECAEADetRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FECAEADetRequest(struct soap *soap, const char *tag, int id, const ns3__FECAEADetRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__FECAEADetRequest), type ? type : "ns3:FECAEADetRequest"))
		return soap->error;
	if (soap_out_int(soap, "ns3:Concepto", -1, &a->ns3__FEDetRequest::Concepto, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:DocTipo", -1, &a->ns3__FEDetRequest::DocTipo, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns3:DocNro", -1, &a->ns3__FEDetRequest::DocNro, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns3:CbteDesde", -1, &a->ns3__FEDetRequest::CbteDesde, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns3:CbteHasta", -1, &a->ns3__FEDetRequest::CbteHasta, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:CbteFch", -1, &a->ns3__FEDetRequest::CbteFch, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:ImpTotal", -1, &a->ns3__FEDetRequest::ImpTotal, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:ImpTotConc", -1, &a->ns3__FEDetRequest::ImpTotConc, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:ImpNeto", -1, &a->ns3__FEDetRequest::ImpNeto, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:ImpOpEx", -1, &a->ns3__FEDetRequest::ImpOpEx, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:ImpTrib", -1, &a->ns3__FEDetRequest::ImpTrib, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:ImpIVA", -1, &a->ns3__FEDetRequest::ImpIVA, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchServDesde", -1, &a->ns3__FEDetRequest::FchServDesde, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchServHasta", -1, &a->ns3__FEDetRequest::FchServHasta, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchVtoPago", -1, &a->ns3__FEDetRequest::FchVtoPago, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:MonId", -1, &a->ns3__FEDetRequest::MonId, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:MonCotiz", -1, &a->ns3__FEDetRequest::MonCotiz, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfCbteAsoc(soap, "ns3:CbtesAsoc", -1, &a->ns3__FEDetRequest::CbtesAsoc, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfTributo(soap, "ns3:Tributos", -1, &a->ns3__FEDetRequest::Tributos, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfAlicIva(soap, "ns3:Iva", -1, &a->ns3__FEDetRequest::Iva, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfOpcional(soap, "ns3:Opcionales", -1, &a->ns3__FEDetRequest::Opcionales, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfComprador(soap, "ns3:Compradores", -1, &a->ns3__FEDetRequest::Compradores, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:CAEA", -1, &a->ns3__FECAEADetRequest::CAEA, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:CbteFchHsGen", -1, &a->ns3__FECAEADetRequest::CbteFchHsGen, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__FECAEADetRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__FECAEADetRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns3__FECAEADetRequest * SOAP_FMAC4 soap_in_ns3__FECAEADetRequest(struct soap *soap, const char *tag, ns3__FECAEADetRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__FECAEADetRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__FECAEADetRequest, sizeof(ns3__FECAEADetRequest), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__FECAEADetRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__FECAEADetRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Concepto2 = 1;
	size_t soap_flag_DocTipo2 = 1;
	size_t soap_flag_DocNro2 = 1;
	size_t soap_flag_CbteDesde2 = 1;
	size_t soap_flag_CbteHasta2 = 1;
	size_t soap_flag_CbteFch2 = 1;
	size_t soap_flag_ImpTotal2 = 1;
	size_t soap_flag_ImpTotConc2 = 1;
	size_t soap_flag_ImpNeto2 = 1;
	size_t soap_flag_ImpOpEx2 = 1;
	size_t soap_flag_ImpTrib2 = 1;
	size_t soap_flag_ImpIVA2 = 1;
	size_t soap_flag_FchServDesde2 = 1;
	size_t soap_flag_FchServHasta2 = 1;
	size_t soap_flag_FchVtoPago2 = 1;
	size_t soap_flag_MonId2 = 1;
	size_t soap_flag_MonCotiz2 = 1;
	size_t soap_flag_CbtesAsoc2 = 1;
	size_t soap_flag_Tributos2 = 1;
	size_t soap_flag_Iva2 = 1;
	size_t soap_flag_Opcionales2 = 1;
	size_t soap_flag_Compradores2 = 1;
	size_t soap_flag_CAEA1 = 1;
	size_t soap_flag_CbteFchHsGen1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Concepto2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:Concepto", &a->ns3__FEDetRequest::Concepto, "xsd:int"))
				{	soap_flag_Concepto2--;
					continue;
				}
			}
			if (soap_flag_DocTipo2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:DocTipo", &a->ns3__FEDetRequest::DocTipo, "xsd:int"))
				{	soap_flag_DocTipo2--;
					continue;
				}
			}
			if (soap_flag_DocNro2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "ns3:DocNro", &a->ns3__FEDetRequest::DocNro, "xsd:long"))
				{	soap_flag_DocNro2--;
					continue;
				}
			}
			if (soap_flag_CbteDesde2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "ns3:CbteDesde", &a->ns3__FEDetRequest::CbteDesde, "xsd:long"))
				{	soap_flag_CbteDesde2--;
					continue;
				}
			}
			if (soap_flag_CbteHasta2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "ns3:CbteHasta", &a->ns3__FEDetRequest::CbteHasta, "xsd:long"))
				{	soap_flag_CbteHasta2--;
					continue;
				}
			}
			if (soap_flag_CbteFch2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:CbteFch", &a->ns3__FEDetRequest::CbteFch, "xsd:string"))
				{	soap_flag_CbteFch2--;
					continue;
				}
			}
			if (soap_flag_ImpTotal2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:ImpTotal", &a->ns3__FEDetRequest::ImpTotal, "xsd:double"))
				{	soap_flag_ImpTotal2--;
					continue;
				}
			}
			if (soap_flag_ImpTotConc2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:ImpTotConc", &a->ns3__FEDetRequest::ImpTotConc, "xsd:double"))
				{	soap_flag_ImpTotConc2--;
					continue;
				}
			}
			if (soap_flag_ImpNeto2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:ImpNeto", &a->ns3__FEDetRequest::ImpNeto, "xsd:double"))
				{	soap_flag_ImpNeto2--;
					continue;
				}
			}
			if (soap_flag_ImpOpEx2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:ImpOpEx", &a->ns3__FEDetRequest::ImpOpEx, "xsd:double"))
				{	soap_flag_ImpOpEx2--;
					continue;
				}
			}
			if (soap_flag_ImpTrib2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:ImpTrib", &a->ns3__FEDetRequest::ImpTrib, "xsd:double"))
				{	soap_flag_ImpTrib2--;
					continue;
				}
			}
			if (soap_flag_ImpIVA2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:ImpIVA", &a->ns3__FEDetRequest::ImpIVA, "xsd:double"))
				{	soap_flag_ImpIVA2--;
					continue;
				}
			}
			if (soap_flag_FchServDesde2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchServDesde", &a->ns3__FEDetRequest::FchServDesde, "xsd:string"))
				{	soap_flag_FchServDesde2--;
					continue;
				}
			}
			if (soap_flag_FchServHasta2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchServHasta", &a->ns3__FEDetRequest::FchServHasta, "xsd:string"))
				{	soap_flag_FchServHasta2--;
					continue;
				}
			}
			if (soap_flag_FchVtoPago2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchVtoPago", &a->ns3__FEDetRequest::FchVtoPago, "xsd:string"))
				{	soap_flag_FchVtoPago2--;
					continue;
				}
			}
			if (soap_flag_MonId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:MonId", &a->ns3__FEDetRequest::MonId, "xsd:string"))
				{	soap_flag_MonId2--;
					continue;
				}
			}
			if (soap_flag_MonCotiz2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:MonCotiz", &a->ns3__FEDetRequest::MonCotiz, "xsd:double"))
				{	soap_flag_MonCotiz2--;
					continue;
				}
			}
			if (soap_flag_CbtesAsoc2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfCbteAsoc(soap, "ns3:CbtesAsoc", &a->ns3__FEDetRequest::CbtesAsoc, "ns3:ArrayOfCbteAsoc"))
				{	soap_flag_CbtesAsoc2--;
					continue;
				}
			}
			if (soap_flag_Tributos2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfTributo(soap, "ns3:Tributos", &a->ns3__FEDetRequest::Tributos, "ns3:ArrayOfTributo"))
				{	soap_flag_Tributos2--;
					continue;
				}
			}
			if (soap_flag_Iva2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfAlicIva(soap, "ns3:Iva", &a->ns3__FEDetRequest::Iva, "ns3:ArrayOfAlicIva"))
				{	soap_flag_Iva2--;
					continue;
				}
			}
			if (soap_flag_Opcionales2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfOpcional(soap, "ns3:Opcionales", &a->ns3__FEDetRequest::Opcionales, "ns3:ArrayOfOpcional"))
				{	soap_flag_Opcionales2--;
					continue;
				}
			}
			if (soap_flag_Compradores2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfComprador(soap, "ns3:Compradores", &a->ns3__FEDetRequest::Compradores, "ns3:ArrayOfComprador"))
				{	soap_flag_Compradores2--;
					continue;
				}
			}
			if (soap_flag_CAEA1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:CAEA", &a->ns3__FECAEADetRequest::CAEA, "xsd:string"))
				{	soap_flag_CAEA1--;
					continue;
				}
			}
			if (soap_flag_CbteFchHsGen1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:CbteFchHsGen", &a->ns3__FECAEADetRequest::CbteFchHsGen, "xsd:string"))
				{	soap_flag_CbteFchHsGen1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Concepto2 > 0 || soap_flag_DocTipo2 > 0 || soap_flag_DocNro2 > 0 || soap_flag_CbteDesde2 > 0 || soap_flag_CbteHasta2 > 0 || soap_flag_ImpTotal2 > 0 || soap_flag_ImpTotConc2 > 0 || soap_flag_ImpNeto2 > 0 || soap_flag_ImpOpEx2 > 0 || soap_flag_ImpTrib2 > 0 || soap_flag_ImpIVA2 > 0 || soap_flag_MonCotiz2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__FECAEADetRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__FECAEADetRequest, SOAP_TYPE_afip_ns3__FECAEADetRequest, sizeof(ns3__FECAEADetRequest), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__FECAEADetRequest * SOAP_FMAC2 soap_instantiate_ns3__FECAEADetRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__FECAEADetRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__FECAEADetRequest *p;
	size_t k = sizeof(ns3__FECAEADetRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FECAEADetRequest, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__FECAEADetRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__FECAEADetRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__FECAEADetRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__FECAEADetRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__FECAEADetRequest(soap, tag ? tag : "ns3:FECAEADetRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__FECAEADetRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__FECAEADetRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns3__FECAEADetRequest * SOAP_FMAC4 soap_get_ns3__FECAEADetRequest(struct soap *soap, ns3__FECAEADetRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__FECAEADetRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__ArrayOfFECAEADetRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__FECAEADetRequest(soap, &this->ns3__ArrayOfFECAEADetRequest::FECAEADetRequest);
}

void ns3__ArrayOfFECAEADetRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons3__FECAEADetRequest(soap, &this->ns3__ArrayOfFECAEADetRequest::FECAEADetRequest);
#endif
}

int ns3__ArrayOfFECAEADetRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfFECAEADetRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfFECAEADetRequest(struct soap *soap, const char *tag, int id, const ns3__ArrayOfFECAEADetRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__ArrayOfFECAEADetRequest), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__FECAEADetRequest(soap, "ns3:FECAEADetRequest", -1, &a->ns3__ArrayOfFECAEADetRequest::FECAEADetRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfFECAEADetRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__ArrayOfFECAEADetRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfFECAEADetRequest * SOAP_FMAC4 soap_in_ns3__ArrayOfFECAEADetRequest(struct soap *soap, const char *tag, ns3__ArrayOfFECAEADetRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfFECAEADetRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__ArrayOfFECAEADetRequest, sizeof(ns3__ArrayOfFECAEADetRequest), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__ArrayOfFECAEADetRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__ArrayOfFECAEADetRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__FECAEADetRequest(soap, "ns3:FECAEADetRequest", &a->ns3__ArrayOfFECAEADetRequest::FECAEADetRequest, "ns3:FECAEADetRequest"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfFECAEADetRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__ArrayOfFECAEADetRequest, SOAP_TYPE_afip_ns3__ArrayOfFECAEADetRequest, sizeof(ns3__ArrayOfFECAEADetRequest), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__ArrayOfFECAEADetRequest * SOAP_FMAC2 soap_instantiate_ns3__ArrayOfFECAEADetRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfFECAEADetRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__ArrayOfFECAEADetRequest *p;
	size_t k = sizeof(ns3__ArrayOfFECAEADetRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__ArrayOfFECAEADetRequest, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__ArrayOfFECAEADetRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__ArrayOfFECAEADetRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__ArrayOfFECAEADetRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__ArrayOfFECAEADetRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__ArrayOfFECAEADetRequest(soap, tag ? tag : "ns3:ArrayOfFECAEADetRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ArrayOfFECAEADetRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfFECAEADetRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfFECAEADetRequest * SOAP_FMAC4 soap_get_ns3__ArrayOfFECAEADetRequest(struct soap *soap, ns3__ArrayOfFECAEADetRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfFECAEADetRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__FECAEACabRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__FECabRequest::soap_default(soap);
}

void ns3__FECAEACabRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns3__FECabRequest::soap_serialize(soap);
#endif
}

int ns3__FECAEACabRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__FECAEACabRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FECAEACabRequest(struct soap *soap, const char *tag, int id, const ns3__FECAEACabRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__FECAEACabRequest), type ? type : "ns3:FECAEACabRequest"))
		return soap->error;
	if (soap_out_int(soap, "ns3:CantReg", -1, &a->ns3__FECabRequest::CantReg, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:PtoVta", -1, &a->ns3__FECabRequest::PtoVta, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:CbteTipo", -1, &a->ns3__FECabRequest::CbteTipo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__FECAEACabRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__FECAEACabRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns3__FECAEACabRequest * SOAP_FMAC4 soap_in_ns3__FECAEACabRequest(struct soap *soap, const char *tag, ns3__FECAEACabRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__FECAEACabRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__FECAEACabRequest, sizeof(ns3__FECAEACabRequest), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__FECAEACabRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__FECAEACabRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CantReg2 = 1;
	size_t soap_flag_PtoVta2 = 1;
	size_t soap_flag_CbteTipo2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CantReg2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:CantReg", &a->ns3__FECabRequest::CantReg, "xsd:int"))
				{	soap_flag_CantReg2--;
					continue;
				}
			}
			if (soap_flag_PtoVta2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:PtoVta", &a->ns3__FECabRequest::PtoVta, "xsd:int"))
				{	soap_flag_PtoVta2--;
					continue;
				}
			}
			if (soap_flag_CbteTipo2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:CbteTipo", &a->ns3__FECabRequest::CbteTipo, "xsd:int"))
				{	soap_flag_CbteTipo2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CantReg2 > 0 || soap_flag_PtoVta2 > 0 || soap_flag_CbteTipo2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__FECAEACabRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__FECAEACabRequest, SOAP_TYPE_afip_ns3__FECAEACabRequest, sizeof(ns3__FECAEACabRequest), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__FECAEACabRequest * SOAP_FMAC2 soap_instantiate_ns3__FECAEACabRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__FECAEACabRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__FECAEACabRequest *p;
	size_t k = sizeof(ns3__FECAEACabRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FECAEACabRequest, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__FECAEACabRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__FECAEACabRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__FECAEACabRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__FECAEACabRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__FECAEACabRequest(soap, tag ? tag : "ns3:FECAEACabRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__FECAEACabRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__FECAEACabRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns3__FECAEACabRequest * SOAP_FMAC4 soap_get_ns3__FECAEACabRequest(struct soap *soap, ns3__FECAEACabRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__FECAEACabRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__FECAEARequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__FECAEARequest::FeCabReq = NULL;
	this->ns3__FECAEARequest::FeDetReq = NULL;
}

void ns3__FECAEARequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FECAEACabRequest(soap, &this->ns3__FECAEARequest::FeCabReq);
	soap_serialize_PointerTons3__ArrayOfFECAEADetRequest(soap, &this->ns3__FECAEARequest::FeDetReq);
#endif
}

int ns3__FECAEARequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__FECAEARequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FECAEARequest(struct soap *soap, const char *tag, int id, const ns3__FECAEARequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__FECAEARequest), type))
		return soap->error;
	if (soap_out_PointerTons3__FECAEACabRequest(soap, "ns3:FeCabReq", -1, &a->ns3__FECAEARequest::FeCabReq, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfFECAEADetRequest(soap, "ns3:FeDetReq", -1, &a->ns3__FECAEARequest::FeDetReq, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__FECAEARequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__FECAEARequest(soap, tag, this, type);
}

SOAP_FMAC3 ns3__FECAEARequest * SOAP_FMAC4 soap_in_ns3__FECAEARequest(struct soap *soap, const char *tag, ns3__FECAEARequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__FECAEARequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__FECAEARequest, sizeof(ns3__FECAEARequest), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__FECAEARequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__FECAEARequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FeCabReq1 = 1;
	size_t soap_flag_FeDetReq1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FeCabReq1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FECAEACabRequest(soap, "ns3:FeCabReq", &a->ns3__FECAEARequest::FeCabReq, "ns3:FECAEACabRequest"))
				{	soap_flag_FeCabReq1--;
					continue;
				}
			}
			if (soap_flag_FeDetReq1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfFECAEADetRequest(soap, "ns3:FeDetReq", &a->ns3__FECAEARequest::FeDetReq, "ns3:ArrayOfFECAEADetRequest"))
				{	soap_flag_FeDetReq1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__FECAEARequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__FECAEARequest, SOAP_TYPE_afip_ns3__FECAEARequest, sizeof(ns3__FECAEARequest), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__FECAEARequest * SOAP_FMAC2 soap_instantiate_ns3__FECAEARequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__FECAEARequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__FECAEARequest *p;
	size_t k = sizeof(ns3__FECAEARequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FECAEARequest, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__FECAEARequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__FECAEARequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__FECAEARequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__FECAEARequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__FECAEARequest(soap, tag ? tag : "ns3:FECAEARequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__FECAEARequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__FECAEARequest(soap, this, tag, type);
}

SOAP_FMAC3 ns3__FECAEARequest * SOAP_FMAC4 soap_get_ns3__FECAEARequest(struct soap *soap, ns3__FECAEARequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__FECAEARequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__FECompConsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__FECAEDetRequest::soap_default(soap);
	this->ns3__FECompConsResponse::Resultado = NULL;
	this->ns3__FECompConsResponse::CodAutorizacion = NULL;
	this->ns3__FECompConsResponse::EmisionTipo = NULL;
	this->ns3__FECompConsResponse::FchVto = NULL;
	this->ns3__FECompConsResponse::FchProceso = NULL;
	this->ns3__FECompConsResponse::Observaciones = NULL;
	soap_default_int(soap, &this->ns3__FECompConsResponse::PtoVta);
	soap_default_int(soap, &this->ns3__FECompConsResponse::CbteTipo);
}

void ns3__FECompConsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns3__FECompConsResponse::Resultado);
	soap_serialize_PointerTostd__string(soap, &this->ns3__FECompConsResponse::CodAutorizacion);
	soap_serialize_PointerTostd__string(soap, &this->ns3__FECompConsResponse::EmisionTipo);
	soap_serialize_PointerTostd__string(soap, &this->ns3__FECompConsResponse::FchVto);
	soap_serialize_PointerTostd__string(soap, &this->ns3__FECompConsResponse::FchProceso);
	soap_serialize_PointerTons3__ArrayOfObs(soap, &this->ns3__FECompConsResponse::Observaciones);
	this->ns3__FECAEDetRequest::soap_serialize(soap);
#endif
}

int ns3__FECompConsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__FECompConsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FECompConsResponse(struct soap *soap, const char *tag, int id, const ns3__FECompConsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__FECompConsResponse), type ? type : "ns3:FECompConsResponse"))
		return soap->error;
	if (soap_out_int(soap, "ns3:Concepto", -1, &a->ns3__FEDetRequest::Concepto, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:DocTipo", -1, &a->ns3__FEDetRequest::DocTipo, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns3:DocNro", -1, &a->ns3__FEDetRequest::DocNro, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns3:CbteDesde", -1, &a->ns3__FEDetRequest::CbteDesde, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns3:CbteHasta", -1, &a->ns3__FEDetRequest::CbteHasta, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:CbteFch", -1, &a->ns3__FEDetRequest::CbteFch, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:ImpTotal", -1, &a->ns3__FEDetRequest::ImpTotal, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:ImpTotConc", -1, &a->ns3__FEDetRequest::ImpTotConc, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:ImpNeto", -1, &a->ns3__FEDetRequest::ImpNeto, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:ImpOpEx", -1, &a->ns3__FEDetRequest::ImpOpEx, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:ImpTrib", -1, &a->ns3__FEDetRequest::ImpTrib, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:ImpIVA", -1, &a->ns3__FEDetRequest::ImpIVA, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchServDesde", -1, &a->ns3__FEDetRequest::FchServDesde, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchServHasta", -1, &a->ns3__FEDetRequest::FchServHasta, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchVtoPago", -1, &a->ns3__FEDetRequest::FchVtoPago, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:MonId", -1, &a->ns3__FEDetRequest::MonId, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:MonCotiz", -1, &a->ns3__FEDetRequest::MonCotiz, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfCbteAsoc(soap, "ns3:CbtesAsoc", -1, &a->ns3__FEDetRequest::CbtesAsoc, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfTributo(soap, "ns3:Tributos", -1, &a->ns3__FEDetRequest::Tributos, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfAlicIva(soap, "ns3:Iva", -1, &a->ns3__FEDetRequest::Iva, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfOpcional(soap, "ns3:Opcionales", -1, &a->ns3__FEDetRequest::Opcionales, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfComprador(soap, "ns3:Compradores", -1, &a->ns3__FEDetRequest::Compradores, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Resultado", -1, &a->ns3__FECompConsResponse::Resultado, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:CodAutorizacion", -1, &a->ns3__FECompConsResponse::CodAutorizacion, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:EmisionTipo", -1, &a->ns3__FECompConsResponse::EmisionTipo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchVto", -1, &a->ns3__FECompConsResponse::FchVto, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchProceso", -1, &a->ns3__FECompConsResponse::FchProceso, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfObs(soap, "ns3:Observaciones", -1, &a->ns3__FECompConsResponse::Observaciones, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:PtoVta", -1, &a->ns3__FECompConsResponse::PtoVta, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:CbteTipo", -1, &a->ns3__FECompConsResponse::CbteTipo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__FECompConsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__FECompConsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns3__FECompConsResponse * SOAP_FMAC4 soap_in_ns3__FECompConsResponse(struct soap *soap, const char *tag, ns3__FECompConsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__FECompConsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__FECompConsResponse, sizeof(ns3__FECompConsResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__FECompConsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__FECompConsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Concepto3 = 1;
	size_t soap_flag_DocTipo3 = 1;
	size_t soap_flag_DocNro3 = 1;
	size_t soap_flag_CbteDesde3 = 1;
	size_t soap_flag_CbteHasta3 = 1;
	size_t soap_flag_CbteFch3 = 1;
	size_t soap_flag_ImpTotal3 = 1;
	size_t soap_flag_ImpTotConc3 = 1;
	size_t soap_flag_ImpNeto3 = 1;
	size_t soap_flag_ImpOpEx3 = 1;
	size_t soap_flag_ImpTrib3 = 1;
	size_t soap_flag_ImpIVA3 = 1;
	size_t soap_flag_FchServDesde3 = 1;
	size_t soap_flag_FchServHasta3 = 1;
	size_t soap_flag_FchVtoPago3 = 1;
	size_t soap_flag_MonId3 = 1;
	size_t soap_flag_MonCotiz3 = 1;
	size_t soap_flag_CbtesAsoc3 = 1;
	size_t soap_flag_Tributos3 = 1;
	size_t soap_flag_Iva3 = 1;
	size_t soap_flag_Opcionales3 = 1;
	size_t soap_flag_Compradores3 = 1;
	size_t soap_flag_Resultado1 = 1;
	size_t soap_flag_CodAutorizacion1 = 1;
	size_t soap_flag_EmisionTipo1 = 1;
	size_t soap_flag_FchVto1 = 1;
	size_t soap_flag_FchProceso1 = 1;
	size_t soap_flag_Observaciones1 = 1;
	size_t soap_flag_PtoVta1 = 1;
	size_t soap_flag_CbteTipo1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Concepto3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:Concepto", &a->ns3__FEDetRequest::Concepto, "xsd:int"))
				{	soap_flag_Concepto3--;
					continue;
				}
			}
			if (soap_flag_DocTipo3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:DocTipo", &a->ns3__FEDetRequest::DocTipo, "xsd:int"))
				{	soap_flag_DocTipo3--;
					continue;
				}
			}
			if (soap_flag_DocNro3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "ns3:DocNro", &a->ns3__FEDetRequest::DocNro, "xsd:long"))
				{	soap_flag_DocNro3--;
					continue;
				}
			}
			if (soap_flag_CbteDesde3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "ns3:CbteDesde", &a->ns3__FEDetRequest::CbteDesde, "xsd:long"))
				{	soap_flag_CbteDesde3--;
					continue;
				}
			}
			if (soap_flag_CbteHasta3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "ns3:CbteHasta", &a->ns3__FEDetRequest::CbteHasta, "xsd:long"))
				{	soap_flag_CbteHasta3--;
					continue;
				}
			}
			if (soap_flag_CbteFch3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:CbteFch", &a->ns3__FEDetRequest::CbteFch, "xsd:string"))
				{	soap_flag_CbteFch3--;
					continue;
				}
			}
			if (soap_flag_ImpTotal3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:ImpTotal", &a->ns3__FEDetRequest::ImpTotal, "xsd:double"))
				{	soap_flag_ImpTotal3--;
					continue;
				}
			}
			if (soap_flag_ImpTotConc3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:ImpTotConc", &a->ns3__FEDetRequest::ImpTotConc, "xsd:double"))
				{	soap_flag_ImpTotConc3--;
					continue;
				}
			}
			if (soap_flag_ImpNeto3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:ImpNeto", &a->ns3__FEDetRequest::ImpNeto, "xsd:double"))
				{	soap_flag_ImpNeto3--;
					continue;
				}
			}
			if (soap_flag_ImpOpEx3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:ImpOpEx", &a->ns3__FEDetRequest::ImpOpEx, "xsd:double"))
				{	soap_flag_ImpOpEx3--;
					continue;
				}
			}
			if (soap_flag_ImpTrib3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:ImpTrib", &a->ns3__FEDetRequest::ImpTrib, "xsd:double"))
				{	soap_flag_ImpTrib3--;
					continue;
				}
			}
			if (soap_flag_ImpIVA3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:ImpIVA", &a->ns3__FEDetRequest::ImpIVA, "xsd:double"))
				{	soap_flag_ImpIVA3--;
					continue;
				}
			}
			if (soap_flag_FchServDesde3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchServDesde", &a->ns3__FEDetRequest::FchServDesde, "xsd:string"))
				{	soap_flag_FchServDesde3--;
					continue;
				}
			}
			if (soap_flag_FchServHasta3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchServHasta", &a->ns3__FEDetRequest::FchServHasta, "xsd:string"))
				{	soap_flag_FchServHasta3--;
					continue;
				}
			}
			if (soap_flag_FchVtoPago3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchVtoPago", &a->ns3__FEDetRequest::FchVtoPago, "xsd:string"))
				{	soap_flag_FchVtoPago3--;
					continue;
				}
			}
			if (soap_flag_MonId3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:MonId", &a->ns3__FEDetRequest::MonId, "xsd:string"))
				{	soap_flag_MonId3--;
					continue;
				}
			}
			if (soap_flag_MonCotiz3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:MonCotiz", &a->ns3__FEDetRequest::MonCotiz, "xsd:double"))
				{	soap_flag_MonCotiz3--;
					continue;
				}
			}
			if (soap_flag_CbtesAsoc3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfCbteAsoc(soap, "ns3:CbtesAsoc", &a->ns3__FEDetRequest::CbtesAsoc, "ns3:ArrayOfCbteAsoc"))
				{	soap_flag_CbtesAsoc3--;
					continue;
				}
			}
			if (soap_flag_Tributos3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfTributo(soap, "ns3:Tributos", &a->ns3__FEDetRequest::Tributos, "ns3:ArrayOfTributo"))
				{	soap_flag_Tributos3--;
					continue;
				}
			}
			if (soap_flag_Iva3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfAlicIva(soap, "ns3:Iva", &a->ns3__FEDetRequest::Iva, "ns3:ArrayOfAlicIva"))
				{	soap_flag_Iva3--;
					continue;
				}
			}
			if (soap_flag_Opcionales3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfOpcional(soap, "ns3:Opcionales", &a->ns3__FEDetRequest::Opcionales, "ns3:ArrayOfOpcional"))
				{	soap_flag_Opcionales3--;
					continue;
				}
			}
			if (soap_flag_Compradores3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfComprador(soap, "ns3:Compradores", &a->ns3__FEDetRequest::Compradores, "ns3:ArrayOfComprador"))
				{	soap_flag_Compradores3--;
					continue;
				}
			}
			if (soap_flag_Resultado1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Resultado", &a->ns3__FECompConsResponse::Resultado, "xsd:string"))
				{	soap_flag_Resultado1--;
					continue;
				}
			}
			if (soap_flag_CodAutorizacion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:CodAutorizacion", &a->ns3__FECompConsResponse::CodAutorizacion, "xsd:string"))
				{	soap_flag_CodAutorizacion1--;
					continue;
				}
			}
			if (soap_flag_EmisionTipo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:EmisionTipo", &a->ns3__FECompConsResponse::EmisionTipo, "xsd:string"))
				{	soap_flag_EmisionTipo1--;
					continue;
				}
			}
			if (soap_flag_FchVto1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchVto", &a->ns3__FECompConsResponse::FchVto, "xsd:string"))
				{	soap_flag_FchVto1--;
					continue;
				}
			}
			if (soap_flag_FchProceso1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchProceso", &a->ns3__FECompConsResponse::FchProceso, "xsd:string"))
				{	soap_flag_FchProceso1--;
					continue;
				}
			}
			if (soap_flag_Observaciones1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfObs(soap, "ns3:Observaciones", &a->ns3__FECompConsResponse::Observaciones, "ns3:ArrayOfObs"))
				{	soap_flag_Observaciones1--;
					continue;
				}
			}
			if (soap_flag_PtoVta1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:PtoVta", &a->ns3__FECompConsResponse::PtoVta, "xsd:int"))
				{	soap_flag_PtoVta1--;
					continue;
				}
			}
			if (soap_flag_CbteTipo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:CbteTipo", &a->ns3__FECompConsResponse::CbteTipo, "xsd:int"))
				{	soap_flag_CbteTipo1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Concepto3 > 0 || soap_flag_DocTipo3 > 0 || soap_flag_DocNro3 > 0 || soap_flag_CbteDesde3 > 0 || soap_flag_CbteHasta3 > 0 || soap_flag_ImpTotal3 > 0 || soap_flag_ImpTotConc3 > 0 || soap_flag_ImpNeto3 > 0 || soap_flag_ImpOpEx3 > 0 || soap_flag_ImpTrib3 > 0 || soap_flag_ImpIVA3 > 0 || soap_flag_MonCotiz3 > 0 || soap_flag_PtoVta1 > 0 || soap_flag_CbteTipo1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__FECompConsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__FECompConsResponse, SOAP_TYPE_afip_ns3__FECompConsResponse, sizeof(ns3__FECompConsResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__FECompConsResponse * SOAP_FMAC2 soap_instantiate_ns3__FECompConsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__FECompConsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__FECompConsResponse *p;
	size_t k = sizeof(ns3__FECompConsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FECompConsResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__FECompConsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__FECompConsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__FECompConsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__FECompConsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__FECompConsResponse(soap, tag ? tag : "ns3:FECompConsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__FECompConsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__FECompConsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns3__FECompConsResponse * SOAP_FMAC4 soap_get_ns3__FECompConsResponse(struct soap *soap, ns3__FECompConsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__FECompConsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__FECompConsultaResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__FECompConsultaResponse::ResultGet = NULL;
	this->ns3__FECompConsultaResponse::Errors = NULL;
	this->ns3__FECompConsultaResponse::Events = NULL;
}

void ns3__FECompConsultaResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FECompConsResponse(soap, &this->ns3__FECompConsultaResponse::ResultGet);
	soap_serialize_PointerTons3__ArrayOfErr(soap, &this->ns3__FECompConsultaResponse::Errors);
	soap_serialize_PointerTons3__ArrayOfEvt(soap, &this->ns3__FECompConsultaResponse::Events);
#endif
}

int ns3__FECompConsultaResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__FECompConsultaResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FECompConsultaResponse(struct soap *soap, const char *tag, int id, const ns3__FECompConsultaResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__FECompConsultaResponse), type))
		return soap->error;
	if (soap_out_PointerTons3__FECompConsResponse(soap, "ns3:ResultGet", -1, &a->ns3__FECompConsultaResponse::ResultGet, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfErr(soap, "ns3:Errors", -1, &a->ns3__FECompConsultaResponse::Errors, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfEvt(soap, "ns3:Events", -1, &a->ns3__FECompConsultaResponse::Events, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__FECompConsultaResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__FECompConsultaResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns3__FECompConsultaResponse * SOAP_FMAC4 soap_in_ns3__FECompConsultaResponse(struct soap *soap, const char *tag, ns3__FECompConsultaResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__FECompConsultaResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__FECompConsultaResponse, sizeof(ns3__FECompConsultaResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__FECompConsultaResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__FECompConsultaResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResultGet1 = 1;
	size_t soap_flag_Errors1 = 1;
	size_t soap_flag_Events1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultGet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FECompConsResponse(soap, "ns3:ResultGet", &a->ns3__FECompConsultaResponse::ResultGet, "ns3:FECompConsResponse"))
				{	soap_flag_ResultGet1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfErr(soap, "ns3:Errors", &a->ns3__FECompConsultaResponse::Errors, "ns3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfEvt(soap, "ns3:Events", &a->ns3__FECompConsultaResponse::Events, "ns3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__FECompConsultaResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__FECompConsultaResponse, SOAP_TYPE_afip_ns3__FECompConsultaResponse, sizeof(ns3__FECompConsultaResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__FECompConsultaResponse * SOAP_FMAC2 soap_instantiate_ns3__FECompConsultaResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__FECompConsultaResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__FECompConsultaResponse *p;
	size_t k = sizeof(ns3__FECompConsultaResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FECompConsultaResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__FECompConsultaResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__FECompConsultaResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__FECompConsultaResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__FECompConsultaResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__FECompConsultaResponse(soap, tag ? tag : "ns3:FECompConsultaResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__FECompConsultaResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__FECompConsultaResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns3__FECompConsultaResponse * SOAP_FMAC4 soap_get_ns3__FECompConsultaResponse(struct soap *soap, ns3__FECompConsultaResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__FECompConsultaResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__FECompConsultaReq::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns3__FECompConsultaReq::CbteTipo);
	soap_default_LONG64(soap, &this->ns3__FECompConsultaReq::CbteNro);
	soap_default_int(soap, &this->ns3__FECompConsultaReq::PtoVta);
}

void ns3__FECompConsultaReq::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns3__FECompConsultaReq::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__FECompConsultaReq(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FECompConsultaReq(struct soap *soap, const char *tag, int id, const ns3__FECompConsultaReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__FECompConsultaReq), type))
		return soap->error;
	if (soap_out_int(soap, "ns3:CbteTipo", -1, &a->ns3__FECompConsultaReq::CbteTipo, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns3:CbteNro", -1, &a->ns3__FECompConsultaReq::CbteNro, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:PtoVta", -1, &a->ns3__FECompConsultaReq::PtoVta, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__FECompConsultaReq::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__FECompConsultaReq(soap, tag, this, type);
}

SOAP_FMAC3 ns3__FECompConsultaReq * SOAP_FMAC4 soap_in_ns3__FECompConsultaReq(struct soap *soap, const char *tag, ns3__FECompConsultaReq *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__FECompConsultaReq*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__FECompConsultaReq, sizeof(ns3__FECompConsultaReq), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__FECompConsultaReq)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__FECompConsultaReq *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CbteTipo1 = 1;
	size_t soap_flag_CbteNro1 = 1;
	size_t soap_flag_PtoVta1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CbteTipo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:CbteTipo", &a->ns3__FECompConsultaReq::CbteTipo, "xsd:int"))
				{	soap_flag_CbteTipo1--;
					continue;
				}
			}
			if (soap_flag_CbteNro1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "ns3:CbteNro", &a->ns3__FECompConsultaReq::CbteNro, "xsd:long"))
				{	soap_flag_CbteNro1--;
					continue;
				}
			}
			if (soap_flag_PtoVta1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:PtoVta", &a->ns3__FECompConsultaReq::PtoVta, "xsd:int"))
				{	soap_flag_PtoVta1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CbteTipo1 > 0 || soap_flag_CbteNro1 > 0 || soap_flag_PtoVta1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__FECompConsultaReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__FECompConsultaReq, SOAP_TYPE_afip_ns3__FECompConsultaReq, sizeof(ns3__FECompConsultaReq), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__FECompConsultaReq * SOAP_FMAC2 soap_instantiate_ns3__FECompConsultaReq(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__FECompConsultaReq(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__FECompConsultaReq *p;
	size_t k = sizeof(ns3__FECompConsultaReq);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FECompConsultaReq, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__FECompConsultaReq);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__FECompConsultaReq, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__FECompConsultaReq location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__FECompConsultaReq::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__FECompConsultaReq(soap, tag ? tag : "ns3:FECompConsultaReq", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__FECompConsultaReq::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__FECompConsultaReq(soap, this, tag, type);
}

SOAP_FMAC3 ns3__FECompConsultaReq * SOAP_FMAC4 soap_get_ns3__FECompConsultaReq(struct soap *soap, ns3__FECompConsultaReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__FECompConsultaReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__FERecuperaLastCbteResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns3__FERecuperaLastCbteResponse::PtoVta);
	soap_default_int(soap, &this->ns3__FERecuperaLastCbteResponse::CbteTipo);
	soap_default_int(soap, &this->ns3__FERecuperaLastCbteResponse::CbteNro);
	this->ns3__FERecuperaLastCbteResponse::Errors = NULL;
	this->ns3__FERecuperaLastCbteResponse::Events = NULL;
}

void ns3__FERecuperaLastCbteResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__ArrayOfErr(soap, &this->ns3__FERecuperaLastCbteResponse::Errors);
	soap_serialize_PointerTons3__ArrayOfEvt(soap, &this->ns3__FERecuperaLastCbteResponse::Events);
#endif
}

int ns3__FERecuperaLastCbteResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__FERecuperaLastCbteResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FERecuperaLastCbteResponse(struct soap *soap, const char *tag, int id, const ns3__FERecuperaLastCbteResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__FERecuperaLastCbteResponse), type))
		return soap->error;
	if (soap_out_int(soap, "ns3:PtoVta", -1, &a->ns3__FERecuperaLastCbteResponse::PtoVta, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:CbteTipo", -1, &a->ns3__FERecuperaLastCbteResponse::CbteTipo, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:CbteNro", -1, &a->ns3__FERecuperaLastCbteResponse::CbteNro, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfErr(soap, "ns3:Errors", -1, &a->ns3__FERecuperaLastCbteResponse::Errors, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfEvt(soap, "ns3:Events", -1, &a->ns3__FERecuperaLastCbteResponse::Events, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__FERecuperaLastCbteResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__FERecuperaLastCbteResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns3__FERecuperaLastCbteResponse * SOAP_FMAC4 soap_in_ns3__FERecuperaLastCbteResponse(struct soap *soap, const char *tag, ns3__FERecuperaLastCbteResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__FERecuperaLastCbteResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__FERecuperaLastCbteResponse, sizeof(ns3__FERecuperaLastCbteResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__FERecuperaLastCbteResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__FERecuperaLastCbteResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PtoVta1 = 1;
	size_t soap_flag_CbteTipo1 = 1;
	size_t soap_flag_CbteNro1 = 1;
	size_t soap_flag_Errors1 = 1;
	size_t soap_flag_Events1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PtoVta1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:PtoVta", &a->ns3__FERecuperaLastCbteResponse::PtoVta, "xsd:int"))
				{	soap_flag_PtoVta1--;
					continue;
				}
			}
			if (soap_flag_CbteTipo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:CbteTipo", &a->ns3__FERecuperaLastCbteResponse::CbteTipo, "xsd:int"))
				{	soap_flag_CbteTipo1--;
					continue;
				}
			}
			if (soap_flag_CbteNro1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:CbteNro", &a->ns3__FERecuperaLastCbteResponse::CbteNro, "xsd:int"))
				{	soap_flag_CbteNro1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfErr(soap, "ns3:Errors", &a->ns3__FERecuperaLastCbteResponse::Errors, "ns3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfEvt(soap, "ns3:Events", &a->ns3__FERecuperaLastCbteResponse::Events, "ns3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PtoVta1 > 0 || soap_flag_CbteTipo1 > 0 || soap_flag_CbteNro1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__FERecuperaLastCbteResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__FERecuperaLastCbteResponse, SOAP_TYPE_afip_ns3__FERecuperaLastCbteResponse, sizeof(ns3__FERecuperaLastCbteResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__FERecuperaLastCbteResponse * SOAP_FMAC2 soap_instantiate_ns3__FERecuperaLastCbteResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__FERecuperaLastCbteResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__FERecuperaLastCbteResponse *p;
	size_t k = sizeof(ns3__FERecuperaLastCbteResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FERecuperaLastCbteResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__FERecuperaLastCbteResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__FERecuperaLastCbteResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__FERecuperaLastCbteResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__FERecuperaLastCbteResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__FERecuperaLastCbteResponse(soap, tag ? tag : "ns3:FERecuperaLastCbteResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__FERecuperaLastCbteResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__FERecuperaLastCbteResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns3__FERecuperaLastCbteResponse * SOAP_FMAC4 soap_get_ns3__FERecuperaLastCbteResponse(struct soap *soap, ns3__FERecuperaLastCbteResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__FERecuperaLastCbteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__DummyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__DummyResponse::AppServer = NULL;
	this->ns3__DummyResponse::DbServer = NULL;
	this->ns3__DummyResponse::AuthServer = NULL;
}

void ns3__DummyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns3__DummyResponse::AppServer);
	soap_serialize_PointerTostd__string(soap, &this->ns3__DummyResponse::DbServer);
	soap_serialize_PointerTostd__string(soap, &this->ns3__DummyResponse::AuthServer);
#endif
}

int ns3__DummyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__DummyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__DummyResponse(struct soap *soap, const char *tag, int id, const ns3__DummyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__DummyResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:AppServer", -1, &a->ns3__DummyResponse::AppServer, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:DbServer", -1, &a->ns3__DummyResponse::DbServer, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:AuthServer", -1, &a->ns3__DummyResponse::AuthServer, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__DummyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__DummyResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns3__DummyResponse * SOAP_FMAC4 soap_in_ns3__DummyResponse(struct soap *soap, const char *tag, ns3__DummyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__DummyResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__DummyResponse, sizeof(ns3__DummyResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__DummyResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__DummyResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AppServer1 = 1;
	size_t soap_flag_DbServer1 = 1;
	size_t soap_flag_AuthServer1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AppServer1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:AppServer", &a->ns3__DummyResponse::AppServer, "xsd:string"))
				{	soap_flag_AppServer1--;
					continue;
				}
			}
			if (soap_flag_DbServer1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:DbServer", &a->ns3__DummyResponse::DbServer, "xsd:string"))
				{	soap_flag_DbServer1--;
					continue;
				}
			}
			if (soap_flag_AuthServer1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:AuthServer", &a->ns3__DummyResponse::AuthServer, "xsd:string"))
				{	soap_flag_AuthServer1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__DummyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__DummyResponse, SOAP_TYPE_afip_ns3__DummyResponse, sizeof(ns3__DummyResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__DummyResponse * SOAP_FMAC2 soap_instantiate_ns3__DummyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__DummyResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__DummyResponse *p;
	size_t k = sizeof(ns3__DummyResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__DummyResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__DummyResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__DummyResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__DummyResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__DummyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__DummyResponse(soap, tag ? tag : "ns3:DummyResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__DummyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__DummyResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns3__DummyResponse * SOAP_FMAC4 soap_get_ns3__DummyResponse(struct soap *soap, ns3__DummyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__DummyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__FERegXReqResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns3__FERegXReqResponse::RegXReq);
	this->ns3__FERegXReqResponse::Errors = NULL;
	this->ns3__FERegXReqResponse::Events = NULL;
}

void ns3__FERegXReqResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__ArrayOfErr(soap, &this->ns3__FERegXReqResponse::Errors);
	soap_serialize_PointerTons3__ArrayOfEvt(soap, &this->ns3__FERegXReqResponse::Events);
#endif
}

int ns3__FERegXReqResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__FERegXReqResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FERegXReqResponse(struct soap *soap, const char *tag, int id, const ns3__FERegXReqResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__FERegXReqResponse), type))
		return soap->error;
	if (soap_out_int(soap, "ns3:RegXReq", -1, &a->ns3__FERegXReqResponse::RegXReq, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfErr(soap, "ns3:Errors", -1, &a->ns3__FERegXReqResponse::Errors, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfEvt(soap, "ns3:Events", -1, &a->ns3__FERegXReqResponse::Events, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__FERegXReqResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__FERegXReqResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns3__FERegXReqResponse * SOAP_FMAC4 soap_in_ns3__FERegXReqResponse(struct soap *soap, const char *tag, ns3__FERegXReqResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__FERegXReqResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__FERegXReqResponse, sizeof(ns3__FERegXReqResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__FERegXReqResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__FERegXReqResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RegXReq1 = 1;
	size_t soap_flag_Errors1 = 1;
	size_t soap_flag_Events1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RegXReq1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:RegXReq", &a->ns3__FERegXReqResponse::RegXReq, "xsd:int"))
				{	soap_flag_RegXReq1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfErr(soap, "ns3:Errors", &a->ns3__FERegXReqResponse::Errors, "ns3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfEvt(soap, "ns3:Events", &a->ns3__FERegXReqResponse::Events, "ns3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RegXReq1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__FERegXReqResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__FERegXReqResponse, SOAP_TYPE_afip_ns3__FERegXReqResponse, sizeof(ns3__FERegXReqResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__FERegXReqResponse * SOAP_FMAC2 soap_instantiate_ns3__FERegXReqResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__FERegXReqResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__FERegXReqResponse *p;
	size_t k = sizeof(ns3__FERegXReqResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FERegXReqResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__FERegXReqResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__FERegXReqResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__FERegXReqResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__FERegXReqResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__FERegXReqResponse(soap, tag ? tag : "ns3:FERegXReqResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__FERegXReqResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__FERegXReqResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns3__FERegXReqResponse * SOAP_FMAC4 soap_get_ns3__FERegXReqResponse(struct soap *soap, ns3__FERegXReqResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__FERegXReqResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__Err::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns3__Err::Code);
	this->ns3__Err::Msg = NULL;
}

void ns3__Err::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns3__Err::Msg);
#endif
}

int ns3__Err::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__Err(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__Err(struct soap *soap, const char *tag, int id, const ns3__Err *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__Err), type))
		return soap->error;
	if (soap_out_int(soap, "ns3:Code", -1, &a->ns3__Err::Code, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Msg", -1, &a->ns3__Err::Msg, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__Err::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__Err(soap, tag, this, type);
}

SOAP_FMAC3 ns3__Err * SOAP_FMAC4 soap_in_ns3__Err(struct soap *soap, const char *tag, ns3__Err *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__Err*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__Err, sizeof(ns3__Err), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__Err)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__Err *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Code1 = 1;
	size_t soap_flag_Msg1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Code1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:Code", &a->ns3__Err::Code, "xsd:int"))
				{	soap_flag_Code1--;
					continue;
				}
			}
			if (soap_flag_Msg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Msg", &a->ns3__Err::Msg, "xsd:string"))
				{	soap_flag_Msg1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Code1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__Err *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__Err, SOAP_TYPE_afip_ns3__Err, sizeof(ns3__Err), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__Err * SOAP_FMAC2 soap_instantiate_ns3__Err(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__Err(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__Err *p;
	size_t k = sizeof(ns3__Err);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__Err, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__Err);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__Err, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__Err location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__Err::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__Err(soap, tag ? tag : "ns3:Err", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__Err::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__Err(soap, this, tag, type);
}

SOAP_FMAC3 ns3__Err * SOAP_FMAC4 soap_get_ns3__Err(struct soap *soap, ns3__Err *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__Err(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__ArrayOfErr::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__Err(soap, &this->ns3__ArrayOfErr::Err);
}

void ns3__ArrayOfErr::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons3__Err(soap, &this->ns3__ArrayOfErr::Err);
#endif
}

int ns3__ArrayOfErr::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfErr(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfErr(struct soap *soap, const char *tag, int id, const ns3__ArrayOfErr *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__ArrayOfErr), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__Err(soap, "ns3:Err", -1, &a->ns3__ArrayOfErr::Err, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfErr::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__ArrayOfErr(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfErr * SOAP_FMAC4 soap_in_ns3__ArrayOfErr(struct soap *soap, const char *tag, ns3__ArrayOfErr *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfErr*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__ArrayOfErr, sizeof(ns3__ArrayOfErr), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__ArrayOfErr)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__ArrayOfErr *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__Err(soap, "ns3:Err", &a->ns3__ArrayOfErr::Err, "ns3:Err"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfErr *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__ArrayOfErr, SOAP_TYPE_afip_ns3__ArrayOfErr, sizeof(ns3__ArrayOfErr), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__ArrayOfErr * SOAP_FMAC2 soap_instantiate_ns3__ArrayOfErr(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfErr(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__ArrayOfErr *p;
	size_t k = sizeof(ns3__ArrayOfErr);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__ArrayOfErr, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__ArrayOfErr);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__ArrayOfErr, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__ArrayOfErr location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__ArrayOfErr::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__ArrayOfErr(soap, tag ? tag : "ns3:ArrayOfErr", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ArrayOfErr::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfErr(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfErr * SOAP_FMAC4 soap_get_ns3__ArrayOfErr(struct soap *soap, ns3__ArrayOfErr *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfErr(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__Evt::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns3__Evt::Code);
	this->ns3__Evt::Msg = NULL;
}

void ns3__Evt::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns3__Evt::Msg);
#endif
}

int ns3__Evt::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__Evt(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__Evt(struct soap *soap, const char *tag, int id, const ns3__Evt *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__Evt), type))
		return soap->error;
	if (soap_out_int(soap, "ns3:Code", -1, &a->ns3__Evt::Code, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Msg", -1, &a->ns3__Evt::Msg, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__Evt::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__Evt(soap, tag, this, type);
}

SOAP_FMAC3 ns3__Evt * SOAP_FMAC4 soap_in_ns3__Evt(struct soap *soap, const char *tag, ns3__Evt *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__Evt*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__Evt, sizeof(ns3__Evt), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__Evt)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__Evt *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Code1 = 1;
	size_t soap_flag_Msg1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Code1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:Code", &a->ns3__Evt::Code, "xsd:int"))
				{	soap_flag_Code1--;
					continue;
				}
			}
			if (soap_flag_Msg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Msg", &a->ns3__Evt::Msg, "xsd:string"))
				{	soap_flag_Msg1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Code1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__Evt *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__Evt, SOAP_TYPE_afip_ns3__Evt, sizeof(ns3__Evt), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__Evt * SOAP_FMAC2 soap_instantiate_ns3__Evt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__Evt(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__Evt *p;
	size_t k = sizeof(ns3__Evt);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__Evt, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__Evt);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__Evt, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__Evt location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__Evt::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__Evt(soap, tag ? tag : "ns3:Evt", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__Evt::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__Evt(soap, this, tag, type);
}

SOAP_FMAC3 ns3__Evt * SOAP_FMAC4 soap_get_ns3__Evt(struct soap *soap, ns3__Evt *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__Evt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__ArrayOfEvt::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__Evt(soap, &this->ns3__ArrayOfEvt::Evt);
}

void ns3__ArrayOfEvt::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons3__Evt(soap, &this->ns3__ArrayOfEvt::Evt);
#endif
}

int ns3__ArrayOfEvt::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfEvt(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfEvt(struct soap *soap, const char *tag, int id, const ns3__ArrayOfEvt *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__ArrayOfEvt), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__Evt(soap, "ns3:Evt", -1, &a->ns3__ArrayOfEvt::Evt, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfEvt::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__ArrayOfEvt(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfEvt * SOAP_FMAC4 soap_in_ns3__ArrayOfEvt(struct soap *soap, const char *tag, ns3__ArrayOfEvt *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfEvt*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__ArrayOfEvt, sizeof(ns3__ArrayOfEvt), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__ArrayOfEvt)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__ArrayOfEvt *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__Evt(soap, "ns3:Evt", &a->ns3__ArrayOfEvt::Evt, "ns3:Evt"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfEvt *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__ArrayOfEvt, SOAP_TYPE_afip_ns3__ArrayOfEvt, sizeof(ns3__ArrayOfEvt), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__ArrayOfEvt * SOAP_FMAC2 soap_instantiate_ns3__ArrayOfEvt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfEvt(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__ArrayOfEvt *p;
	size_t k = sizeof(ns3__ArrayOfEvt);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__ArrayOfEvt, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__ArrayOfEvt);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__ArrayOfEvt, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__ArrayOfEvt location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__ArrayOfEvt::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__ArrayOfEvt(soap, tag ? tag : "ns3:ArrayOfEvt", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ArrayOfEvt::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfEvt(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfEvt * SOAP_FMAC4 soap_get_ns3__ArrayOfEvt(struct soap *soap, ns3__ArrayOfEvt *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfEvt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__Obs::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns3__Obs::Code);
	this->ns3__Obs::Msg = NULL;
}

void ns3__Obs::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns3__Obs::Msg);
#endif
}

int ns3__Obs::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__Obs(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__Obs(struct soap *soap, const char *tag, int id, const ns3__Obs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__Obs), type))
		return soap->error;
	if (soap_out_int(soap, "ns3:Code", -1, &a->ns3__Obs::Code, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Msg", -1, &a->ns3__Obs::Msg, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__Obs::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__Obs(soap, tag, this, type);
}

SOAP_FMAC3 ns3__Obs * SOAP_FMAC4 soap_in_ns3__Obs(struct soap *soap, const char *tag, ns3__Obs *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__Obs*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__Obs, sizeof(ns3__Obs), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__Obs)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__Obs *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Code1 = 1;
	size_t soap_flag_Msg1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Code1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:Code", &a->ns3__Obs::Code, "xsd:int"))
				{	soap_flag_Code1--;
					continue;
				}
			}
			if (soap_flag_Msg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Msg", &a->ns3__Obs::Msg, "xsd:string"))
				{	soap_flag_Msg1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Code1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__Obs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__Obs, SOAP_TYPE_afip_ns3__Obs, sizeof(ns3__Obs), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__Obs * SOAP_FMAC2 soap_instantiate_ns3__Obs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__Obs(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__Obs *p;
	size_t k = sizeof(ns3__Obs);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__Obs, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__Obs);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__Obs, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__Obs location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__Obs::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__Obs(soap, tag ? tag : "ns3:Obs", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__Obs::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__Obs(soap, this, tag, type);
}

SOAP_FMAC3 ns3__Obs * SOAP_FMAC4 soap_get_ns3__Obs(struct soap *soap, ns3__Obs *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__Obs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__ArrayOfObs::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__Obs(soap, &this->ns3__ArrayOfObs::Obs);
}

void ns3__ArrayOfObs::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons3__Obs(soap, &this->ns3__ArrayOfObs::Obs);
#endif
}

int ns3__ArrayOfObs::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfObs(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfObs(struct soap *soap, const char *tag, int id, const ns3__ArrayOfObs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__ArrayOfObs), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__Obs(soap, "ns3:Obs", -1, &a->ns3__ArrayOfObs::Obs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfObs::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__ArrayOfObs(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfObs * SOAP_FMAC4 soap_in_ns3__ArrayOfObs(struct soap *soap, const char *tag, ns3__ArrayOfObs *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfObs*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__ArrayOfObs, sizeof(ns3__ArrayOfObs), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__ArrayOfObs)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__ArrayOfObs *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__Obs(soap, "ns3:Obs", &a->ns3__ArrayOfObs::Obs, "ns3:Obs"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfObs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__ArrayOfObs, SOAP_TYPE_afip_ns3__ArrayOfObs, sizeof(ns3__ArrayOfObs), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__ArrayOfObs * SOAP_FMAC2 soap_instantiate_ns3__ArrayOfObs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfObs(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__ArrayOfObs *p;
	size_t k = sizeof(ns3__ArrayOfObs);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__ArrayOfObs, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__ArrayOfObs);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__ArrayOfObs, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__ArrayOfObs location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__ArrayOfObs::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__ArrayOfObs(soap, tag ? tag : "ns3:ArrayOfObs", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ArrayOfObs::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfObs(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfObs * SOAP_FMAC4 soap_get_ns3__ArrayOfObs(struct soap *soap, ns3__ArrayOfObs *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfObs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__FEDetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns3__FEDetResponse::Concepto);
	soap_default_int(soap, &this->ns3__FEDetResponse::DocTipo);
	soap_default_LONG64(soap, &this->ns3__FEDetResponse::DocNro);
	soap_default_LONG64(soap, &this->ns3__FEDetResponse::CbteDesde);
	soap_default_LONG64(soap, &this->ns3__FEDetResponse::CbteHasta);
	this->ns3__FEDetResponse::CbteFch = NULL;
	this->ns3__FEDetResponse::Resultado = NULL;
	this->ns3__FEDetResponse::Observaciones = NULL;
}

void ns3__FEDetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns3__FEDetResponse::CbteFch);
	soap_serialize_PointerTostd__string(soap, &this->ns3__FEDetResponse::Resultado);
	soap_serialize_PointerTons3__ArrayOfObs(soap, &this->ns3__FEDetResponse::Observaciones);
#endif
}

int ns3__FEDetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__FEDetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FEDetResponse(struct soap *soap, const char *tag, int id, const ns3__FEDetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__FEDetResponse), type))
		return soap->error;
	if (soap_out_int(soap, "ns3:Concepto", -1, &a->ns3__FEDetResponse::Concepto, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:DocTipo", -1, &a->ns3__FEDetResponse::DocTipo, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns3:DocNro", -1, &a->ns3__FEDetResponse::DocNro, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns3:CbteDesde", -1, &a->ns3__FEDetResponse::CbteDesde, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns3:CbteHasta", -1, &a->ns3__FEDetResponse::CbteHasta, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:CbteFch", -1, &a->ns3__FEDetResponse::CbteFch, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Resultado", -1, &a->ns3__FEDetResponse::Resultado, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfObs(soap, "ns3:Observaciones", -1, &a->ns3__FEDetResponse::Observaciones, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__FEDetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__FEDetResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns3__FEDetResponse * SOAP_FMAC4 soap_in_ns3__FEDetResponse(struct soap *soap, const char *tag, ns3__FEDetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__FEDetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__FEDetResponse, sizeof(ns3__FEDetResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__FEDetResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__FEDetResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Concepto1 = 1;
	size_t soap_flag_DocTipo1 = 1;
	size_t soap_flag_DocNro1 = 1;
	size_t soap_flag_CbteDesde1 = 1;
	size_t soap_flag_CbteHasta1 = 1;
	size_t soap_flag_CbteFch1 = 1;
	size_t soap_flag_Resultado1 = 1;
	size_t soap_flag_Observaciones1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Concepto1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:Concepto", &a->ns3__FEDetResponse::Concepto, "xsd:int"))
				{	soap_flag_Concepto1--;
					continue;
				}
			}
			if (soap_flag_DocTipo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:DocTipo", &a->ns3__FEDetResponse::DocTipo, "xsd:int"))
				{	soap_flag_DocTipo1--;
					continue;
				}
			}
			if (soap_flag_DocNro1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "ns3:DocNro", &a->ns3__FEDetResponse::DocNro, "xsd:long"))
				{	soap_flag_DocNro1--;
					continue;
				}
			}
			if (soap_flag_CbteDesde1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "ns3:CbteDesde", &a->ns3__FEDetResponse::CbteDesde, "xsd:long"))
				{	soap_flag_CbteDesde1--;
					continue;
				}
			}
			if (soap_flag_CbteHasta1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "ns3:CbteHasta", &a->ns3__FEDetResponse::CbteHasta, "xsd:long"))
				{	soap_flag_CbteHasta1--;
					continue;
				}
			}
			if (soap_flag_CbteFch1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:CbteFch", &a->ns3__FEDetResponse::CbteFch, "xsd:string"))
				{	soap_flag_CbteFch1--;
					continue;
				}
			}
			if (soap_flag_Resultado1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Resultado", &a->ns3__FEDetResponse::Resultado, "xsd:string"))
				{	soap_flag_Resultado1--;
					continue;
				}
			}
			if (soap_flag_Observaciones1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfObs(soap, "ns3:Observaciones", &a->ns3__FEDetResponse::Observaciones, "ns3:ArrayOfObs"))
				{	soap_flag_Observaciones1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Concepto1 > 0 || soap_flag_DocTipo1 > 0 || soap_flag_DocNro1 > 0 || soap_flag_CbteDesde1 > 0 || soap_flag_CbteHasta1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__FEDetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__FEDetResponse, SOAP_TYPE_afip_ns3__FEDetResponse, sizeof(ns3__FEDetResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__FEDetResponse * SOAP_FMAC2 soap_instantiate_ns3__FEDetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__FEDetResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "ns3:FECAEDetResponse"))
		return soap_instantiate_ns3__FECAEDetResponse(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns3:FECAEADetResponse"))
		return soap_instantiate_ns3__FECAEADetResponse(soap, n, NULL, NULL, size);
	ns3__FEDetResponse *p;
	size_t k = sizeof(ns3__FEDetResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FEDetResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__FEDetResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__FEDetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__FEDetResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__FEDetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__FEDetResponse(soap, tag ? tag : "ns3:FEDetResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__FEDetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__FEDetResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns3__FEDetResponse * SOAP_FMAC4 soap_get_ns3__FEDetResponse(struct soap *soap, ns3__FEDetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__FEDetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__FECAEDetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__FEDetResponse::soap_default(soap);
	this->ns3__FECAEDetResponse::CAE = NULL;
	this->ns3__FECAEDetResponse::CAEFchVto = NULL;
}

void ns3__FECAEDetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns3__FECAEDetResponse::CAE);
	soap_serialize_PointerTostd__string(soap, &this->ns3__FECAEDetResponse::CAEFchVto);
	this->ns3__FEDetResponse::soap_serialize(soap);
#endif
}

int ns3__FECAEDetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__FECAEDetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FECAEDetResponse(struct soap *soap, const char *tag, int id, const ns3__FECAEDetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__FECAEDetResponse), type ? type : "ns3:FECAEDetResponse"))
		return soap->error;
	if (soap_out_int(soap, "ns3:Concepto", -1, &a->ns3__FEDetResponse::Concepto, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:DocTipo", -1, &a->ns3__FEDetResponse::DocTipo, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns3:DocNro", -1, &a->ns3__FEDetResponse::DocNro, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns3:CbteDesde", -1, &a->ns3__FEDetResponse::CbteDesde, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns3:CbteHasta", -1, &a->ns3__FEDetResponse::CbteHasta, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:CbteFch", -1, &a->ns3__FEDetResponse::CbteFch, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Resultado", -1, &a->ns3__FEDetResponse::Resultado, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfObs(soap, "ns3:Observaciones", -1, &a->ns3__FEDetResponse::Observaciones, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:CAE", -1, &a->ns3__FECAEDetResponse::CAE, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:CAEFchVto", -1, &a->ns3__FECAEDetResponse::CAEFchVto, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__FECAEDetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__FECAEDetResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns3__FECAEDetResponse * SOAP_FMAC4 soap_in_ns3__FECAEDetResponse(struct soap *soap, const char *tag, ns3__FECAEDetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__FECAEDetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__FECAEDetResponse, sizeof(ns3__FECAEDetResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__FECAEDetResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__FECAEDetResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Concepto2 = 1;
	size_t soap_flag_DocTipo2 = 1;
	size_t soap_flag_DocNro2 = 1;
	size_t soap_flag_CbteDesde2 = 1;
	size_t soap_flag_CbteHasta2 = 1;
	size_t soap_flag_CbteFch2 = 1;
	size_t soap_flag_Resultado2 = 1;
	size_t soap_flag_Observaciones2 = 1;
	size_t soap_flag_CAE1 = 1;
	size_t soap_flag_CAEFchVto1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Concepto2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:Concepto", &a->ns3__FEDetResponse::Concepto, "xsd:int"))
				{	soap_flag_Concepto2--;
					continue;
				}
			}
			if (soap_flag_DocTipo2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:DocTipo", &a->ns3__FEDetResponse::DocTipo, "xsd:int"))
				{	soap_flag_DocTipo2--;
					continue;
				}
			}
			if (soap_flag_DocNro2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "ns3:DocNro", &a->ns3__FEDetResponse::DocNro, "xsd:long"))
				{	soap_flag_DocNro2--;
					continue;
				}
			}
			if (soap_flag_CbteDesde2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "ns3:CbteDesde", &a->ns3__FEDetResponse::CbteDesde, "xsd:long"))
				{	soap_flag_CbteDesde2--;
					continue;
				}
			}
			if (soap_flag_CbteHasta2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "ns3:CbteHasta", &a->ns3__FEDetResponse::CbteHasta, "xsd:long"))
				{	soap_flag_CbteHasta2--;
					continue;
				}
			}
			if (soap_flag_CbteFch2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:CbteFch", &a->ns3__FEDetResponse::CbteFch, "xsd:string"))
				{	soap_flag_CbteFch2--;
					continue;
				}
			}
			if (soap_flag_Resultado2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Resultado", &a->ns3__FEDetResponse::Resultado, "xsd:string"))
				{	soap_flag_Resultado2--;
					continue;
				}
			}
			if (soap_flag_Observaciones2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfObs(soap, "ns3:Observaciones", &a->ns3__FEDetResponse::Observaciones, "ns3:ArrayOfObs"))
				{	soap_flag_Observaciones2--;
					continue;
				}
			}
			if (soap_flag_CAE1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:CAE", &a->ns3__FECAEDetResponse::CAE, "xsd:string"))
				{	soap_flag_CAE1--;
					continue;
				}
			}
			if (soap_flag_CAEFchVto1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:CAEFchVto", &a->ns3__FECAEDetResponse::CAEFchVto, "xsd:string"))
				{	soap_flag_CAEFchVto1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Concepto2 > 0 || soap_flag_DocTipo2 > 0 || soap_flag_DocNro2 > 0 || soap_flag_CbteDesde2 > 0 || soap_flag_CbteHasta2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__FECAEDetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__FECAEDetResponse, SOAP_TYPE_afip_ns3__FECAEDetResponse, sizeof(ns3__FECAEDetResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__FECAEDetResponse * SOAP_FMAC2 soap_instantiate_ns3__FECAEDetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__FECAEDetResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__FECAEDetResponse *p;
	size_t k = sizeof(ns3__FECAEDetResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FECAEDetResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__FECAEDetResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__FECAEDetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__FECAEDetResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__FECAEDetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__FECAEDetResponse(soap, tag ? tag : "ns3:FECAEDetResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__FECAEDetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__FECAEDetResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns3__FECAEDetResponse * SOAP_FMAC4 soap_get_ns3__FECAEDetResponse(struct soap *soap, ns3__FECAEDetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__FECAEDetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__ArrayOfFECAEDetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__FECAEDetResponse(soap, &this->ns3__ArrayOfFECAEDetResponse::FECAEDetResponse);
}

void ns3__ArrayOfFECAEDetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons3__FECAEDetResponse(soap, &this->ns3__ArrayOfFECAEDetResponse::FECAEDetResponse);
#endif
}

int ns3__ArrayOfFECAEDetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfFECAEDetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfFECAEDetResponse(struct soap *soap, const char *tag, int id, const ns3__ArrayOfFECAEDetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__ArrayOfFECAEDetResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__FECAEDetResponse(soap, "ns3:FECAEDetResponse", -1, &a->ns3__ArrayOfFECAEDetResponse::FECAEDetResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfFECAEDetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__ArrayOfFECAEDetResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfFECAEDetResponse * SOAP_FMAC4 soap_in_ns3__ArrayOfFECAEDetResponse(struct soap *soap, const char *tag, ns3__ArrayOfFECAEDetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfFECAEDetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__ArrayOfFECAEDetResponse, sizeof(ns3__ArrayOfFECAEDetResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__ArrayOfFECAEDetResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__ArrayOfFECAEDetResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__FECAEDetResponse(soap, "ns3:FECAEDetResponse", &a->ns3__ArrayOfFECAEDetResponse::FECAEDetResponse, "ns3:FECAEDetResponse"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfFECAEDetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__ArrayOfFECAEDetResponse, SOAP_TYPE_afip_ns3__ArrayOfFECAEDetResponse, sizeof(ns3__ArrayOfFECAEDetResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__ArrayOfFECAEDetResponse * SOAP_FMAC2 soap_instantiate_ns3__ArrayOfFECAEDetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfFECAEDetResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__ArrayOfFECAEDetResponse *p;
	size_t k = sizeof(ns3__ArrayOfFECAEDetResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__ArrayOfFECAEDetResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__ArrayOfFECAEDetResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__ArrayOfFECAEDetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__ArrayOfFECAEDetResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__ArrayOfFECAEDetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__ArrayOfFECAEDetResponse(soap, tag ? tag : "ns3:ArrayOfFECAEDetResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ArrayOfFECAEDetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfFECAEDetResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfFECAEDetResponse * SOAP_FMAC4 soap_get_ns3__ArrayOfFECAEDetResponse(struct soap *soap, ns3__ArrayOfFECAEDetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfFECAEDetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__FECabResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->ns3__FECabResponse::Cuit);
	soap_default_int(soap, &this->ns3__FECabResponse::PtoVta);
	soap_default_int(soap, &this->ns3__FECabResponse::CbteTipo);
	this->ns3__FECabResponse::FchProceso = NULL;
	soap_default_int(soap, &this->ns3__FECabResponse::CantReg);
	this->ns3__FECabResponse::Resultado = NULL;
	this->ns3__FECabResponse::Reproceso = NULL;
}

void ns3__FECabResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns3__FECabResponse::FchProceso);
	soap_serialize_PointerTostd__string(soap, &this->ns3__FECabResponse::Resultado);
	soap_serialize_PointerTostd__string(soap, &this->ns3__FECabResponse::Reproceso);
#endif
}

int ns3__FECabResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__FECabResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FECabResponse(struct soap *soap, const char *tag, int id, const ns3__FECabResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__FECabResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "ns3:Cuit", -1, &a->ns3__FECabResponse::Cuit, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:PtoVta", -1, &a->ns3__FECabResponse::PtoVta, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:CbteTipo", -1, &a->ns3__FECabResponse::CbteTipo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchProceso", -1, &a->ns3__FECabResponse::FchProceso, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:CantReg", -1, &a->ns3__FECabResponse::CantReg, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Resultado", -1, &a->ns3__FECabResponse::Resultado, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Reproceso", -1, &a->ns3__FECabResponse::Reproceso, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__FECabResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__FECabResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns3__FECabResponse * SOAP_FMAC4 soap_in_ns3__FECabResponse(struct soap *soap, const char *tag, ns3__FECabResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__FECabResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__FECabResponse, sizeof(ns3__FECabResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__FECabResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__FECabResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Cuit1 = 1;
	size_t soap_flag_PtoVta1 = 1;
	size_t soap_flag_CbteTipo1 = 1;
	size_t soap_flag_FchProceso1 = 1;
	size_t soap_flag_CantReg1 = 1;
	size_t soap_flag_Resultado1 = 1;
	size_t soap_flag_Reproceso1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Cuit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "ns3:Cuit", &a->ns3__FECabResponse::Cuit, "xsd:long"))
				{	soap_flag_Cuit1--;
					continue;
				}
			}
			if (soap_flag_PtoVta1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:PtoVta", &a->ns3__FECabResponse::PtoVta, "xsd:int"))
				{	soap_flag_PtoVta1--;
					continue;
				}
			}
			if (soap_flag_CbteTipo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:CbteTipo", &a->ns3__FECabResponse::CbteTipo, "xsd:int"))
				{	soap_flag_CbteTipo1--;
					continue;
				}
			}
			if (soap_flag_FchProceso1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchProceso", &a->ns3__FECabResponse::FchProceso, "xsd:string"))
				{	soap_flag_FchProceso1--;
					continue;
				}
			}
			if (soap_flag_CantReg1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:CantReg", &a->ns3__FECabResponse::CantReg, "xsd:int"))
				{	soap_flag_CantReg1--;
					continue;
				}
			}
			if (soap_flag_Resultado1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Resultado", &a->ns3__FECabResponse::Resultado, "xsd:string"))
				{	soap_flag_Resultado1--;
					continue;
				}
			}
			if (soap_flag_Reproceso1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Reproceso", &a->ns3__FECabResponse::Reproceso, "xsd:string"))
				{	soap_flag_Reproceso1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Cuit1 > 0 || soap_flag_PtoVta1 > 0 || soap_flag_CbteTipo1 > 0 || soap_flag_CantReg1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__FECabResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__FECabResponse, SOAP_TYPE_afip_ns3__FECabResponse, sizeof(ns3__FECabResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__FECabResponse * SOAP_FMAC2 soap_instantiate_ns3__FECabResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__FECabResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "ns3:FECAECabResponse"))
		return soap_instantiate_ns3__FECAECabResponse(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns3:FECAEACabResponse"))
		return soap_instantiate_ns3__FECAEACabResponse(soap, n, NULL, NULL, size);
	ns3__FECabResponse *p;
	size_t k = sizeof(ns3__FECabResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FECabResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__FECabResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__FECabResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__FECabResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__FECabResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__FECabResponse(soap, tag ? tag : "ns3:FECabResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__FECabResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__FECabResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns3__FECabResponse * SOAP_FMAC4 soap_get_ns3__FECabResponse(struct soap *soap, ns3__FECabResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__FECabResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__FECAECabResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__FECabResponse::soap_default(soap);
}

void ns3__FECAECabResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns3__FECabResponse::soap_serialize(soap);
#endif
}

int ns3__FECAECabResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__FECAECabResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FECAECabResponse(struct soap *soap, const char *tag, int id, const ns3__FECAECabResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__FECAECabResponse), type ? type : "ns3:FECAECabResponse"))
		return soap->error;
	if (soap_out_LONG64(soap, "ns3:Cuit", -1, &a->ns3__FECabResponse::Cuit, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:PtoVta", -1, &a->ns3__FECabResponse::PtoVta, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:CbteTipo", -1, &a->ns3__FECabResponse::CbteTipo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchProceso", -1, &a->ns3__FECabResponse::FchProceso, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:CantReg", -1, &a->ns3__FECabResponse::CantReg, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Resultado", -1, &a->ns3__FECabResponse::Resultado, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Reproceso", -1, &a->ns3__FECabResponse::Reproceso, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__FECAECabResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__FECAECabResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns3__FECAECabResponse * SOAP_FMAC4 soap_in_ns3__FECAECabResponse(struct soap *soap, const char *tag, ns3__FECAECabResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__FECAECabResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__FECAECabResponse, sizeof(ns3__FECAECabResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__FECAECabResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__FECAECabResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Cuit2 = 1;
	size_t soap_flag_PtoVta2 = 1;
	size_t soap_flag_CbteTipo2 = 1;
	size_t soap_flag_FchProceso2 = 1;
	size_t soap_flag_CantReg2 = 1;
	size_t soap_flag_Resultado2 = 1;
	size_t soap_flag_Reproceso2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Cuit2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "ns3:Cuit", &a->ns3__FECabResponse::Cuit, "xsd:long"))
				{	soap_flag_Cuit2--;
					continue;
				}
			}
			if (soap_flag_PtoVta2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:PtoVta", &a->ns3__FECabResponse::PtoVta, "xsd:int"))
				{	soap_flag_PtoVta2--;
					continue;
				}
			}
			if (soap_flag_CbteTipo2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:CbteTipo", &a->ns3__FECabResponse::CbteTipo, "xsd:int"))
				{	soap_flag_CbteTipo2--;
					continue;
				}
			}
			if (soap_flag_FchProceso2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchProceso", &a->ns3__FECabResponse::FchProceso, "xsd:string"))
				{	soap_flag_FchProceso2--;
					continue;
				}
			}
			if (soap_flag_CantReg2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:CantReg", &a->ns3__FECabResponse::CantReg, "xsd:int"))
				{	soap_flag_CantReg2--;
					continue;
				}
			}
			if (soap_flag_Resultado2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Resultado", &a->ns3__FECabResponse::Resultado, "xsd:string"))
				{	soap_flag_Resultado2--;
					continue;
				}
			}
			if (soap_flag_Reproceso2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Reproceso", &a->ns3__FECabResponse::Reproceso, "xsd:string"))
				{	soap_flag_Reproceso2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Cuit2 > 0 || soap_flag_PtoVta2 > 0 || soap_flag_CbteTipo2 > 0 || soap_flag_CantReg2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__FECAECabResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__FECAECabResponse, SOAP_TYPE_afip_ns3__FECAECabResponse, sizeof(ns3__FECAECabResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__FECAECabResponse * SOAP_FMAC2 soap_instantiate_ns3__FECAECabResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__FECAECabResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__FECAECabResponse *p;
	size_t k = sizeof(ns3__FECAECabResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FECAECabResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__FECAECabResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__FECAECabResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__FECAECabResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__FECAECabResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__FECAECabResponse(soap, tag ? tag : "ns3:FECAECabResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__FECAECabResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__FECAECabResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns3__FECAECabResponse * SOAP_FMAC4 soap_get_ns3__FECAECabResponse(struct soap *soap, ns3__FECAECabResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__FECAECabResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__FECAEResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__FECAEResponse::FeCabResp = NULL;
	this->ns3__FECAEResponse::FeDetResp = NULL;
	this->ns3__FECAEResponse::Events = NULL;
	this->ns3__FECAEResponse::Errors = NULL;
}

void ns3__FECAEResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FECAECabResponse(soap, &this->ns3__FECAEResponse::FeCabResp);
	soap_serialize_PointerTons3__ArrayOfFECAEDetResponse(soap, &this->ns3__FECAEResponse::FeDetResp);
	soap_serialize_PointerTons3__ArrayOfEvt(soap, &this->ns3__FECAEResponse::Events);
	soap_serialize_PointerTons3__ArrayOfErr(soap, &this->ns3__FECAEResponse::Errors);
#endif
}

int ns3__FECAEResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__FECAEResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FECAEResponse(struct soap *soap, const char *tag, int id, const ns3__FECAEResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__FECAEResponse), type))
		return soap->error;
	if (soap_out_PointerTons3__FECAECabResponse(soap, "ns3:FeCabResp", -1, &a->ns3__FECAEResponse::FeCabResp, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfFECAEDetResponse(soap, "ns3:FeDetResp", -1, &a->ns3__FECAEResponse::FeDetResp, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfEvt(soap, "ns3:Events", -1, &a->ns3__FECAEResponse::Events, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfErr(soap, "ns3:Errors", -1, &a->ns3__FECAEResponse::Errors, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__FECAEResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__FECAEResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns3__FECAEResponse * SOAP_FMAC4 soap_in_ns3__FECAEResponse(struct soap *soap, const char *tag, ns3__FECAEResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__FECAEResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__FECAEResponse, sizeof(ns3__FECAEResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__FECAEResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__FECAEResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FeCabResp1 = 1;
	size_t soap_flag_FeDetResp1 = 1;
	size_t soap_flag_Events1 = 1;
	size_t soap_flag_Errors1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FeCabResp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FECAECabResponse(soap, "ns3:FeCabResp", &a->ns3__FECAEResponse::FeCabResp, "ns3:FECAECabResponse"))
				{	soap_flag_FeCabResp1--;
					continue;
				}
			}
			if (soap_flag_FeDetResp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfFECAEDetResponse(soap, "ns3:FeDetResp", &a->ns3__FECAEResponse::FeDetResp, "ns3:ArrayOfFECAEDetResponse"))
				{	soap_flag_FeDetResp1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfEvt(soap, "ns3:Events", &a->ns3__FECAEResponse::Events, "ns3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfErr(soap, "ns3:Errors", &a->ns3__FECAEResponse::Errors, "ns3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__FECAEResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__FECAEResponse, SOAP_TYPE_afip_ns3__FECAEResponse, sizeof(ns3__FECAEResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__FECAEResponse * SOAP_FMAC2 soap_instantiate_ns3__FECAEResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__FECAEResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__FECAEResponse *p;
	size_t k = sizeof(ns3__FECAEResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FECAEResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__FECAEResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__FECAEResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__FECAEResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__FECAEResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__FECAEResponse(soap, tag ? tag : "ns3:FECAEResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__FECAEResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__FECAEResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns3__FECAEResponse * SOAP_FMAC4 soap_get_ns3__FECAEResponse(struct soap *soap, ns3__FECAEResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__FECAEResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__Comprador::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns3__Comprador::DocTipo);
	soap_default_LONG64(soap, &this->ns3__Comprador::DocNro);
	soap_default_double(soap, &this->ns3__Comprador::Porcentaje);
}

void ns3__Comprador::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns3__Comprador::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__Comprador(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__Comprador(struct soap *soap, const char *tag, int id, const ns3__Comprador *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__Comprador), type))
		return soap->error;
	if (soap_out_int(soap, "ns3:DocTipo", -1, &a->ns3__Comprador::DocTipo, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns3:DocNro", -1, &a->ns3__Comprador::DocNro, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:Porcentaje", -1, &a->ns3__Comprador::Porcentaje, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__Comprador::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__Comprador(soap, tag, this, type);
}

SOAP_FMAC3 ns3__Comprador * SOAP_FMAC4 soap_in_ns3__Comprador(struct soap *soap, const char *tag, ns3__Comprador *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__Comprador*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__Comprador, sizeof(ns3__Comprador), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__Comprador)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__Comprador *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DocTipo1 = 1;
	size_t soap_flag_DocNro1 = 1;
	size_t soap_flag_Porcentaje1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DocTipo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:DocTipo", &a->ns3__Comprador::DocTipo, "xsd:int"))
				{	soap_flag_DocTipo1--;
					continue;
				}
			}
			if (soap_flag_DocNro1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "ns3:DocNro", &a->ns3__Comprador::DocNro, "xsd:long"))
				{	soap_flag_DocNro1--;
					continue;
				}
			}
			if (soap_flag_Porcentaje1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:Porcentaje", &a->ns3__Comprador::Porcentaje, "xsd:double"))
				{	soap_flag_Porcentaje1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DocTipo1 > 0 || soap_flag_DocNro1 > 0 || soap_flag_Porcentaje1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__Comprador *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__Comprador, SOAP_TYPE_afip_ns3__Comprador, sizeof(ns3__Comprador), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__Comprador * SOAP_FMAC2 soap_instantiate_ns3__Comprador(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__Comprador(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__Comprador *p;
	size_t k = sizeof(ns3__Comprador);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__Comprador, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__Comprador);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__Comprador, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__Comprador location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__Comprador::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__Comprador(soap, tag ? tag : "ns3:Comprador", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__Comprador::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__Comprador(soap, this, tag, type);
}

SOAP_FMAC3 ns3__Comprador * SOAP_FMAC4 soap_get_ns3__Comprador(struct soap *soap, ns3__Comprador *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__Comprador(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__ArrayOfComprador::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__Comprador(soap, &this->ns3__ArrayOfComprador::Comprador);
}

void ns3__ArrayOfComprador::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons3__Comprador(soap, &this->ns3__ArrayOfComprador::Comprador);
#endif
}

int ns3__ArrayOfComprador::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfComprador(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfComprador(struct soap *soap, const char *tag, int id, const ns3__ArrayOfComprador *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__ArrayOfComprador), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__Comprador(soap, "ns3:Comprador", -1, &a->ns3__ArrayOfComprador::Comprador, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfComprador::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__ArrayOfComprador(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfComprador * SOAP_FMAC4 soap_in_ns3__ArrayOfComprador(struct soap *soap, const char *tag, ns3__ArrayOfComprador *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfComprador*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__ArrayOfComprador, sizeof(ns3__ArrayOfComprador), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__ArrayOfComprador)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__ArrayOfComprador *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__Comprador(soap, "ns3:Comprador", &a->ns3__ArrayOfComprador::Comprador, "ns3:Comprador"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfComprador *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__ArrayOfComprador, SOAP_TYPE_afip_ns3__ArrayOfComprador, sizeof(ns3__ArrayOfComprador), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__ArrayOfComprador * SOAP_FMAC2 soap_instantiate_ns3__ArrayOfComprador(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfComprador(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__ArrayOfComprador *p;
	size_t k = sizeof(ns3__ArrayOfComprador);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__ArrayOfComprador, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__ArrayOfComprador);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__ArrayOfComprador, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__ArrayOfComprador location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__ArrayOfComprador::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__ArrayOfComprador(soap, tag ? tag : "ns3:ArrayOfComprador", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ArrayOfComprador::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfComprador(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfComprador * SOAP_FMAC4 soap_get_ns3__ArrayOfComprador(struct soap *soap, ns3__ArrayOfComprador *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfComprador(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__Opcional::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__Opcional::Id = NULL;
	this->ns3__Opcional::Valor = NULL;
}

void ns3__Opcional::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns3__Opcional::Id);
	soap_serialize_PointerTostd__string(soap, &this->ns3__Opcional::Valor);
#endif
}

int ns3__Opcional::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__Opcional(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__Opcional(struct soap *soap, const char *tag, int id, const ns3__Opcional *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__Opcional), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Id", -1, &a->ns3__Opcional::Id, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Valor", -1, &a->ns3__Opcional::Valor, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__Opcional::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__Opcional(soap, tag, this, type);
}

SOAP_FMAC3 ns3__Opcional * SOAP_FMAC4 soap_in_ns3__Opcional(struct soap *soap, const char *tag, ns3__Opcional *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__Opcional*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__Opcional, sizeof(ns3__Opcional), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__Opcional)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__Opcional *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_Valor1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Id", &a->ns3__Opcional::Id, "xsd:string"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_Valor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Valor", &a->ns3__Opcional::Valor, "xsd:string"))
				{	soap_flag_Valor1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__Opcional *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__Opcional, SOAP_TYPE_afip_ns3__Opcional, sizeof(ns3__Opcional), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__Opcional * SOAP_FMAC2 soap_instantiate_ns3__Opcional(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__Opcional(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__Opcional *p;
	size_t k = sizeof(ns3__Opcional);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__Opcional, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__Opcional);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__Opcional, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__Opcional location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__Opcional::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__Opcional(soap, tag ? tag : "ns3:Opcional", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__Opcional::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__Opcional(soap, this, tag, type);
}

SOAP_FMAC3 ns3__Opcional * SOAP_FMAC4 soap_get_ns3__Opcional(struct soap *soap, ns3__Opcional *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__Opcional(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__ArrayOfOpcional::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__Opcional(soap, &this->ns3__ArrayOfOpcional::Opcional);
}

void ns3__ArrayOfOpcional::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons3__Opcional(soap, &this->ns3__ArrayOfOpcional::Opcional);
#endif
}

int ns3__ArrayOfOpcional::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfOpcional(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfOpcional(struct soap *soap, const char *tag, int id, const ns3__ArrayOfOpcional *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__ArrayOfOpcional), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__Opcional(soap, "ns3:Opcional", -1, &a->ns3__ArrayOfOpcional::Opcional, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfOpcional::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__ArrayOfOpcional(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfOpcional * SOAP_FMAC4 soap_in_ns3__ArrayOfOpcional(struct soap *soap, const char *tag, ns3__ArrayOfOpcional *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfOpcional*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__ArrayOfOpcional, sizeof(ns3__ArrayOfOpcional), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__ArrayOfOpcional)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__ArrayOfOpcional *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__Opcional(soap, "ns3:Opcional", &a->ns3__ArrayOfOpcional::Opcional, "ns3:Opcional"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfOpcional *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__ArrayOfOpcional, SOAP_TYPE_afip_ns3__ArrayOfOpcional, sizeof(ns3__ArrayOfOpcional), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__ArrayOfOpcional * SOAP_FMAC2 soap_instantiate_ns3__ArrayOfOpcional(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfOpcional(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__ArrayOfOpcional *p;
	size_t k = sizeof(ns3__ArrayOfOpcional);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__ArrayOfOpcional, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__ArrayOfOpcional);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__ArrayOfOpcional, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__ArrayOfOpcional location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__ArrayOfOpcional::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__ArrayOfOpcional(soap, tag ? tag : "ns3:ArrayOfOpcional", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ArrayOfOpcional::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfOpcional(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfOpcional * SOAP_FMAC4 soap_get_ns3__ArrayOfOpcional(struct soap *soap, ns3__ArrayOfOpcional *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfOpcional(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__AlicIva::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns3__AlicIva::Id);
	soap_default_double(soap, &this->ns3__AlicIva::BaseImp);
	soap_default_double(soap, &this->ns3__AlicIva::Importe);
}

void ns3__AlicIva::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns3__AlicIva::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__AlicIva(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__AlicIva(struct soap *soap, const char *tag, int id, const ns3__AlicIva *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__AlicIva), type))
		return soap->error;
	if (soap_out_int(soap, "ns3:Id", -1, &a->ns3__AlicIva::Id, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:BaseImp", -1, &a->ns3__AlicIva::BaseImp, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:Importe", -1, &a->ns3__AlicIva::Importe, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__AlicIva::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__AlicIva(soap, tag, this, type);
}

SOAP_FMAC3 ns3__AlicIva * SOAP_FMAC4 soap_in_ns3__AlicIva(struct soap *soap, const char *tag, ns3__AlicIva *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__AlicIva*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__AlicIva, sizeof(ns3__AlicIva), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__AlicIva)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__AlicIva *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_BaseImp1 = 1;
	size_t soap_flag_Importe1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:Id", &a->ns3__AlicIva::Id, "xsd:int"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_BaseImp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:BaseImp", &a->ns3__AlicIva::BaseImp, "xsd:double"))
				{	soap_flag_BaseImp1--;
					continue;
				}
			}
			if (soap_flag_Importe1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:Importe", &a->ns3__AlicIva::Importe, "xsd:double"))
				{	soap_flag_Importe1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0 || soap_flag_BaseImp1 > 0 || soap_flag_Importe1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__AlicIva *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__AlicIva, SOAP_TYPE_afip_ns3__AlicIva, sizeof(ns3__AlicIva), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__AlicIva * SOAP_FMAC2 soap_instantiate_ns3__AlicIva(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__AlicIva(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__AlicIva *p;
	size_t k = sizeof(ns3__AlicIva);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__AlicIva, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__AlicIva);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__AlicIva, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__AlicIva location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__AlicIva::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__AlicIva(soap, tag ? tag : "ns3:AlicIva", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__AlicIva::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__AlicIva(soap, this, tag, type);
}

SOAP_FMAC3 ns3__AlicIva * SOAP_FMAC4 soap_get_ns3__AlicIva(struct soap *soap, ns3__AlicIva *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__AlicIva(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__ArrayOfAlicIva::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__AlicIva(soap, &this->ns3__ArrayOfAlicIva::AlicIva);
}

void ns3__ArrayOfAlicIva::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons3__AlicIva(soap, &this->ns3__ArrayOfAlicIva::AlicIva);
#endif
}

int ns3__ArrayOfAlicIva::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfAlicIva(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfAlicIva(struct soap *soap, const char *tag, int id, const ns3__ArrayOfAlicIva *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__ArrayOfAlicIva), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__AlicIva(soap, "ns3:AlicIva", -1, &a->ns3__ArrayOfAlicIva::AlicIva, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfAlicIva::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__ArrayOfAlicIva(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfAlicIva * SOAP_FMAC4 soap_in_ns3__ArrayOfAlicIva(struct soap *soap, const char *tag, ns3__ArrayOfAlicIva *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfAlicIva*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__ArrayOfAlicIva, sizeof(ns3__ArrayOfAlicIva), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__ArrayOfAlicIva)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__ArrayOfAlicIva *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__AlicIva(soap, "ns3:AlicIva", &a->ns3__ArrayOfAlicIva::AlicIva, "ns3:AlicIva"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfAlicIva *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__ArrayOfAlicIva, SOAP_TYPE_afip_ns3__ArrayOfAlicIva, sizeof(ns3__ArrayOfAlicIva), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__ArrayOfAlicIva * SOAP_FMAC2 soap_instantiate_ns3__ArrayOfAlicIva(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfAlicIva(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__ArrayOfAlicIva *p;
	size_t k = sizeof(ns3__ArrayOfAlicIva);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__ArrayOfAlicIva, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__ArrayOfAlicIva);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__ArrayOfAlicIva, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__ArrayOfAlicIva location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__ArrayOfAlicIva::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__ArrayOfAlicIva(soap, tag ? tag : "ns3:ArrayOfAlicIva", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ArrayOfAlicIva::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfAlicIva(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfAlicIva * SOAP_FMAC4 soap_get_ns3__ArrayOfAlicIva(struct soap *soap, ns3__ArrayOfAlicIva *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfAlicIva(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__Tributo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_short(soap, &this->ns3__Tributo::Id);
	this->ns3__Tributo::Desc = NULL;
	soap_default_double(soap, &this->ns3__Tributo::BaseImp);
	soap_default_double(soap, &this->ns3__Tributo::Alic);
	soap_default_double(soap, &this->ns3__Tributo::Importe);
}

void ns3__Tributo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns3__Tributo::Desc);
#endif
}

int ns3__Tributo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__Tributo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__Tributo(struct soap *soap, const char *tag, int id, const ns3__Tributo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__Tributo), type))
		return soap->error;
	if (soap_out_short(soap, "ns3:Id", -1, &a->ns3__Tributo::Id, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Desc", -1, &a->ns3__Tributo::Desc, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:BaseImp", -1, &a->ns3__Tributo::BaseImp, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:Alic", -1, &a->ns3__Tributo::Alic, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:Importe", -1, &a->ns3__Tributo::Importe, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__Tributo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__Tributo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__Tributo * SOAP_FMAC4 soap_in_ns3__Tributo(struct soap *soap, const char *tag, ns3__Tributo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__Tributo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__Tributo, sizeof(ns3__Tributo), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__Tributo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__Tributo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_Desc1 = 1;
	size_t soap_flag_BaseImp1 = 1;
	size_t soap_flag_Alic1 = 1;
	size_t soap_flag_Importe1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_short(soap, "ns3:Id", &a->ns3__Tributo::Id, "xsd:short"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_Desc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Desc", &a->ns3__Tributo::Desc, "xsd:string"))
				{	soap_flag_Desc1--;
					continue;
				}
			}
			if (soap_flag_BaseImp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:BaseImp", &a->ns3__Tributo::BaseImp, "xsd:double"))
				{	soap_flag_BaseImp1--;
					continue;
				}
			}
			if (soap_flag_Alic1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:Alic", &a->ns3__Tributo::Alic, "xsd:double"))
				{	soap_flag_Alic1--;
					continue;
				}
			}
			if (soap_flag_Importe1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:Importe", &a->ns3__Tributo::Importe, "xsd:double"))
				{	soap_flag_Importe1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0 || soap_flag_BaseImp1 > 0 || soap_flag_Alic1 > 0 || soap_flag_Importe1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__Tributo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__Tributo, SOAP_TYPE_afip_ns3__Tributo, sizeof(ns3__Tributo), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__Tributo * SOAP_FMAC2 soap_instantiate_ns3__Tributo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__Tributo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__Tributo *p;
	size_t k = sizeof(ns3__Tributo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__Tributo, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__Tributo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__Tributo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__Tributo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__Tributo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__Tributo(soap, tag ? tag : "ns3:Tributo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__Tributo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__Tributo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__Tributo * SOAP_FMAC4 soap_get_ns3__Tributo(struct soap *soap, ns3__Tributo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__Tributo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__ArrayOfTributo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__Tributo(soap, &this->ns3__ArrayOfTributo::Tributo);
}

void ns3__ArrayOfTributo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons3__Tributo(soap, &this->ns3__ArrayOfTributo::Tributo);
#endif
}

int ns3__ArrayOfTributo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfTributo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfTributo(struct soap *soap, const char *tag, int id, const ns3__ArrayOfTributo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__ArrayOfTributo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__Tributo(soap, "ns3:Tributo", -1, &a->ns3__ArrayOfTributo::Tributo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfTributo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__ArrayOfTributo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfTributo * SOAP_FMAC4 soap_in_ns3__ArrayOfTributo(struct soap *soap, const char *tag, ns3__ArrayOfTributo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfTributo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__ArrayOfTributo, sizeof(ns3__ArrayOfTributo), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__ArrayOfTributo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__ArrayOfTributo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__Tributo(soap, "ns3:Tributo", &a->ns3__ArrayOfTributo::Tributo, "ns3:Tributo"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfTributo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__ArrayOfTributo, SOAP_TYPE_afip_ns3__ArrayOfTributo, sizeof(ns3__ArrayOfTributo), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__ArrayOfTributo * SOAP_FMAC2 soap_instantiate_ns3__ArrayOfTributo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfTributo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__ArrayOfTributo *p;
	size_t k = sizeof(ns3__ArrayOfTributo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__ArrayOfTributo, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__ArrayOfTributo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__ArrayOfTributo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__ArrayOfTributo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__ArrayOfTributo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__ArrayOfTributo(soap, tag ? tag : "ns3:ArrayOfTributo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ArrayOfTributo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfTributo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfTributo * SOAP_FMAC4 soap_get_ns3__ArrayOfTributo(struct soap *soap, ns3__ArrayOfTributo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfTributo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__CbteAsoc::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns3__CbteAsoc::Tipo);
	soap_default_int(soap, &this->ns3__CbteAsoc::PtoVta);
	soap_default_LONG64(soap, &this->ns3__CbteAsoc::Nro);
	this->ns3__CbteAsoc::Cuit = NULL;
	this->ns3__CbteAsoc::CbteFch = NULL;
}

void ns3__CbteAsoc::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns3__CbteAsoc::Cuit);
	soap_serialize_PointerTostd__string(soap, &this->ns3__CbteAsoc::CbteFch);
#endif
}

int ns3__CbteAsoc::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__CbteAsoc(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__CbteAsoc(struct soap *soap, const char *tag, int id, const ns3__CbteAsoc *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__CbteAsoc), type))
		return soap->error;
	if (soap_out_int(soap, "ns3:Tipo", -1, &a->ns3__CbteAsoc::Tipo, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:PtoVta", -1, &a->ns3__CbteAsoc::PtoVta, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns3:Nro", -1, &a->ns3__CbteAsoc::Nro, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Cuit", -1, &a->ns3__CbteAsoc::Cuit, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:CbteFch", -1, &a->ns3__CbteAsoc::CbteFch, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__CbteAsoc::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__CbteAsoc(soap, tag, this, type);
}

SOAP_FMAC3 ns3__CbteAsoc * SOAP_FMAC4 soap_in_ns3__CbteAsoc(struct soap *soap, const char *tag, ns3__CbteAsoc *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__CbteAsoc*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__CbteAsoc, sizeof(ns3__CbteAsoc), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__CbteAsoc)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__CbteAsoc *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Tipo1 = 1;
	size_t soap_flag_PtoVta1 = 1;
	size_t soap_flag_Nro1 = 1;
	size_t soap_flag_Cuit1 = 1;
	size_t soap_flag_CbteFch1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Tipo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:Tipo", &a->ns3__CbteAsoc::Tipo, "xsd:int"))
				{	soap_flag_Tipo1--;
					continue;
				}
			}
			if (soap_flag_PtoVta1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:PtoVta", &a->ns3__CbteAsoc::PtoVta, "xsd:int"))
				{	soap_flag_PtoVta1--;
					continue;
				}
			}
			if (soap_flag_Nro1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "ns3:Nro", &a->ns3__CbteAsoc::Nro, "xsd:long"))
				{	soap_flag_Nro1--;
					continue;
				}
			}
			if (soap_flag_Cuit1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Cuit", &a->ns3__CbteAsoc::Cuit, "xsd:string"))
				{	soap_flag_Cuit1--;
					continue;
				}
			}
			if (soap_flag_CbteFch1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:CbteFch", &a->ns3__CbteAsoc::CbteFch, "xsd:string"))
				{	soap_flag_CbteFch1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Tipo1 > 0 || soap_flag_PtoVta1 > 0 || soap_flag_Nro1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__CbteAsoc *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__CbteAsoc, SOAP_TYPE_afip_ns3__CbteAsoc, sizeof(ns3__CbteAsoc), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__CbteAsoc * SOAP_FMAC2 soap_instantiate_ns3__CbteAsoc(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__CbteAsoc(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__CbteAsoc *p;
	size_t k = sizeof(ns3__CbteAsoc);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__CbteAsoc, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__CbteAsoc);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__CbteAsoc, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__CbteAsoc location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__CbteAsoc::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__CbteAsoc(soap, tag ? tag : "ns3:CbteAsoc", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__CbteAsoc::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__CbteAsoc(soap, this, tag, type);
}

SOAP_FMAC3 ns3__CbteAsoc * SOAP_FMAC4 soap_get_ns3__CbteAsoc(struct soap *soap, ns3__CbteAsoc *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__CbteAsoc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__ArrayOfCbteAsoc::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__CbteAsoc(soap, &this->ns3__ArrayOfCbteAsoc::CbteAsoc);
}

void ns3__ArrayOfCbteAsoc::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons3__CbteAsoc(soap, &this->ns3__ArrayOfCbteAsoc::CbteAsoc);
#endif
}

int ns3__ArrayOfCbteAsoc::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfCbteAsoc(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfCbteAsoc(struct soap *soap, const char *tag, int id, const ns3__ArrayOfCbteAsoc *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__ArrayOfCbteAsoc), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__CbteAsoc(soap, "ns3:CbteAsoc", -1, &a->ns3__ArrayOfCbteAsoc::CbteAsoc, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfCbteAsoc::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__ArrayOfCbteAsoc(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfCbteAsoc * SOAP_FMAC4 soap_in_ns3__ArrayOfCbteAsoc(struct soap *soap, const char *tag, ns3__ArrayOfCbteAsoc *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfCbteAsoc*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__ArrayOfCbteAsoc, sizeof(ns3__ArrayOfCbteAsoc), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__ArrayOfCbteAsoc)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__ArrayOfCbteAsoc *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__CbteAsoc(soap, "ns3:CbteAsoc", &a->ns3__ArrayOfCbteAsoc::CbteAsoc, "ns3:CbteAsoc"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfCbteAsoc *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__ArrayOfCbteAsoc, SOAP_TYPE_afip_ns3__ArrayOfCbteAsoc, sizeof(ns3__ArrayOfCbteAsoc), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__ArrayOfCbteAsoc * SOAP_FMAC2 soap_instantiate_ns3__ArrayOfCbteAsoc(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfCbteAsoc(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__ArrayOfCbteAsoc *p;
	size_t k = sizeof(ns3__ArrayOfCbteAsoc);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__ArrayOfCbteAsoc, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__ArrayOfCbteAsoc);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__ArrayOfCbteAsoc, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__ArrayOfCbteAsoc location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__ArrayOfCbteAsoc::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__ArrayOfCbteAsoc(soap, tag ? tag : "ns3:ArrayOfCbteAsoc", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ArrayOfCbteAsoc::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfCbteAsoc(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfCbteAsoc * SOAP_FMAC4 soap_get_ns3__ArrayOfCbteAsoc(struct soap *soap, ns3__ArrayOfCbteAsoc *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfCbteAsoc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__FEDetRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns3__FEDetRequest::Concepto);
	soap_default_int(soap, &this->ns3__FEDetRequest::DocTipo);
	soap_default_LONG64(soap, &this->ns3__FEDetRequest::DocNro);
	soap_default_LONG64(soap, &this->ns3__FEDetRequest::CbteDesde);
	soap_default_LONG64(soap, &this->ns3__FEDetRequest::CbteHasta);
	this->ns3__FEDetRequest::CbteFch = NULL;
	soap_default_double(soap, &this->ns3__FEDetRequest::ImpTotal);
	soap_default_double(soap, &this->ns3__FEDetRequest::ImpTotConc);
	soap_default_double(soap, &this->ns3__FEDetRequest::ImpNeto);
	soap_default_double(soap, &this->ns3__FEDetRequest::ImpOpEx);
	soap_default_double(soap, &this->ns3__FEDetRequest::ImpTrib);
	soap_default_double(soap, &this->ns3__FEDetRequest::ImpIVA);
	this->ns3__FEDetRequest::FchServDesde = NULL;
	this->ns3__FEDetRequest::FchServHasta = NULL;
	this->ns3__FEDetRequest::FchVtoPago = NULL;
	this->ns3__FEDetRequest::MonId = NULL;
	soap_default_double(soap, &this->ns3__FEDetRequest::MonCotiz);
	this->ns3__FEDetRequest::CbtesAsoc = NULL;
	this->ns3__FEDetRequest::Tributos = NULL;
	this->ns3__FEDetRequest::Iva = NULL;
	this->ns3__FEDetRequest::Opcionales = NULL;
	this->ns3__FEDetRequest::Compradores = NULL;
}

void ns3__FEDetRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns3__FEDetRequest::CbteFch);
	soap_serialize_PointerTostd__string(soap, &this->ns3__FEDetRequest::FchServDesde);
	soap_serialize_PointerTostd__string(soap, &this->ns3__FEDetRequest::FchServHasta);
	soap_serialize_PointerTostd__string(soap, &this->ns3__FEDetRequest::FchVtoPago);
	soap_serialize_PointerTostd__string(soap, &this->ns3__FEDetRequest::MonId);
	soap_serialize_PointerTons3__ArrayOfCbteAsoc(soap, &this->ns3__FEDetRequest::CbtesAsoc);
	soap_serialize_PointerTons3__ArrayOfTributo(soap, &this->ns3__FEDetRequest::Tributos);
	soap_serialize_PointerTons3__ArrayOfAlicIva(soap, &this->ns3__FEDetRequest::Iva);
	soap_serialize_PointerTons3__ArrayOfOpcional(soap, &this->ns3__FEDetRequest::Opcionales);
	soap_serialize_PointerTons3__ArrayOfComprador(soap, &this->ns3__FEDetRequest::Compradores);
#endif
}

int ns3__FEDetRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__FEDetRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FEDetRequest(struct soap *soap, const char *tag, int id, const ns3__FEDetRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__FEDetRequest), type))
		return soap->error;
	if (soap_out_int(soap, "ns3:Concepto", -1, &a->ns3__FEDetRequest::Concepto, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:DocTipo", -1, &a->ns3__FEDetRequest::DocTipo, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns3:DocNro", -1, &a->ns3__FEDetRequest::DocNro, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns3:CbteDesde", -1, &a->ns3__FEDetRequest::CbteDesde, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns3:CbteHasta", -1, &a->ns3__FEDetRequest::CbteHasta, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:CbteFch", -1, &a->ns3__FEDetRequest::CbteFch, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:ImpTotal", -1, &a->ns3__FEDetRequest::ImpTotal, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:ImpTotConc", -1, &a->ns3__FEDetRequest::ImpTotConc, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:ImpNeto", -1, &a->ns3__FEDetRequest::ImpNeto, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:ImpOpEx", -1, &a->ns3__FEDetRequest::ImpOpEx, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:ImpTrib", -1, &a->ns3__FEDetRequest::ImpTrib, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:ImpIVA", -1, &a->ns3__FEDetRequest::ImpIVA, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchServDesde", -1, &a->ns3__FEDetRequest::FchServDesde, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchServHasta", -1, &a->ns3__FEDetRequest::FchServHasta, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchVtoPago", -1, &a->ns3__FEDetRequest::FchVtoPago, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:MonId", -1, &a->ns3__FEDetRequest::MonId, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:MonCotiz", -1, &a->ns3__FEDetRequest::MonCotiz, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfCbteAsoc(soap, "ns3:CbtesAsoc", -1, &a->ns3__FEDetRequest::CbtesAsoc, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfTributo(soap, "ns3:Tributos", -1, &a->ns3__FEDetRequest::Tributos, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfAlicIva(soap, "ns3:Iva", -1, &a->ns3__FEDetRequest::Iva, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfOpcional(soap, "ns3:Opcionales", -1, &a->ns3__FEDetRequest::Opcionales, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfComprador(soap, "ns3:Compradores", -1, &a->ns3__FEDetRequest::Compradores, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__FEDetRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__FEDetRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns3__FEDetRequest * SOAP_FMAC4 soap_in_ns3__FEDetRequest(struct soap *soap, const char *tag, ns3__FEDetRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__FEDetRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__FEDetRequest, sizeof(ns3__FEDetRequest), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__FEDetRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__FEDetRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Concepto1 = 1;
	size_t soap_flag_DocTipo1 = 1;
	size_t soap_flag_DocNro1 = 1;
	size_t soap_flag_CbteDesde1 = 1;
	size_t soap_flag_CbteHasta1 = 1;
	size_t soap_flag_CbteFch1 = 1;
	size_t soap_flag_ImpTotal1 = 1;
	size_t soap_flag_ImpTotConc1 = 1;
	size_t soap_flag_ImpNeto1 = 1;
	size_t soap_flag_ImpOpEx1 = 1;
	size_t soap_flag_ImpTrib1 = 1;
	size_t soap_flag_ImpIVA1 = 1;
	size_t soap_flag_FchServDesde1 = 1;
	size_t soap_flag_FchServHasta1 = 1;
	size_t soap_flag_FchVtoPago1 = 1;
	size_t soap_flag_MonId1 = 1;
	size_t soap_flag_MonCotiz1 = 1;
	size_t soap_flag_CbtesAsoc1 = 1;
	size_t soap_flag_Tributos1 = 1;
	size_t soap_flag_Iva1 = 1;
	size_t soap_flag_Opcionales1 = 1;
	size_t soap_flag_Compradores1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Concepto1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:Concepto", &a->ns3__FEDetRequest::Concepto, "xsd:int"))
				{	soap_flag_Concepto1--;
					continue;
				}
			}
			if (soap_flag_DocTipo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:DocTipo", &a->ns3__FEDetRequest::DocTipo, "xsd:int"))
				{	soap_flag_DocTipo1--;
					continue;
				}
			}
			if (soap_flag_DocNro1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "ns3:DocNro", &a->ns3__FEDetRequest::DocNro, "xsd:long"))
				{	soap_flag_DocNro1--;
					continue;
				}
			}
			if (soap_flag_CbteDesde1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "ns3:CbteDesde", &a->ns3__FEDetRequest::CbteDesde, "xsd:long"))
				{	soap_flag_CbteDesde1--;
					continue;
				}
			}
			if (soap_flag_CbteHasta1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "ns3:CbteHasta", &a->ns3__FEDetRequest::CbteHasta, "xsd:long"))
				{	soap_flag_CbteHasta1--;
					continue;
				}
			}
			if (soap_flag_CbteFch1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:CbteFch", &a->ns3__FEDetRequest::CbteFch, "xsd:string"))
				{	soap_flag_CbteFch1--;
					continue;
				}
			}
			if (soap_flag_ImpTotal1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:ImpTotal", &a->ns3__FEDetRequest::ImpTotal, "xsd:double"))
				{	soap_flag_ImpTotal1--;
					continue;
				}
			}
			if (soap_flag_ImpTotConc1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:ImpTotConc", &a->ns3__FEDetRequest::ImpTotConc, "xsd:double"))
				{	soap_flag_ImpTotConc1--;
					continue;
				}
			}
			if (soap_flag_ImpNeto1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:ImpNeto", &a->ns3__FEDetRequest::ImpNeto, "xsd:double"))
				{	soap_flag_ImpNeto1--;
					continue;
				}
			}
			if (soap_flag_ImpOpEx1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:ImpOpEx", &a->ns3__FEDetRequest::ImpOpEx, "xsd:double"))
				{	soap_flag_ImpOpEx1--;
					continue;
				}
			}
			if (soap_flag_ImpTrib1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:ImpTrib", &a->ns3__FEDetRequest::ImpTrib, "xsd:double"))
				{	soap_flag_ImpTrib1--;
					continue;
				}
			}
			if (soap_flag_ImpIVA1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:ImpIVA", &a->ns3__FEDetRequest::ImpIVA, "xsd:double"))
				{	soap_flag_ImpIVA1--;
					continue;
				}
			}
			if (soap_flag_FchServDesde1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchServDesde", &a->ns3__FEDetRequest::FchServDesde, "xsd:string"))
				{	soap_flag_FchServDesde1--;
					continue;
				}
			}
			if (soap_flag_FchServHasta1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchServHasta", &a->ns3__FEDetRequest::FchServHasta, "xsd:string"))
				{	soap_flag_FchServHasta1--;
					continue;
				}
			}
			if (soap_flag_FchVtoPago1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchVtoPago", &a->ns3__FEDetRequest::FchVtoPago, "xsd:string"))
				{	soap_flag_FchVtoPago1--;
					continue;
				}
			}
			if (soap_flag_MonId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:MonId", &a->ns3__FEDetRequest::MonId, "xsd:string"))
				{	soap_flag_MonId1--;
					continue;
				}
			}
			if (soap_flag_MonCotiz1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:MonCotiz", &a->ns3__FEDetRequest::MonCotiz, "xsd:double"))
				{	soap_flag_MonCotiz1--;
					continue;
				}
			}
			if (soap_flag_CbtesAsoc1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfCbteAsoc(soap, "ns3:CbtesAsoc", &a->ns3__FEDetRequest::CbtesAsoc, "ns3:ArrayOfCbteAsoc"))
				{	soap_flag_CbtesAsoc1--;
					continue;
				}
			}
			if (soap_flag_Tributos1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfTributo(soap, "ns3:Tributos", &a->ns3__FEDetRequest::Tributos, "ns3:ArrayOfTributo"))
				{	soap_flag_Tributos1--;
					continue;
				}
			}
			if (soap_flag_Iva1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfAlicIva(soap, "ns3:Iva", &a->ns3__FEDetRequest::Iva, "ns3:ArrayOfAlicIva"))
				{	soap_flag_Iva1--;
					continue;
				}
			}
			if (soap_flag_Opcionales1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfOpcional(soap, "ns3:Opcionales", &a->ns3__FEDetRequest::Opcionales, "ns3:ArrayOfOpcional"))
				{	soap_flag_Opcionales1--;
					continue;
				}
			}
			if (soap_flag_Compradores1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfComprador(soap, "ns3:Compradores", &a->ns3__FEDetRequest::Compradores, "ns3:ArrayOfComprador"))
				{	soap_flag_Compradores1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Concepto1 > 0 || soap_flag_DocTipo1 > 0 || soap_flag_DocNro1 > 0 || soap_flag_CbteDesde1 > 0 || soap_flag_CbteHasta1 > 0 || soap_flag_ImpTotal1 > 0 || soap_flag_ImpTotConc1 > 0 || soap_flag_ImpNeto1 > 0 || soap_flag_ImpOpEx1 > 0 || soap_flag_ImpTrib1 > 0 || soap_flag_ImpIVA1 > 0 || soap_flag_MonCotiz1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__FEDetRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__FEDetRequest, SOAP_TYPE_afip_ns3__FEDetRequest, sizeof(ns3__FEDetRequest), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__FEDetRequest * SOAP_FMAC2 soap_instantiate_ns3__FEDetRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__FEDetRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "ns3:FECAEDetRequest"))
		return soap_instantiate_ns3__FECAEDetRequest(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns3:FECAEADetRequest"))
		return soap_instantiate_ns3__FECAEADetRequest(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns3:FECompConsResponse"))
		return soap_instantiate_ns3__FECompConsResponse(soap, n, NULL, NULL, size);
	ns3__FEDetRequest *p;
	size_t k = sizeof(ns3__FEDetRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FEDetRequest, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__FEDetRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__FEDetRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__FEDetRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__FEDetRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__FEDetRequest(soap, tag ? tag : "ns3:FEDetRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__FEDetRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__FEDetRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns3__FEDetRequest * SOAP_FMAC4 soap_get_ns3__FEDetRequest(struct soap *soap, ns3__FEDetRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__FEDetRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__FECAEDetRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__FEDetRequest::soap_default(soap);
}

void ns3__FECAEDetRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns3__FEDetRequest::soap_serialize(soap);
#endif
}

int ns3__FECAEDetRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__FECAEDetRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FECAEDetRequest(struct soap *soap, const char *tag, int id, const ns3__FECAEDetRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__FECAEDetRequest), type ? type : "ns3:FECAEDetRequest"))
		return soap->error;
	if (soap_out_int(soap, "ns3:Concepto", -1, &a->ns3__FEDetRequest::Concepto, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:DocTipo", -1, &a->ns3__FEDetRequest::DocTipo, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns3:DocNro", -1, &a->ns3__FEDetRequest::DocNro, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns3:CbteDesde", -1, &a->ns3__FEDetRequest::CbteDesde, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns3:CbteHasta", -1, &a->ns3__FEDetRequest::CbteHasta, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:CbteFch", -1, &a->ns3__FEDetRequest::CbteFch, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:ImpTotal", -1, &a->ns3__FEDetRequest::ImpTotal, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:ImpTotConc", -1, &a->ns3__FEDetRequest::ImpTotConc, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:ImpNeto", -1, &a->ns3__FEDetRequest::ImpNeto, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:ImpOpEx", -1, &a->ns3__FEDetRequest::ImpOpEx, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:ImpTrib", -1, &a->ns3__FEDetRequest::ImpTrib, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:ImpIVA", -1, &a->ns3__FEDetRequest::ImpIVA, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchServDesde", -1, &a->ns3__FEDetRequest::FchServDesde, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchServHasta", -1, &a->ns3__FEDetRequest::FchServHasta, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:FchVtoPago", -1, &a->ns3__FEDetRequest::FchVtoPago, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:MonId", -1, &a->ns3__FEDetRequest::MonId, ""))
		return soap->error;
	if (soap_out_double(soap, "ns3:MonCotiz", -1, &a->ns3__FEDetRequest::MonCotiz, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfCbteAsoc(soap, "ns3:CbtesAsoc", -1, &a->ns3__FEDetRequest::CbtesAsoc, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfTributo(soap, "ns3:Tributos", -1, &a->ns3__FEDetRequest::Tributos, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfAlicIva(soap, "ns3:Iva", -1, &a->ns3__FEDetRequest::Iva, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfOpcional(soap, "ns3:Opcionales", -1, &a->ns3__FEDetRequest::Opcionales, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfComprador(soap, "ns3:Compradores", -1, &a->ns3__FEDetRequest::Compradores, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__FECAEDetRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__FECAEDetRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns3__FECAEDetRequest * SOAP_FMAC4 soap_in_ns3__FECAEDetRequest(struct soap *soap, const char *tag, ns3__FECAEDetRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__FECAEDetRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__FECAEDetRequest, sizeof(ns3__FECAEDetRequest), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__FECAEDetRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__FECAEDetRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Concepto2 = 1;
	size_t soap_flag_DocTipo2 = 1;
	size_t soap_flag_DocNro2 = 1;
	size_t soap_flag_CbteDesde2 = 1;
	size_t soap_flag_CbteHasta2 = 1;
	size_t soap_flag_CbteFch2 = 1;
	size_t soap_flag_ImpTotal2 = 1;
	size_t soap_flag_ImpTotConc2 = 1;
	size_t soap_flag_ImpNeto2 = 1;
	size_t soap_flag_ImpOpEx2 = 1;
	size_t soap_flag_ImpTrib2 = 1;
	size_t soap_flag_ImpIVA2 = 1;
	size_t soap_flag_FchServDesde2 = 1;
	size_t soap_flag_FchServHasta2 = 1;
	size_t soap_flag_FchVtoPago2 = 1;
	size_t soap_flag_MonId2 = 1;
	size_t soap_flag_MonCotiz2 = 1;
	size_t soap_flag_CbtesAsoc2 = 1;
	size_t soap_flag_Tributos2 = 1;
	size_t soap_flag_Iva2 = 1;
	size_t soap_flag_Opcionales2 = 1;
	size_t soap_flag_Compradores2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Concepto2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:Concepto", &a->ns3__FEDetRequest::Concepto, "xsd:int"))
				{	soap_flag_Concepto2--;
					continue;
				}
			}
			if (soap_flag_DocTipo2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:DocTipo", &a->ns3__FEDetRequest::DocTipo, "xsd:int"))
				{	soap_flag_DocTipo2--;
					continue;
				}
			}
			if (soap_flag_DocNro2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "ns3:DocNro", &a->ns3__FEDetRequest::DocNro, "xsd:long"))
				{	soap_flag_DocNro2--;
					continue;
				}
			}
			if (soap_flag_CbteDesde2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "ns3:CbteDesde", &a->ns3__FEDetRequest::CbteDesde, "xsd:long"))
				{	soap_flag_CbteDesde2--;
					continue;
				}
			}
			if (soap_flag_CbteHasta2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "ns3:CbteHasta", &a->ns3__FEDetRequest::CbteHasta, "xsd:long"))
				{	soap_flag_CbteHasta2--;
					continue;
				}
			}
			if (soap_flag_CbteFch2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:CbteFch", &a->ns3__FEDetRequest::CbteFch, "xsd:string"))
				{	soap_flag_CbteFch2--;
					continue;
				}
			}
			if (soap_flag_ImpTotal2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:ImpTotal", &a->ns3__FEDetRequest::ImpTotal, "xsd:double"))
				{	soap_flag_ImpTotal2--;
					continue;
				}
			}
			if (soap_flag_ImpTotConc2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:ImpTotConc", &a->ns3__FEDetRequest::ImpTotConc, "xsd:double"))
				{	soap_flag_ImpTotConc2--;
					continue;
				}
			}
			if (soap_flag_ImpNeto2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:ImpNeto", &a->ns3__FEDetRequest::ImpNeto, "xsd:double"))
				{	soap_flag_ImpNeto2--;
					continue;
				}
			}
			if (soap_flag_ImpOpEx2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:ImpOpEx", &a->ns3__FEDetRequest::ImpOpEx, "xsd:double"))
				{	soap_flag_ImpOpEx2--;
					continue;
				}
			}
			if (soap_flag_ImpTrib2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:ImpTrib", &a->ns3__FEDetRequest::ImpTrib, "xsd:double"))
				{	soap_flag_ImpTrib2--;
					continue;
				}
			}
			if (soap_flag_ImpIVA2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:ImpIVA", &a->ns3__FEDetRequest::ImpIVA, "xsd:double"))
				{	soap_flag_ImpIVA2--;
					continue;
				}
			}
			if (soap_flag_FchServDesde2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchServDesde", &a->ns3__FEDetRequest::FchServDesde, "xsd:string"))
				{	soap_flag_FchServDesde2--;
					continue;
				}
			}
			if (soap_flag_FchServHasta2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchServHasta", &a->ns3__FEDetRequest::FchServHasta, "xsd:string"))
				{	soap_flag_FchServHasta2--;
					continue;
				}
			}
			if (soap_flag_FchVtoPago2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:FchVtoPago", &a->ns3__FEDetRequest::FchVtoPago, "xsd:string"))
				{	soap_flag_FchVtoPago2--;
					continue;
				}
			}
			if (soap_flag_MonId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:MonId", &a->ns3__FEDetRequest::MonId, "xsd:string"))
				{	soap_flag_MonId2--;
					continue;
				}
			}
			if (soap_flag_MonCotiz2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ns3:MonCotiz", &a->ns3__FEDetRequest::MonCotiz, "xsd:double"))
				{	soap_flag_MonCotiz2--;
					continue;
				}
			}
			if (soap_flag_CbtesAsoc2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfCbteAsoc(soap, "ns3:CbtesAsoc", &a->ns3__FEDetRequest::CbtesAsoc, "ns3:ArrayOfCbteAsoc"))
				{	soap_flag_CbtesAsoc2--;
					continue;
				}
			}
			if (soap_flag_Tributos2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfTributo(soap, "ns3:Tributos", &a->ns3__FEDetRequest::Tributos, "ns3:ArrayOfTributo"))
				{	soap_flag_Tributos2--;
					continue;
				}
			}
			if (soap_flag_Iva2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfAlicIva(soap, "ns3:Iva", &a->ns3__FEDetRequest::Iva, "ns3:ArrayOfAlicIva"))
				{	soap_flag_Iva2--;
					continue;
				}
			}
			if (soap_flag_Opcionales2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfOpcional(soap, "ns3:Opcionales", &a->ns3__FEDetRequest::Opcionales, "ns3:ArrayOfOpcional"))
				{	soap_flag_Opcionales2--;
					continue;
				}
			}
			if (soap_flag_Compradores2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfComprador(soap, "ns3:Compradores", &a->ns3__FEDetRequest::Compradores, "ns3:ArrayOfComprador"))
				{	soap_flag_Compradores2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Concepto2 > 0 || soap_flag_DocTipo2 > 0 || soap_flag_DocNro2 > 0 || soap_flag_CbteDesde2 > 0 || soap_flag_CbteHasta2 > 0 || soap_flag_ImpTotal2 > 0 || soap_flag_ImpTotConc2 > 0 || soap_flag_ImpNeto2 > 0 || soap_flag_ImpOpEx2 > 0 || soap_flag_ImpTrib2 > 0 || soap_flag_ImpIVA2 > 0 || soap_flag_MonCotiz2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__FECAEDetRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__FECAEDetRequest, SOAP_TYPE_afip_ns3__FECAEDetRequest, sizeof(ns3__FECAEDetRequest), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__FECAEDetRequest * SOAP_FMAC2 soap_instantiate_ns3__FECAEDetRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__FECAEDetRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "ns3:FECompConsResponse"))
		return soap_instantiate_ns3__FECompConsResponse(soap, n, NULL, NULL, size);
	ns3__FECAEDetRequest *p;
	size_t k = sizeof(ns3__FECAEDetRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FECAEDetRequest, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__FECAEDetRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__FECAEDetRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__FECAEDetRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__FECAEDetRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__FECAEDetRequest(soap, tag ? tag : "ns3:FECAEDetRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__FECAEDetRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__FECAEDetRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns3__FECAEDetRequest * SOAP_FMAC4 soap_get_ns3__FECAEDetRequest(struct soap *soap, ns3__FECAEDetRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__FECAEDetRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__ArrayOfFECAEDetRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__FECAEDetRequest(soap, &this->ns3__ArrayOfFECAEDetRequest::FECAEDetRequest);
}

void ns3__ArrayOfFECAEDetRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons3__FECAEDetRequest(soap, &this->ns3__ArrayOfFECAEDetRequest::FECAEDetRequest);
#endif
}

int ns3__ArrayOfFECAEDetRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfFECAEDetRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfFECAEDetRequest(struct soap *soap, const char *tag, int id, const ns3__ArrayOfFECAEDetRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__ArrayOfFECAEDetRequest), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__FECAEDetRequest(soap, "ns3:FECAEDetRequest", -1, &a->ns3__ArrayOfFECAEDetRequest::FECAEDetRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfFECAEDetRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__ArrayOfFECAEDetRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfFECAEDetRequest * SOAP_FMAC4 soap_in_ns3__ArrayOfFECAEDetRequest(struct soap *soap, const char *tag, ns3__ArrayOfFECAEDetRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfFECAEDetRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__ArrayOfFECAEDetRequest, sizeof(ns3__ArrayOfFECAEDetRequest), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__ArrayOfFECAEDetRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__ArrayOfFECAEDetRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons3__FECAEDetRequest(soap, "ns3:FECAEDetRequest", &a->ns3__ArrayOfFECAEDetRequest::FECAEDetRequest, "ns3:FECAEDetRequest"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfFECAEDetRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__ArrayOfFECAEDetRequest, SOAP_TYPE_afip_ns3__ArrayOfFECAEDetRequest, sizeof(ns3__ArrayOfFECAEDetRequest), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__ArrayOfFECAEDetRequest * SOAP_FMAC2 soap_instantiate_ns3__ArrayOfFECAEDetRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfFECAEDetRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__ArrayOfFECAEDetRequest *p;
	size_t k = sizeof(ns3__ArrayOfFECAEDetRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__ArrayOfFECAEDetRequest, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__ArrayOfFECAEDetRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__ArrayOfFECAEDetRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__ArrayOfFECAEDetRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__ArrayOfFECAEDetRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__ArrayOfFECAEDetRequest(soap, tag ? tag : "ns3:ArrayOfFECAEDetRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__ArrayOfFECAEDetRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfFECAEDetRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfFECAEDetRequest * SOAP_FMAC4 soap_get_ns3__ArrayOfFECAEDetRequest(struct soap *soap, ns3__ArrayOfFECAEDetRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfFECAEDetRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__FECabRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns3__FECabRequest::CantReg);
	soap_default_int(soap, &this->ns3__FECabRequest::PtoVta);
	soap_default_int(soap, &this->ns3__FECabRequest::CbteTipo);
}

void ns3__FECabRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns3__FECabRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__FECabRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FECabRequest(struct soap *soap, const char *tag, int id, const ns3__FECabRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__FECabRequest), type))
		return soap->error;
	if (soap_out_int(soap, "ns3:CantReg", -1, &a->ns3__FECabRequest::CantReg, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:PtoVta", -1, &a->ns3__FECabRequest::PtoVta, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:CbteTipo", -1, &a->ns3__FECabRequest::CbteTipo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__FECabRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__FECabRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns3__FECabRequest * SOAP_FMAC4 soap_in_ns3__FECabRequest(struct soap *soap, const char *tag, ns3__FECabRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__FECabRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__FECabRequest, sizeof(ns3__FECabRequest), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__FECabRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__FECabRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CantReg1 = 1;
	size_t soap_flag_PtoVta1 = 1;
	size_t soap_flag_CbteTipo1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CantReg1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:CantReg", &a->ns3__FECabRequest::CantReg, "xsd:int"))
				{	soap_flag_CantReg1--;
					continue;
				}
			}
			if (soap_flag_PtoVta1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:PtoVta", &a->ns3__FECabRequest::PtoVta, "xsd:int"))
				{	soap_flag_PtoVta1--;
					continue;
				}
			}
			if (soap_flag_CbteTipo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:CbteTipo", &a->ns3__FECabRequest::CbteTipo, "xsd:int"))
				{	soap_flag_CbteTipo1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CantReg1 > 0 || soap_flag_PtoVta1 > 0 || soap_flag_CbteTipo1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__FECabRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__FECabRequest, SOAP_TYPE_afip_ns3__FECabRequest, sizeof(ns3__FECabRequest), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__FECabRequest * SOAP_FMAC2 soap_instantiate_ns3__FECabRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__FECabRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "ns3:FECAECabRequest"))
		return soap_instantiate_ns3__FECAECabRequest(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns3:FECAEACabRequest"))
		return soap_instantiate_ns3__FECAEACabRequest(soap, n, NULL, NULL, size);
	ns3__FECabRequest *p;
	size_t k = sizeof(ns3__FECabRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FECabRequest, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__FECabRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__FECabRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__FECabRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__FECabRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__FECabRequest(soap, tag ? tag : "ns3:FECabRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__FECabRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__FECabRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns3__FECabRequest * SOAP_FMAC4 soap_get_ns3__FECabRequest(struct soap *soap, ns3__FECabRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__FECabRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__FECAECabRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__FECabRequest::soap_default(soap);
}

void ns3__FECAECabRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns3__FECabRequest::soap_serialize(soap);
#endif
}

int ns3__FECAECabRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__FECAECabRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FECAECabRequest(struct soap *soap, const char *tag, int id, const ns3__FECAECabRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__FECAECabRequest), type ? type : "ns3:FECAECabRequest"))
		return soap->error;
	if (soap_out_int(soap, "ns3:CantReg", -1, &a->ns3__FECabRequest::CantReg, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:PtoVta", -1, &a->ns3__FECabRequest::PtoVta, ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:CbteTipo", -1, &a->ns3__FECabRequest::CbteTipo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__FECAECabRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__FECAECabRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns3__FECAECabRequest * SOAP_FMAC4 soap_in_ns3__FECAECabRequest(struct soap *soap, const char *tag, ns3__FECAECabRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__FECAECabRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__FECAECabRequest, sizeof(ns3__FECAECabRequest), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__FECAECabRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__FECAECabRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CantReg2 = 1;
	size_t soap_flag_PtoVta2 = 1;
	size_t soap_flag_CbteTipo2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CantReg2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:CantReg", &a->ns3__FECabRequest::CantReg, "xsd:int"))
				{	soap_flag_CantReg2--;
					continue;
				}
			}
			if (soap_flag_PtoVta2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:PtoVta", &a->ns3__FECabRequest::PtoVta, "xsd:int"))
				{	soap_flag_PtoVta2--;
					continue;
				}
			}
			if (soap_flag_CbteTipo2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ns3:CbteTipo", &a->ns3__FECabRequest::CbteTipo, "xsd:int"))
				{	soap_flag_CbteTipo2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CantReg2 > 0 || soap_flag_PtoVta2 > 0 || soap_flag_CbteTipo2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__FECAECabRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__FECAECabRequest, SOAP_TYPE_afip_ns3__FECAECabRequest, sizeof(ns3__FECAECabRequest), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__FECAECabRequest * SOAP_FMAC2 soap_instantiate_ns3__FECAECabRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__FECAECabRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__FECAECabRequest *p;
	size_t k = sizeof(ns3__FECAECabRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FECAECabRequest, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__FECAECabRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__FECAECabRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__FECAECabRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__FECAECabRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__FECAECabRequest(soap, tag ? tag : "ns3:FECAECabRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__FECAECabRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__FECAECabRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns3__FECAECabRequest * SOAP_FMAC4 soap_get_ns3__FECAECabRequest(struct soap *soap, ns3__FECAECabRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__FECAECabRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__FECAERequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__FECAERequest::FeCabReq = NULL;
	this->ns3__FECAERequest::FeDetReq = NULL;
}

void ns3__FECAERequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__FECAECabRequest(soap, &this->ns3__FECAERequest::FeCabReq);
	soap_serialize_PointerTons3__ArrayOfFECAEDetRequest(soap, &this->ns3__FECAERequest::FeDetReq);
#endif
}

int ns3__FECAERequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__FECAERequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FECAERequest(struct soap *soap, const char *tag, int id, const ns3__FECAERequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__FECAERequest), type))
		return soap->error;
	if (soap_out_PointerTons3__FECAECabRequest(soap, "ns3:FeCabReq", -1, &a->ns3__FECAERequest::FeCabReq, ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfFECAEDetRequest(soap, "ns3:FeDetReq", -1, &a->ns3__FECAERequest::FeDetReq, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__FECAERequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__FECAERequest(soap, tag, this, type);
}

SOAP_FMAC3 ns3__FECAERequest * SOAP_FMAC4 soap_in_ns3__FECAERequest(struct soap *soap, const char *tag, ns3__FECAERequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__FECAERequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__FECAERequest, sizeof(ns3__FECAERequest), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__FECAERequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__FECAERequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FeCabReq1 = 1;
	size_t soap_flag_FeDetReq1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FeCabReq1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__FECAECabRequest(soap, "ns3:FeCabReq", &a->ns3__FECAERequest::FeCabReq, "ns3:FECAECabRequest"))
				{	soap_flag_FeCabReq1--;
					continue;
				}
			}
			if (soap_flag_FeDetReq1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__ArrayOfFECAEDetRequest(soap, "ns3:FeDetReq", &a->ns3__FECAERequest::FeDetReq, "ns3:ArrayOfFECAEDetRequest"))
				{	soap_flag_FeDetReq1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__FECAERequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__FECAERequest, SOAP_TYPE_afip_ns3__FECAERequest, sizeof(ns3__FECAERequest), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__FECAERequest * SOAP_FMAC2 soap_instantiate_ns3__FECAERequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__FECAERequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__FECAERequest *p;
	size_t k = sizeof(ns3__FECAERequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FECAERequest, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__FECAERequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__FECAERequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__FECAERequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__FECAERequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__FECAERequest(soap, tag ? tag : "ns3:FECAERequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__FECAERequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__FECAERequest(soap, this, tag, type);
}

SOAP_FMAC3 ns3__FECAERequest * SOAP_FMAC4 soap_get_ns3__FECAERequest(struct soap *soap, ns3__FECAERequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__FECAERequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__FEAuthRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__FEAuthRequest::Token = NULL;
	this->ns3__FEAuthRequest::Sign = NULL;
	soap_default_LONG64(soap, &this->ns3__FEAuthRequest::Cuit);
}

void ns3__FEAuthRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns3__FEAuthRequest::Token);
	soap_serialize_PointerTostd__string(soap, &this->ns3__FEAuthRequest::Sign);
#endif
}

int ns3__FEAuthRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__FEAuthRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__FEAuthRequest(struct soap *soap, const char *tag, int id, const ns3__FEAuthRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns3__FEAuthRequest), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Token", -1, &a->ns3__FEAuthRequest::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns3:Sign", -1, &a->ns3__FEAuthRequest::Sign, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns3:Cuit", -1, &a->ns3__FEAuthRequest::Cuit, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__FEAuthRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns3__FEAuthRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns3__FEAuthRequest * SOAP_FMAC4 soap_in_ns3__FEAuthRequest(struct soap *soap, const char *tag, ns3__FEAuthRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__FEAuthRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns3__FEAuthRequest, sizeof(ns3__FEAuthRequest), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns3__FEAuthRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__FEAuthRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Sign1 = 1;
	size_t soap_flag_Cuit1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Token", &a->ns3__FEAuthRequest::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			}
			if (soap_flag_Sign1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns3:Sign", &a->ns3__FEAuthRequest::Sign, "xsd:string"))
				{	soap_flag_Sign1--;
					continue;
				}
			}
			if (soap_flag_Cuit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "ns3:Cuit", &a->ns3__FEAuthRequest::Cuit, "xsd:long"))
				{	soap_flag_Cuit1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Cuit1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns3__FEAuthRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns3__FEAuthRequest, SOAP_TYPE_afip_ns3__FEAuthRequest, sizeof(ns3__FEAuthRequest), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__FEAuthRequest * SOAP_FMAC2 soap_instantiate_ns3__FEAuthRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__FEAuthRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__FEAuthRequest *p;
	size_t k = sizeof(ns3__FEAuthRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns3__FEAuthRequest, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns3__FEAuthRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns3__FEAuthRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__FEAuthRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns3__FEAuthRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__FEAuthRequest(soap, tag ? tag : "ns3:FEAuthRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__FEAuthRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__FEAuthRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns3__FEAuthRequest * SOAP_FMAC4 soap_get_ns3__FEAuthRequest(struct soap *soap, ns3__FEAuthRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__FEAuthRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__LoginFault::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void ns2__LoginFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__LoginFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__LoginFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__LoginFault(struct soap *soap, const char *tag, int id, const ns2__LoginFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_ns2__LoginFault), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__LoginFault::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns2__LoginFault(soap, tag, this, type);
}

SOAP_FMAC3 ns2__LoginFault * SOAP_FMAC4 soap_in_ns2__LoginFault(struct soap *soap, const char *tag, ns2__LoginFault *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__LoginFault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_ns2__LoginFault, sizeof(ns2__LoginFault), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip_ns2__LoginFault)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__LoginFault *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__LoginFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_ns2__LoginFault, SOAP_TYPE_afip_ns2__LoginFault, sizeof(ns2__LoginFault), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__LoginFault * SOAP_FMAC2 soap_instantiate_ns2__LoginFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__LoginFault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__LoginFault *p;
	size_t k = sizeof(ns2__LoginFault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_ns2__LoginFault, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns2__LoginFault);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns2__LoginFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__LoginFault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns2__LoginFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__LoginFault(soap, tag ? tag : "ns2:LoginFault", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__LoginFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__LoginFault(soap, this, tag, type);
}

SOAP_FMAC3 ns2__LoginFault * SOAP_FMAC4 soap_get_ns2__LoginFault(struct soap *soap, ns2__LoginFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__LoginFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__loginCmsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__loginCmsResponse::loginCmsReturn);
}

void _ns1__loginCmsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns1__loginCmsResponse::loginCmsReturn, SOAP_TYPE_afip_std__string);
	soap_serialize_std__string(soap, &this->_ns1__loginCmsResponse::loginCmsReturn);
#endif
}

int _ns1__loginCmsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__loginCmsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__loginCmsResponse(struct soap *soap, const char *tag, int id, const _ns1__loginCmsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns1__loginCmsResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:loginCmsReturn");
	if (soap_out_std__string(soap, "ns1:loginCmsReturn", -1, &a->_ns1__loginCmsResponse::loginCmsReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__loginCmsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__loginCmsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__loginCmsResponse * SOAP_FMAC4 soap_in__ns1__loginCmsResponse(struct soap *soap, const char *tag, _ns1__loginCmsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__loginCmsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns1__loginCmsResponse, sizeof(_ns1__loginCmsResponse), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns1__loginCmsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__loginCmsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_loginCmsReturn1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_loginCmsReturn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:loginCmsReturn", &a->_ns1__loginCmsResponse::loginCmsReturn, "xsd:string"))
				{	soap_flag_loginCmsReturn1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:loginCmsReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_loginCmsReturn1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__loginCmsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns1__loginCmsResponse, SOAP_TYPE_afip__ns1__loginCmsResponse, sizeof(_ns1__loginCmsResponse), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__loginCmsResponse * SOAP_FMAC2 soap_instantiate__ns1__loginCmsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__loginCmsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__loginCmsResponse *p;
	size_t k = sizeof(_ns1__loginCmsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns1__loginCmsResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__loginCmsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__loginCmsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__loginCmsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__loginCmsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__loginCmsResponse(soap, tag ? tag : "ns1:loginCmsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__loginCmsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__loginCmsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__loginCmsResponse * SOAP_FMAC4 soap_get__ns1__loginCmsResponse(struct soap *soap, _ns1__loginCmsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__loginCmsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__loginCms::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__loginCms::in0);
}

void _ns1__loginCms::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns1__loginCms::in0, SOAP_TYPE_afip_std__string);
	soap_serialize_std__string(soap, &this->_ns1__loginCms::in0);
#endif
}

int _ns1__loginCms::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__loginCms(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__loginCms(struct soap *soap, const char *tag, int id, const _ns1__loginCms *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip__ns1__loginCms), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:in0", -1, &a->_ns1__loginCms::in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__loginCms::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__loginCms(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__loginCms * SOAP_FMAC4 soap_in__ns1__loginCms(struct soap *soap, const char *tag, _ns1__loginCms *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__loginCms*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip__ns1__loginCms, sizeof(_ns1__loginCms), soap->type, soap->arrayType, afip_instantiate, afip_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip__ns1__loginCms)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__loginCms *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_in01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:in0", &a->_ns1__loginCms::in0, "xsd:string"))
				{	soap_flag_in01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__loginCms *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip__ns1__loginCms, SOAP_TYPE_afip__ns1__loginCms, sizeof(_ns1__loginCms), 0, afip_finsert, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__loginCms * SOAP_FMAC2 soap_instantiate__ns1__loginCms(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__loginCms(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__loginCms *p;
	size_t k = sizeof(_ns1__loginCms);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip__ns1__loginCms, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__loginCms);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__loginCms, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__loginCms location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__loginCms::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__loginCms(soap, tag ? tag : "ns1:loginCms", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__loginCms::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__loginCms(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__loginCms * SOAP_FMAC4 soap_get__ns1__loginCms(struct soap *soap, _ns1__loginCms *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__loginCms(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode;
	soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Fault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_SOAP_ENV__Fault, SOAP_TYPE_afip_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, afip_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_SOAP_ENV__Fault, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Reason*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_SOAP_ENV__Reason, SOAP_TYPE_afip_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, afip_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_SOAP_ENV__Reason, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value;
	soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_SOAP_ENV__Code, SOAP_TYPE_afip_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, afip_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_SOAP_ENV__Code, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Header*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_SOAP_ENV__Header, SOAP_TYPE_afip_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, afip_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_SOAP_ENV__Header, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FEParamGetTiposPaises_(struct soap *soap, struct __ns3__FEParamGetTiposPaises_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FEParamGetTiposPaises = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FEParamGetTiposPaises_(struct soap *soap, const struct __ns3__FEParamGetTiposPaises_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FEParamGetTiposPaises(soap, &a->ns3__FEParamGetTiposPaises);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FEParamGetTiposPaises_(struct soap *soap, const char *tag, int id, const struct __ns3__FEParamGetTiposPaises_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FEParamGetTiposPaises(soap, "ns3:FEParamGetTiposPaises", -1, &a->ns3__FEParamGetTiposPaises, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetTiposPaises_ * SOAP_FMAC4 soap_in___ns3__FEParamGetTiposPaises_(struct soap *soap, const char *tag, struct __ns3__FEParamGetTiposPaises_ *a, const char *type)
{
	size_t soap_flag_ns3__FEParamGetTiposPaises = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FEParamGetTiposPaises_*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FEParamGetTiposPaises_, sizeof(struct __ns3__FEParamGetTiposPaises_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FEParamGetTiposPaises_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FEParamGetTiposPaises && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FEParamGetTiposPaises(soap, "ns3:FEParamGetTiposPaises", &a->ns3__FEParamGetTiposPaises, ""))
				{	soap_flag_ns3__FEParamGetTiposPaises--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FEParamGetTiposPaises_ * SOAP_FMAC2 soap_instantiate___ns3__FEParamGetTiposPaises_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FEParamGetTiposPaises_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FEParamGetTiposPaises_ *p;
	size_t k = sizeof(struct __ns3__FEParamGetTiposPaises_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FEParamGetTiposPaises_, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FEParamGetTiposPaises_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FEParamGetTiposPaises_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FEParamGetTiposPaises_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FEParamGetTiposPaises_(struct soap *soap, const struct __ns3__FEParamGetTiposPaises_ *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FEParamGetTiposPaises_(soap, tag ? tag : "-ns3:FEParamGetTiposPaises", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetTiposPaises_ * SOAP_FMAC4 soap_get___ns3__FEParamGetTiposPaises_(struct soap *soap, struct __ns3__FEParamGetTiposPaises_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FEParamGetTiposPaises_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FEParamGetTiposDoc_(struct soap *soap, struct __ns3__FEParamGetTiposDoc_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FEParamGetTiposDoc = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FEParamGetTiposDoc_(struct soap *soap, const struct __ns3__FEParamGetTiposDoc_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FEParamGetTiposDoc(soap, &a->ns3__FEParamGetTiposDoc);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FEParamGetTiposDoc_(struct soap *soap, const char *tag, int id, const struct __ns3__FEParamGetTiposDoc_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FEParamGetTiposDoc(soap, "ns3:FEParamGetTiposDoc", -1, &a->ns3__FEParamGetTiposDoc, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetTiposDoc_ * SOAP_FMAC4 soap_in___ns3__FEParamGetTiposDoc_(struct soap *soap, const char *tag, struct __ns3__FEParamGetTiposDoc_ *a, const char *type)
{
	size_t soap_flag_ns3__FEParamGetTiposDoc = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FEParamGetTiposDoc_*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FEParamGetTiposDoc_, sizeof(struct __ns3__FEParamGetTiposDoc_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FEParamGetTiposDoc_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FEParamGetTiposDoc && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FEParamGetTiposDoc(soap, "ns3:FEParamGetTiposDoc", &a->ns3__FEParamGetTiposDoc, ""))
				{	soap_flag_ns3__FEParamGetTiposDoc--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FEParamGetTiposDoc_ * SOAP_FMAC2 soap_instantiate___ns3__FEParamGetTiposDoc_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FEParamGetTiposDoc_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FEParamGetTiposDoc_ *p;
	size_t k = sizeof(struct __ns3__FEParamGetTiposDoc_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FEParamGetTiposDoc_, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FEParamGetTiposDoc_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FEParamGetTiposDoc_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FEParamGetTiposDoc_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FEParamGetTiposDoc_(struct soap *soap, const struct __ns3__FEParamGetTiposDoc_ *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FEParamGetTiposDoc_(soap, tag ? tag : "-ns3:FEParamGetTiposDoc", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetTiposDoc_ * SOAP_FMAC4 soap_get___ns3__FEParamGetTiposDoc_(struct soap *soap, struct __ns3__FEParamGetTiposDoc_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FEParamGetTiposDoc_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FEParamGetTiposCbte_(struct soap *soap, struct __ns3__FEParamGetTiposCbte_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FEParamGetTiposCbte = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FEParamGetTiposCbte_(struct soap *soap, const struct __ns3__FEParamGetTiposCbte_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FEParamGetTiposCbte(soap, &a->ns3__FEParamGetTiposCbte);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FEParamGetTiposCbte_(struct soap *soap, const char *tag, int id, const struct __ns3__FEParamGetTiposCbte_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FEParamGetTiposCbte(soap, "ns3:FEParamGetTiposCbte", -1, &a->ns3__FEParamGetTiposCbte, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetTiposCbte_ * SOAP_FMAC4 soap_in___ns3__FEParamGetTiposCbte_(struct soap *soap, const char *tag, struct __ns3__FEParamGetTiposCbte_ *a, const char *type)
{
	size_t soap_flag_ns3__FEParamGetTiposCbte = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FEParamGetTiposCbte_*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FEParamGetTiposCbte_, sizeof(struct __ns3__FEParamGetTiposCbte_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FEParamGetTiposCbte_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FEParamGetTiposCbte && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FEParamGetTiposCbte(soap, "ns3:FEParamGetTiposCbte", &a->ns3__FEParamGetTiposCbte, ""))
				{	soap_flag_ns3__FEParamGetTiposCbte--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FEParamGetTiposCbte_ * SOAP_FMAC2 soap_instantiate___ns3__FEParamGetTiposCbte_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FEParamGetTiposCbte_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FEParamGetTiposCbte_ *p;
	size_t k = sizeof(struct __ns3__FEParamGetTiposCbte_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FEParamGetTiposCbte_, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FEParamGetTiposCbte_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FEParamGetTiposCbte_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FEParamGetTiposCbte_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FEParamGetTiposCbte_(struct soap *soap, const struct __ns3__FEParamGetTiposCbte_ *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FEParamGetTiposCbte_(soap, tag ? tag : "-ns3:FEParamGetTiposCbte", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetTiposCbte_ * SOAP_FMAC4 soap_get___ns3__FEParamGetTiposCbte_(struct soap *soap, struct __ns3__FEParamGetTiposCbte_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FEParamGetTiposCbte_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FEParamGetPtosVenta_(struct soap *soap, struct __ns3__FEParamGetPtosVenta_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FEParamGetPtosVenta = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FEParamGetPtosVenta_(struct soap *soap, const struct __ns3__FEParamGetPtosVenta_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FEParamGetPtosVenta(soap, &a->ns3__FEParamGetPtosVenta);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FEParamGetPtosVenta_(struct soap *soap, const char *tag, int id, const struct __ns3__FEParamGetPtosVenta_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FEParamGetPtosVenta(soap, "ns3:FEParamGetPtosVenta", -1, &a->ns3__FEParamGetPtosVenta, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetPtosVenta_ * SOAP_FMAC4 soap_in___ns3__FEParamGetPtosVenta_(struct soap *soap, const char *tag, struct __ns3__FEParamGetPtosVenta_ *a, const char *type)
{
	size_t soap_flag_ns3__FEParamGetPtosVenta = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FEParamGetPtosVenta_*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FEParamGetPtosVenta_, sizeof(struct __ns3__FEParamGetPtosVenta_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FEParamGetPtosVenta_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FEParamGetPtosVenta && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FEParamGetPtosVenta(soap, "ns3:FEParamGetPtosVenta", &a->ns3__FEParamGetPtosVenta, ""))
				{	soap_flag_ns3__FEParamGetPtosVenta--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FEParamGetPtosVenta_ * SOAP_FMAC2 soap_instantiate___ns3__FEParamGetPtosVenta_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FEParamGetPtosVenta_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FEParamGetPtosVenta_ *p;
	size_t k = sizeof(struct __ns3__FEParamGetPtosVenta_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FEParamGetPtosVenta_, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FEParamGetPtosVenta_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FEParamGetPtosVenta_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FEParamGetPtosVenta_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FEParamGetPtosVenta_(struct soap *soap, const struct __ns3__FEParamGetPtosVenta_ *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FEParamGetPtosVenta_(soap, tag ? tag : "-ns3:FEParamGetPtosVenta", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetPtosVenta_ * SOAP_FMAC4 soap_get___ns3__FEParamGetPtosVenta_(struct soap *soap, struct __ns3__FEParamGetPtosVenta_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FEParamGetPtosVenta_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FEParamGetTiposConcepto_(struct soap *soap, struct __ns3__FEParamGetTiposConcepto_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FEParamGetTiposConcepto = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FEParamGetTiposConcepto_(struct soap *soap, const struct __ns3__FEParamGetTiposConcepto_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FEParamGetTiposConcepto(soap, &a->ns3__FEParamGetTiposConcepto);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FEParamGetTiposConcepto_(struct soap *soap, const char *tag, int id, const struct __ns3__FEParamGetTiposConcepto_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FEParamGetTiposConcepto(soap, "ns3:FEParamGetTiposConcepto", -1, &a->ns3__FEParamGetTiposConcepto, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetTiposConcepto_ * SOAP_FMAC4 soap_in___ns3__FEParamGetTiposConcepto_(struct soap *soap, const char *tag, struct __ns3__FEParamGetTiposConcepto_ *a, const char *type)
{
	size_t soap_flag_ns3__FEParamGetTiposConcepto = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FEParamGetTiposConcepto_*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FEParamGetTiposConcepto_, sizeof(struct __ns3__FEParamGetTiposConcepto_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FEParamGetTiposConcepto_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FEParamGetTiposConcepto && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FEParamGetTiposConcepto(soap, "ns3:FEParamGetTiposConcepto", &a->ns3__FEParamGetTiposConcepto, ""))
				{	soap_flag_ns3__FEParamGetTiposConcepto--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FEParamGetTiposConcepto_ * SOAP_FMAC2 soap_instantiate___ns3__FEParamGetTiposConcepto_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FEParamGetTiposConcepto_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FEParamGetTiposConcepto_ *p;
	size_t k = sizeof(struct __ns3__FEParamGetTiposConcepto_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FEParamGetTiposConcepto_, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FEParamGetTiposConcepto_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FEParamGetTiposConcepto_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FEParamGetTiposConcepto_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FEParamGetTiposConcepto_(struct soap *soap, const struct __ns3__FEParamGetTiposConcepto_ *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FEParamGetTiposConcepto_(soap, tag ? tag : "-ns3:FEParamGetTiposConcepto", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetTiposConcepto_ * SOAP_FMAC4 soap_get___ns3__FEParamGetTiposConcepto_(struct soap *soap, struct __ns3__FEParamGetTiposConcepto_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FEParamGetTiposConcepto_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FEParamGetTiposOpcional_(struct soap *soap, struct __ns3__FEParamGetTiposOpcional_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FEParamGetTiposOpcional = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FEParamGetTiposOpcional_(struct soap *soap, const struct __ns3__FEParamGetTiposOpcional_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FEParamGetTiposOpcional(soap, &a->ns3__FEParamGetTiposOpcional);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FEParamGetTiposOpcional_(struct soap *soap, const char *tag, int id, const struct __ns3__FEParamGetTiposOpcional_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FEParamGetTiposOpcional(soap, "ns3:FEParamGetTiposOpcional", -1, &a->ns3__FEParamGetTiposOpcional, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetTiposOpcional_ * SOAP_FMAC4 soap_in___ns3__FEParamGetTiposOpcional_(struct soap *soap, const char *tag, struct __ns3__FEParamGetTiposOpcional_ *a, const char *type)
{
	size_t soap_flag_ns3__FEParamGetTiposOpcional = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FEParamGetTiposOpcional_*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FEParamGetTiposOpcional_, sizeof(struct __ns3__FEParamGetTiposOpcional_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FEParamGetTiposOpcional_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FEParamGetTiposOpcional && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FEParamGetTiposOpcional(soap, "ns3:FEParamGetTiposOpcional", &a->ns3__FEParamGetTiposOpcional, ""))
				{	soap_flag_ns3__FEParamGetTiposOpcional--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FEParamGetTiposOpcional_ * SOAP_FMAC2 soap_instantiate___ns3__FEParamGetTiposOpcional_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FEParamGetTiposOpcional_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FEParamGetTiposOpcional_ *p;
	size_t k = sizeof(struct __ns3__FEParamGetTiposOpcional_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FEParamGetTiposOpcional_, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FEParamGetTiposOpcional_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FEParamGetTiposOpcional_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FEParamGetTiposOpcional_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FEParamGetTiposOpcional_(struct soap *soap, const struct __ns3__FEParamGetTiposOpcional_ *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FEParamGetTiposOpcional_(soap, tag ? tag : "-ns3:FEParamGetTiposOpcional", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetTiposOpcional_ * SOAP_FMAC4 soap_get___ns3__FEParamGetTiposOpcional_(struct soap *soap, struct __ns3__FEParamGetTiposOpcional_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FEParamGetTiposOpcional_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FEParamGetTiposIva_(struct soap *soap, struct __ns3__FEParamGetTiposIva_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FEParamGetTiposIva = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FEParamGetTiposIva_(struct soap *soap, const struct __ns3__FEParamGetTiposIva_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FEParamGetTiposIva(soap, &a->ns3__FEParamGetTiposIva);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FEParamGetTiposIva_(struct soap *soap, const char *tag, int id, const struct __ns3__FEParamGetTiposIva_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FEParamGetTiposIva(soap, "ns3:FEParamGetTiposIva", -1, &a->ns3__FEParamGetTiposIva, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetTiposIva_ * SOAP_FMAC4 soap_in___ns3__FEParamGetTiposIva_(struct soap *soap, const char *tag, struct __ns3__FEParamGetTiposIva_ *a, const char *type)
{
	size_t soap_flag_ns3__FEParamGetTiposIva = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FEParamGetTiposIva_*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FEParamGetTiposIva_, sizeof(struct __ns3__FEParamGetTiposIva_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FEParamGetTiposIva_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FEParamGetTiposIva && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FEParamGetTiposIva(soap, "ns3:FEParamGetTiposIva", &a->ns3__FEParamGetTiposIva, ""))
				{	soap_flag_ns3__FEParamGetTiposIva--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FEParamGetTiposIva_ * SOAP_FMAC2 soap_instantiate___ns3__FEParamGetTiposIva_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FEParamGetTiposIva_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FEParamGetTiposIva_ *p;
	size_t k = sizeof(struct __ns3__FEParamGetTiposIva_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FEParamGetTiposIva_, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FEParamGetTiposIva_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FEParamGetTiposIva_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FEParamGetTiposIva_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FEParamGetTiposIva_(struct soap *soap, const struct __ns3__FEParamGetTiposIva_ *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FEParamGetTiposIva_(soap, tag ? tag : "-ns3:FEParamGetTiposIva", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetTiposIva_ * SOAP_FMAC4 soap_get___ns3__FEParamGetTiposIva_(struct soap *soap, struct __ns3__FEParamGetTiposIva_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FEParamGetTiposIva_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FEParamGetTiposMonedas_(struct soap *soap, struct __ns3__FEParamGetTiposMonedas_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FEParamGetTiposMonedas = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FEParamGetTiposMonedas_(struct soap *soap, const struct __ns3__FEParamGetTiposMonedas_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FEParamGetTiposMonedas(soap, &a->ns3__FEParamGetTiposMonedas);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FEParamGetTiposMonedas_(struct soap *soap, const char *tag, int id, const struct __ns3__FEParamGetTiposMonedas_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FEParamGetTiposMonedas(soap, "ns3:FEParamGetTiposMonedas", -1, &a->ns3__FEParamGetTiposMonedas, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetTiposMonedas_ * SOAP_FMAC4 soap_in___ns3__FEParamGetTiposMonedas_(struct soap *soap, const char *tag, struct __ns3__FEParamGetTiposMonedas_ *a, const char *type)
{
	size_t soap_flag_ns3__FEParamGetTiposMonedas = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FEParamGetTiposMonedas_*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FEParamGetTiposMonedas_, sizeof(struct __ns3__FEParamGetTiposMonedas_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FEParamGetTiposMonedas_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FEParamGetTiposMonedas && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FEParamGetTiposMonedas(soap, "ns3:FEParamGetTiposMonedas", &a->ns3__FEParamGetTiposMonedas, ""))
				{	soap_flag_ns3__FEParamGetTiposMonedas--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FEParamGetTiposMonedas_ * SOAP_FMAC2 soap_instantiate___ns3__FEParamGetTiposMonedas_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FEParamGetTiposMonedas_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FEParamGetTiposMonedas_ *p;
	size_t k = sizeof(struct __ns3__FEParamGetTiposMonedas_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FEParamGetTiposMonedas_, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FEParamGetTiposMonedas_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FEParamGetTiposMonedas_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FEParamGetTiposMonedas_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FEParamGetTiposMonedas_(struct soap *soap, const struct __ns3__FEParamGetTiposMonedas_ *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FEParamGetTiposMonedas_(soap, tag ? tag : "-ns3:FEParamGetTiposMonedas", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetTiposMonedas_ * SOAP_FMAC4 soap_get___ns3__FEParamGetTiposMonedas_(struct soap *soap, struct __ns3__FEParamGetTiposMonedas_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FEParamGetTiposMonedas_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FEParamGetTiposTributos_(struct soap *soap, struct __ns3__FEParamGetTiposTributos_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FEParamGetTiposTributos = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FEParamGetTiposTributos_(struct soap *soap, const struct __ns3__FEParamGetTiposTributos_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FEParamGetTiposTributos(soap, &a->ns3__FEParamGetTiposTributos);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FEParamGetTiposTributos_(struct soap *soap, const char *tag, int id, const struct __ns3__FEParamGetTiposTributos_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FEParamGetTiposTributos(soap, "ns3:FEParamGetTiposTributos", -1, &a->ns3__FEParamGetTiposTributos, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetTiposTributos_ * SOAP_FMAC4 soap_in___ns3__FEParamGetTiposTributos_(struct soap *soap, const char *tag, struct __ns3__FEParamGetTiposTributos_ *a, const char *type)
{
	size_t soap_flag_ns3__FEParamGetTiposTributos = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FEParamGetTiposTributos_*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FEParamGetTiposTributos_, sizeof(struct __ns3__FEParamGetTiposTributos_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FEParamGetTiposTributos_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FEParamGetTiposTributos && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FEParamGetTiposTributos(soap, "ns3:FEParamGetTiposTributos", &a->ns3__FEParamGetTiposTributos, ""))
				{	soap_flag_ns3__FEParamGetTiposTributos--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FEParamGetTiposTributos_ * SOAP_FMAC2 soap_instantiate___ns3__FEParamGetTiposTributos_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FEParamGetTiposTributos_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FEParamGetTiposTributos_ *p;
	size_t k = sizeof(struct __ns3__FEParamGetTiposTributos_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FEParamGetTiposTributos_, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FEParamGetTiposTributos_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FEParamGetTiposTributos_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FEParamGetTiposTributos_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FEParamGetTiposTributos_(struct soap *soap, const struct __ns3__FEParamGetTiposTributos_ *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FEParamGetTiposTributos_(soap, tag ? tag : "-ns3:FEParamGetTiposTributos", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetTiposTributos_ * SOAP_FMAC4 soap_get___ns3__FEParamGetTiposTributos_(struct soap *soap, struct __ns3__FEParamGetTiposTributos_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FEParamGetTiposTributos_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FEParamGetCotizacion_(struct soap *soap, struct __ns3__FEParamGetCotizacion_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FEParamGetCotizacion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FEParamGetCotizacion_(struct soap *soap, const struct __ns3__FEParamGetCotizacion_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FEParamGetCotizacion(soap, &a->ns3__FEParamGetCotizacion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FEParamGetCotizacion_(struct soap *soap, const char *tag, int id, const struct __ns3__FEParamGetCotizacion_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FEParamGetCotizacion(soap, "ns3:FEParamGetCotizacion", -1, &a->ns3__FEParamGetCotizacion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetCotizacion_ * SOAP_FMAC4 soap_in___ns3__FEParamGetCotizacion_(struct soap *soap, const char *tag, struct __ns3__FEParamGetCotizacion_ *a, const char *type)
{
	size_t soap_flag_ns3__FEParamGetCotizacion = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FEParamGetCotizacion_*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FEParamGetCotizacion_, sizeof(struct __ns3__FEParamGetCotizacion_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FEParamGetCotizacion_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FEParamGetCotizacion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FEParamGetCotizacion(soap, "ns3:FEParamGetCotizacion", &a->ns3__FEParamGetCotizacion, ""))
				{	soap_flag_ns3__FEParamGetCotizacion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FEParamGetCotizacion_ * SOAP_FMAC2 soap_instantiate___ns3__FEParamGetCotizacion_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FEParamGetCotizacion_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FEParamGetCotizacion_ *p;
	size_t k = sizeof(struct __ns3__FEParamGetCotizacion_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FEParamGetCotizacion_, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FEParamGetCotizacion_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FEParamGetCotizacion_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FEParamGetCotizacion_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FEParamGetCotizacion_(struct soap *soap, const struct __ns3__FEParamGetCotizacion_ *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FEParamGetCotizacion_(soap, tag ? tag : "-ns3:FEParamGetCotizacion", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetCotizacion_ * SOAP_FMAC4 soap_get___ns3__FEParamGetCotizacion_(struct soap *soap, struct __ns3__FEParamGetCotizacion_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FEParamGetCotizacion_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FECAEAConsultar_(struct soap *soap, struct __ns3__FECAEAConsultar_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FECAEAConsultar = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FECAEAConsultar_(struct soap *soap, const struct __ns3__FECAEAConsultar_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FECAEAConsultar(soap, &a->ns3__FECAEAConsultar);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FECAEAConsultar_(struct soap *soap, const char *tag, int id, const struct __ns3__FECAEAConsultar_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FECAEAConsultar(soap, "ns3:FECAEAConsultar", -1, &a->ns3__FECAEAConsultar, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECAEAConsultar_ * SOAP_FMAC4 soap_in___ns3__FECAEAConsultar_(struct soap *soap, const char *tag, struct __ns3__FECAEAConsultar_ *a, const char *type)
{
	size_t soap_flag_ns3__FECAEAConsultar = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FECAEAConsultar_*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FECAEAConsultar_, sizeof(struct __ns3__FECAEAConsultar_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FECAEAConsultar_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FECAEAConsultar && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FECAEAConsultar(soap, "ns3:FECAEAConsultar", &a->ns3__FECAEAConsultar, ""))
				{	soap_flag_ns3__FECAEAConsultar--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FECAEAConsultar_ * SOAP_FMAC2 soap_instantiate___ns3__FECAEAConsultar_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FECAEAConsultar_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FECAEAConsultar_ *p;
	size_t k = sizeof(struct __ns3__FECAEAConsultar_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FECAEAConsultar_, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FECAEAConsultar_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FECAEAConsultar_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FECAEAConsultar_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FECAEAConsultar_(struct soap *soap, const struct __ns3__FECAEAConsultar_ *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FECAEAConsultar_(soap, tag ? tag : "-ns3:FECAEAConsultar", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECAEAConsultar_ * SOAP_FMAC4 soap_get___ns3__FECAEAConsultar_(struct soap *soap, struct __ns3__FECAEAConsultar_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FECAEAConsultar_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FECAEASinMovimientoInformar_(struct soap *soap, struct __ns3__FECAEASinMovimientoInformar_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FECAEASinMovimientoInformar = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FECAEASinMovimientoInformar_(struct soap *soap, const struct __ns3__FECAEASinMovimientoInformar_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FECAEASinMovimientoInformar(soap, &a->ns3__FECAEASinMovimientoInformar);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FECAEASinMovimientoInformar_(struct soap *soap, const char *tag, int id, const struct __ns3__FECAEASinMovimientoInformar_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FECAEASinMovimientoInformar(soap, "ns3:FECAEASinMovimientoInformar", -1, &a->ns3__FECAEASinMovimientoInformar, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECAEASinMovimientoInformar_ * SOAP_FMAC4 soap_in___ns3__FECAEASinMovimientoInformar_(struct soap *soap, const char *tag, struct __ns3__FECAEASinMovimientoInformar_ *a, const char *type)
{
	size_t soap_flag_ns3__FECAEASinMovimientoInformar = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FECAEASinMovimientoInformar_*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FECAEASinMovimientoInformar_, sizeof(struct __ns3__FECAEASinMovimientoInformar_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FECAEASinMovimientoInformar_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FECAEASinMovimientoInformar && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FECAEASinMovimientoInformar(soap, "ns3:FECAEASinMovimientoInformar", &a->ns3__FECAEASinMovimientoInformar, ""))
				{	soap_flag_ns3__FECAEASinMovimientoInformar--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FECAEASinMovimientoInformar_ * SOAP_FMAC2 soap_instantiate___ns3__FECAEASinMovimientoInformar_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FECAEASinMovimientoInformar_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FECAEASinMovimientoInformar_ *p;
	size_t k = sizeof(struct __ns3__FECAEASinMovimientoInformar_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FECAEASinMovimientoInformar_, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FECAEASinMovimientoInformar_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FECAEASinMovimientoInformar_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FECAEASinMovimientoInformar_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FECAEASinMovimientoInformar_(struct soap *soap, const struct __ns3__FECAEASinMovimientoInformar_ *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FECAEASinMovimientoInformar_(soap, tag ? tag : "-ns3:FECAEASinMovimientoInformar", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECAEASinMovimientoInformar_ * SOAP_FMAC4 soap_get___ns3__FECAEASinMovimientoInformar_(struct soap *soap, struct __ns3__FECAEASinMovimientoInformar_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FECAEASinMovimientoInformar_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FECAEASinMovimientoConsultar_(struct soap *soap, struct __ns3__FECAEASinMovimientoConsultar_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FECAEASinMovimientoConsultar = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FECAEASinMovimientoConsultar_(struct soap *soap, const struct __ns3__FECAEASinMovimientoConsultar_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FECAEASinMovimientoConsultar(soap, &a->ns3__FECAEASinMovimientoConsultar);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FECAEASinMovimientoConsultar_(struct soap *soap, const char *tag, int id, const struct __ns3__FECAEASinMovimientoConsultar_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FECAEASinMovimientoConsultar(soap, "ns3:FECAEASinMovimientoConsultar", -1, &a->ns3__FECAEASinMovimientoConsultar, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECAEASinMovimientoConsultar_ * SOAP_FMAC4 soap_in___ns3__FECAEASinMovimientoConsultar_(struct soap *soap, const char *tag, struct __ns3__FECAEASinMovimientoConsultar_ *a, const char *type)
{
	size_t soap_flag_ns3__FECAEASinMovimientoConsultar = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FECAEASinMovimientoConsultar_*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FECAEASinMovimientoConsultar_, sizeof(struct __ns3__FECAEASinMovimientoConsultar_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FECAEASinMovimientoConsultar_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FECAEASinMovimientoConsultar && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FECAEASinMovimientoConsultar(soap, "ns3:FECAEASinMovimientoConsultar", &a->ns3__FECAEASinMovimientoConsultar, ""))
				{	soap_flag_ns3__FECAEASinMovimientoConsultar--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FECAEASinMovimientoConsultar_ * SOAP_FMAC2 soap_instantiate___ns3__FECAEASinMovimientoConsultar_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FECAEASinMovimientoConsultar_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FECAEASinMovimientoConsultar_ *p;
	size_t k = sizeof(struct __ns3__FECAEASinMovimientoConsultar_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FECAEASinMovimientoConsultar_, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FECAEASinMovimientoConsultar_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FECAEASinMovimientoConsultar_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FECAEASinMovimientoConsultar_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FECAEASinMovimientoConsultar_(struct soap *soap, const struct __ns3__FECAEASinMovimientoConsultar_ *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FECAEASinMovimientoConsultar_(soap, tag ? tag : "-ns3:FECAEASinMovimientoConsultar", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECAEASinMovimientoConsultar_ * SOAP_FMAC4 soap_get___ns3__FECAEASinMovimientoConsultar_(struct soap *soap, struct __ns3__FECAEASinMovimientoConsultar_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FECAEASinMovimientoConsultar_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FECAEASolicitar_(struct soap *soap, struct __ns3__FECAEASolicitar_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FECAEASolicitar = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FECAEASolicitar_(struct soap *soap, const struct __ns3__FECAEASolicitar_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FECAEASolicitar(soap, &a->ns3__FECAEASolicitar);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FECAEASolicitar_(struct soap *soap, const char *tag, int id, const struct __ns3__FECAEASolicitar_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FECAEASolicitar(soap, "ns3:FECAEASolicitar", -1, &a->ns3__FECAEASolicitar, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECAEASolicitar_ * SOAP_FMAC4 soap_in___ns3__FECAEASolicitar_(struct soap *soap, const char *tag, struct __ns3__FECAEASolicitar_ *a, const char *type)
{
	size_t soap_flag_ns3__FECAEASolicitar = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FECAEASolicitar_*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FECAEASolicitar_, sizeof(struct __ns3__FECAEASolicitar_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FECAEASolicitar_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FECAEASolicitar && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FECAEASolicitar(soap, "ns3:FECAEASolicitar", &a->ns3__FECAEASolicitar, ""))
				{	soap_flag_ns3__FECAEASolicitar--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FECAEASolicitar_ * SOAP_FMAC2 soap_instantiate___ns3__FECAEASolicitar_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FECAEASolicitar_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FECAEASolicitar_ *p;
	size_t k = sizeof(struct __ns3__FECAEASolicitar_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FECAEASolicitar_, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FECAEASolicitar_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FECAEASolicitar_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FECAEASolicitar_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FECAEASolicitar_(struct soap *soap, const struct __ns3__FECAEASolicitar_ *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FECAEASolicitar_(soap, tag ? tag : "-ns3:FECAEASolicitar", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECAEASolicitar_ * SOAP_FMAC4 soap_get___ns3__FECAEASolicitar_(struct soap *soap, struct __ns3__FECAEASolicitar_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FECAEASolicitar_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FECAEARegInformativo_(struct soap *soap, struct __ns3__FECAEARegInformativo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FECAEARegInformativo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FECAEARegInformativo_(struct soap *soap, const struct __ns3__FECAEARegInformativo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FECAEARegInformativo(soap, &a->ns3__FECAEARegInformativo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FECAEARegInformativo_(struct soap *soap, const char *tag, int id, const struct __ns3__FECAEARegInformativo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FECAEARegInformativo(soap, "ns3:FECAEARegInformativo", -1, &a->ns3__FECAEARegInformativo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECAEARegInformativo_ * SOAP_FMAC4 soap_in___ns3__FECAEARegInformativo_(struct soap *soap, const char *tag, struct __ns3__FECAEARegInformativo_ *a, const char *type)
{
	size_t soap_flag_ns3__FECAEARegInformativo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FECAEARegInformativo_*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FECAEARegInformativo_, sizeof(struct __ns3__FECAEARegInformativo_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FECAEARegInformativo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FECAEARegInformativo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FECAEARegInformativo(soap, "ns3:FECAEARegInformativo", &a->ns3__FECAEARegInformativo, ""))
				{	soap_flag_ns3__FECAEARegInformativo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FECAEARegInformativo_ * SOAP_FMAC2 soap_instantiate___ns3__FECAEARegInformativo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FECAEARegInformativo_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FECAEARegInformativo_ *p;
	size_t k = sizeof(struct __ns3__FECAEARegInformativo_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FECAEARegInformativo_, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FECAEARegInformativo_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FECAEARegInformativo_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FECAEARegInformativo_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FECAEARegInformativo_(struct soap *soap, const struct __ns3__FECAEARegInformativo_ *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FECAEARegInformativo_(soap, tag ? tag : "-ns3:FECAEARegInformativo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECAEARegInformativo_ * SOAP_FMAC4 soap_get___ns3__FECAEARegInformativo_(struct soap *soap, struct __ns3__FECAEARegInformativo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FECAEARegInformativo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FECompConsultar_(struct soap *soap, struct __ns3__FECompConsultar_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FECompConsultar = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FECompConsultar_(struct soap *soap, const struct __ns3__FECompConsultar_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FECompConsultar(soap, &a->ns3__FECompConsultar);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FECompConsultar_(struct soap *soap, const char *tag, int id, const struct __ns3__FECompConsultar_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FECompConsultar(soap, "ns3:FECompConsultar", -1, &a->ns3__FECompConsultar, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECompConsultar_ * SOAP_FMAC4 soap_in___ns3__FECompConsultar_(struct soap *soap, const char *tag, struct __ns3__FECompConsultar_ *a, const char *type)
{
	size_t soap_flag_ns3__FECompConsultar = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FECompConsultar_*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FECompConsultar_, sizeof(struct __ns3__FECompConsultar_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FECompConsultar_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FECompConsultar && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FECompConsultar(soap, "ns3:FECompConsultar", &a->ns3__FECompConsultar, ""))
				{	soap_flag_ns3__FECompConsultar--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FECompConsultar_ * SOAP_FMAC2 soap_instantiate___ns3__FECompConsultar_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FECompConsultar_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FECompConsultar_ *p;
	size_t k = sizeof(struct __ns3__FECompConsultar_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FECompConsultar_, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FECompConsultar_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FECompConsultar_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FECompConsultar_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FECompConsultar_(struct soap *soap, const struct __ns3__FECompConsultar_ *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FECompConsultar_(soap, tag ? tag : "-ns3:FECompConsultar", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECompConsultar_ * SOAP_FMAC4 soap_get___ns3__FECompConsultar_(struct soap *soap, struct __ns3__FECompConsultar_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FECompConsultar_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FECompUltimoAutorizado_(struct soap *soap, struct __ns3__FECompUltimoAutorizado_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FECompUltimoAutorizado = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FECompUltimoAutorizado_(struct soap *soap, const struct __ns3__FECompUltimoAutorizado_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FECompUltimoAutorizado(soap, &a->ns3__FECompUltimoAutorizado);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FECompUltimoAutorizado_(struct soap *soap, const char *tag, int id, const struct __ns3__FECompUltimoAutorizado_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FECompUltimoAutorizado(soap, "ns3:FECompUltimoAutorizado", -1, &a->ns3__FECompUltimoAutorizado, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECompUltimoAutorizado_ * SOAP_FMAC4 soap_in___ns3__FECompUltimoAutorizado_(struct soap *soap, const char *tag, struct __ns3__FECompUltimoAutorizado_ *a, const char *type)
{
	size_t soap_flag_ns3__FECompUltimoAutorizado = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FECompUltimoAutorizado_*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FECompUltimoAutorizado_, sizeof(struct __ns3__FECompUltimoAutorizado_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FECompUltimoAutorizado_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FECompUltimoAutorizado && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FECompUltimoAutorizado(soap, "ns3:FECompUltimoAutorizado", &a->ns3__FECompUltimoAutorizado, ""))
				{	soap_flag_ns3__FECompUltimoAutorizado--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FECompUltimoAutorizado_ * SOAP_FMAC2 soap_instantiate___ns3__FECompUltimoAutorizado_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FECompUltimoAutorizado_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FECompUltimoAutorizado_ *p;
	size_t k = sizeof(struct __ns3__FECompUltimoAutorizado_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FECompUltimoAutorizado_, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FECompUltimoAutorizado_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FECompUltimoAutorizado_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FECompUltimoAutorizado_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FECompUltimoAutorizado_(struct soap *soap, const struct __ns3__FECompUltimoAutorizado_ *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FECompUltimoAutorizado_(soap, tag ? tag : "-ns3:FECompUltimoAutorizado", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECompUltimoAutorizado_ * SOAP_FMAC4 soap_get___ns3__FECompUltimoAutorizado_(struct soap *soap, struct __ns3__FECompUltimoAutorizado_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FECompUltimoAutorizado_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FEDummy_(struct soap *soap, struct __ns3__FEDummy_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FEDummy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FEDummy_(struct soap *soap, const struct __ns3__FEDummy_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FEDummy(soap, &a->ns3__FEDummy);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FEDummy_(struct soap *soap, const char *tag, int id, const struct __ns3__FEDummy_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FEDummy(soap, "ns3:FEDummy", -1, &a->ns3__FEDummy, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEDummy_ * SOAP_FMAC4 soap_in___ns3__FEDummy_(struct soap *soap, const char *tag, struct __ns3__FEDummy_ *a, const char *type)
{
	size_t soap_flag_ns3__FEDummy = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FEDummy_*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FEDummy_, sizeof(struct __ns3__FEDummy_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FEDummy_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FEDummy && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FEDummy(soap, "ns3:FEDummy", &a->ns3__FEDummy, ""))
				{	soap_flag_ns3__FEDummy--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FEDummy_ * SOAP_FMAC2 soap_instantiate___ns3__FEDummy_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FEDummy_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FEDummy_ *p;
	size_t k = sizeof(struct __ns3__FEDummy_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FEDummy_, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FEDummy_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FEDummy_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FEDummy_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FEDummy_(struct soap *soap, const struct __ns3__FEDummy_ *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FEDummy_(soap, tag ? tag : "-ns3:FEDummy", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEDummy_ * SOAP_FMAC4 soap_get___ns3__FEDummy_(struct soap *soap, struct __ns3__FEDummy_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FEDummy_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FECompTotXRequest_(struct soap *soap, struct __ns3__FECompTotXRequest_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FECompTotXRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FECompTotXRequest_(struct soap *soap, const struct __ns3__FECompTotXRequest_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FECompTotXRequest(soap, &a->ns3__FECompTotXRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FECompTotXRequest_(struct soap *soap, const char *tag, int id, const struct __ns3__FECompTotXRequest_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FECompTotXRequest(soap, "ns3:FECompTotXRequest", -1, &a->ns3__FECompTotXRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECompTotXRequest_ * SOAP_FMAC4 soap_in___ns3__FECompTotXRequest_(struct soap *soap, const char *tag, struct __ns3__FECompTotXRequest_ *a, const char *type)
{
	size_t soap_flag_ns3__FECompTotXRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FECompTotXRequest_*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FECompTotXRequest_, sizeof(struct __ns3__FECompTotXRequest_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FECompTotXRequest_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FECompTotXRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FECompTotXRequest(soap, "ns3:FECompTotXRequest", &a->ns3__FECompTotXRequest, ""))
				{	soap_flag_ns3__FECompTotXRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FECompTotXRequest_ * SOAP_FMAC2 soap_instantiate___ns3__FECompTotXRequest_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FECompTotXRequest_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FECompTotXRequest_ *p;
	size_t k = sizeof(struct __ns3__FECompTotXRequest_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FECompTotXRequest_, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FECompTotXRequest_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FECompTotXRequest_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FECompTotXRequest_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FECompTotXRequest_(struct soap *soap, const struct __ns3__FECompTotXRequest_ *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FECompTotXRequest_(soap, tag ? tag : "-ns3:FECompTotXRequest", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECompTotXRequest_ * SOAP_FMAC4 soap_get___ns3__FECompTotXRequest_(struct soap *soap, struct __ns3__FECompTotXRequest_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FECompTotXRequest_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FECAESolicitar_(struct soap *soap, struct __ns3__FECAESolicitar_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FECAESolicitar = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FECAESolicitar_(struct soap *soap, const struct __ns3__FECAESolicitar_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FECAESolicitar(soap, &a->ns3__FECAESolicitar);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FECAESolicitar_(struct soap *soap, const char *tag, int id, const struct __ns3__FECAESolicitar_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FECAESolicitar(soap, "ns3:FECAESolicitar", -1, &a->ns3__FECAESolicitar, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECAESolicitar_ * SOAP_FMAC4 soap_in___ns3__FECAESolicitar_(struct soap *soap, const char *tag, struct __ns3__FECAESolicitar_ *a, const char *type)
{
	size_t soap_flag_ns3__FECAESolicitar = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FECAESolicitar_*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FECAESolicitar_, sizeof(struct __ns3__FECAESolicitar_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FECAESolicitar_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FECAESolicitar && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FECAESolicitar(soap, "ns3:FECAESolicitar", &a->ns3__FECAESolicitar, ""))
				{	soap_flag_ns3__FECAESolicitar--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FECAESolicitar_ * SOAP_FMAC2 soap_instantiate___ns3__FECAESolicitar_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FECAESolicitar_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FECAESolicitar_ *p;
	size_t k = sizeof(struct __ns3__FECAESolicitar_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FECAESolicitar_, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FECAESolicitar_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FECAESolicitar_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FECAESolicitar_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FECAESolicitar_(struct soap *soap, const struct __ns3__FECAESolicitar_ *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FECAESolicitar_(soap, tag ? tag : "-ns3:FECAESolicitar", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECAESolicitar_ * SOAP_FMAC4 soap_get___ns3__FECAESolicitar_(struct soap *soap, struct __ns3__FECAESolicitar_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FECAESolicitar_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FEParamGetTiposPaises(struct soap *soap, struct __ns3__FEParamGetTiposPaises *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FEParamGetTiposPaises = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FEParamGetTiposPaises(struct soap *soap, const struct __ns3__FEParamGetTiposPaises *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FEParamGetTiposPaises(soap, &a->ns3__FEParamGetTiposPaises);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FEParamGetTiposPaises(struct soap *soap, const char *tag, int id, const struct __ns3__FEParamGetTiposPaises *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FEParamGetTiposPaises(soap, "ns3:FEParamGetTiposPaises", -1, &a->ns3__FEParamGetTiposPaises, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetTiposPaises * SOAP_FMAC4 soap_in___ns3__FEParamGetTiposPaises(struct soap *soap, const char *tag, struct __ns3__FEParamGetTiposPaises *a, const char *type)
{
	size_t soap_flag_ns3__FEParamGetTiposPaises = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FEParamGetTiposPaises*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FEParamGetTiposPaises, sizeof(struct __ns3__FEParamGetTiposPaises), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FEParamGetTiposPaises(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FEParamGetTiposPaises && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FEParamGetTiposPaises(soap, "ns3:FEParamGetTiposPaises", &a->ns3__FEParamGetTiposPaises, ""))
				{	soap_flag_ns3__FEParamGetTiposPaises--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FEParamGetTiposPaises * SOAP_FMAC2 soap_instantiate___ns3__FEParamGetTiposPaises(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FEParamGetTiposPaises(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FEParamGetTiposPaises *p;
	size_t k = sizeof(struct __ns3__FEParamGetTiposPaises);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FEParamGetTiposPaises, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FEParamGetTiposPaises);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FEParamGetTiposPaises, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FEParamGetTiposPaises location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FEParamGetTiposPaises(struct soap *soap, const struct __ns3__FEParamGetTiposPaises *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FEParamGetTiposPaises(soap, tag ? tag : "-ns3:FEParamGetTiposPaises", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetTiposPaises * SOAP_FMAC4 soap_get___ns3__FEParamGetTiposPaises(struct soap *soap, struct __ns3__FEParamGetTiposPaises *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FEParamGetTiposPaises(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FEParamGetTiposDoc(struct soap *soap, struct __ns3__FEParamGetTiposDoc *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FEParamGetTiposDoc = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FEParamGetTiposDoc(struct soap *soap, const struct __ns3__FEParamGetTiposDoc *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FEParamGetTiposDoc(soap, &a->ns3__FEParamGetTiposDoc);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FEParamGetTiposDoc(struct soap *soap, const char *tag, int id, const struct __ns3__FEParamGetTiposDoc *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FEParamGetTiposDoc(soap, "ns3:FEParamGetTiposDoc", -1, &a->ns3__FEParamGetTiposDoc, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetTiposDoc * SOAP_FMAC4 soap_in___ns3__FEParamGetTiposDoc(struct soap *soap, const char *tag, struct __ns3__FEParamGetTiposDoc *a, const char *type)
{
	size_t soap_flag_ns3__FEParamGetTiposDoc = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FEParamGetTiposDoc*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FEParamGetTiposDoc, sizeof(struct __ns3__FEParamGetTiposDoc), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FEParamGetTiposDoc(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FEParamGetTiposDoc && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FEParamGetTiposDoc(soap, "ns3:FEParamGetTiposDoc", &a->ns3__FEParamGetTiposDoc, ""))
				{	soap_flag_ns3__FEParamGetTiposDoc--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FEParamGetTiposDoc * SOAP_FMAC2 soap_instantiate___ns3__FEParamGetTiposDoc(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FEParamGetTiposDoc(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FEParamGetTiposDoc *p;
	size_t k = sizeof(struct __ns3__FEParamGetTiposDoc);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FEParamGetTiposDoc, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FEParamGetTiposDoc);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FEParamGetTiposDoc, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FEParamGetTiposDoc location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FEParamGetTiposDoc(struct soap *soap, const struct __ns3__FEParamGetTiposDoc *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FEParamGetTiposDoc(soap, tag ? tag : "-ns3:FEParamGetTiposDoc", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetTiposDoc * SOAP_FMAC4 soap_get___ns3__FEParamGetTiposDoc(struct soap *soap, struct __ns3__FEParamGetTiposDoc *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FEParamGetTiposDoc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FEParamGetTiposCbte(struct soap *soap, struct __ns3__FEParamGetTiposCbte *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FEParamGetTiposCbte = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FEParamGetTiposCbte(struct soap *soap, const struct __ns3__FEParamGetTiposCbte *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FEParamGetTiposCbte(soap, &a->ns3__FEParamGetTiposCbte);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FEParamGetTiposCbte(struct soap *soap, const char *tag, int id, const struct __ns3__FEParamGetTiposCbte *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FEParamGetTiposCbte(soap, "ns3:FEParamGetTiposCbte", -1, &a->ns3__FEParamGetTiposCbte, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetTiposCbte * SOAP_FMAC4 soap_in___ns3__FEParamGetTiposCbte(struct soap *soap, const char *tag, struct __ns3__FEParamGetTiposCbte *a, const char *type)
{
	size_t soap_flag_ns3__FEParamGetTiposCbte = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FEParamGetTiposCbte*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FEParamGetTiposCbte, sizeof(struct __ns3__FEParamGetTiposCbte), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FEParamGetTiposCbte(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FEParamGetTiposCbte && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FEParamGetTiposCbte(soap, "ns3:FEParamGetTiposCbte", &a->ns3__FEParamGetTiposCbte, ""))
				{	soap_flag_ns3__FEParamGetTiposCbte--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FEParamGetTiposCbte * SOAP_FMAC2 soap_instantiate___ns3__FEParamGetTiposCbte(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FEParamGetTiposCbte(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FEParamGetTiposCbte *p;
	size_t k = sizeof(struct __ns3__FEParamGetTiposCbte);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FEParamGetTiposCbte, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FEParamGetTiposCbte);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FEParamGetTiposCbte, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FEParamGetTiposCbte location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FEParamGetTiposCbte(struct soap *soap, const struct __ns3__FEParamGetTiposCbte *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FEParamGetTiposCbte(soap, tag ? tag : "-ns3:FEParamGetTiposCbte", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetTiposCbte * SOAP_FMAC4 soap_get___ns3__FEParamGetTiposCbte(struct soap *soap, struct __ns3__FEParamGetTiposCbte *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FEParamGetTiposCbte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FEParamGetPtosVenta(struct soap *soap, struct __ns3__FEParamGetPtosVenta *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FEParamGetPtosVenta = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FEParamGetPtosVenta(struct soap *soap, const struct __ns3__FEParamGetPtosVenta *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FEParamGetPtosVenta(soap, &a->ns3__FEParamGetPtosVenta);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FEParamGetPtosVenta(struct soap *soap, const char *tag, int id, const struct __ns3__FEParamGetPtosVenta *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FEParamGetPtosVenta(soap, "ns3:FEParamGetPtosVenta", -1, &a->ns3__FEParamGetPtosVenta, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetPtosVenta * SOAP_FMAC4 soap_in___ns3__FEParamGetPtosVenta(struct soap *soap, const char *tag, struct __ns3__FEParamGetPtosVenta *a, const char *type)
{
	size_t soap_flag_ns3__FEParamGetPtosVenta = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FEParamGetPtosVenta*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FEParamGetPtosVenta, sizeof(struct __ns3__FEParamGetPtosVenta), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FEParamGetPtosVenta(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FEParamGetPtosVenta && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FEParamGetPtosVenta(soap, "ns3:FEParamGetPtosVenta", &a->ns3__FEParamGetPtosVenta, ""))
				{	soap_flag_ns3__FEParamGetPtosVenta--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FEParamGetPtosVenta * SOAP_FMAC2 soap_instantiate___ns3__FEParamGetPtosVenta(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FEParamGetPtosVenta(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FEParamGetPtosVenta *p;
	size_t k = sizeof(struct __ns3__FEParamGetPtosVenta);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FEParamGetPtosVenta, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FEParamGetPtosVenta);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FEParamGetPtosVenta, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FEParamGetPtosVenta location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FEParamGetPtosVenta(struct soap *soap, const struct __ns3__FEParamGetPtosVenta *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FEParamGetPtosVenta(soap, tag ? tag : "-ns3:FEParamGetPtosVenta", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetPtosVenta * SOAP_FMAC4 soap_get___ns3__FEParamGetPtosVenta(struct soap *soap, struct __ns3__FEParamGetPtosVenta *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FEParamGetPtosVenta(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FEParamGetTiposConcepto(struct soap *soap, struct __ns3__FEParamGetTiposConcepto *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FEParamGetTiposConcepto = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FEParamGetTiposConcepto(struct soap *soap, const struct __ns3__FEParamGetTiposConcepto *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FEParamGetTiposConcepto(soap, &a->ns3__FEParamGetTiposConcepto);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FEParamGetTiposConcepto(struct soap *soap, const char *tag, int id, const struct __ns3__FEParamGetTiposConcepto *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FEParamGetTiposConcepto(soap, "ns3:FEParamGetTiposConcepto", -1, &a->ns3__FEParamGetTiposConcepto, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetTiposConcepto * SOAP_FMAC4 soap_in___ns3__FEParamGetTiposConcepto(struct soap *soap, const char *tag, struct __ns3__FEParamGetTiposConcepto *a, const char *type)
{
	size_t soap_flag_ns3__FEParamGetTiposConcepto = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FEParamGetTiposConcepto*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FEParamGetTiposConcepto, sizeof(struct __ns3__FEParamGetTiposConcepto), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FEParamGetTiposConcepto(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FEParamGetTiposConcepto && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FEParamGetTiposConcepto(soap, "ns3:FEParamGetTiposConcepto", &a->ns3__FEParamGetTiposConcepto, ""))
				{	soap_flag_ns3__FEParamGetTiposConcepto--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FEParamGetTiposConcepto * SOAP_FMAC2 soap_instantiate___ns3__FEParamGetTiposConcepto(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FEParamGetTiposConcepto(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FEParamGetTiposConcepto *p;
	size_t k = sizeof(struct __ns3__FEParamGetTiposConcepto);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FEParamGetTiposConcepto, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FEParamGetTiposConcepto);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FEParamGetTiposConcepto, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FEParamGetTiposConcepto location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FEParamGetTiposConcepto(struct soap *soap, const struct __ns3__FEParamGetTiposConcepto *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FEParamGetTiposConcepto(soap, tag ? tag : "-ns3:FEParamGetTiposConcepto", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetTiposConcepto * SOAP_FMAC4 soap_get___ns3__FEParamGetTiposConcepto(struct soap *soap, struct __ns3__FEParamGetTiposConcepto *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FEParamGetTiposConcepto(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FEParamGetTiposOpcional(struct soap *soap, struct __ns3__FEParamGetTiposOpcional *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FEParamGetTiposOpcional = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FEParamGetTiposOpcional(struct soap *soap, const struct __ns3__FEParamGetTiposOpcional *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FEParamGetTiposOpcional(soap, &a->ns3__FEParamGetTiposOpcional);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FEParamGetTiposOpcional(struct soap *soap, const char *tag, int id, const struct __ns3__FEParamGetTiposOpcional *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FEParamGetTiposOpcional(soap, "ns3:FEParamGetTiposOpcional", -1, &a->ns3__FEParamGetTiposOpcional, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetTiposOpcional * SOAP_FMAC4 soap_in___ns3__FEParamGetTiposOpcional(struct soap *soap, const char *tag, struct __ns3__FEParamGetTiposOpcional *a, const char *type)
{
	size_t soap_flag_ns3__FEParamGetTiposOpcional = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FEParamGetTiposOpcional*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FEParamGetTiposOpcional, sizeof(struct __ns3__FEParamGetTiposOpcional), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FEParamGetTiposOpcional(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FEParamGetTiposOpcional && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FEParamGetTiposOpcional(soap, "ns3:FEParamGetTiposOpcional", &a->ns3__FEParamGetTiposOpcional, ""))
				{	soap_flag_ns3__FEParamGetTiposOpcional--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FEParamGetTiposOpcional * SOAP_FMAC2 soap_instantiate___ns3__FEParamGetTiposOpcional(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FEParamGetTiposOpcional(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FEParamGetTiposOpcional *p;
	size_t k = sizeof(struct __ns3__FEParamGetTiposOpcional);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FEParamGetTiposOpcional, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FEParamGetTiposOpcional);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FEParamGetTiposOpcional, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FEParamGetTiposOpcional location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FEParamGetTiposOpcional(struct soap *soap, const struct __ns3__FEParamGetTiposOpcional *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FEParamGetTiposOpcional(soap, tag ? tag : "-ns3:FEParamGetTiposOpcional", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetTiposOpcional * SOAP_FMAC4 soap_get___ns3__FEParamGetTiposOpcional(struct soap *soap, struct __ns3__FEParamGetTiposOpcional *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FEParamGetTiposOpcional(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FEParamGetTiposIva(struct soap *soap, struct __ns3__FEParamGetTiposIva *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FEParamGetTiposIva = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FEParamGetTiposIva(struct soap *soap, const struct __ns3__FEParamGetTiposIva *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FEParamGetTiposIva(soap, &a->ns3__FEParamGetTiposIva);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FEParamGetTiposIva(struct soap *soap, const char *tag, int id, const struct __ns3__FEParamGetTiposIva *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FEParamGetTiposIva(soap, "ns3:FEParamGetTiposIva", -1, &a->ns3__FEParamGetTiposIva, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetTiposIva * SOAP_FMAC4 soap_in___ns3__FEParamGetTiposIva(struct soap *soap, const char *tag, struct __ns3__FEParamGetTiposIva *a, const char *type)
{
	size_t soap_flag_ns3__FEParamGetTiposIva = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FEParamGetTiposIva*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FEParamGetTiposIva, sizeof(struct __ns3__FEParamGetTiposIva), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FEParamGetTiposIva(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FEParamGetTiposIva && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FEParamGetTiposIva(soap, "ns3:FEParamGetTiposIva", &a->ns3__FEParamGetTiposIva, ""))
				{	soap_flag_ns3__FEParamGetTiposIva--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FEParamGetTiposIva * SOAP_FMAC2 soap_instantiate___ns3__FEParamGetTiposIva(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FEParamGetTiposIva(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FEParamGetTiposIva *p;
	size_t k = sizeof(struct __ns3__FEParamGetTiposIva);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FEParamGetTiposIva, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FEParamGetTiposIva);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FEParamGetTiposIva, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FEParamGetTiposIva location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FEParamGetTiposIva(struct soap *soap, const struct __ns3__FEParamGetTiposIva *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FEParamGetTiposIva(soap, tag ? tag : "-ns3:FEParamGetTiposIva", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetTiposIva * SOAP_FMAC4 soap_get___ns3__FEParamGetTiposIva(struct soap *soap, struct __ns3__FEParamGetTiposIva *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FEParamGetTiposIva(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FEParamGetTiposMonedas(struct soap *soap, struct __ns3__FEParamGetTiposMonedas *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FEParamGetTiposMonedas = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FEParamGetTiposMonedas(struct soap *soap, const struct __ns3__FEParamGetTiposMonedas *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FEParamGetTiposMonedas(soap, &a->ns3__FEParamGetTiposMonedas);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FEParamGetTiposMonedas(struct soap *soap, const char *tag, int id, const struct __ns3__FEParamGetTiposMonedas *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FEParamGetTiposMonedas(soap, "ns3:FEParamGetTiposMonedas", -1, &a->ns3__FEParamGetTiposMonedas, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetTiposMonedas * SOAP_FMAC4 soap_in___ns3__FEParamGetTiposMonedas(struct soap *soap, const char *tag, struct __ns3__FEParamGetTiposMonedas *a, const char *type)
{
	size_t soap_flag_ns3__FEParamGetTiposMonedas = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FEParamGetTiposMonedas*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FEParamGetTiposMonedas, sizeof(struct __ns3__FEParamGetTiposMonedas), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FEParamGetTiposMonedas(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FEParamGetTiposMonedas && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FEParamGetTiposMonedas(soap, "ns3:FEParamGetTiposMonedas", &a->ns3__FEParamGetTiposMonedas, ""))
				{	soap_flag_ns3__FEParamGetTiposMonedas--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FEParamGetTiposMonedas * SOAP_FMAC2 soap_instantiate___ns3__FEParamGetTiposMonedas(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FEParamGetTiposMonedas(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FEParamGetTiposMonedas *p;
	size_t k = sizeof(struct __ns3__FEParamGetTiposMonedas);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FEParamGetTiposMonedas, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FEParamGetTiposMonedas);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FEParamGetTiposMonedas, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FEParamGetTiposMonedas location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FEParamGetTiposMonedas(struct soap *soap, const struct __ns3__FEParamGetTiposMonedas *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FEParamGetTiposMonedas(soap, tag ? tag : "-ns3:FEParamGetTiposMonedas", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetTiposMonedas * SOAP_FMAC4 soap_get___ns3__FEParamGetTiposMonedas(struct soap *soap, struct __ns3__FEParamGetTiposMonedas *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FEParamGetTiposMonedas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FEParamGetTiposTributos(struct soap *soap, struct __ns3__FEParamGetTiposTributos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FEParamGetTiposTributos = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FEParamGetTiposTributos(struct soap *soap, const struct __ns3__FEParamGetTiposTributos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FEParamGetTiposTributos(soap, &a->ns3__FEParamGetTiposTributos);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FEParamGetTiposTributos(struct soap *soap, const char *tag, int id, const struct __ns3__FEParamGetTiposTributos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FEParamGetTiposTributos(soap, "ns3:FEParamGetTiposTributos", -1, &a->ns3__FEParamGetTiposTributos, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetTiposTributos * SOAP_FMAC4 soap_in___ns3__FEParamGetTiposTributos(struct soap *soap, const char *tag, struct __ns3__FEParamGetTiposTributos *a, const char *type)
{
	size_t soap_flag_ns3__FEParamGetTiposTributos = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FEParamGetTiposTributos*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FEParamGetTiposTributos, sizeof(struct __ns3__FEParamGetTiposTributos), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FEParamGetTiposTributos(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FEParamGetTiposTributos && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FEParamGetTiposTributos(soap, "ns3:FEParamGetTiposTributos", &a->ns3__FEParamGetTiposTributos, ""))
				{	soap_flag_ns3__FEParamGetTiposTributos--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FEParamGetTiposTributos * SOAP_FMAC2 soap_instantiate___ns3__FEParamGetTiposTributos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FEParamGetTiposTributos(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FEParamGetTiposTributos *p;
	size_t k = sizeof(struct __ns3__FEParamGetTiposTributos);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FEParamGetTiposTributos, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FEParamGetTiposTributos);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FEParamGetTiposTributos, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FEParamGetTiposTributos location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FEParamGetTiposTributos(struct soap *soap, const struct __ns3__FEParamGetTiposTributos *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FEParamGetTiposTributos(soap, tag ? tag : "-ns3:FEParamGetTiposTributos", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetTiposTributos * SOAP_FMAC4 soap_get___ns3__FEParamGetTiposTributos(struct soap *soap, struct __ns3__FEParamGetTiposTributos *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FEParamGetTiposTributos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FEParamGetCotizacion(struct soap *soap, struct __ns3__FEParamGetCotizacion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FEParamGetCotizacion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FEParamGetCotizacion(struct soap *soap, const struct __ns3__FEParamGetCotizacion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FEParamGetCotizacion(soap, &a->ns3__FEParamGetCotizacion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FEParamGetCotizacion(struct soap *soap, const char *tag, int id, const struct __ns3__FEParamGetCotizacion *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FEParamGetCotizacion(soap, "ns3:FEParamGetCotizacion", -1, &a->ns3__FEParamGetCotizacion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetCotizacion * SOAP_FMAC4 soap_in___ns3__FEParamGetCotizacion(struct soap *soap, const char *tag, struct __ns3__FEParamGetCotizacion *a, const char *type)
{
	size_t soap_flag_ns3__FEParamGetCotizacion = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FEParamGetCotizacion*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FEParamGetCotizacion, sizeof(struct __ns3__FEParamGetCotizacion), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FEParamGetCotizacion(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FEParamGetCotizacion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FEParamGetCotizacion(soap, "ns3:FEParamGetCotizacion", &a->ns3__FEParamGetCotizacion, ""))
				{	soap_flag_ns3__FEParamGetCotizacion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FEParamGetCotizacion * SOAP_FMAC2 soap_instantiate___ns3__FEParamGetCotizacion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FEParamGetCotizacion(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FEParamGetCotizacion *p;
	size_t k = sizeof(struct __ns3__FEParamGetCotizacion);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FEParamGetCotizacion, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FEParamGetCotizacion);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FEParamGetCotizacion, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FEParamGetCotizacion location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FEParamGetCotizacion(struct soap *soap, const struct __ns3__FEParamGetCotizacion *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FEParamGetCotizacion(soap, tag ? tag : "-ns3:FEParamGetCotizacion", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEParamGetCotizacion * SOAP_FMAC4 soap_get___ns3__FEParamGetCotizacion(struct soap *soap, struct __ns3__FEParamGetCotizacion *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FEParamGetCotizacion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FECAEAConsultar(struct soap *soap, struct __ns3__FECAEAConsultar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FECAEAConsultar = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FECAEAConsultar(struct soap *soap, const struct __ns3__FECAEAConsultar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FECAEAConsultar(soap, &a->ns3__FECAEAConsultar);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FECAEAConsultar(struct soap *soap, const char *tag, int id, const struct __ns3__FECAEAConsultar *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FECAEAConsultar(soap, "ns3:FECAEAConsultar", -1, &a->ns3__FECAEAConsultar, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECAEAConsultar * SOAP_FMAC4 soap_in___ns3__FECAEAConsultar(struct soap *soap, const char *tag, struct __ns3__FECAEAConsultar *a, const char *type)
{
	size_t soap_flag_ns3__FECAEAConsultar = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FECAEAConsultar*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FECAEAConsultar, sizeof(struct __ns3__FECAEAConsultar), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FECAEAConsultar(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FECAEAConsultar && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FECAEAConsultar(soap, "ns3:FECAEAConsultar", &a->ns3__FECAEAConsultar, ""))
				{	soap_flag_ns3__FECAEAConsultar--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FECAEAConsultar * SOAP_FMAC2 soap_instantiate___ns3__FECAEAConsultar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FECAEAConsultar(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FECAEAConsultar *p;
	size_t k = sizeof(struct __ns3__FECAEAConsultar);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FECAEAConsultar, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FECAEAConsultar);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FECAEAConsultar, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FECAEAConsultar location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FECAEAConsultar(struct soap *soap, const struct __ns3__FECAEAConsultar *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FECAEAConsultar(soap, tag ? tag : "-ns3:FECAEAConsultar", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECAEAConsultar * SOAP_FMAC4 soap_get___ns3__FECAEAConsultar(struct soap *soap, struct __ns3__FECAEAConsultar *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FECAEAConsultar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FECAEASinMovimientoInformar(struct soap *soap, struct __ns3__FECAEASinMovimientoInformar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FECAEASinMovimientoInformar = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FECAEASinMovimientoInformar(struct soap *soap, const struct __ns3__FECAEASinMovimientoInformar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FECAEASinMovimientoInformar(soap, &a->ns3__FECAEASinMovimientoInformar);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FECAEASinMovimientoInformar(struct soap *soap, const char *tag, int id, const struct __ns3__FECAEASinMovimientoInformar *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FECAEASinMovimientoInformar(soap, "ns3:FECAEASinMovimientoInformar", -1, &a->ns3__FECAEASinMovimientoInformar, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECAEASinMovimientoInformar * SOAP_FMAC4 soap_in___ns3__FECAEASinMovimientoInformar(struct soap *soap, const char *tag, struct __ns3__FECAEASinMovimientoInformar *a, const char *type)
{
	size_t soap_flag_ns3__FECAEASinMovimientoInformar = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FECAEASinMovimientoInformar*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FECAEASinMovimientoInformar, sizeof(struct __ns3__FECAEASinMovimientoInformar), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FECAEASinMovimientoInformar(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FECAEASinMovimientoInformar && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FECAEASinMovimientoInformar(soap, "ns3:FECAEASinMovimientoInformar", &a->ns3__FECAEASinMovimientoInformar, ""))
				{	soap_flag_ns3__FECAEASinMovimientoInformar--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FECAEASinMovimientoInformar * SOAP_FMAC2 soap_instantiate___ns3__FECAEASinMovimientoInformar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FECAEASinMovimientoInformar(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FECAEASinMovimientoInformar *p;
	size_t k = sizeof(struct __ns3__FECAEASinMovimientoInformar);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FECAEASinMovimientoInformar, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FECAEASinMovimientoInformar);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FECAEASinMovimientoInformar, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FECAEASinMovimientoInformar location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FECAEASinMovimientoInformar(struct soap *soap, const struct __ns3__FECAEASinMovimientoInformar *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FECAEASinMovimientoInformar(soap, tag ? tag : "-ns3:FECAEASinMovimientoInformar", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECAEASinMovimientoInformar * SOAP_FMAC4 soap_get___ns3__FECAEASinMovimientoInformar(struct soap *soap, struct __ns3__FECAEASinMovimientoInformar *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FECAEASinMovimientoInformar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FECAEASinMovimientoConsultar(struct soap *soap, struct __ns3__FECAEASinMovimientoConsultar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FECAEASinMovimientoConsultar = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FECAEASinMovimientoConsultar(struct soap *soap, const struct __ns3__FECAEASinMovimientoConsultar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FECAEASinMovimientoConsultar(soap, &a->ns3__FECAEASinMovimientoConsultar);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FECAEASinMovimientoConsultar(struct soap *soap, const char *tag, int id, const struct __ns3__FECAEASinMovimientoConsultar *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FECAEASinMovimientoConsultar(soap, "ns3:FECAEASinMovimientoConsultar", -1, &a->ns3__FECAEASinMovimientoConsultar, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECAEASinMovimientoConsultar * SOAP_FMAC4 soap_in___ns3__FECAEASinMovimientoConsultar(struct soap *soap, const char *tag, struct __ns3__FECAEASinMovimientoConsultar *a, const char *type)
{
	size_t soap_flag_ns3__FECAEASinMovimientoConsultar = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FECAEASinMovimientoConsultar*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FECAEASinMovimientoConsultar, sizeof(struct __ns3__FECAEASinMovimientoConsultar), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FECAEASinMovimientoConsultar(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FECAEASinMovimientoConsultar && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FECAEASinMovimientoConsultar(soap, "ns3:FECAEASinMovimientoConsultar", &a->ns3__FECAEASinMovimientoConsultar, ""))
				{	soap_flag_ns3__FECAEASinMovimientoConsultar--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FECAEASinMovimientoConsultar * SOAP_FMAC2 soap_instantiate___ns3__FECAEASinMovimientoConsultar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FECAEASinMovimientoConsultar(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FECAEASinMovimientoConsultar *p;
	size_t k = sizeof(struct __ns3__FECAEASinMovimientoConsultar);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FECAEASinMovimientoConsultar, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FECAEASinMovimientoConsultar);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FECAEASinMovimientoConsultar, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FECAEASinMovimientoConsultar location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FECAEASinMovimientoConsultar(struct soap *soap, const struct __ns3__FECAEASinMovimientoConsultar *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FECAEASinMovimientoConsultar(soap, tag ? tag : "-ns3:FECAEASinMovimientoConsultar", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECAEASinMovimientoConsultar * SOAP_FMAC4 soap_get___ns3__FECAEASinMovimientoConsultar(struct soap *soap, struct __ns3__FECAEASinMovimientoConsultar *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FECAEASinMovimientoConsultar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FECAEASolicitar(struct soap *soap, struct __ns3__FECAEASolicitar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FECAEASolicitar = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FECAEASolicitar(struct soap *soap, const struct __ns3__FECAEASolicitar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FECAEASolicitar(soap, &a->ns3__FECAEASolicitar);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FECAEASolicitar(struct soap *soap, const char *tag, int id, const struct __ns3__FECAEASolicitar *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FECAEASolicitar(soap, "ns3:FECAEASolicitar", -1, &a->ns3__FECAEASolicitar, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECAEASolicitar * SOAP_FMAC4 soap_in___ns3__FECAEASolicitar(struct soap *soap, const char *tag, struct __ns3__FECAEASolicitar *a, const char *type)
{
	size_t soap_flag_ns3__FECAEASolicitar = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FECAEASolicitar*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FECAEASolicitar, sizeof(struct __ns3__FECAEASolicitar), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FECAEASolicitar(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FECAEASolicitar && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FECAEASolicitar(soap, "ns3:FECAEASolicitar", &a->ns3__FECAEASolicitar, ""))
				{	soap_flag_ns3__FECAEASolicitar--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FECAEASolicitar * SOAP_FMAC2 soap_instantiate___ns3__FECAEASolicitar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FECAEASolicitar(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FECAEASolicitar *p;
	size_t k = sizeof(struct __ns3__FECAEASolicitar);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FECAEASolicitar, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FECAEASolicitar);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FECAEASolicitar, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FECAEASolicitar location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FECAEASolicitar(struct soap *soap, const struct __ns3__FECAEASolicitar *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FECAEASolicitar(soap, tag ? tag : "-ns3:FECAEASolicitar", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECAEASolicitar * SOAP_FMAC4 soap_get___ns3__FECAEASolicitar(struct soap *soap, struct __ns3__FECAEASolicitar *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FECAEASolicitar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FECAEARegInformativo(struct soap *soap, struct __ns3__FECAEARegInformativo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FECAEARegInformativo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FECAEARegInformativo(struct soap *soap, const struct __ns3__FECAEARegInformativo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FECAEARegInformativo(soap, &a->ns3__FECAEARegInformativo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FECAEARegInformativo(struct soap *soap, const char *tag, int id, const struct __ns3__FECAEARegInformativo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FECAEARegInformativo(soap, "ns3:FECAEARegInformativo", -1, &a->ns3__FECAEARegInformativo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECAEARegInformativo * SOAP_FMAC4 soap_in___ns3__FECAEARegInformativo(struct soap *soap, const char *tag, struct __ns3__FECAEARegInformativo *a, const char *type)
{
	size_t soap_flag_ns3__FECAEARegInformativo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FECAEARegInformativo*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FECAEARegInformativo, sizeof(struct __ns3__FECAEARegInformativo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FECAEARegInformativo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FECAEARegInformativo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FECAEARegInformativo(soap, "ns3:FECAEARegInformativo", &a->ns3__FECAEARegInformativo, ""))
				{	soap_flag_ns3__FECAEARegInformativo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FECAEARegInformativo * SOAP_FMAC2 soap_instantiate___ns3__FECAEARegInformativo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FECAEARegInformativo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FECAEARegInformativo *p;
	size_t k = sizeof(struct __ns3__FECAEARegInformativo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FECAEARegInformativo, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FECAEARegInformativo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FECAEARegInformativo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FECAEARegInformativo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FECAEARegInformativo(struct soap *soap, const struct __ns3__FECAEARegInformativo *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FECAEARegInformativo(soap, tag ? tag : "-ns3:FECAEARegInformativo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECAEARegInformativo * SOAP_FMAC4 soap_get___ns3__FECAEARegInformativo(struct soap *soap, struct __ns3__FECAEARegInformativo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FECAEARegInformativo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FECompConsultar(struct soap *soap, struct __ns3__FECompConsultar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FECompConsultar = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FECompConsultar(struct soap *soap, const struct __ns3__FECompConsultar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FECompConsultar(soap, &a->ns3__FECompConsultar);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FECompConsultar(struct soap *soap, const char *tag, int id, const struct __ns3__FECompConsultar *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FECompConsultar(soap, "ns3:FECompConsultar", -1, &a->ns3__FECompConsultar, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECompConsultar * SOAP_FMAC4 soap_in___ns3__FECompConsultar(struct soap *soap, const char *tag, struct __ns3__FECompConsultar *a, const char *type)
{
	size_t soap_flag_ns3__FECompConsultar = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FECompConsultar*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FECompConsultar, sizeof(struct __ns3__FECompConsultar), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FECompConsultar(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FECompConsultar && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FECompConsultar(soap, "ns3:FECompConsultar", &a->ns3__FECompConsultar, ""))
				{	soap_flag_ns3__FECompConsultar--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FECompConsultar * SOAP_FMAC2 soap_instantiate___ns3__FECompConsultar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FECompConsultar(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FECompConsultar *p;
	size_t k = sizeof(struct __ns3__FECompConsultar);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FECompConsultar, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FECompConsultar);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FECompConsultar, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FECompConsultar location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FECompConsultar(struct soap *soap, const struct __ns3__FECompConsultar *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FECompConsultar(soap, tag ? tag : "-ns3:FECompConsultar", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECompConsultar * SOAP_FMAC4 soap_get___ns3__FECompConsultar(struct soap *soap, struct __ns3__FECompConsultar *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FECompConsultar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FECompUltimoAutorizado(struct soap *soap, struct __ns3__FECompUltimoAutorizado *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FECompUltimoAutorizado = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FECompUltimoAutorizado(struct soap *soap, const struct __ns3__FECompUltimoAutorizado *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FECompUltimoAutorizado(soap, &a->ns3__FECompUltimoAutorizado);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FECompUltimoAutorizado(struct soap *soap, const char *tag, int id, const struct __ns3__FECompUltimoAutorizado *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FECompUltimoAutorizado(soap, "ns3:FECompUltimoAutorizado", -1, &a->ns3__FECompUltimoAutorizado, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECompUltimoAutorizado * SOAP_FMAC4 soap_in___ns3__FECompUltimoAutorizado(struct soap *soap, const char *tag, struct __ns3__FECompUltimoAutorizado *a, const char *type)
{
	size_t soap_flag_ns3__FECompUltimoAutorizado = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FECompUltimoAutorizado*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FECompUltimoAutorizado, sizeof(struct __ns3__FECompUltimoAutorizado), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FECompUltimoAutorizado(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FECompUltimoAutorizado && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FECompUltimoAutorizado(soap, "ns3:FECompUltimoAutorizado", &a->ns3__FECompUltimoAutorizado, ""))
				{	soap_flag_ns3__FECompUltimoAutorizado--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FECompUltimoAutorizado * SOAP_FMAC2 soap_instantiate___ns3__FECompUltimoAutorizado(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FECompUltimoAutorizado(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FECompUltimoAutorizado *p;
	size_t k = sizeof(struct __ns3__FECompUltimoAutorizado);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FECompUltimoAutorizado, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FECompUltimoAutorizado);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FECompUltimoAutorizado, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FECompUltimoAutorizado location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FECompUltimoAutorizado(struct soap *soap, const struct __ns3__FECompUltimoAutorizado *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FECompUltimoAutorizado(soap, tag ? tag : "-ns3:FECompUltimoAutorizado", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECompUltimoAutorizado * SOAP_FMAC4 soap_get___ns3__FECompUltimoAutorizado(struct soap *soap, struct __ns3__FECompUltimoAutorizado *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FECompUltimoAutorizado(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FEDummy(struct soap *soap, struct __ns3__FEDummy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FEDummy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FEDummy(struct soap *soap, const struct __ns3__FEDummy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FEDummy(soap, &a->ns3__FEDummy);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FEDummy(struct soap *soap, const char *tag, int id, const struct __ns3__FEDummy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FEDummy(soap, "ns3:FEDummy", -1, &a->ns3__FEDummy, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEDummy * SOAP_FMAC4 soap_in___ns3__FEDummy(struct soap *soap, const char *tag, struct __ns3__FEDummy *a, const char *type)
{
	size_t soap_flag_ns3__FEDummy = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FEDummy*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FEDummy, sizeof(struct __ns3__FEDummy), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FEDummy(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FEDummy && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FEDummy(soap, "ns3:FEDummy", &a->ns3__FEDummy, ""))
				{	soap_flag_ns3__FEDummy--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FEDummy * SOAP_FMAC2 soap_instantiate___ns3__FEDummy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FEDummy(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FEDummy *p;
	size_t k = sizeof(struct __ns3__FEDummy);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FEDummy, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FEDummy);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FEDummy, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FEDummy location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FEDummy(struct soap *soap, const struct __ns3__FEDummy *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FEDummy(soap, tag ? tag : "-ns3:FEDummy", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FEDummy * SOAP_FMAC4 soap_get___ns3__FEDummy(struct soap *soap, struct __ns3__FEDummy *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FEDummy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FECompTotXRequest(struct soap *soap, struct __ns3__FECompTotXRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FECompTotXRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FECompTotXRequest(struct soap *soap, const struct __ns3__FECompTotXRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FECompTotXRequest(soap, &a->ns3__FECompTotXRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FECompTotXRequest(struct soap *soap, const char *tag, int id, const struct __ns3__FECompTotXRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FECompTotXRequest(soap, "ns3:FECompTotXRequest", -1, &a->ns3__FECompTotXRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECompTotXRequest * SOAP_FMAC4 soap_in___ns3__FECompTotXRequest(struct soap *soap, const char *tag, struct __ns3__FECompTotXRequest *a, const char *type)
{
	size_t soap_flag_ns3__FECompTotXRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FECompTotXRequest*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FECompTotXRequest, sizeof(struct __ns3__FECompTotXRequest), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FECompTotXRequest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FECompTotXRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FECompTotXRequest(soap, "ns3:FECompTotXRequest", &a->ns3__FECompTotXRequest, ""))
				{	soap_flag_ns3__FECompTotXRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FECompTotXRequest * SOAP_FMAC2 soap_instantiate___ns3__FECompTotXRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FECompTotXRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FECompTotXRequest *p;
	size_t k = sizeof(struct __ns3__FECompTotXRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FECompTotXRequest, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FECompTotXRequest);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FECompTotXRequest, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FECompTotXRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FECompTotXRequest(struct soap *soap, const struct __ns3__FECompTotXRequest *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FECompTotXRequest(soap, tag ? tag : "-ns3:FECompTotXRequest", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECompTotXRequest * SOAP_FMAC4 soap_get___ns3__FECompTotXRequest(struct soap *soap, struct __ns3__FECompTotXRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FECompTotXRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__FECAESolicitar(struct soap *soap, struct __ns3__FECAESolicitar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__FECAESolicitar = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__FECAESolicitar(struct soap *soap, const struct __ns3__FECAESolicitar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__FECAESolicitar(soap, &a->ns3__FECAESolicitar);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__FECAESolicitar(struct soap *soap, const char *tag, int id, const struct __ns3__FECAESolicitar *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__FECAESolicitar(soap, "ns3:FECAESolicitar", -1, &a->ns3__FECAESolicitar, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECAESolicitar * SOAP_FMAC4 soap_in___ns3__FECAESolicitar(struct soap *soap, const char *tag, struct __ns3__FECAESolicitar *a, const char *type)
{
	size_t soap_flag_ns3__FECAESolicitar = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__FECAESolicitar*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns3__FECAESolicitar, sizeof(struct __ns3__FECAESolicitar), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__FECAESolicitar(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__FECAESolicitar && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns3__FECAESolicitar(soap, "ns3:FECAESolicitar", &a->ns3__FECAESolicitar, ""))
				{	soap_flag_ns3__FECAESolicitar--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns3__FECAESolicitar * SOAP_FMAC2 soap_instantiate___ns3__FECAESolicitar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__FECAESolicitar(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns3__FECAESolicitar *p;
	size_t k = sizeof(struct __ns3__FECAESolicitar);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns3__FECAESolicitar, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns3__FECAESolicitar);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns3__FECAESolicitar, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns3__FECAESolicitar location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__FECAESolicitar(struct soap *soap, const struct __ns3__FECAESolicitar *a, const char *tag, const char *type)
{
	if (soap_out___ns3__FECAESolicitar(soap, tag ? tag : "-ns3:FECAESolicitar", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__FECAESolicitar * SOAP_FMAC4 soap_get___ns3__FECAESolicitar(struct soap *soap, struct __ns3__FECAESolicitar *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__FECAESolicitar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__loginCms(struct soap *soap, struct __ns2__loginCms *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__loginCms = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__loginCms(struct soap *soap, const struct __ns2__loginCms *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__loginCms(soap, &a->ns1__loginCms);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__loginCms(struct soap *soap, const char *tag, int id, const struct __ns2__loginCms *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__loginCms(soap, "ns1:loginCms", -1, &a->ns1__loginCms, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__loginCms * SOAP_FMAC4 soap_in___ns2__loginCms(struct soap *soap, const char *tag, struct __ns2__loginCms *a, const char *type)
{
	size_t soap_flag_ns1__loginCms = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns2__loginCms*)soap_id_enter(soap, "", a, SOAP_TYPE_afip___ns2__loginCms, sizeof(struct __ns2__loginCms), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__loginCms(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__loginCms && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__loginCms(soap, "ns1:loginCms", &a->ns1__loginCms, ""))
				{	soap_flag_ns1__loginCms--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns2__loginCms * SOAP_FMAC2 soap_instantiate___ns2__loginCms(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__loginCms(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns2__loginCms *p;
	size_t k = sizeof(struct __ns2__loginCms);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip___ns2__loginCms, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns2__loginCms);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns2__loginCms, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns2__loginCms location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__loginCms(struct soap *soap, const struct __ns2__loginCms *a, const char *tag, const char *type)
{
	if (soap_out___ns2__loginCms(soap, tag ? tag : "-ns2:loginCms", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__loginCms * SOAP_FMAC4 soap_get___ns2__loginCms(struct soap *soap, struct __ns2__loginCms *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__loginCms(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__fault = NULL;
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__LoginFault(soap, &a->ns2__fault);
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_out_PointerTons2__LoginFault(soap, "ns2:fault", -1, &a->ns2__fault, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_ns2__fault = 1;
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Detail*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__fault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__LoginFault(soap, "ns2:fault", &a->ns2__fault, "ns2:LoginFault"))
				{	soap_flag_ns2__fault--;
					continue;
				}
			}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, "fault", &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip_SOAP_ENV__Detail, SOAP_TYPE_afip_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, afip_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_SOAP_ENV__Detail, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__FEParamGetTiposPaises(struct soap *soap, _ns3__FEParamGetTiposPaises *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip__ns3__FEParamGetTiposPaises))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__FEParamGetTiposPaises(struct soap *soap, const char *tag, int id, _ns3__FEParamGetTiposPaises *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip__ns3__FEParamGetTiposPaises, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip__ns3__FEParamGetTiposPaises ? type : NULL);
}

SOAP_FMAC3 _ns3__FEParamGetTiposPaises ** SOAP_FMAC4 soap_in_PointerTo_ns3__FEParamGetTiposPaises(struct soap *soap, const char *tag, _ns3__FEParamGetTiposPaises **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__FEParamGetTiposPaises **)soap_malloc(soap, sizeof(_ns3__FEParamGetTiposPaises *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__FEParamGetTiposPaises *)soap_instantiate__ns3__FEParamGetTiposPaises(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns3__FEParamGetTiposPaises **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip__ns3__FEParamGetTiposPaises, sizeof(_ns3__FEParamGetTiposPaises), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__FEParamGetTiposPaises(struct soap *soap, _ns3__FEParamGetTiposPaises *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__FEParamGetTiposPaises(soap, tag ? tag : "ns3:FEParamGetTiposPaises", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__FEParamGetTiposPaises ** SOAP_FMAC4 soap_get_PointerTo_ns3__FEParamGetTiposPaises(struct soap *soap, _ns3__FEParamGetTiposPaises **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__FEParamGetTiposPaises(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__FEParamGetTiposDoc(struct soap *soap, _ns3__FEParamGetTiposDoc *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip__ns3__FEParamGetTiposDoc))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__FEParamGetTiposDoc(struct soap *soap, const char *tag, int id, _ns3__FEParamGetTiposDoc *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip__ns3__FEParamGetTiposDoc, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip__ns3__FEParamGetTiposDoc ? type : NULL);
}

SOAP_FMAC3 _ns3__FEParamGetTiposDoc ** SOAP_FMAC4 soap_in_PointerTo_ns3__FEParamGetTiposDoc(struct soap *soap, const char *tag, _ns3__FEParamGetTiposDoc **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__FEParamGetTiposDoc **)soap_malloc(soap, sizeof(_ns3__FEParamGetTiposDoc *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__FEParamGetTiposDoc *)soap_instantiate__ns3__FEParamGetTiposDoc(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns3__FEParamGetTiposDoc **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip__ns3__FEParamGetTiposDoc, sizeof(_ns3__FEParamGetTiposDoc), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__FEParamGetTiposDoc(struct soap *soap, _ns3__FEParamGetTiposDoc *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__FEParamGetTiposDoc(soap, tag ? tag : "ns3:FEParamGetTiposDoc", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__FEParamGetTiposDoc ** SOAP_FMAC4 soap_get_PointerTo_ns3__FEParamGetTiposDoc(struct soap *soap, _ns3__FEParamGetTiposDoc **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__FEParamGetTiposDoc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__FEParamGetTiposCbte(struct soap *soap, _ns3__FEParamGetTiposCbte *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip__ns3__FEParamGetTiposCbte))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__FEParamGetTiposCbte(struct soap *soap, const char *tag, int id, _ns3__FEParamGetTiposCbte *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip__ns3__FEParamGetTiposCbte, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip__ns3__FEParamGetTiposCbte ? type : NULL);
}

SOAP_FMAC3 _ns3__FEParamGetTiposCbte ** SOAP_FMAC4 soap_in_PointerTo_ns3__FEParamGetTiposCbte(struct soap *soap, const char *tag, _ns3__FEParamGetTiposCbte **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__FEParamGetTiposCbte **)soap_malloc(soap, sizeof(_ns3__FEParamGetTiposCbte *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__FEParamGetTiposCbte *)soap_instantiate__ns3__FEParamGetTiposCbte(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns3__FEParamGetTiposCbte **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip__ns3__FEParamGetTiposCbte, sizeof(_ns3__FEParamGetTiposCbte), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__FEParamGetTiposCbte(struct soap *soap, _ns3__FEParamGetTiposCbte *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__FEParamGetTiposCbte(soap, tag ? tag : "ns3:FEParamGetTiposCbte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__FEParamGetTiposCbte ** SOAP_FMAC4 soap_get_PointerTo_ns3__FEParamGetTiposCbte(struct soap *soap, _ns3__FEParamGetTiposCbte **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__FEParamGetTiposCbte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__FEParamGetPtosVenta(struct soap *soap, _ns3__FEParamGetPtosVenta *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip__ns3__FEParamGetPtosVenta))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__FEParamGetPtosVenta(struct soap *soap, const char *tag, int id, _ns3__FEParamGetPtosVenta *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip__ns3__FEParamGetPtosVenta, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip__ns3__FEParamGetPtosVenta ? type : NULL);
}

SOAP_FMAC3 _ns3__FEParamGetPtosVenta ** SOAP_FMAC4 soap_in_PointerTo_ns3__FEParamGetPtosVenta(struct soap *soap, const char *tag, _ns3__FEParamGetPtosVenta **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__FEParamGetPtosVenta **)soap_malloc(soap, sizeof(_ns3__FEParamGetPtosVenta *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__FEParamGetPtosVenta *)soap_instantiate__ns3__FEParamGetPtosVenta(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns3__FEParamGetPtosVenta **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip__ns3__FEParamGetPtosVenta, sizeof(_ns3__FEParamGetPtosVenta), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__FEParamGetPtosVenta(struct soap *soap, _ns3__FEParamGetPtosVenta *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__FEParamGetPtosVenta(soap, tag ? tag : "ns3:FEParamGetPtosVenta", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__FEParamGetPtosVenta ** SOAP_FMAC4 soap_get_PointerTo_ns3__FEParamGetPtosVenta(struct soap *soap, _ns3__FEParamGetPtosVenta **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__FEParamGetPtosVenta(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__FEParamGetTiposConcepto(struct soap *soap, _ns3__FEParamGetTiposConcepto *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip__ns3__FEParamGetTiposConcepto))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__FEParamGetTiposConcepto(struct soap *soap, const char *tag, int id, _ns3__FEParamGetTiposConcepto *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip__ns3__FEParamGetTiposConcepto, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip__ns3__FEParamGetTiposConcepto ? type : NULL);
}

SOAP_FMAC3 _ns3__FEParamGetTiposConcepto ** SOAP_FMAC4 soap_in_PointerTo_ns3__FEParamGetTiposConcepto(struct soap *soap, const char *tag, _ns3__FEParamGetTiposConcepto **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__FEParamGetTiposConcepto **)soap_malloc(soap, sizeof(_ns3__FEParamGetTiposConcepto *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__FEParamGetTiposConcepto *)soap_instantiate__ns3__FEParamGetTiposConcepto(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns3__FEParamGetTiposConcepto **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip__ns3__FEParamGetTiposConcepto, sizeof(_ns3__FEParamGetTiposConcepto), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__FEParamGetTiposConcepto(struct soap *soap, _ns3__FEParamGetTiposConcepto *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__FEParamGetTiposConcepto(soap, tag ? tag : "ns3:FEParamGetTiposConcepto", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__FEParamGetTiposConcepto ** SOAP_FMAC4 soap_get_PointerTo_ns3__FEParamGetTiposConcepto(struct soap *soap, _ns3__FEParamGetTiposConcepto **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__FEParamGetTiposConcepto(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__FEParamGetTiposOpcional(struct soap *soap, _ns3__FEParamGetTiposOpcional *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip__ns3__FEParamGetTiposOpcional))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__FEParamGetTiposOpcional(struct soap *soap, const char *tag, int id, _ns3__FEParamGetTiposOpcional *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip__ns3__FEParamGetTiposOpcional, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip__ns3__FEParamGetTiposOpcional ? type : NULL);
}

SOAP_FMAC3 _ns3__FEParamGetTiposOpcional ** SOAP_FMAC4 soap_in_PointerTo_ns3__FEParamGetTiposOpcional(struct soap *soap, const char *tag, _ns3__FEParamGetTiposOpcional **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__FEParamGetTiposOpcional **)soap_malloc(soap, sizeof(_ns3__FEParamGetTiposOpcional *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__FEParamGetTiposOpcional *)soap_instantiate__ns3__FEParamGetTiposOpcional(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns3__FEParamGetTiposOpcional **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip__ns3__FEParamGetTiposOpcional, sizeof(_ns3__FEParamGetTiposOpcional), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__FEParamGetTiposOpcional(struct soap *soap, _ns3__FEParamGetTiposOpcional *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__FEParamGetTiposOpcional(soap, tag ? tag : "ns3:FEParamGetTiposOpcional", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__FEParamGetTiposOpcional ** SOAP_FMAC4 soap_get_PointerTo_ns3__FEParamGetTiposOpcional(struct soap *soap, _ns3__FEParamGetTiposOpcional **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__FEParamGetTiposOpcional(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__FEParamGetTiposIva(struct soap *soap, _ns3__FEParamGetTiposIva *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip__ns3__FEParamGetTiposIva))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__FEParamGetTiposIva(struct soap *soap, const char *tag, int id, _ns3__FEParamGetTiposIva *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip__ns3__FEParamGetTiposIva, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip__ns3__FEParamGetTiposIva ? type : NULL);
}

SOAP_FMAC3 _ns3__FEParamGetTiposIva ** SOAP_FMAC4 soap_in_PointerTo_ns3__FEParamGetTiposIva(struct soap *soap, const char *tag, _ns3__FEParamGetTiposIva **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__FEParamGetTiposIva **)soap_malloc(soap, sizeof(_ns3__FEParamGetTiposIva *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__FEParamGetTiposIva *)soap_instantiate__ns3__FEParamGetTiposIva(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns3__FEParamGetTiposIva **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip__ns3__FEParamGetTiposIva, sizeof(_ns3__FEParamGetTiposIva), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__FEParamGetTiposIva(struct soap *soap, _ns3__FEParamGetTiposIva *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__FEParamGetTiposIva(soap, tag ? tag : "ns3:FEParamGetTiposIva", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__FEParamGetTiposIva ** SOAP_FMAC4 soap_get_PointerTo_ns3__FEParamGetTiposIva(struct soap *soap, _ns3__FEParamGetTiposIva **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__FEParamGetTiposIva(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__FEParamGetTiposMonedas(struct soap *soap, _ns3__FEParamGetTiposMonedas *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip__ns3__FEParamGetTiposMonedas))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__FEParamGetTiposMonedas(struct soap *soap, const char *tag, int id, _ns3__FEParamGetTiposMonedas *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip__ns3__FEParamGetTiposMonedas, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip__ns3__FEParamGetTiposMonedas ? type : NULL);
}

SOAP_FMAC3 _ns3__FEParamGetTiposMonedas ** SOAP_FMAC4 soap_in_PointerTo_ns3__FEParamGetTiposMonedas(struct soap *soap, const char *tag, _ns3__FEParamGetTiposMonedas **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__FEParamGetTiposMonedas **)soap_malloc(soap, sizeof(_ns3__FEParamGetTiposMonedas *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__FEParamGetTiposMonedas *)soap_instantiate__ns3__FEParamGetTiposMonedas(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns3__FEParamGetTiposMonedas **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip__ns3__FEParamGetTiposMonedas, sizeof(_ns3__FEParamGetTiposMonedas), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__FEParamGetTiposMonedas(struct soap *soap, _ns3__FEParamGetTiposMonedas *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__FEParamGetTiposMonedas(soap, tag ? tag : "ns3:FEParamGetTiposMonedas", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__FEParamGetTiposMonedas ** SOAP_FMAC4 soap_get_PointerTo_ns3__FEParamGetTiposMonedas(struct soap *soap, _ns3__FEParamGetTiposMonedas **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__FEParamGetTiposMonedas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__FEParamGetTiposTributos(struct soap *soap, _ns3__FEParamGetTiposTributos *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip__ns3__FEParamGetTiposTributos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__FEParamGetTiposTributos(struct soap *soap, const char *tag, int id, _ns3__FEParamGetTiposTributos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip__ns3__FEParamGetTiposTributos, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip__ns3__FEParamGetTiposTributos ? type : NULL);
}

SOAP_FMAC3 _ns3__FEParamGetTiposTributos ** SOAP_FMAC4 soap_in_PointerTo_ns3__FEParamGetTiposTributos(struct soap *soap, const char *tag, _ns3__FEParamGetTiposTributos **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__FEParamGetTiposTributos **)soap_malloc(soap, sizeof(_ns3__FEParamGetTiposTributos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__FEParamGetTiposTributos *)soap_instantiate__ns3__FEParamGetTiposTributos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns3__FEParamGetTiposTributos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip__ns3__FEParamGetTiposTributos, sizeof(_ns3__FEParamGetTiposTributos), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__FEParamGetTiposTributos(struct soap *soap, _ns3__FEParamGetTiposTributos *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__FEParamGetTiposTributos(soap, tag ? tag : "ns3:FEParamGetTiposTributos", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__FEParamGetTiposTributos ** SOAP_FMAC4 soap_get_PointerTo_ns3__FEParamGetTiposTributos(struct soap *soap, _ns3__FEParamGetTiposTributos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__FEParamGetTiposTributos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__FEParamGetCotizacion(struct soap *soap, _ns3__FEParamGetCotizacion *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip__ns3__FEParamGetCotizacion))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__FEParamGetCotizacion(struct soap *soap, const char *tag, int id, _ns3__FEParamGetCotizacion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip__ns3__FEParamGetCotizacion, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip__ns3__FEParamGetCotizacion ? type : NULL);
}

SOAP_FMAC3 _ns3__FEParamGetCotizacion ** SOAP_FMAC4 soap_in_PointerTo_ns3__FEParamGetCotizacion(struct soap *soap, const char *tag, _ns3__FEParamGetCotizacion **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__FEParamGetCotizacion **)soap_malloc(soap, sizeof(_ns3__FEParamGetCotizacion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__FEParamGetCotizacion *)soap_instantiate__ns3__FEParamGetCotizacion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns3__FEParamGetCotizacion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip__ns3__FEParamGetCotizacion, sizeof(_ns3__FEParamGetCotizacion), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__FEParamGetCotizacion(struct soap *soap, _ns3__FEParamGetCotizacion *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__FEParamGetCotizacion(soap, tag ? tag : "ns3:FEParamGetCotizacion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__FEParamGetCotizacion ** SOAP_FMAC4 soap_get_PointerTo_ns3__FEParamGetCotizacion(struct soap *soap, _ns3__FEParamGetCotizacion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__FEParamGetCotizacion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__FECAEAConsultar(struct soap *soap, _ns3__FECAEAConsultar *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip__ns3__FECAEAConsultar))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__FECAEAConsultar(struct soap *soap, const char *tag, int id, _ns3__FECAEAConsultar *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip__ns3__FECAEAConsultar, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip__ns3__FECAEAConsultar ? type : NULL);
}

SOAP_FMAC3 _ns3__FECAEAConsultar ** SOAP_FMAC4 soap_in_PointerTo_ns3__FECAEAConsultar(struct soap *soap, const char *tag, _ns3__FECAEAConsultar **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__FECAEAConsultar **)soap_malloc(soap, sizeof(_ns3__FECAEAConsultar *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__FECAEAConsultar *)soap_instantiate__ns3__FECAEAConsultar(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns3__FECAEAConsultar **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip__ns3__FECAEAConsultar, sizeof(_ns3__FECAEAConsultar), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__FECAEAConsultar(struct soap *soap, _ns3__FECAEAConsultar *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__FECAEAConsultar(soap, tag ? tag : "ns3:FECAEAConsultar", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__FECAEAConsultar ** SOAP_FMAC4 soap_get_PointerTo_ns3__FECAEAConsultar(struct soap *soap, _ns3__FECAEAConsultar **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__FECAEAConsultar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__FECAEASinMovimientoInformar(struct soap *soap, _ns3__FECAEASinMovimientoInformar *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip__ns3__FECAEASinMovimientoInformar))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__FECAEASinMovimientoInformar(struct soap *soap, const char *tag, int id, _ns3__FECAEASinMovimientoInformar *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip__ns3__FECAEASinMovimientoInformar, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip__ns3__FECAEASinMovimientoInformar ? type : NULL);
}

SOAP_FMAC3 _ns3__FECAEASinMovimientoInformar ** SOAP_FMAC4 soap_in_PointerTo_ns3__FECAEASinMovimientoInformar(struct soap *soap, const char *tag, _ns3__FECAEASinMovimientoInformar **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__FECAEASinMovimientoInformar **)soap_malloc(soap, sizeof(_ns3__FECAEASinMovimientoInformar *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__FECAEASinMovimientoInformar *)soap_instantiate__ns3__FECAEASinMovimientoInformar(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns3__FECAEASinMovimientoInformar **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip__ns3__FECAEASinMovimientoInformar, sizeof(_ns3__FECAEASinMovimientoInformar), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__FECAEASinMovimientoInformar(struct soap *soap, _ns3__FECAEASinMovimientoInformar *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__FECAEASinMovimientoInformar(soap, tag ? tag : "ns3:FECAEASinMovimientoInformar", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__FECAEASinMovimientoInformar ** SOAP_FMAC4 soap_get_PointerTo_ns3__FECAEASinMovimientoInformar(struct soap *soap, _ns3__FECAEASinMovimientoInformar **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__FECAEASinMovimientoInformar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__FECAEASinMovimientoConsultar(struct soap *soap, _ns3__FECAEASinMovimientoConsultar *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip__ns3__FECAEASinMovimientoConsultar))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__FECAEASinMovimientoConsultar(struct soap *soap, const char *tag, int id, _ns3__FECAEASinMovimientoConsultar *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip__ns3__FECAEASinMovimientoConsultar, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip__ns3__FECAEASinMovimientoConsultar ? type : NULL);
}

SOAP_FMAC3 _ns3__FECAEASinMovimientoConsultar ** SOAP_FMAC4 soap_in_PointerTo_ns3__FECAEASinMovimientoConsultar(struct soap *soap, const char *tag, _ns3__FECAEASinMovimientoConsultar **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__FECAEASinMovimientoConsultar **)soap_malloc(soap, sizeof(_ns3__FECAEASinMovimientoConsultar *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__FECAEASinMovimientoConsultar *)soap_instantiate__ns3__FECAEASinMovimientoConsultar(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns3__FECAEASinMovimientoConsultar **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip__ns3__FECAEASinMovimientoConsultar, sizeof(_ns3__FECAEASinMovimientoConsultar), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__FECAEASinMovimientoConsultar(struct soap *soap, _ns3__FECAEASinMovimientoConsultar *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__FECAEASinMovimientoConsultar(soap, tag ? tag : "ns3:FECAEASinMovimientoConsultar", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__FECAEASinMovimientoConsultar ** SOAP_FMAC4 soap_get_PointerTo_ns3__FECAEASinMovimientoConsultar(struct soap *soap, _ns3__FECAEASinMovimientoConsultar **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__FECAEASinMovimientoConsultar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__FECAEASolicitar(struct soap *soap, _ns3__FECAEASolicitar *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip__ns3__FECAEASolicitar))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__FECAEASolicitar(struct soap *soap, const char *tag, int id, _ns3__FECAEASolicitar *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip__ns3__FECAEASolicitar, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip__ns3__FECAEASolicitar ? type : NULL);
}

SOAP_FMAC3 _ns3__FECAEASolicitar ** SOAP_FMAC4 soap_in_PointerTo_ns3__FECAEASolicitar(struct soap *soap, const char *tag, _ns3__FECAEASolicitar **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__FECAEASolicitar **)soap_malloc(soap, sizeof(_ns3__FECAEASolicitar *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__FECAEASolicitar *)soap_instantiate__ns3__FECAEASolicitar(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns3__FECAEASolicitar **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip__ns3__FECAEASolicitar, sizeof(_ns3__FECAEASolicitar), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__FECAEASolicitar(struct soap *soap, _ns3__FECAEASolicitar *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__FECAEASolicitar(soap, tag ? tag : "ns3:FECAEASolicitar", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__FECAEASolicitar ** SOAP_FMAC4 soap_get_PointerTo_ns3__FECAEASolicitar(struct soap *soap, _ns3__FECAEASolicitar **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__FECAEASolicitar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__FECAEARegInformativo(struct soap *soap, _ns3__FECAEARegInformativo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip__ns3__FECAEARegInformativo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__FECAEARegInformativo(struct soap *soap, const char *tag, int id, _ns3__FECAEARegInformativo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip__ns3__FECAEARegInformativo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip__ns3__FECAEARegInformativo ? type : NULL);
}

SOAP_FMAC3 _ns3__FECAEARegInformativo ** SOAP_FMAC4 soap_in_PointerTo_ns3__FECAEARegInformativo(struct soap *soap, const char *tag, _ns3__FECAEARegInformativo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__FECAEARegInformativo **)soap_malloc(soap, sizeof(_ns3__FECAEARegInformativo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__FECAEARegInformativo *)soap_instantiate__ns3__FECAEARegInformativo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns3__FECAEARegInformativo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip__ns3__FECAEARegInformativo, sizeof(_ns3__FECAEARegInformativo), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__FECAEARegInformativo(struct soap *soap, _ns3__FECAEARegInformativo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__FECAEARegInformativo(soap, tag ? tag : "ns3:FECAEARegInformativo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__FECAEARegInformativo ** SOAP_FMAC4 soap_get_PointerTo_ns3__FECAEARegInformativo(struct soap *soap, _ns3__FECAEARegInformativo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__FECAEARegInformativo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__FECompConsultar(struct soap *soap, _ns3__FECompConsultar *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip__ns3__FECompConsultar))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__FECompConsultar(struct soap *soap, const char *tag, int id, _ns3__FECompConsultar *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip__ns3__FECompConsultar, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip__ns3__FECompConsultar ? type : NULL);
}

SOAP_FMAC3 _ns3__FECompConsultar ** SOAP_FMAC4 soap_in_PointerTo_ns3__FECompConsultar(struct soap *soap, const char *tag, _ns3__FECompConsultar **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__FECompConsultar **)soap_malloc(soap, sizeof(_ns3__FECompConsultar *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__FECompConsultar *)soap_instantiate__ns3__FECompConsultar(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns3__FECompConsultar **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip__ns3__FECompConsultar, sizeof(_ns3__FECompConsultar), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__FECompConsultar(struct soap *soap, _ns3__FECompConsultar *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__FECompConsultar(soap, tag ? tag : "ns3:FECompConsultar", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__FECompConsultar ** SOAP_FMAC4 soap_get_PointerTo_ns3__FECompConsultar(struct soap *soap, _ns3__FECompConsultar **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__FECompConsultar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__FECompUltimoAutorizado(struct soap *soap, _ns3__FECompUltimoAutorizado *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip__ns3__FECompUltimoAutorizado))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__FECompUltimoAutorizado(struct soap *soap, const char *tag, int id, _ns3__FECompUltimoAutorizado *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip__ns3__FECompUltimoAutorizado, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip__ns3__FECompUltimoAutorizado ? type : NULL);
}

SOAP_FMAC3 _ns3__FECompUltimoAutorizado ** SOAP_FMAC4 soap_in_PointerTo_ns3__FECompUltimoAutorizado(struct soap *soap, const char *tag, _ns3__FECompUltimoAutorizado **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__FECompUltimoAutorizado **)soap_malloc(soap, sizeof(_ns3__FECompUltimoAutorizado *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__FECompUltimoAutorizado *)soap_instantiate__ns3__FECompUltimoAutorizado(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns3__FECompUltimoAutorizado **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip__ns3__FECompUltimoAutorizado, sizeof(_ns3__FECompUltimoAutorizado), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__FECompUltimoAutorizado(struct soap *soap, _ns3__FECompUltimoAutorizado *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__FECompUltimoAutorizado(soap, tag ? tag : "ns3:FECompUltimoAutorizado", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__FECompUltimoAutorizado ** SOAP_FMAC4 soap_get_PointerTo_ns3__FECompUltimoAutorizado(struct soap *soap, _ns3__FECompUltimoAutorizado **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__FECompUltimoAutorizado(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__FEDummy(struct soap *soap, _ns3__FEDummy *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip__ns3__FEDummy))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__FEDummy(struct soap *soap, const char *tag, int id, _ns3__FEDummy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip__ns3__FEDummy, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip__ns3__FEDummy ? type : NULL);
}

SOAP_FMAC3 _ns3__FEDummy ** SOAP_FMAC4 soap_in_PointerTo_ns3__FEDummy(struct soap *soap, const char *tag, _ns3__FEDummy **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__FEDummy **)soap_malloc(soap, sizeof(_ns3__FEDummy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__FEDummy *)soap_instantiate__ns3__FEDummy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns3__FEDummy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip__ns3__FEDummy, sizeof(_ns3__FEDummy), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__FEDummy(struct soap *soap, _ns3__FEDummy *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__FEDummy(soap, tag ? tag : "ns3:FEDummy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__FEDummy ** SOAP_FMAC4 soap_get_PointerTo_ns3__FEDummy(struct soap *soap, _ns3__FEDummy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__FEDummy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__FECompTotXRequest(struct soap *soap, _ns3__FECompTotXRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip__ns3__FECompTotXRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__FECompTotXRequest(struct soap *soap, const char *tag, int id, _ns3__FECompTotXRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip__ns3__FECompTotXRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip__ns3__FECompTotXRequest ? type : NULL);
}

SOAP_FMAC3 _ns3__FECompTotXRequest ** SOAP_FMAC4 soap_in_PointerTo_ns3__FECompTotXRequest(struct soap *soap, const char *tag, _ns3__FECompTotXRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__FECompTotXRequest **)soap_malloc(soap, sizeof(_ns3__FECompTotXRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__FECompTotXRequest *)soap_instantiate__ns3__FECompTotXRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns3__FECompTotXRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip__ns3__FECompTotXRequest, sizeof(_ns3__FECompTotXRequest), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__FECompTotXRequest(struct soap *soap, _ns3__FECompTotXRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__FECompTotXRequest(soap, tag ? tag : "ns3:FECompTotXRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__FECompTotXRequest ** SOAP_FMAC4 soap_get_PointerTo_ns3__FECompTotXRequest(struct soap *soap, _ns3__FECompTotXRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__FECompTotXRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__FECAESolicitar(struct soap *soap, _ns3__FECAESolicitar *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip__ns3__FECAESolicitar))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__FECAESolicitar(struct soap *soap, const char *tag, int id, _ns3__FECAESolicitar *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip__ns3__FECAESolicitar, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip__ns3__FECAESolicitar ? type : NULL);
}

SOAP_FMAC3 _ns3__FECAESolicitar ** SOAP_FMAC4 soap_in_PointerTo_ns3__FECAESolicitar(struct soap *soap, const char *tag, _ns3__FECAESolicitar **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__FECAESolicitar **)soap_malloc(soap, sizeof(_ns3__FECAESolicitar *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__FECAESolicitar *)soap_instantiate__ns3__FECAESolicitar(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns3__FECAESolicitar **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip__ns3__FECAESolicitar, sizeof(_ns3__FECAESolicitar), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__FECAESolicitar(struct soap *soap, _ns3__FECAESolicitar *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns3__FECAESolicitar(soap, tag ? tag : "ns3:FECAESolicitar", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns3__FECAESolicitar ** SOAP_FMAC4 soap_get_PointerTo_ns3__FECAESolicitar(struct soap *soap, _ns3__FECAESolicitar **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__FECAESolicitar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__loginCms(struct soap *soap, _ns1__loginCms *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip__ns1__loginCms))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__loginCms(struct soap *soap, const char *tag, int id, _ns1__loginCms *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip__ns1__loginCms, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip__ns1__loginCms ? type : NULL);
}

SOAP_FMAC3 _ns1__loginCms ** SOAP_FMAC4 soap_in_PointerTo_ns1__loginCms(struct soap *soap, const char *tag, _ns1__loginCms **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__loginCms **)soap_malloc(soap, sizeof(_ns1__loginCms *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__loginCms *)soap_instantiate__ns1__loginCms(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__loginCms **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip__ns1__loginCms, sizeof(_ns1__loginCms), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__loginCms(struct soap *soap, _ns1__loginCms *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__loginCms(soap, tag ? tag : "ns1:loginCms", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__loginCms ** SOAP_FMAC4 soap_get_PointerTo_ns1__loginCms(struct soap *soap, _ns1__loginCms **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__loginCms(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__LoginFault(struct soap *soap, ns2__LoginFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns2__LoginFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__LoginFault(struct soap *soap, const char *tag, int id, ns2__LoginFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns2__LoginFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns2__LoginFault ? type : NULL);
}

SOAP_FMAC3 ns2__LoginFault ** SOAP_FMAC4 soap_in_PointerTons2__LoginFault(struct soap *soap, const char *tag, ns2__LoginFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__LoginFault **)soap_malloc(soap, sizeof(ns2__LoginFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__LoginFault *)soap_instantiate_ns2__LoginFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__LoginFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns2__LoginFault, sizeof(ns2__LoginFault), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__LoginFault(struct soap *soap, ns2__LoginFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__LoginFault(soap, tag ? tag : "ns2:LoginFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__LoginFault ** SOAP_FMAC4 soap_get_PointerTons2__LoginFault(struct soap *soap, ns2__LoginFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__LoginFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__FEPaisResponse(struct soap *soap, ns3__FEPaisResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__FEPaisResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__FEPaisResponse(struct soap *soap, const char *tag, int id, ns3__FEPaisResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__FEPaisResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__FEPaisResponse ? type : NULL);
}

SOAP_FMAC3 ns3__FEPaisResponse ** SOAP_FMAC4 soap_in_PointerTons3__FEPaisResponse(struct soap *soap, const char *tag, ns3__FEPaisResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__FEPaisResponse **)soap_malloc(soap, sizeof(ns3__FEPaisResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__FEPaisResponse *)soap_instantiate_ns3__FEPaisResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__FEPaisResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__FEPaisResponse, sizeof(ns3__FEPaisResponse), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__FEPaisResponse(struct soap *soap, ns3__FEPaisResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__FEPaisResponse(soap, tag ? tag : "ns3:FEPaisResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__FEPaisResponse ** SOAP_FMAC4 soap_get_PointerTons3__FEPaisResponse(struct soap *soap, ns3__FEPaisResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__FEPaisResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__DocTipoResponse(struct soap *soap, ns3__DocTipoResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__DocTipoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__DocTipoResponse(struct soap *soap, const char *tag, int id, ns3__DocTipoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__DocTipoResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__DocTipoResponse ? type : NULL);
}

SOAP_FMAC3 ns3__DocTipoResponse ** SOAP_FMAC4 soap_in_PointerTons3__DocTipoResponse(struct soap *soap, const char *tag, ns3__DocTipoResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__DocTipoResponse **)soap_malloc(soap, sizeof(ns3__DocTipoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__DocTipoResponse *)soap_instantiate_ns3__DocTipoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__DocTipoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__DocTipoResponse, sizeof(ns3__DocTipoResponse), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__DocTipoResponse(struct soap *soap, ns3__DocTipoResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__DocTipoResponse(soap, tag ? tag : "ns3:DocTipoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__DocTipoResponse ** SOAP_FMAC4 soap_get_PointerTons3__DocTipoResponse(struct soap *soap, ns3__DocTipoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__DocTipoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__CbteTipoResponse(struct soap *soap, ns3__CbteTipoResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__CbteTipoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__CbteTipoResponse(struct soap *soap, const char *tag, int id, ns3__CbteTipoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__CbteTipoResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__CbteTipoResponse ? type : NULL);
}

SOAP_FMAC3 ns3__CbteTipoResponse ** SOAP_FMAC4 soap_in_PointerTons3__CbteTipoResponse(struct soap *soap, const char *tag, ns3__CbteTipoResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__CbteTipoResponse **)soap_malloc(soap, sizeof(ns3__CbteTipoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__CbteTipoResponse *)soap_instantiate_ns3__CbteTipoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__CbteTipoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__CbteTipoResponse, sizeof(ns3__CbteTipoResponse), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__CbteTipoResponse(struct soap *soap, ns3__CbteTipoResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__CbteTipoResponse(soap, tag ? tag : "ns3:CbteTipoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__CbteTipoResponse ** SOAP_FMAC4 soap_get_PointerTons3__CbteTipoResponse(struct soap *soap, ns3__CbteTipoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__CbteTipoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__FEPtoVentaResponse(struct soap *soap, ns3__FEPtoVentaResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__FEPtoVentaResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__FEPtoVentaResponse(struct soap *soap, const char *tag, int id, ns3__FEPtoVentaResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__FEPtoVentaResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__FEPtoVentaResponse ? type : NULL);
}

SOAP_FMAC3 ns3__FEPtoVentaResponse ** SOAP_FMAC4 soap_in_PointerTons3__FEPtoVentaResponse(struct soap *soap, const char *tag, ns3__FEPtoVentaResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__FEPtoVentaResponse **)soap_malloc(soap, sizeof(ns3__FEPtoVentaResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__FEPtoVentaResponse *)soap_instantiate_ns3__FEPtoVentaResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__FEPtoVentaResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__FEPtoVentaResponse, sizeof(ns3__FEPtoVentaResponse), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__FEPtoVentaResponse(struct soap *soap, ns3__FEPtoVentaResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__FEPtoVentaResponse(soap, tag ? tag : "ns3:FEPtoVentaResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__FEPtoVentaResponse ** SOAP_FMAC4 soap_get_PointerTons3__FEPtoVentaResponse(struct soap *soap, ns3__FEPtoVentaResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__FEPtoVentaResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ConceptoTipoResponse(struct soap *soap, ns3__ConceptoTipoResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__ConceptoTipoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ConceptoTipoResponse(struct soap *soap, const char *tag, int id, ns3__ConceptoTipoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__ConceptoTipoResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__ConceptoTipoResponse ? type : NULL);
}

SOAP_FMAC3 ns3__ConceptoTipoResponse ** SOAP_FMAC4 soap_in_PointerTons3__ConceptoTipoResponse(struct soap *soap, const char *tag, ns3__ConceptoTipoResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ConceptoTipoResponse **)soap_malloc(soap, sizeof(ns3__ConceptoTipoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ConceptoTipoResponse *)soap_instantiate_ns3__ConceptoTipoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__ConceptoTipoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__ConceptoTipoResponse, sizeof(ns3__ConceptoTipoResponse), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ConceptoTipoResponse(struct soap *soap, ns3__ConceptoTipoResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__ConceptoTipoResponse(soap, tag ? tag : "ns3:ConceptoTipoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__ConceptoTipoResponse ** SOAP_FMAC4 soap_get_PointerTons3__ConceptoTipoResponse(struct soap *soap, ns3__ConceptoTipoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ConceptoTipoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__OpcionalTipoResponse(struct soap *soap, ns3__OpcionalTipoResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__OpcionalTipoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__OpcionalTipoResponse(struct soap *soap, const char *tag, int id, ns3__OpcionalTipoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__OpcionalTipoResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__OpcionalTipoResponse ? type : NULL);
}

SOAP_FMAC3 ns3__OpcionalTipoResponse ** SOAP_FMAC4 soap_in_PointerTons3__OpcionalTipoResponse(struct soap *soap, const char *tag, ns3__OpcionalTipoResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__OpcionalTipoResponse **)soap_malloc(soap, sizeof(ns3__OpcionalTipoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__OpcionalTipoResponse *)soap_instantiate_ns3__OpcionalTipoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__OpcionalTipoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__OpcionalTipoResponse, sizeof(ns3__OpcionalTipoResponse), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__OpcionalTipoResponse(struct soap *soap, ns3__OpcionalTipoResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__OpcionalTipoResponse(soap, tag ? tag : "ns3:OpcionalTipoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__OpcionalTipoResponse ** SOAP_FMAC4 soap_get_PointerTons3__OpcionalTipoResponse(struct soap *soap, ns3__OpcionalTipoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__OpcionalTipoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__IvaTipoResponse(struct soap *soap, ns3__IvaTipoResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__IvaTipoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__IvaTipoResponse(struct soap *soap, const char *tag, int id, ns3__IvaTipoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__IvaTipoResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__IvaTipoResponse ? type : NULL);
}

SOAP_FMAC3 ns3__IvaTipoResponse ** SOAP_FMAC4 soap_in_PointerTons3__IvaTipoResponse(struct soap *soap, const char *tag, ns3__IvaTipoResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__IvaTipoResponse **)soap_malloc(soap, sizeof(ns3__IvaTipoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__IvaTipoResponse *)soap_instantiate_ns3__IvaTipoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__IvaTipoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__IvaTipoResponse, sizeof(ns3__IvaTipoResponse), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__IvaTipoResponse(struct soap *soap, ns3__IvaTipoResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__IvaTipoResponse(soap, tag ? tag : "ns3:IvaTipoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__IvaTipoResponse ** SOAP_FMAC4 soap_get_PointerTons3__IvaTipoResponse(struct soap *soap, ns3__IvaTipoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__IvaTipoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__MonedaResponse(struct soap *soap, ns3__MonedaResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__MonedaResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__MonedaResponse(struct soap *soap, const char *tag, int id, ns3__MonedaResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__MonedaResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__MonedaResponse ? type : NULL);
}

SOAP_FMAC3 ns3__MonedaResponse ** SOAP_FMAC4 soap_in_PointerTons3__MonedaResponse(struct soap *soap, const char *tag, ns3__MonedaResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__MonedaResponse **)soap_malloc(soap, sizeof(ns3__MonedaResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__MonedaResponse *)soap_instantiate_ns3__MonedaResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__MonedaResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__MonedaResponse, sizeof(ns3__MonedaResponse), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__MonedaResponse(struct soap *soap, ns3__MonedaResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__MonedaResponse(soap, tag ? tag : "ns3:MonedaResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__MonedaResponse ** SOAP_FMAC4 soap_get_PointerTons3__MonedaResponse(struct soap *soap, ns3__MonedaResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__MonedaResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__FETributoResponse(struct soap *soap, ns3__FETributoResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__FETributoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__FETributoResponse(struct soap *soap, const char *tag, int id, ns3__FETributoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__FETributoResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__FETributoResponse ? type : NULL);
}

SOAP_FMAC3 ns3__FETributoResponse ** SOAP_FMAC4 soap_in_PointerTons3__FETributoResponse(struct soap *soap, const char *tag, ns3__FETributoResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__FETributoResponse **)soap_malloc(soap, sizeof(ns3__FETributoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__FETributoResponse *)soap_instantiate_ns3__FETributoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__FETributoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__FETributoResponse, sizeof(ns3__FETributoResponse), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__FETributoResponse(struct soap *soap, ns3__FETributoResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__FETributoResponse(soap, tag ? tag : "ns3:FETributoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__FETributoResponse ** SOAP_FMAC4 soap_get_PointerTons3__FETributoResponse(struct soap *soap, ns3__FETributoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__FETributoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__FECotizacionResponse(struct soap *soap, ns3__FECotizacionResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__FECotizacionResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__FECotizacionResponse(struct soap *soap, const char *tag, int id, ns3__FECotizacionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__FECotizacionResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__FECotizacionResponse ? type : NULL);
}

SOAP_FMAC3 ns3__FECotizacionResponse ** SOAP_FMAC4 soap_in_PointerTons3__FECotizacionResponse(struct soap *soap, const char *tag, ns3__FECotizacionResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__FECotizacionResponse **)soap_malloc(soap, sizeof(ns3__FECotizacionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__FECotizacionResponse *)soap_instantiate_ns3__FECotizacionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__FECotizacionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__FECotizacionResponse, sizeof(ns3__FECotizacionResponse), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__FECotizacionResponse(struct soap *soap, ns3__FECotizacionResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__FECotizacionResponse(soap, tag ? tag : "ns3:FECotizacionResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__FECotizacionResponse ** SOAP_FMAC4 soap_get_PointerTons3__FECotizacionResponse(struct soap *soap, ns3__FECotizacionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__FECotizacionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__FECAEASinMovResponse(struct soap *soap, ns3__FECAEASinMovResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__FECAEASinMovResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__FECAEASinMovResponse(struct soap *soap, const char *tag, int id, ns3__FECAEASinMovResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__FECAEASinMovResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__FECAEASinMovResponse ? type : NULL);
}

SOAP_FMAC3 ns3__FECAEASinMovResponse ** SOAP_FMAC4 soap_in_PointerTons3__FECAEASinMovResponse(struct soap *soap, const char *tag, ns3__FECAEASinMovResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__FECAEASinMovResponse **)soap_malloc(soap, sizeof(ns3__FECAEASinMovResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__FECAEASinMovResponse *)soap_instantiate_ns3__FECAEASinMovResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__FECAEASinMovResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__FECAEASinMovResponse, sizeof(ns3__FECAEASinMovResponse), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__FECAEASinMovResponse(struct soap *soap, ns3__FECAEASinMovResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__FECAEASinMovResponse(soap, tag ? tag : "ns3:FECAEASinMovResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__FECAEASinMovResponse ** SOAP_FMAC4 soap_get_PointerTons3__FECAEASinMovResponse(struct soap *soap, ns3__FECAEASinMovResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__FECAEASinMovResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__FECAEASinMovConsResponse(struct soap *soap, ns3__FECAEASinMovConsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__FECAEASinMovConsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__FECAEASinMovConsResponse(struct soap *soap, const char *tag, int id, ns3__FECAEASinMovConsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__FECAEASinMovConsResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__FECAEASinMovConsResponse ? type : NULL);
}

SOAP_FMAC3 ns3__FECAEASinMovConsResponse ** SOAP_FMAC4 soap_in_PointerTons3__FECAEASinMovConsResponse(struct soap *soap, const char *tag, ns3__FECAEASinMovConsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__FECAEASinMovConsResponse **)soap_malloc(soap, sizeof(ns3__FECAEASinMovConsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__FECAEASinMovConsResponse *)soap_instantiate_ns3__FECAEASinMovConsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__FECAEASinMovConsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__FECAEASinMovConsResponse, sizeof(ns3__FECAEASinMovConsResponse), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__FECAEASinMovConsResponse(struct soap *soap, ns3__FECAEASinMovConsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__FECAEASinMovConsResponse(soap, tag ? tag : "ns3:FECAEASinMovConsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__FECAEASinMovConsResponse ** SOAP_FMAC4 soap_get_PointerTons3__FECAEASinMovConsResponse(struct soap *soap, ns3__FECAEASinMovConsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__FECAEASinMovConsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__FECAEAGetResponse(struct soap *soap, ns3__FECAEAGetResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__FECAEAGetResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__FECAEAGetResponse(struct soap *soap, const char *tag, int id, ns3__FECAEAGetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__FECAEAGetResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__FECAEAGetResponse ? type : NULL);
}

SOAP_FMAC3 ns3__FECAEAGetResponse ** SOAP_FMAC4 soap_in_PointerTons3__FECAEAGetResponse(struct soap *soap, const char *tag, ns3__FECAEAGetResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__FECAEAGetResponse **)soap_malloc(soap, sizeof(ns3__FECAEAGetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__FECAEAGetResponse *)soap_instantiate_ns3__FECAEAGetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__FECAEAGetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__FECAEAGetResponse, sizeof(ns3__FECAEAGetResponse), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__FECAEAGetResponse(struct soap *soap, ns3__FECAEAGetResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__FECAEAGetResponse(soap, tag ? tag : "ns3:FECAEAGetResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__FECAEAGetResponse ** SOAP_FMAC4 soap_get_PointerTons3__FECAEAGetResponse(struct soap *soap, ns3__FECAEAGetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__FECAEAGetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__FECAEAResponse(struct soap *soap, ns3__FECAEAResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__FECAEAResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__FECAEAResponse(struct soap *soap, const char *tag, int id, ns3__FECAEAResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__FECAEAResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__FECAEAResponse ? type : NULL);
}

SOAP_FMAC3 ns3__FECAEAResponse ** SOAP_FMAC4 soap_in_PointerTons3__FECAEAResponse(struct soap *soap, const char *tag, ns3__FECAEAResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__FECAEAResponse **)soap_malloc(soap, sizeof(ns3__FECAEAResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__FECAEAResponse *)soap_instantiate_ns3__FECAEAResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__FECAEAResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__FECAEAResponse, sizeof(ns3__FECAEAResponse), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__FECAEAResponse(struct soap *soap, ns3__FECAEAResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__FECAEAResponse(soap, tag ? tag : "ns3:FECAEAResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__FECAEAResponse ** SOAP_FMAC4 soap_get_PointerTons3__FECAEAResponse(struct soap *soap, ns3__FECAEAResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__FECAEAResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__FECAEARequest(struct soap *soap, ns3__FECAEARequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__FECAEARequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__FECAEARequest(struct soap *soap, const char *tag, int id, ns3__FECAEARequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__FECAEARequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__FECAEARequest ? type : NULL);
}

SOAP_FMAC3 ns3__FECAEARequest ** SOAP_FMAC4 soap_in_PointerTons3__FECAEARequest(struct soap *soap, const char *tag, ns3__FECAEARequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__FECAEARequest **)soap_malloc(soap, sizeof(ns3__FECAEARequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__FECAEARequest *)soap_instantiate_ns3__FECAEARequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__FECAEARequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__FECAEARequest, sizeof(ns3__FECAEARequest), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__FECAEARequest(struct soap *soap, ns3__FECAEARequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__FECAEARequest(soap, tag ? tag : "ns3:FECAEARequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__FECAEARequest ** SOAP_FMAC4 soap_get_PointerTons3__FECAEARequest(struct soap *soap, ns3__FECAEARequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__FECAEARequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__FECompConsultaResponse(struct soap *soap, ns3__FECompConsultaResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__FECompConsultaResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__FECompConsultaResponse(struct soap *soap, const char *tag, int id, ns3__FECompConsultaResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__FECompConsultaResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__FECompConsultaResponse ? type : NULL);
}

SOAP_FMAC3 ns3__FECompConsultaResponse ** SOAP_FMAC4 soap_in_PointerTons3__FECompConsultaResponse(struct soap *soap, const char *tag, ns3__FECompConsultaResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__FECompConsultaResponse **)soap_malloc(soap, sizeof(ns3__FECompConsultaResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__FECompConsultaResponse *)soap_instantiate_ns3__FECompConsultaResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__FECompConsultaResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__FECompConsultaResponse, sizeof(ns3__FECompConsultaResponse), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__FECompConsultaResponse(struct soap *soap, ns3__FECompConsultaResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__FECompConsultaResponse(soap, tag ? tag : "ns3:FECompConsultaResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__FECompConsultaResponse ** SOAP_FMAC4 soap_get_PointerTons3__FECompConsultaResponse(struct soap *soap, ns3__FECompConsultaResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__FECompConsultaResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__FECompConsultaReq(struct soap *soap, ns3__FECompConsultaReq *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__FECompConsultaReq))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__FECompConsultaReq(struct soap *soap, const char *tag, int id, ns3__FECompConsultaReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__FECompConsultaReq, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__FECompConsultaReq ? type : NULL);
}

SOAP_FMAC3 ns3__FECompConsultaReq ** SOAP_FMAC4 soap_in_PointerTons3__FECompConsultaReq(struct soap *soap, const char *tag, ns3__FECompConsultaReq **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__FECompConsultaReq **)soap_malloc(soap, sizeof(ns3__FECompConsultaReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__FECompConsultaReq *)soap_instantiate_ns3__FECompConsultaReq(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__FECompConsultaReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__FECompConsultaReq, sizeof(ns3__FECompConsultaReq), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__FECompConsultaReq(struct soap *soap, ns3__FECompConsultaReq *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__FECompConsultaReq(soap, tag ? tag : "ns3:FECompConsultaReq", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__FECompConsultaReq ** SOAP_FMAC4 soap_get_PointerTons3__FECompConsultaReq(struct soap *soap, ns3__FECompConsultaReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__FECompConsultaReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__FERecuperaLastCbteResponse(struct soap *soap, ns3__FERecuperaLastCbteResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__FERecuperaLastCbteResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__FERecuperaLastCbteResponse(struct soap *soap, const char *tag, int id, ns3__FERecuperaLastCbteResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__FERecuperaLastCbteResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__FERecuperaLastCbteResponse ? type : NULL);
}

SOAP_FMAC3 ns3__FERecuperaLastCbteResponse ** SOAP_FMAC4 soap_in_PointerTons3__FERecuperaLastCbteResponse(struct soap *soap, const char *tag, ns3__FERecuperaLastCbteResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__FERecuperaLastCbteResponse **)soap_malloc(soap, sizeof(ns3__FERecuperaLastCbteResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__FERecuperaLastCbteResponse *)soap_instantiate_ns3__FERecuperaLastCbteResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__FERecuperaLastCbteResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__FERecuperaLastCbteResponse, sizeof(ns3__FERecuperaLastCbteResponse), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__FERecuperaLastCbteResponse(struct soap *soap, ns3__FERecuperaLastCbteResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__FERecuperaLastCbteResponse(soap, tag ? tag : "ns3:FERecuperaLastCbteResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__FERecuperaLastCbteResponse ** SOAP_FMAC4 soap_get_PointerTons3__FERecuperaLastCbteResponse(struct soap *soap, ns3__FERecuperaLastCbteResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__FERecuperaLastCbteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__DummyResponse(struct soap *soap, ns3__DummyResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__DummyResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__DummyResponse(struct soap *soap, const char *tag, int id, ns3__DummyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__DummyResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__DummyResponse ? type : NULL);
}

SOAP_FMAC3 ns3__DummyResponse ** SOAP_FMAC4 soap_in_PointerTons3__DummyResponse(struct soap *soap, const char *tag, ns3__DummyResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__DummyResponse **)soap_malloc(soap, sizeof(ns3__DummyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__DummyResponse *)soap_instantiate_ns3__DummyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__DummyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__DummyResponse, sizeof(ns3__DummyResponse), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__DummyResponse(struct soap *soap, ns3__DummyResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__DummyResponse(soap, tag ? tag : "ns3:DummyResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__DummyResponse ** SOAP_FMAC4 soap_get_PointerTons3__DummyResponse(struct soap *soap, ns3__DummyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__DummyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__FERegXReqResponse(struct soap *soap, ns3__FERegXReqResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__FERegXReqResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__FERegXReqResponse(struct soap *soap, const char *tag, int id, ns3__FERegXReqResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__FERegXReqResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__FERegXReqResponse ? type : NULL);
}

SOAP_FMAC3 ns3__FERegXReqResponse ** SOAP_FMAC4 soap_in_PointerTons3__FERegXReqResponse(struct soap *soap, const char *tag, ns3__FERegXReqResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__FERegXReqResponse **)soap_malloc(soap, sizeof(ns3__FERegXReqResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__FERegXReqResponse *)soap_instantiate_ns3__FERegXReqResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__FERegXReqResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__FERegXReqResponse, sizeof(ns3__FERegXReqResponse), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__FERegXReqResponse(struct soap *soap, ns3__FERegXReqResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__FERegXReqResponse(soap, tag ? tag : "ns3:FERegXReqResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__FERegXReqResponse ** SOAP_FMAC4 soap_get_PointerTons3__FERegXReqResponse(struct soap *soap, ns3__FERegXReqResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__FERegXReqResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__FECAEResponse(struct soap *soap, ns3__FECAEResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__FECAEResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__FECAEResponse(struct soap *soap, const char *tag, int id, ns3__FECAEResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__FECAEResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__FECAEResponse ? type : NULL);
}

SOAP_FMAC3 ns3__FECAEResponse ** SOAP_FMAC4 soap_in_PointerTons3__FECAEResponse(struct soap *soap, const char *tag, ns3__FECAEResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__FECAEResponse **)soap_malloc(soap, sizeof(ns3__FECAEResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__FECAEResponse *)soap_instantiate_ns3__FECAEResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__FECAEResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__FECAEResponse, sizeof(ns3__FECAEResponse), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__FECAEResponse(struct soap *soap, ns3__FECAEResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__FECAEResponse(soap, tag ? tag : "ns3:FECAEResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__FECAEResponse ** SOAP_FMAC4 soap_get_PointerTons3__FECAEResponse(struct soap *soap, ns3__FECAEResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__FECAEResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__FECAERequest(struct soap *soap, ns3__FECAERequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__FECAERequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__FECAERequest(struct soap *soap, const char *tag, int id, ns3__FECAERequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__FECAERequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__FECAERequest ? type : NULL);
}

SOAP_FMAC3 ns3__FECAERequest ** SOAP_FMAC4 soap_in_PointerTons3__FECAERequest(struct soap *soap, const char *tag, ns3__FECAERequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__FECAERequest **)soap_malloc(soap, sizeof(ns3__FECAERequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__FECAERequest *)soap_instantiate_ns3__FECAERequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__FECAERequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__FECAERequest, sizeof(ns3__FECAERequest), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__FECAERequest(struct soap *soap, ns3__FECAERequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__FECAERequest(soap, tag ? tag : "ns3:FECAERequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__FECAERequest ** SOAP_FMAC4 soap_get_PointerTons3__FECAERequest(struct soap *soap, ns3__FECAERequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__FECAERequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__FEAuthRequest(struct soap *soap, ns3__FEAuthRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__FEAuthRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__FEAuthRequest(struct soap *soap, const char *tag, int id, ns3__FEAuthRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__FEAuthRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__FEAuthRequest ? type : NULL);
}

SOAP_FMAC3 ns3__FEAuthRequest ** SOAP_FMAC4 soap_in_PointerTons3__FEAuthRequest(struct soap *soap, const char *tag, ns3__FEAuthRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__FEAuthRequest **)soap_malloc(soap, sizeof(ns3__FEAuthRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__FEAuthRequest *)soap_instantiate_ns3__FEAuthRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__FEAuthRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__FEAuthRequest, sizeof(ns3__FEAuthRequest), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__FEAuthRequest(struct soap *soap, ns3__FEAuthRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__FEAuthRequest(soap, tag ? tag : "ns3:FEAuthRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__FEAuthRequest ** SOAP_FMAC4 soap_get_PointerTons3__FEAuthRequest(struct soap *soap, ns3__FEAuthRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__FEAuthRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__PaisTipo(struct soap *soap, ns3__PaisTipo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__PaisTipo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__PaisTipo(struct soap *soap, const char *tag, int id, ns3__PaisTipo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__PaisTipo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__PaisTipo ? type : NULL);
}

SOAP_FMAC3 ns3__PaisTipo ** SOAP_FMAC4 soap_in_PointerTons3__PaisTipo(struct soap *soap, const char *tag, ns3__PaisTipo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__PaisTipo **)soap_malloc(soap, sizeof(ns3__PaisTipo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__PaisTipo *)soap_instantiate_ns3__PaisTipo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__PaisTipo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__PaisTipo, sizeof(ns3__PaisTipo), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__PaisTipo(struct soap *soap, ns3__PaisTipo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__PaisTipo(soap, tag ? tag : "ns3:PaisTipo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__PaisTipo ** SOAP_FMAC4 soap_get_PointerTons3__PaisTipo(struct soap *soap, ns3__PaisTipo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__PaisTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfPaisTipo(struct soap *soap, ns3__ArrayOfPaisTipo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__ArrayOfPaisTipo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfPaisTipo(struct soap *soap, const char *tag, int id, ns3__ArrayOfPaisTipo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__ArrayOfPaisTipo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__ArrayOfPaisTipo ? type : NULL);
}

SOAP_FMAC3 ns3__ArrayOfPaisTipo ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfPaisTipo(struct soap *soap, const char *tag, ns3__ArrayOfPaisTipo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfPaisTipo **)soap_malloc(soap, sizeof(ns3__ArrayOfPaisTipo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfPaisTipo *)soap_instantiate_ns3__ArrayOfPaisTipo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__ArrayOfPaisTipo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__ArrayOfPaisTipo, sizeof(ns3__ArrayOfPaisTipo), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfPaisTipo(struct soap *soap, ns3__ArrayOfPaisTipo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__ArrayOfPaisTipo(soap, tag ? tag : "ns3:ArrayOfPaisTipo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__ArrayOfPaisTipo ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfPaisTipo(struct soap *soap, ns3__ArrayOfPaisTipo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfPaisTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__DocTipo(struct soap *soap, ns3__DocTipo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__DocTipo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__DocTipo(struct soap *soap, const char *tag, int id, ns3__DocTipo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__DocTipo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__DocTipo ? type : NULL);
}

SOAP_FMAC3 ns3__DocTipo ** SOAP_FMAC4 soap_in_PointerTons3__DocTipo(struct soap *soap, const char *tag, ns3__DocTipo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__DocTipo **)soap_malloc(soap, sizeof(ns3__DocTipo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__DocTipo *)soap_instantiate_ns3__DocTipo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__DocTipo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__DocTipo, sizeof(ns3__DocTipo), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__DocTipo(struct soap *soap, ns3__DocTipo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__DocTipo(soap, tag ? tag : "ns3:DocTipo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__DocTipo ** SOAP_FMAC4 soap_get_PointerTons3__DocTipo(struct soap *soap, ns3__DocTipo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__DocTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfDocTipo(struct soap *soap, ns3__ArrayOfDocTipo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__ArrayOfDocTipo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfDocTipo(struct soap *soap, const char *tag, int id, ns3__ArrayOfDocTipo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__ArrayOfDocTipo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__ArrayOfDocTipo ? type : NULL);
}

SOAP_FMAC3 ns3__ArrayOfDocTipo ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfDocTipo(struct soap *soap, const char *tag, ns3__ArrayOfDocTipo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfDocTipo **)soap_malloc(soap, sizeof(ns3__ArrayOfDocTipo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfDocTipo *)soap_instantiate_ns3__ArrayOfDocTipo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__ArrayOfDocTipo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__ArrayOfDocTipo, sizeof(ns3__ArrayOfDocTipo), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfDocTipo(struct soap *soap, ns3__ArrayOfDocTipo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__ArrayOfDocTipo(soap, tag ? tag : "ns3:ArrayOfDocTipo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__ArrayOfDocTipo ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfDocTipo(struct soap *soap, ns3__ArrayOfDocTipo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfDocTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__CbteTipo(struct soap *soap, ns3__CbteTipo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__CbteTipo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__CbteTipo(struct soap *soap, const char *tag, int id, ns3__CbteTipo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__CbteTipo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__CbteTipo ? type : NULL);
}

SOAP_FMAC3 ns3__CbteTipo ** SOAP_FMAC4 soap_in_PointerTons3__CbteTipo(struct soap *soap, const char *tag, ns3__CbteTipo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__CbteTipo **)soap_malloc(soap, sizeof(ns3__CbteTipo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__CbteTipo *)soap_instantiate_ns3__CbteTipo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__CbteTipo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__CbteTipo, sizeof(ns3__CbteTipo), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__CbteTipo(struct soap *soap, ns3__CbteTipo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__CbteTipo(soap, tag ? tag : "ns3:CbteTipo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__CbteTipo ** SOAP_FMAC4 soap_get_PointerTons3__CbteTipo(struct soap *soap, ns3__CbteTipo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__CbteTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfCbteTipo(struct soap *soap, ns3__ArrayOfCbteTipo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__ArrayOfCbteTipo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfCbteTipo(struct soap *soap, const char *tag, int id, ns3__ArrayOfCbteTipo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__ArrayOfCbteTipo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__ArrayOfCbteTipo ? type : NULL);
}

SOAP_FMAC3 ns3__ArrayOfCbteTipo ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfCbteTipo(struct soap *soap, const char *tag, ns3__ArrayOfCbteTipo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfCbteTipo **)soap_malloc(soap, sizeof(ns3__ArrayOfCbteTipo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfCbteTipo *)soap_instantiate_ns3__ArrayOfCbteTipo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__ArrayOfCbteTipo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__ArrayOfCbteTipo, sizeof(ns3__ArrayOfCbteTipo), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfCbteTipo(struct soap *soap, ns3__ArrayOfCbteTipo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__ArrayOfCbteTipo(soap, tag ? tag : "ns3:ArrayOfCbteTipo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__ArrayOfCbteTipo ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfCbteTipo(struct soap *soap, ns3__ArrayOfCbteTipo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfCbteTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__PtoVenta(struct soap *soap, ns3__PtoVenta *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__PtoVenta))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__PtoVenta(struct soap *soap, const char *tag, int id, ns3__PtoVenta *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__PtoVenta, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__PtoVenta ? type : NULL);
}

SOAP_FMAC3 ns3__PtoVenta ** SOAP_FMAC4 soap_in_PointerTons3__PtoVenta(struct soap *soap, const char *tag, ns3__PtoVenta **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__PtoVenta **)soap_malloc(soap, sizeof(ns3__PtoVenta *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__PtoVenta *)soap_instantiate_ns3__PtoVenta(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__PtoVenta **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__PtoVenta, sizeof(ns3__PtoVenta), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__PtoVenta(struct soap *soap, ns3__PtoVenta *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__PtoVenta(soap, tag ? tag : "ns3:PtoVenta", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__PtoVenta ** SOAP_FMAC4 soap_get_PointerTons3__PtoVenta(struct soap *soap, ns3__PtoVenta **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__PtoVenta(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfPtoVenta(struct soap *soap, ns3__ArrayOfPtoVenta *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__ArrayOfPtoVenta))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfPtoVenta(struct soap *soap, const char *tag, int id, ns3__ArrayOfPtoVenta *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__ArrayOfPtoVenta, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__ArrayOfPtoVenta ? type : NULL);
}

SOAP_FMAC3 ns3__ArrayOfPtoVenta ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfPtoVenta(struct soap *soap, const char *tag, ns3__ArrayOfPtoVenta **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfPtoVenta **)soap_malloc(soap, sizeof(ns3__ArrayOfPtoVenta *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfPtoVenta *)soap_instantiate_ns3__ArrayOfPtoVenta(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__ArrayOfPtoVenta **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__ArrayOfPtoVenta, sizeof(ns3__ArrayOfPtoVenta), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfPtoVenta(struct soap *soap, ns3__ArrayOfPtoVenta *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__ArrayOfPtoVenta(soap, tag ? tag : "ns3:ArrayOfPtoVenta", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__ArrayOfPtoVenta ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfPtoVenta(struct soap *soap, ns3__ArrayOfPtoVenta **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfPtoVenta(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ConceptoTipo(struct soap *soap, ns3__ConceptoTipo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__ConceptoTipo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ConceptoTipo(struct soap *soap, const char *tag, int id, ns3__ConceptoTipo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__ConceptoTipo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__ConceptoTipo ? type : NULL);
}

SOAP_FMAC3 ns3__ConceptoTipo ** SOAP_FMAC4 soap_in_PointerTons3__ConceptoTipo(struct soap *soap, const char *tag, ns3__ConceptoTipo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ConceptoTipo **)soap_malloc(soap, sizeof(ns3__ConceptoTipo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ConceptoTipo *)soap_instantiate_ns3__ConceptoTipo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__ConceptoTipo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__ConceptoTipo, sizeof(ns3__ConceptoTipo), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ConceptoTipo(struct soap *soap, ns3__ConceptoTipo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__ConceptoTipo(soap, tag ? tag : "ns3:ConceptoTipo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__ConceptoTipo ** SOAP_FMAC4 soap_get_PointerTons3__ConceptoTipo(struct soap *soap, ns3__ConceptoTipo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ConceptoTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfConceptoTipo(struct soap *soap, ns3__ArrayOfConceptoTipo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__ArrayOfConceptoTipo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfConceptoTipo(struct soap *soap, const char *tag, int id, ns3__ArrayOfConceptoTipo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__ArrayOfConceptoTipo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__ArrayOfConceptoTipo ? type : NULL);
}

SOAP_FMAC3 ns3__ArrayOfConceptoTipo ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfConceptoTipo(struct soap *soap, const char *tag, ns3__ArrayOfConceptoTipo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfConceptoTipo **)soap_malloc(soap, sizeof(ns3__ArrayOfConceptoTipo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfConceptoTipo *)soap_instantiate_ns3__ArrayOfConceptoTipo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__ArrayOfConceptoTipo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__ArrayOfConceptoTipo, sizeof(ns3__ArrayOfConceptoTipo), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfConceptoTipo(struct soap *soap, ns3__ArrayOfConceptoTipo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__ArrayOfConceptoTipo(soap, tag ? tag : "ns3:ArrayOfConceptoTipo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__ArrayOfConceptoTipo ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfConceptoTipo(struct soap *soap, ns3__ArrayOfConceptoTipo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfConceptoTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__OpcionalTipo(struct soap *soap, ns3__OpcionalTipo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__OpcionalTipo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__OpcionalTipo(struct soap *soap, const char *tag, int id, ns3__OpcionalTipo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__OpcionalTipo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__OpcionalTipo ? type : NULL);
}

SOAP_FMAC3 ns3__OpcionalTipo ** SOAP_FMAC4 soap_in_PointerTons3__OpcionalTipo(struct soap *soap, const char *tag, ns3__OpcionalTipo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__OpcionalTipo **)soap_malloc(soap, sizeof(ns3__OpcionalTipo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__OpcionalTipo *)soap_instantiate_ns3__OpcionalTipo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__OpcionalTipo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__OpcionalTipo, sizeof(ns3__OpcionalTipo), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__OpcionalTipo(struct soap *soap, ns3__OpcionalTipo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__OpcionalTipo(soap, tag ? tag : "ns3:OpcionalTipo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__OpcionalTipo ** SOAP_FMAC4 soap_get_PointerTons3__OpcionalTipo(struct soap *soap, ns3__OpcionalTipo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__OpcionalTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfOpcionalTipo(struct soap *soap, ns3__ArrayOfOpcionalTipo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__ArrayOfOpcionalTipo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfOpcionalTipo(struct soap *soap, const char *tag, int id, ns3__ArrayOfOpcionalTipo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__ArrayOfOpcionalTipo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__ArrayOfOpcionalTipo ? type : NULL);
}

SOAP_FMAC3 ns3__ArrayOfOpcionalTipo ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfOpcionalTipo(struct soap *soap, const char *tag, ns3__ArrayOfOpcionalTipo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfOpcionalTipo **)soap_malloc(soap, sizeof(ns3__ArrayOfOpcionalTipo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfOpcionalTipo *)soap_instantiate_ns3__ArrayOfOpcionalTipo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__ArrayOfOpcionalTipo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__ArrayOfOpcionalTipo, sizeof(ns3__ArrayOfOpcionalTipo), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfOpcionalTipo(struct soap *soap, ns3__ArrayOfOpcionalTipo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__ArrayOfOpcionalTipo(soap, tag ? tag : "ns3:ArrayOfOpcionalTipo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__ArrayOfOpcionalTipo ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfOpcionalTipo(struct soap *soap, ns3__ArrayOfOpcionalTipo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfOpcionalTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__IvaTipo(struct soap *soap, ns3__IvaTipo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__IvaTipo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__IvaTipo(struct soap *soap, const char *tag, int id, ns3__IvaTipo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__IvaTipo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__IvaTipo ? type : NULL);
}

SOAP_FMAC3 ns3__IvaTipo ** SOAP_FMAC4 soap_in_PointerTons3__IvaTipo(struct soap *soap, const char *tag, ns3__IvaTipo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__IvaTipo **)soap_malloc(soap, sizeof(ns3__IvaTipo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__IvaTipo *)soap_instantiate_ns3__IvaTipo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__IvaTipo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__IvaTipo, sizeof(ns3__IvaTipo), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__IvaTipo(struct soap *soap, ns3__IvaTipo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__IvaTipo(soap, tag ? tag : "ns3:IvaTipo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__IvaTipo ** SOAP_FMAC4 soap_get_PointerTons3__IvaTipo(struct soap *soap, ns3__IvaTipo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__IvaTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfIvaTipo(struct soap *soap, ns3__ArrayOfIvaTipo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__ArrayOfIvaTipo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfIvaTipo(struct soap *soap, const char *tag, int id, ns3__ArrayOfIvaTipo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__ArrayOfIvaTipo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__ArrayOfIvaTipo ? type : NULL);
}

SOAP_FMAC3 ns3__ArrayOfIvaTipo ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfIvaTipo(struct soap *soap, const char *tag, ns3__ArrayOfIvaTipo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfIvaTipo **)soap_malloc(soap, sizeof(ns3__ArrayOfIvaTipo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfIvaTipo *)soap_instantiate_ns3__ArrayOfIvaTipo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__ArrayOfIvaTipo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__ArrayOfIvaTipo, sizeof(ns3__ArrayOfIvaTipo), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfIvaTipo(struct soap *soap, ns3__ArrayOfIvaTipo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__ArrayOfIvaTipo(soap, tag ? tag : "ns3:ArrayOfIvaTipo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__ArrayOfIvaTipo ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfIvaTipo(struct soap *soap, ns3__ArrayOfIvaTipo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfIvaTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__Moneda(struct soap *soap, ns3__Moneda *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__Moneda))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__Moneda(struct soap *soap, const char *tag, int id, ns3__Moneda *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__Moneda, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__Moneda ? type : NULL);
}

SOAP_FMAC3 ns3__Moneda ** SOAP_FMAC4 soap_in_PointerTons3__Moneda(struct soap *soap, const char *tag, ns3__Moneda **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__Moneda **)soap_malloc(soap, sizeof(ns3__Moneda *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__Moneda *)soap_instantiate_ns3__Moneda(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__Moneda **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__Moneda, sizeof(ns3__Moneda), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__Moneda(struct soap *soap, ns3__Moneda *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__Moneda(soap, tag ? tag : "ns3:Moneda", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__Moneda ** SOAP_FMAC4 soap_get_PointerTons3__Moneda(struct soap *soap, ns3__Moneda **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__Moneda(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfMoneda(struct soap *soap, ns3__ArrayOfMoneda *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__ArrayOfMoneda))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfMoneda(struct soap *soap, const char *tag, int id, ns3__ArrayOfMoneda *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__ArrayOfMoneda, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__ArrayOfMoneda ? type : NULL);
}

SOAP_FMAC3 ns3__ArrayOfMoneda ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfMoneda(struct soap *soap, const char *tag, ns3__ArrayOfMoneda **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfMoneda **)soap_malloc(soap, sizeof(ns3__ArrayOfMoneda *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfMoneda *)soap_instantiate_ns3__ArrayOfMoneda(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__ArrayOfMoneda **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__ArrayOfMoneda, sizeof(ns3__ArrayOfMoneda), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfMoneda(struct soap *soap, ns3__ArrayOfMoneda *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__ArrayOfMoneda(soap, tag ? tag : "ns3:ArrayOfMoneda", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__ArrayOfMoneda ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfMoneda(struct soap *soap, ns3__ArrayOfMoneda **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfMoneda(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__TributoTipo(struct soap *soap, ns3__TributoTipo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__TributoTipo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__TributoTipo(struct soap *soap, const char *tag, int id, ns3__TributoTipo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__TributoTipo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__TributoTipo ? type : NULL);
}

SOAP_FMAC3 ns3__TributoTipo ** SOAP_FMAC4 soap_in_PointerTons3__TributoTipo(struct soap *soap, const char *tag, ns3__TributoTipo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__TributoTipo **)soap_malloc(soap, sizeof(ns3__TributoTipo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__TributoTipo *)soap_instantiate_ns3__TributoTipo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__TributoTipo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__TributoTipo, sizeof(ns3__TributoTipo), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__TributoTipo(struct soap *soap, ns3__TributoTipo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__TributoTipo(soap, tag ? tag : "ns3:TributoTipo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__TributoTipo ** SOAP_FMAC4 soap_get_PointerTons3__TributoTipo(struct soap *soap, ns3__TributoTipo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__TributoTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfTributoTipo(struct soap *soap, ns3__ArrayOfTributoTipo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__ArrayOfTributoTipo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfTributoTipo(struct soap *soap, const char *tag, int id, ns3__ArrayOfTributoTipo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__ArrayOfTributoTipo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__ArrayOfTributoTipo ? type : NULL);
}

SOAP_FMAC3 ns3__ArrayOfTributoTipo ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfTributoTipo(struct soap *soap, const char *tag, ns3__ArrayOfTributoTipo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfTributoTipo **)soap_malloc(soap, sizeof(ns3__ArrayOfTributoTipo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfTributoTipo *)soap_instantiate_ns3__ArrayOfTributoTipo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__ArrayOfTributoTipo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__ArrayOfTributoTipo, sizeof(ns3__ArrayOfTributoTipo), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfTributoTipo(struct soap *soap, ns3__ArrayOfTributoTipo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__ArrayOfTributoTipo(soap, tag ? tag : "ns3:ArrayOfTributoTipo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__ArrayOfTributoTipo ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfTributoTipo(struct soap *soap, ns3__ArrayOfTributoTipo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfTributoTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__Cotizacion(struct soap *soap, ns3__Cotizacion *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__Cotizacion))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__Cotizacion(struct soap *soap, const char *tag, int id, ns3__Cotizacion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__Cotizacion, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__Cotizacion ? type : NULL);
}

SOAP_FMAC3 ns3__Cotizacion ** SOAP_FMAC4 soap_in_PointerTons3__Cotizacion(struct soap *soap, const char *tag, ns3__Cotizacion **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__Cotizacion **)soap_malloc(soap, sizeof(ns3__Cotizacion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__Cotizacion *)soap_instantiate_ns3__Cotizacion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__Cotizacion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__Cotizacion, sizeof(ns3__Cotizacion), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__Cotizacion(struct soap *soap, ns3__Cotizacion *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__Cotizacion(soap, tag ? tag : "ns3:Cotizacion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__Cotizacion ** SOAP_FMAC4 soap_get_PointerTons3__Cotizacion(struct soap *soap, ns3__Cotizacion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__Cotizacion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__FECAEASinMov(struct soap *soap, ns3__FECAEASinMov *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__FECAEASinMov))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__FECAEASinMov(struct soap *soap, const char *tag, int id, ns3__FECAEASinMov *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__FECAEASinMov, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__FECAEASinMov ? type : NULL);
}

SOAP_FMAC3 ns3__FECAEASinMov ** SOAP_FMAC4 soap_in_PointerTons3__FECAEASinMov(struct soap *soap, const char *tag, ns3__FECAEASinMov **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__FECAEASinMov **)soap_malloc(soap, sizeof(ns3__FECAEASinMov *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__FECAEASinMov *)soap_instantiate_ns3__FECAEASinMov(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__FECAEASinMov **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__FECAEASinMov, sizeof(ns3__FECAEASinMov), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__FECAEASinMov(struct soap *soap, ns3__FECAEASinMov *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__FECAEASinMov(soap, tag ? tag : "ns3:FECAEASinMov", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__FECAEASinMov ** SOAP_FMAC4 soap_get_PointerTons3__FECAEASinMov(struct soap *soap, ns3__FECAEASinMov **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__FECAEASinMov(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfFECAEASinMov(struct soap *soap, ns3__ArrayOfFECAEASinMov *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__ArrayOfFECAEASinMov))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfFECAEASinMov(struct soap *soap, const char *tag, int id, ns3__ArrayOfFECAEASinMov *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__ArrayOfFECAEASinMov, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__ArrayOfFECAEASinMov ? type : NULL);
}

SOAP_FMAC3 ns3__ArrayOfFECAEASinMov ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfFECAEASinMov(struct soap *soap, const char *tag, ns3__ArrayOfFECAEASinMov **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfFECAEASinMov **)soap_malloc(soap, sizeof(ns3__ArrayOfFECAEASinMov *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfFECAEASinMov *)soap_instantiate_ns3__ArrayOfFECAEASinMov(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__ArrayOfFECAEASinMov **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__ArrayOfFECAEASinMov, sizeof(ns3__ArrayOfFECAEASinMov), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfFECAEASinMov(struct soap *soap, ns3__ArrayOfFECAEASinMov *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__ArrayOfFECAEASinMov(soap, tag ? tag : "ns3:ArrayOfFECAEASinMov", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__ArrayOfFECAEASinMov ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfFECAEASinMov(struct soap *soap, ns3__ArrayOfFECAEASinMov **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfFECAEASinMov(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__FECAEAGet(struct soap *soap, ns3__FECAEAGet *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__FECAEAGet))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__FECAEAGet(struct soap *soap, const char *tag, int id, ns3__FECAEAGet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__FECAEAGet, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__FECAEAGet ? type : NULL);
}

SOAP_FMAC3 ns3__FECAEAGet ** SOAP_FMAC4 soap_in_PointerTons3__FECAEAGet(struct soap *soap, const char *tag, ns3__FECAEAGet **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__FECAEAGet **)soap_malloc(soap, sizeof(ns3__FECAEAGet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__FECAEAGet *)soap_instantiate_ns3__FECAEAGet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__FECAEAGet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__FECAEAGet, sizeof(ns3__FECAEAGet), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__FECAEAGet(struct soap *soap, ns3__FECAEAGet *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__FECAEAGet(soap, tag ? tag : "ns3:FECAEAGet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__FECAEAGet ** SOAP_FMAC4 soap_get_PointerTons3__FECAEAGet(struct soap *soap, ns3__FECAEAGet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__FECAEAGet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__FECAEADetResponse(struct soap *soap, ns3__FECAEADetResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__FECAEADetResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__FECAEADetResponse(struct soap *soap, const char *tag, int id, ns3__FECAEADetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__FECAEADetResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__FECAEADetResponse ? type : NULL);
}

SOAP_FMAC3 ns3__FECAEADetResponse ** SOAP_FMAC4 soap_in_PointerTons3__FECAEADetResponse(struct soap *soap, const char *tag, ns3__FECAEADetResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__FECAEADetResponse **)soap_malloc(soap, sizeof(ns3__FECAEADetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__FECAEADetResponse *)soap_instantiate_ns3__FECAEADetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__FECAEADetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__FECAEADetResponse, sizeof(ns3__FECAEADetResponse), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__FECAEADetResponse(struct soap *soap, ns3__FECAEADetResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__FECAEADetResponse(soap, tag ? tag : "ns3:FECAEADetResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__FECAEADetResponse ** SOAP_FMAC4 soap_get_PointerTons3__FECAEADetResponse(struct soap *soap, ns3__FECAEADetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__FECAEADetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfFECAEADetResponse(struct soap *soap, ns3__ArrayOfFECAEADetResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__ArrayOfFECAEADetResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfFECAEADetResponse(struct soap *soap, const char *tag, int id, ns3__ArrayOfFECAEADetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__ArrayOfFECAEADetResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__ArrayOfFECAEADetResponse ? type : NULL);
}

SOAP_FMAC3 ns3__ArrayOfFECAEADetResponse ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfFECAEADetResponse(struct soap *soap, const char *tag, ns3__ArrayOfFECAEADetResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfFECAEADetResponse **)soap_malloc(soap, sizeof(ns3__ArrayOfFECAEADetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfFECAEADetResponse *)soap_instantiate_ns3__ArrayOfFECAEADetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__ArrayOfFECAEADetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__ArrayOfFECAEADetResponse, sizeof(ns3__ArrayOfFECAEADetResponse), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfFECAEADetResponse(struct soap *soap, ns3__ArrayOfFECAEADetResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__ArrayOfFECAEADetResponse(soap, tag ? tag : "ns3:ArrayOfFECAEADetResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__ArrayOfFECAEADetResponse ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfFECAEADetResponse(struct soap *soap, ns3__ArrayOfFECAEADetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfFECAEADetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__FECAEACabResponse(struct soap *soap, ns3__FECAEACabResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__FECAEACabResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__FECAEACabResponse(struct soap *soap, const char *tag, int id, ns3__FECAEACabResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__FECAEACabResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__FECAEACabResponse ? type : NULL);
}

SOAP_FMAC3 ns3__FECAEACabResponse ** SOAP_FMAC4 soap_in_PointerTons3__FECAEACabResponse(struct soap *soap, const char *tag, ns3__FECAEACabResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__FECAEACabResponse **)soap_malloc(soap, sizeof(ns3__FECAEACabResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__FECAEACabResponse *)soap_instantiate_ns3__FECAEACabResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__FECAEACabResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__FECAEACabResponse, sizeof(ns3__FECAEACabResponse), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__FECAEACabResponse(struct soap *soap, ns3__FECAEACabResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__FECAEACabResponse(soap, tag ? tag : "ns3:FECAEACabResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__FECAEACabResponse ** SOAP_FMAC4 soap_get_PointerTons3__FECAEACabResponse(struct soap *soap, ns3__FECAEACabResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__FECAEACabResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__FECAEADetRequest(struct soap *soap, ns3__FECAEADetRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__FECAEADetRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__FECAEADetRequest(struct soap *soap, const char *tag, int id, ns3__FECAEADetRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__FECAEADetRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__FECAEADetRequest ? type : NULL);
}

SOAP_FMAC3 ns3__FECAEADetRequest ** SOAP_FMAC4 soap_in_PointerTons3__FECAEADetRequest(struct soap *soap, const char *tag, ns3__FECAEADetRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__FECAEADetRequest **)soap_malloc(soap, sizeof(ns3__FECAEADetRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__FECAEADetRequest *)soap_instantiate_ns3__FECAEADetRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__FECAEADetRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__FECAEADetRequest, sizeof(ns3__FECAEADetRequest), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__FECAEADetRequest(struct soap *soap, ns3__FECAEADetRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__FECAEADetRequest(soap, tag ? tag : "ns3:FECAEADetRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__FECAEADetRequest ** SOAP_FMAC4 soap_get_PointerTons3__FECAEADetRequest(struct soap *soap, ns3__FECAEADetRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__FECAEADetRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfFECAEADetRequest(struct soap *soap, ns3__ArrayOfFECAEADetRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__ArrayOfFECAEADetRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfFECAEADetRequest(struct soap *soap, const char *tag, int id, ns3__ArrayOfFECAEADetRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__ArrayOfFECAEADetRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__ArrayOfFECAEADetRequest ? type : NULL);
}

SOAP_FMAC3 ns3__ArrayOfFECAEADetRequest ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfFECAEADetRequest(struct soap *soap, const char *tag, ns3__ArrayOfFECAEADetRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfFECAEADetRequest **)soap_malloc(soap, sizeof(ns3__ArrayOfFECAEADetRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfFECAEADetRequest *)soap_instantiate_ns3__ArrayOfFECAEADetRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__ArrayOfFECAEADetRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__ArrayOfFECAEADetRequest, sizeof(ns3__ArrayOfFECAEADetRequest), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfFECAEADetRequest(struct soap *soap, ns3__ArrayOfFECAEADetRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__ArrayOfFECAEADetRequest(soap, tag ? tag : "ns3:ArrayOfFECAEADetRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__ArrayOfFECAEADetRequest ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfFECAEADetRequest(struct soap *soap, ns3__ArrayOfFECAEADetRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfFECAEADetRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__FECAEACabRequest(struct soap *soap, ns3__FECAEACabRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__FECAEACabRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__FECAEACabRequest(struct soap *soap, const char *tag, int id, ns3__FECAEACabRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__FECAEACabRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__FECAEACabRequest ? type : NULL);
}

SOAP_FMAC3 ns3__FECAEACabRequest ** SOAP_FMAC4 soap_in_PointerTons3__FECAEACabRequest(struct soap *soap, const char *tag, ns3__FECAEACabRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__FECAEACabRequest **)soap_malloc(soap, sizeof(ns3__FECAEACabRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__FECAEACabRequest *)soap_instantiate_ns3__FECAEACabRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__FECAEACabRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__FECAEACabRequest, sizeof(ns3__FECAEACabRequest), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__FECAEACabRequest(struct soap *soap, ns3__FECAEACabRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__FECAEACabRequest(soap, tag ? tag : "ns3:FECAEACabRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__FECAEACabRequest ** SOAP_FMAC4 soap_get_PointerTons3__FECAEACabRequest(struct soap *soap, ns3__FECAEACabRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__FECAEACabRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__FECompConsResponse(struct soap *soap, ns3__FECompConsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__FECompConsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__FECompConsResponse(struct soap *soap, const char *tag, int id, ns3__FECompConsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__FECompConsResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__FECompConsResponse ? type : NULL);
}

SOAP_FMAC3 ns3__FECompConsResponse ** SOAP_FMAC4 soap_in_PointerTons3__FECompConsResponse(struct soap *soap, const char *tag, ns3__FECompConsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__FECompConsResponse **)soap_malloc(soap, sizeof(ns3__FECompConsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__FECompConsResponse *)soap_instantiate_ns3__FECompConsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__FECompConsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__FECompConsResponse, sizeof(ns3__FECompConsResponse), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__FECompConsResponse(struct soap *soap, ns3__FECompConsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__FECompConsResponse(soap, tag ? tag : "ns3:FECompConsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__FECompConsResponse ** SOAP_FMAC4 soap_get_PointerTons3__FECompConsResponse(struct soap *soap, ns3__FECompConsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__FECompConsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__Err(struct soap *soap, ns3__Err *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__Err))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__Err(struct soap *soap, const char *tag, int id, ns3__Err *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__Err, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__Err ? type : NULL);
}

SOAP_FMAC3 ns3__Err ** SOAP_FMAC4 soap_in_PointerTons3__Err(struct soap *soap, const char *tag, ns3__Err **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__Err **)soap_malloc(soap, sizeof(ns3__Err *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__Err *)soap_instantiate_ns3__Err(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__Err **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__Err, sizeof(ns3__Err), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__Err(struct soap *soap, ns3__Err *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__Err(soap, tag ? tag : "ns3:Err", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__Err ** SOAP_FMAC4 soap_get_PointerTons3__Err(struct soap *soap, ns3__Err **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__Err(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__Evt(struct soap *soap, ns3__Evt *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__Evt))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__Evt(struct soap *soap, const char *tag, int id, ns3__Evt *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__Evt, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__Evt ? type : NULL);
}

SOAP_FMAC3 ns3__Evt ** SOAP_FMAC4 soap_in_PointerTons3__Evt(struct soap *soap, const char *tag, ns3__Evt **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__Evt **)soap_malloc(soap, sizeof(ns3__Evt *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__Evt *)soap_instantiate_ns3__Evt(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__Evt **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__Evt, sizeof(ns3__Evt), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__Evt(struct soap *soap, ns3__Evt *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__Evt(soap, tag ? tag : "ns3:Evt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__Evt ** SOAP_FMAC4 soap_get_PointerTons3__Evt(struct soap *soap, ns3__Evt **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__Evt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__Obs(struct soap *soap, ns3__Obs *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__Obs))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__Obs(struct soap *soap, const char *tag, int id, ns3__Obs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__Obs, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__Obs ? type : NULL);
}

SOAP_FMAC3 ns3__Obs ** SOAP_FMAC4 soap_in_PointerTons3__Obs(struct soap *soap, const char *tag, ns3__Obs **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__Obs **)soap_malloc(soap, sizeof(ns3__Obs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__Obs *)soap_instantiate_ns3__Obs(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__Obs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__Obs, sizeof(ns3__Obs), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__Obs(struct soap *soap, ns3__Obs *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__Obs(soap, tag ? tag : "ns3:Obs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__Obs ** SOAP_FMAC4 soap_get_PointerTons3__Obs(struct soap *soap, ns3__Obs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__Obs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfObs(struct soap *soap, ns3__ArrayOfObs *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__ArrayOfObs))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfObs(struct soap *soap, const char *tag, int id, ns3__ArrayOfObs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__ArrayOfObs, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__ArrayOfObs ? type : NULL);
}

SOAP_FMAC3 ns3__ArrayOfObs ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfObs(struct soap *soap, const char *tag, ns3__ArrayOfObs **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfObs **)soap_malloc(soap, sizeof(ns3__ArrayOfObs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfObs *)soap_instantiate_ns3__ArrayOfObs(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__ArrayOfObs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__ArrayOfObs, sizeof(ns3__ArrayOfObs), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfObs(struct soap *soap, ns3__ArrayOfObs *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__ArrayOfObs(soap, tag ? tag : "ns3:ArrayOfObs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__ArrayOfObs ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfObs(struct soap *soap, ns3__ArrayOfObs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfObs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__FECAEDetResponse(struct soap *soap, ns3__FECAEDetResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__FECAEDetResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__FECAEDetResponse(struct soap *soap, const char *tag, int id, ns3__FECAEDetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__FECAEDetResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__FECAEDetResponse ? type : NULL);
}

SOAP_FMAC3 ns3__FECAEDetResponse ** SOAP_FMAC4 soap_in_PointerTons3__FECAEDetResponse(struct soap *soap, const char *tag, ns3__FECAEDetResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__FECAEDetResponse **)soap_malloc(soap, sizeof(ns3__FECAEDetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__FECAEDetResponse *)soap_instantiate_ns3__FECAEDetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__FECAEDetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__FECAEDetResponse, sizeof(ns3__FECAEDetResponse), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__FECAEDetResponse(struct soap *soap, ns3__FECAEDetResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__FECAEDetResponse(soap, tag ? tag : "ns3:FECAEDetResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__FECAEDetResponse ** SOAP_FMAC4 soap_get_PointerTons3__FECAEDetResponse(struct soap *soap, ns3__FECAEDetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__FECAEDetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfErr(struct soap *soap, ns3__ArrayOfErr *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__ArrayOfErr))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfErr(struct soap *soap, const char *tag, int id, ns3__ArrayOfErr *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__ArrayOfErr, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__ArrayOfErr ? type : NULL);
}

SOAP_FMAC3 ns3__ArrayOfErr ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfErr(struct soap *soap, const char *tag, ns3__ArrayOfErr **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfErr **)soap_malloc(soap, sizeof(ns3__ArrayOfErr *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfErr *)soap_instantiate_ns3__ArrayOfErr(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__ArrayOfErr **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__ArrayOfErr, sizeof(ns3__ArrayOfErr), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfErr(struct soap *soap, ns3__ArrayOfErr *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__ArrayOfErr(soap, tag ? tag : "ns3:ArrayOfErr", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__ArrayOfErr ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfErr(struct soap *soap, ns3__ArrayOfErr **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfErr(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfEvt(struct soap *soap, ns3__ArrayOfEvt *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__ArrayOfEvt))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfEvt(struct soap *soap, const char *tag, int id, ns3__ArrayOfEvt *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__ArrayOfEvt, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__ArrayOfEvt ? type : NULL);
}

SOAP_FMAC3 ns3__ArrayOfEvt ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfEvt(struct soap *soap, const char *tag, ns3__ArrayOfEvt **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfEvt **)soap_malloc(soap, sizeof(ns3__ArrayOfEvt *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfEvt *)soap_instantiate_ns3__ArrayOfEvt(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__ArrayOfEvt **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__ArrayOfEvt, sizeof(ns3__ArrayOfEvt), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfEvt(struct soap *soap, ns3__ArrayOfEvt *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__ArrayOfEvt(soap, tag ? tag : "ns3:ArrayOfEvt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__ArrayOfEvt ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfEvt(struct soap *soap, ns3__ArrayOfEvt **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfEvt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfFECAEDetResponse(struct soap *soap, ns3__ArrayOfFECAEDetResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__ArrayOfFECAEDetResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfFECAEDetResponse(struct soap *soap, const char *tag, int id, ns3__ArrayOfFECAEDetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__ArrayOfFECAEDetResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__ArrayOfFECAEDetResponse ? type : NULL);
}

SOAP_FMAC3 ns3__ArrayOfFECAEDetResponse ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfFECAEDetResponse(struct soap *soap, const char *tag, ns3__ArrayOfFECAEDetResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfFECAEDetResponse **)soap_malloc(soap, sizeof(ns3__ArrayOfFECAEDetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfFECAEDetResponse *)soap_instantiate_ns3__ArrayOfFECAEDetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__ArrayOfFECAEDetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__ArrayOfFECAEDetResponse, sizeof(ns3__ArrayOfFECAEDetResponse), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfFECAEDetResponse(struct soap *soap, ns3__ArrayOfFECAEDetResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__ArrayOfFECAEDetResponse(soap, tag ? tag : "ns3:ArrayOfFECAEDetResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__ArrayOfFECAEDetResponse ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfFECAEDetResponse(struct soap *soap, ns3__ArrayOfFECAEDetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfFECAEDetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__FECAECabResponse(struct soap *soap, ns3__FECAECabResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__FECAECabResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__FECAECabResponse(struct soap *soap, const char *tag, int id, ns3__FECAECabResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__FECAECabResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__FECAECabResponse ? type : NULL);
}

SOAP_FMAC3 ns3__FECAECabResponse ** SOAP_FMAC4 soap_in_PointerTons3__FECAECabResponse(struct soap *soap, const char *tag, ns3__FECAECabResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__FECAECabResponse **)soap_malloc(soap, sizeof(ns3__FECAECabResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__FECAECabResponse *)soap_instantiate_ns3__FECAECabResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__FECAECabResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__FECAECabResponse, sizeof(ns3__FECAECabResponse), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__FECAECabResponse(struct soap *soap, ns3__FECAECabResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__FECAECabResponse(soap, tag ? tag : "ns3:FECAECabResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__FECAECabResponse ** SOAP_FMAC4 soap_get_PointerTons3__FECAECabResponse(struct soap *soap, ns3__FECAECabResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__FECAECabResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__Comprador(struct soap *soap, ns3__Comprador *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__Comprador))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__Comprador(struct soap *soap, const char *tag, int id, ns3__Comprador *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__Comprador, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__Comprador ? type : NULL);
}

SOAP_FMAC3 ns3__Comprador ** SOAP_FMAC4 soap_in_PointerTons3__Comprador(struct soap *soap, const char *tag, ns3__Comprador **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__Comprador **)soap_malloc(soap, sizeof(ns3__Comprador *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__Comprador *)soap_instantiate_ns3__Comprador(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__Comprador **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__Comprador, sizeof(ns3__Comprador), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__Comprador(struct soap *soap, ns3__Comprador *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__Comprador(soap, tag ? tag : "ns3:Comprador", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__Comprador ** SOAP_FMAC4 soap_get_PointerTons3__Comprador(struct soap *soap, ns3__Comprador **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__Comprador(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__Opcional(struct soap *soap, ns3__Opcional *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__Opcional))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__Opcional(struct soap *soap, const char *tag, int id, ns3__Opcional *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__Opcional, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__Opcional ? type : NULL);
}

SOAP_FMAC3 ns3__Opcional ** SOAP_FMAC4 soap_in_PointerTons3__Opcional(struct soap *soap, const char *tag, ns3__Opcional **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__Opcional **)soap_malloc(soap, sizeof(ns3__Opcional *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__Opcional *)soap_instantiate_ns3__Opcional(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__Opcional **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__Opcional, sizeof(ns3__Opcional), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__Opcional(struct soap *soap, ns3__Opcional *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__Opcional(soap, tag ? tag : "ns3:Opcional", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__Opcional ** SOAP_FMAC4 soap_get_PointerTons3__Opcional(struct soap *soap, ns3__Opcional **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__Opcional(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__AlicIva(struct soap *soap, ns3__AlicIva *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__AlicIva))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__AlicIva(struct soap *soap, const char *tag, int id, ns3__AlicIva *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__AlicIva, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__AlicIva ? type : NULL);
}

SOAP_FMAC3 ns3__AlicIva ** SOAP_FMAC4 soap_in_PointerTons3__AlicIva(struct soap *soap, const char *tag, ns3__AlicIva **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__AlicIva **)soap_malloc(soap, sizeof(ns3__AlicIva *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__AlicIva *)soap_instantiate_ns3__AlicIva(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__AlicIva **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__AlicIva, sizeof(ns3__AlicIva), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__AlicIva(struct soap *soap, ns3__AlicIva *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__AlicIva(soap, tag ? tag : "ns3:AlicIva", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__AlicIva ** SOAP_FMAC4 soap_get_PointerTons3__AlicIva(struct soap *soap, ns3__AlicIva **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__AlicIva(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__Tributo(struct soap *soap, ns3__Tributo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__Tributo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__Tributo(struct soap *soap, const char *tag, int id, ns3__Tributo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__Tributo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__Tributo ? type : NULL);
}

SOAP_FMAC3 ns3__Tributo ** SOAP_FMAC4 soap_in_PointerTons3__Tributo(struct soap *soap, const char *tag, ns3__Tributo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__Tributo **)soap_malloc(soap, sizeof(ns3__Tributo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__Tributo *)soap_instantiate_ns3__Tributo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__Tributo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__Tributo, sizeof(ns3__Tributo), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__Tributo(struct soap *soap, ns3__Tributo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__Tributo(soap, tag ? tag : "ns3:Tributo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__Tributo ** SOAP_FMAC4 soap_get_PointerTons3__Tributo(struct soap *soap, ns3__Tributo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__Tributo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__CbteAsoc(struct soap *soap, ns3__CbteAsoc *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__CbteAsoc))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__CbteAsoc(struct soap *soap, const char *tag, int id, ns3__CbteAsoc *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__CbteAsoc, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__CbteAsoc ? type : NULL);
}

SOAP_FMAC3 ns3__CbteAsoc ** SOAP_FMAC4 soap_in_PointerTons3__CbteAsoc(struct soap *soap, const char *tag, ns3__CbteAsoc **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__CbteAsoc **)soap_malloc(soap, sizeof(ns3__CbteAsoc *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__CbteAsoc *)soap_instantiate_ns3__CbteAsoc(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__CbteAsoc **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__CbteAsoc, sizeof(ns3__CbteAsoc), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__CbteAsoc(struct soap *soap, ns3__CbteAsoc *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__CbteAsoc(soap, tag ? tag : "ns3:CbteAsoc", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__CbteAsoc ** SOAP_FMAC4 soap_get_PointerTons3__CbteAsoc(struct soap *soap, ns3__CbteAsoc **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__CbteAsoc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfComprador(struct soap *soap, ns3__ArrayOfComprador *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__ArrayOfComprador))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfComprador(struct soap *soap, const char *tag, int id, ns3__ArrayOfComprador *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__ArrayOfComprador, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__ArrayOfComprador ? type : NULL);
}

SOAP_FMAC3 ns3__ArrayOfComprador ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfComprador(struct soap *soap, const char *tag, ns3__ArrayOfComprador **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfComprador **)soap_malloc(soap, sizeof(ns3__ArrayOfComprador *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfComprador *)soap_instantiate_ns3__ArrayOfComprador(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__ArrayOfComprador **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__ArrayOfComprador, sizeof(ns3__ArrayOfComprador), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfComprador(struct soap *soap, ns3__ArrayOfComprador *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__ArrayOfComprador(soap, tag ? tag : "ns3:ArrayOfComprador", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__ArrayOfComprador ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfComprador(struct soap *soap, ns3__ArrayOfComprador **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfComprador(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfOpcional(struct soap *soap, ns3__ArrayOfOpcional *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__ArrayOfOpcional))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfOpcional(struct soap *soap, const char *tag, int id, ns3__ArrayOfOpcional *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__ArrayOfOpcional, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__ArrayOfOpcional ? type : NULL);
}

SOAP_FMAC3 ns3__ArrayOfOpcional ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfOpcional(struct soap *soap, const char *tag, ns3__ArrayOfOpcional **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfOpcional **)soap_malloc(soap, sizeof(ns3__ArrayOfOpcional *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfOpcional *)soap_instantiate_ns3__ArrayOfOpcional(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__ArrayOfOpcional **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__ArrayOfOpcional, sizeof(ns3__ArrayOfOpcional), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfOpcional(struct soap *soap, ns3__ArrayOfOpcional *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__ArrayOfOpcional(soap, tag ? tag : "ns3:ArrayOfOpcional", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__ArrayOfOpcional ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfOpcional(struct soap *soap, ns3__ArrayOfOpcional **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfOpcional(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfAlicIva(struct soap *soap, ns3__ArrayOfAlicIva *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__ArrayOfAlicIva))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfAlicIva(struct soap *soap, const char *tag, int id, ns3__ArrayOfAlicIva *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__ArrayOfAlicIva, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__ArrayOfAlicIva ? type : NULL);
}

SOAP_FMAC3 ns3__ArrayOfAlicIva ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfAlicIva(struct soap *soap, const char *tag, ns3__ArrayOfAlicIva **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfAlicIva **)soap_malloc(soap, sizeof(ns3__ArrayOfAlicIva *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfAlicIva *)soap_instantiate_ns3__ArrayOfAlicIva(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__ArrayOfAlicIva **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__ArrayOfAlicIva, sizeof(ns3__ArrayOfAlicIva), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfAlicIva(struct soap *soap, ns3__ArrayOfAlicIva *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__ArrayOfAlicIva(soap, tag ? tag : "ns3:ArrayOfAlicIva", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__ArrayOfAlicIva ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfAlicIva(struct soap *soap, ns3__ArrayOfAlicIva **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfAlicIva(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfTributo(struct soap *soap, ns3__ArrayOfTributo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__ArrayOfTributo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfTributo(struct soap *soap, const char *tag, int id, ns3__ArrayOfTributo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__ArrayOfTributo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__ArrayOfTributo ? type : NULL);
}

SOAP_FMAC3 ns3__ArrayOfTributo ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfTributo(struct soap *soap, const char *tag, ns3__ArrayOfTributo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfTributo **)soap_malloc(soap, sizeof(ns3__ArrayOfTributo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfTributo *)soap_instantiate_ns3__ArrayOfTributo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__ArrayOfTributo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__ArrayOfTributo, sizeof(ns3__ArrayOfTributo), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfTributo(struct soap *soap, ns3__ArrayOfTributo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__ArrayOfTributo(soap, tag ? tag : "ns3:ArrayOfTributo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__ArrayOfTributo ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfTributo(struct soap *soap, ns3__ArrayOfTributo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfTributo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfCbteAsoc(struct soap *soap, ns3__ArrayOfCbteAsoc *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__ArrayOfCbteAsoc))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfCbteAsoc(struct soap *soap, const char *tag, int id, ns3__ArrayOfCbteAsoc *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__ArrayOfCbteAsoc, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__ArrayOfCbteAsoc ? type : NULL);
}

SOAP_FMAC3 ns3__ArrayOfCbteAsoc ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfCbteAsoc(struct soap *soap, const char *tag, ns3__ArrayOfCbteAsoc **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfCbteAsoc **)soap_malloc(soap, sizeof(ns3__ArrayOfCbteAsoc *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfCbteAsoc *)soap_instantiate_ns3__ArrayOfCbteAsoc(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__ArrayOfCbteAsoc **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__ArrayOfCbteAsoc, sizeof(ns3__ArrayOfCbteAsoc), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfCbteAsoc(struct soap *soap, ns3__ArrayOfCbteAsoc *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__ArrayOfCbteAsoc(soap, tag ? tag : "ns3:ArrayOfCbteAsoc", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__ArrayOfCbteAsoc ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfCbteAsoc(struct soap *soap, ns3__ArrayOfCbteAsoc **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfCbteAsoc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__FECAEDetRequest(struct soap *soap, ns3__FECAEDetRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__FECAEDetRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__FECAEDetRequest(struct soap *soap, const char *tag, int id, ns3__FECAEDetRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__FECAEDetRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__FECAEDetRequest ? type : NULL);
}

SOAP_FMAC3 ns3__FECAEDetRequest ** SOAP_FMAC4 soap_in_PointerTons3__FECAEDetRequest(struct soap *soap, const char *tag, ns3__FECAEDetRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__FECAEDetRequest **)soap_malloc(soap, sizeof(ns3__FECAEDetRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__FECAEDetRequest *)soap_instantiate_ns3__FECAEDetRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__FECAEDetRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__FECAEDetRequest, sizeof(ns3__FECAEDetRequest), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__FECAEDetRequest(struct soap *soap, ns3__FECAEDetRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__FECAEDetRequest(soap, tag ? tag : "ns3:FECAEDetRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__FECAEDetRequest ** SOAP_FMAC4 soap_get_PointerTons3__FECAEDetRequest(struct soap *soap, ns3__FECAEDetRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__FECAEDetRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfFECAEDetRequest(struct soap *soap, ns3__ArrayOfFECAEDetRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__ArrayOfFECAEDetRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfFECAEDetRequest(struct soap *soap, const char *tag, int id, ns3__ArrayOfFECAEDetRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__ArrayOfFECAEDetRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__ArrayOfFECAEDetRequest ? type : NULL);
}

SOAP_FMAC3 ns3__ArrayOfFECAEDetRequest ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfFECAEDetRequest(struct soap *soap, const char *tag, ns3__ArrayOfFECAEDetRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfFECAEDetRequest **)soap_malloc(soap, sizeof(ns3__ArrayOfFECAEDetRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfFECAEDetRequest *)soap_instantiate_ns3__ArrayOfFECAEDetRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__ArrayOfFECAEDetRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__ArrayOfFECAEDetRequest, sizeof(ns3__ArrayOfFECAEDetRequest), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfFECAEDetRequest(struct soap *soap, ns3__ArrayOfFECAEDetRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__ArrayOfFECAEDetRequest(soap, tag ? tag : "ns3:ArrayOfFECAEDetRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__ArrayOfFECAEDetRequest ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfFECAEDetRequest(struct soap *soap, ns3__ArrayOfFECAEDetRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfFECAEDetRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__FECAECabRequest(struct soap *soap, ns3__FECAECabRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_ns3__FECAECabRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__FECAECabRequest(struct soap *soap, const char *tag, int id, ns3__FECAECabRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_ns3__FECAECabRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip_ns3__FECAECabRequest ? type : NULL);
}

SOAP_FMAC3 ns3__FECAECabRequest ** SOAP_FMAC4 soap_in_PointerTons3__FECAECabRequest(struct soap *soap, const char *tag, ns3__FECAECabRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__FECAECabRequest **)soap_malloc(soap, sizeof(ns3__FECAECabRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__FECAECabRequest *)soap_instantiate_ns3__FECAECabRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__FECAECabRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_ns3__FECAECabRequest, sizeof(ns3__FECAECabRequest), 0, afip_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__FECAECabRequest(struct soap *soap, ns3__FECAECabRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__FECAECabRequest(soap, tag ? tag : "ns3:FECAECabRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__FECAECabRequest ** SOAP_FMAC4 soap_get_PointerTons3__FECAECabRequest(struct soap *soap, ns3__FECAECabRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__FECAECabRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip_std__string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip_std__string, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_afip__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_afip__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_afip__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_afip_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_afip_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_afip_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__PaisTipo(struct soap *soap, std::vector<ns3__PaisTipo *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__PaisTipo(struct soap *soap, const std::vector<ns3__PaisTipo *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns3__PaisTipo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__PaisTipo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__PaisTipo(struct soap *soap, const char *tag, int id, const std::vector<ns3__PaisTipo *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns3__PaisTipo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__PaisTipo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__PaisTipo *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__PaisTipo(struct soap *soap, const char *tag, std::vector<ns3__PaisTipo *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__PaisTipo(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns3__PaisTipo *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip_ns3__PaisTipo, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__PaisTipo, sizeof(ns3__PaisTipo), 1, afip_finsert, afip_fbase))
				break;
			if (!soap_in_PointerTons3__PaisTipo(soap, tag, NULL, "ns3:PaisTipo"))
				break;
		}
		else
		{	if (!soap_in_PointerTons3__PaisTipo(soap, tag, &n, "ns3:PaisTipo"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__PaisTipo *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__PaisTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__PaisTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns3__PaisTipo *> *p;
	size_t k = sizeof(std::vector<ns3__PaisTipo *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__PaisTipo, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns3__PaisTipo *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns3__PaisTipo *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns3__PaisTipo *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__DocTipo(struct soap *soap, std::vector<ns3__DocTipo *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__DocTipo(struct soap *soap, const std::vector<ns3__DocTipo *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns3__DocTipo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__DocTipo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__DocTipo(struct soap *soap, const char *tag, int id, const std::vector<ns3__DocTipo *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns3__DocTipo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__DocTipo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__DocTipo *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__DocTipo(struct soap *soap, const char *tag, std::vector<ns3__DocTipo *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__DocTipo(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns3__DocTipo *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip_ns3__DocTipo, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__DocTipo, sizeof(ns3__DocTipo), 1, afip_finsert, afip_fbase))
				break;
			if (!soap_in_PointerTons3__DocTipo(soap, tag, NULL, "ns3:DocTipo"))
				break;
		}
		else
		{	if (!soap_in_PointerTons3__DocTipo(soap, tag, &n, "ns3:DocTipo"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__DocTipo *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__DocTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__DocTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns3__DocTipo *> *p;
	size_t k = sizeof(std::vector<ns3__DocTipo *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__DocTipo, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns3__DocTipo *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns3__DocTipo *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns3__DocTipo *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__CbteTipo(struct soap *soap, std::vector<ns3__CbteTipo *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__CbteTipo(struct soap *soap, const std::vector<ns3__CbteTipo *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns3__CbteTipo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__CbteTipo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__CbteTipo(struct soap *soap, const char *tag, int id, const std::vector<ns3__CbteTipo *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns3__CbteTipo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__CbteTipo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__CbteTipo *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__CbteTipo(struct soap *soap, const char *tag, std::vector<ns3__CbteTipo *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__CbteTipo(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns3__CbteTipo *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip_ns3__CbteTipo, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__CbteTipo, sizeof(ns3__CbteTipo), 1, afip_finsert, afip_fbase))
				break;
			if (!soap_in_PointerTons3__CbteTipo(soap, tag, NULL, "ns3:CbteTipo"))
				break;
		}
		else
		{	if (!soap_in_PointerTons3__CbteTipo(soap, tag, &n, "ns3:CbteTipo"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__CbteTipo *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__CbteTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__CbteTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns3__CbteTipo *> *p;
	size_t k = sizeof(std::vector<ns3__CbteTipo *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__CbteTipo, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns3__CbteTipo *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns3__CbteTipo *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns3__CbteTipo *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__PtoVenta(struct soap *soap, std::vector<ns3__PtoVenta *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__PtoVenta(struct soap *soap, const std::vector<ns3__PtoVenta *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns3__PtoVenta *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__PtoVenta(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__PtoVenta(struct soap *soap, const char *tag, int id, const std::vector<ns3__PtoVenta *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns3__PtoVenta *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__PtoVenta(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__PtoVenta *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__PtoVenta(struct soap *soap, const char *tag, std::vector<ns3__PtoVenta *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__PtoVenta(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns3__PtoVenta *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip_ns3__PtoVenta, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__PtoVenta, sizeof(ns3__PtoVenta), 1, afip_finsert, afip_fbase))
				break;
			if (!soap_in_PointerTons3__PtoVenta(soap, tag, NULL, "ns3:PtoVenta"))
				break;
		}
		else
		{	if (!soap_in_PointerTons3__PtoVenta(soap, tag, &n, "ns3:PtoVenta"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__PtoVenta *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__PtoVenta(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__PtoVenta(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns3__PtoVenta *> *p;
	size_t k = sizeof(std::vector<ns3__PtoVenta *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__PtoVenta, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns3__PtoVenta *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns3__PtoVenta *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns3__PtoVenta *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__ConceptoTipo(struct soap *soap, std::vector<ns3__ConceptoTipo *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__ConceptoTipo(struct soap *soap, const std::vector<ns3__ConceptoTipo *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns3__ConceptoTipo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__ConceptoTipo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__ConceptoTipo(struct soap *soap, const char *tag, int id, const std::vector<ns3__ConceptoTipo *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns3__ConceptoTipo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__ConceptoTipo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__ConceptoTipo *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__ConceptoTipo(struct soap *soap, const char *tag, std::vector<ns3__ConceptoTipo *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__ConceptoTipo(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns3__ConceptoTipo *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip_ns3__ConceptoTipo, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__ConceptoTipo, sizeof(ns3__ConceptoTipo), 1, afip_finsert, afip_fbase))
				break;
			if (!soap_in_PointerTons3__ConceptoTipo(soap, tag, NULL, "ns3:ConceptoTipo"))
				break;
		}
		else
		{	if (!soap_in_PointerTons3__ConceptoTipo(soap, tag, &n, "ns3:ConceptoTipo"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__ConceptoTipo *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__ConceptoTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__ConceptoTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns3__ConceptoTipo *> *p;
	size_t k = sizeof(std::vector<ns3__ConceptoTipo *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__ConceptoTipo, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns3__ConceptoTipo *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns3__ConceptoTipo *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns3__ConceptoTipo *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__OpcionalTipo(struct soap *soap, std::vector<ns3__OpcionalTipo *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__OpcionalTipo(struct soap *soap, const std::vector<ns3__OpcionalTipo *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns3__OpcionalTipo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__OpcionalTipo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__OpcionalTipo(struct soap *soap, const char *tag, int id, const std::vector<ns3__OpcionalTipo *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns3__OpcionalTipo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__OpcionalTipo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__OpcionalTipo *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__OpcionalTipo(struct soap *soap, const char *tag, std::vector<ns3__OpcionalTipo *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__OpcionalTipo(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns3__OpcionalTipo *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip_ns3__OpcionalTipo, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__OpcionalTipo, sizeof(ns3__OpcionalTipo), 1, afip_finsert, afip_fbase))
				break;
			if (!soap_in_PointerTons3__OpcionalTipo(soap, tag, NULL, "ns3:OpcionalTipo"))
				break;
		}
		else
		{	if (!soap_in_PointerTons3__OpcionalTipo(soap, tag, &n, "ns3:OpcionalTipo"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__OpcionalTipo *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__OpcionalTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__OpcionalTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns3__OpcionalTipo *> *p;
	size_t k = sizeof(std::vector<ns3__OpcionalTipo *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__OpcionalTipo, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns3__OpcionalTipo *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns3__OpcionalTipo *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns3__OpcionalTipo *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__IvaTipo(struct soap *soap, std::vector<ns3__IvaTipo *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__IvaTipo(struct soap *soap, const std::vector<ns3__IvaTipo *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns3__IvaTipo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__IvaTipo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__IvaTipo(struct soap *soap, const char *tag, int id, const std::vector<ns3__IvaTipo *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns3__IvaTipo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__IvaTipo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__IvaTipo *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__IvaTipo(struct soap *soap, const char *tag, std::vector<ns3__IvaTipo *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__IvaTipo(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns3__IvaTipo *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip_ns3__IvaTipo, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__IvaTipo, sizeof(ns3__IvaTipo), 1, afip_finsert, afip_fbase))
				break;
			if (!soap_in_PointerTons3__IvaTipo(soap, tag, NULL, "ns3:IvaTipo"))
				break;
		}
		else
		{	if (!soap_in_PointerTons3__IvaTipo(soap, tag, &n, "ns3:IvaTipo"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__IvaTipo *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__IvaTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__IvaTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns3__IvaTipo *> *p;
	size_t k = sizeof(std::vector<ns3__IvaTipo *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__IvaTipo, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns3__IvaTipo *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns3__IvaTipo *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns3__IvaTipo *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__Moneda(struct soap *soap, std::vector<ns3__Moneda *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__Moneda(struct soap *soap, const std::vector<ns3__Moneda *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns3__Moneda *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__Moneda(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__Moneda(struct soap *soap, const char *tag, int id, const std::vector<ns3__Moneda *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns3__Moneda *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__Moneda(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__Moneda *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__Moneda(struct soap *soap, const char *tag, std::vector<ns3__Moneda *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__Moneda(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns3__Moneda *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip_ns3__Moneda, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Moneda, sizeof(ns3__Moneda), 1, afip_finsert, afip_fbase))
				break;
			if (!soap_in_PointerTons3__Moneda(soap, tag, NULL, "ns3:Moneda"))
				break;
		}
		else
		{	if (!soap_in_PointerTons3__Moneda(soap, tag, &n, "ns3:Moneda"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__Moneda *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__Moneda(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__Moneda(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns3__Moneda *> *p;
	size_t k = sizeof(std::vector<ns3__Moneda *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Moneda, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns3__Moneda *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns3__Moneda *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns3__Moneda *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__TributoTipo(struct soap *soap, std::vector<ns3__TributoTipo *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__TributoTipo(struct soap *soap, const std::vector<ns3__TributoTipo *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns3__TributoTipo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__TributoTipo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__TributoTipo(struct soap *soap, const char *tag, int id, const std::vector<ns3__TributoTipo *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns3__TributoTipo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__TributoTipo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__TributoTipo *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__TributoTipo(struct soap *soap, const char *tag, std::vector<ns3__TributoTipo *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__TributoTipo(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns3__TributoTipo *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip_ns3__TributoTipo, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__TributoTipo, sizeof(ns3__TributoTipo), 1, afip_finsert, afip_fbase))
				break;
			if (!soap_in_PointerTons3__TributoTipo(soap, tag, NULL, "ns3:TributoTipo"))
				break;
		}
		else
		{	if (!soap_in_PointerTons3__TributoTipo(soap, tag, &n, "ns3:TributoTipo"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__TributoTipo *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__TributoTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__TributoTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns3__TributoTipo *> *p;
	size_t k = sizeof(std::vector<ns3__TributoTipo *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__TributoTipo, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns3__TributoTipo *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns3__TributoTipo *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns3__TributoTipo *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__FECAEASinMov(struct soap *soap, std::vector<ns3__FECAEASinMov *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__FECAEASinMov(struct soap *soap, const std::vector<ns3__FECAEASinMov *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns3__FECAEASinMov *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__FECAEASinMov(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__FECAEASinMov(struct soap *soap, const char *tag, int id, const std::vector<ns3__FECAEASinMov *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns3__FECAEASinMov *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__FECAEASinMov(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__FECAEASinMov *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__FECAEASinMov(struct soap *soap, const char *tag, std::vector<ns3__FECAEASinMov *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__FECAEASinMov(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns3__FECAEASinMov *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip_ns3__FECAEASinMov, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__FECAEASinMov, sizeof(ns3__FECAEASinMov), 1, afip_finsert, afip_fbase))
				break;
			if (!soap_in_PointerTons3__FECAEASinMov(soap, tag, NULL, "ns3:FECAEASinMov"))
				break;
		}
		else
		{	if (!soap_in_PointerTons3__FECAEASinMov(soap, tag, &n, "ns3:FECAEASinMov"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__FECAEASinMov *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__FECAEASinMov(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__FECAEASinMov(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns3__FECAEASinMov *> *p;
	size_t k = sizeof(std::vector<ns3__FECAEASinMov *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__FECAEASinMov, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns3__FECAEASinMov *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns3__FECAEASinMov *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns3__FECAEASinMov *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__FECAEADetResponse(struct soap *soap, std::vector<ns3__FECAEADetResponse *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__FECAEADetResponse(struct soap *soap, const std::vector<ns3__FECAEADetResponse *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns3__FECAEADetResponse *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__FECAEADetResponse(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__FECAEADetResponse(struct soap *soap, const char *tag, int id, const std::vector<ns3__FECAEADetResponse *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns3__FECAEADetResponse *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__FECAEADetResponse(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__FECAEADetResponse *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__FECAEADetResponse(struct soap *soap, const char *tag, std::vector<ns3__FECAEADetResponse *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__FECAEADetResponse(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns3__FECAEADetResponse *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip_ns3__FECAEADetResponse, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__FECAEADetResponse, sizeof(ns3__FECAEADetResponse), 1, afip_finsert, afip_fbase))
				break;
			if (!soap_in_PointerTons3__FECAEADetResponse(soap, tag, NULL, "ns3:FECAEADetResponse"))
				break;
		}
		else
		{	if (!soap_in_PointerTons3__FECAEADetResponse(soap, tag, &n, "ns3:FECAEADetResponse"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__FECAEADetResponse *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__FECAEADetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__FECAEADetResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns3__FECAEADetResponse *> *p;
	size_t k = sizeof(std::vector<ns3__FECAEADetResponse *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__FECAEADetResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns3__FECAEADetResponse *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns3__FECAEADetResponse *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns3__FECAEADetResponse *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__FECAEADetRequest(struct soap *soap, std::vector<ns3__FECAEADetRequest *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__FECAEADetRequest(struct soap *soap, const std::vector<ns3__FECAEADetRequest *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns3__FECAEADetRequest *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__FECAEADetRequest(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__FECAEADetRequest(struct soap *soap, const char *tag, int id, const std::vector<ns3__FECAEADetRequest *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns3__FECAEADetRequest *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__FECAEADetRequest(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__FECAEADetRequest *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__FECAEADetRequest(struct soap *soap, const char *tag, std::vector<ns3__FECAEADetRequest *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__FECAEADetRequest(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns3__FECAEADetRequest *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip_ns3__FECAEADetRequest, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__FECAEADetRequest, sizeof(ns3__FECAEADetRequest), 1, afip_finsert, afip_fbase))
				break;
			if (!soap_in_PointerTons3__FECAEADetRequest(soap, tag, NULL, "ns3:FECAEADetRequest"))
				break;
		}
		else
		{	if (!soap_in_PointerTons3__FECAEADetRequest(soap, tag, &n, "ns3:FECAEADetRequest"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__FECAEADetRequest *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__FECAEADetRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__FECAEADetRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns3__FECAEADetRequest *> *p;
	size_t k = sizeof(std::vector<ns3__FECAEADetRequest *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__FECAEADetRequest, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns3__FECAEADetRequest *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns3__FECAEADetRequest *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns3__FECAEADetRequest *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__Err(struct soap *soap, std::vector<ns3__Err *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__Err(struct soap *soap, const std::vector<ns3__Err *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns3__Err *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__Err(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__Err(struct soap *soap, const char *tag, int id, const std::vector<ns3__Err *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns3__Err *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__Err(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__Err *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__Err(struct soap *soap, const char *tag, std::vector<ns3__Err *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__Err(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns3__Err *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip_ns3__Err, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Err, sizeof(ns3__Err), 1, afip_finsert, afip_fbase))
				break;
			if (!soap_in_PointerTons3__Err(soap, tag, NULL, "ns3:Err"))
				break;
		}
		else
		{	if (!soap_in_PointerTons3__Err(soap, tag, &n, "ns3:Err"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__Err *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__Err(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__Err(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns3__Err *> *p;
	size_t k = sizeof(std::vector<ns3__Err *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Err, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns3__Err *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns3__Err *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns3__Err *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__Evt(struct soap *soap, std::vector<ns3__Evt *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__Evt(struct soap *soap, const std::vector<ns3__Evt *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns3__Evt *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__Evt(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__Evt(struct soap *soap, const char *tag, int id, const std::vector<ns3__Evt *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns3__Evt *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__Evt(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__Evt *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__Evt(struct soap *soap, const char *tag, std::vector<ns3__Evt *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__Evt(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns3__Evt *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip_ns3__Evt, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Evt, sizeof(ns3__Evt), 1, afip_finsert, afip_fbase))
				break;
			if (!soap_in_PointerTons3__Evt(soap, tag, NULL, "ns3:Evt"))
				break;
		}
		else
		{	if (!soap_in_PointerTons3__Evt(soap, tag, &n, "ns3:Evt"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__Evt *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__Evt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__Evt(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns3__Evt *> *p;
	size_t k = sizeof(std::vector<ns3__Evt *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Evt, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns3__Evt *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns3__Evt *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns3__Evt *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__Obs(struct soap *soap, std::vector<ns3__Obs *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__Obs(struct soap *soap, const std::vector<ns3__Obs *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns3__Obs *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__Obs(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__Obs(struct soap *soap, const char *tag, int id, const std::vector<ns3__Obs *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns3__Obs *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__Obs(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__Obs *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__Obs(struct soap *soap, const char *tag, std::vector<ns3__Obs *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__Obs(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns3__Obs *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip_ns3__Obs, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Obs, sizeof(ns3__Obs), 1, afip_finsert, afip_fbase))
				break;
			if (!soap_in_PointerTons3__Obs(soap, tag, NULL, "ns3:Obs"))
				break;
		}
		else
		{	if (!soap_in_PointerTons3__Obs(soap, tag, &n, "ns3:Obs"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__Obs *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__Obs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__Obs(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns3__Obs *> *p;
	size_t k = sizeof(std::vector<ns3__Obs *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Obs, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns3__Obs *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns3__Obs *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns3__Obs *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__FECAEDetResponse(struct soap *soap, std::vector<ns3__FECAEDetResponse *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__FECAEDetResponse(struct soap *soap, const std::vector<ns3__FECAEDetResponse *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns3__FECAEDetResponse *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__FECAEDetResponse(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__FECAEDetResponse(struct soap *soap, const char *tag, int id, const std::vector<ns3__FECAEDetResponse *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns3__FECAEDetResponse *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__FECAEDetResponse(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__FECAEDetResponse *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__FECAEDetResponse(struct soap *soap, const char *tag, std::vector<ns3__FECAEDetResponse *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__FECAEDetResponse(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns3__FECAEDetResponse *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip_ns3__FECAEDetResponse, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__FECAEDetResponse, sizeof(ns3__FECAEDetResponse), 1, afip_finsert, afip_fbase))
				break;
			if (!soap_in_PointerTons3__FECAEDetResponse(soap, tag, NULL, "ns3:FECAEDetResponse"))
				break;
		}
		else
		{	if (!soap_in_PointerTons3__FECAEDetResponse(soap, tag, &n, "ns3:FECAEDetResponse"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__FECAEDetResponse *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__FECAEDetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__FECAEDetResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns3__FECAEDetResponse *> *p;
	size_t k = sizeof(std::vector<ns3__FECAEDetResponse *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__FECAEDetResponse, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns3__FECAEDetResponse *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns3__FECAEDetResponse *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns3__FECAEDetResponse *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__Comprador(struct soap *soap, std::vector<ns3__Comprador *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__Comprador(struct soap *soap, const std::vector<ns3__Comprador *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns3__Comprador *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__Comprador(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__Comprador(struct soap *soap, const char *tag, int id, const std::vector<ns3__Comprador *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns3__Comprador *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__Comprador(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__Comprador *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__Comprador(struct soap *soap, const char *tag, std::vector<ns3__Comprador *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__Comprador(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns3__Comprador *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip_ns3__Comprador, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Comprador, sizeof(ns3__Comprador), 1, afip_finsert, afip_fbase))
				break;
			if (!soap_in_PointerTons3__Comprador(soap, tag, NULL, "ns3:Comprador"))
				break;
		}
		else
		{	if (!soap_in_PointerTons3__Comprador(soap, tag, &n, "ns3:Comprador"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__Comprador *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__Comprador(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__Comprador(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns3__Comprador *> *p;
	size_t k = sizeof(std::vector<ns3__Comprador *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Comprador, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns3__Comprador *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns3__Comprador *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns3__Comprador *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__Opcional(struct soap *soap, std::vector<ns3__Opcional *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__Opcional(struct soap *soap, const std::vector<ns3__Opcional *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns3__Opcional *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__Opcional(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__Opcional(struct soap *soap, const char *tag, int id, const std::vector<ns3__Opcional *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns3__Opcional *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__Opcional(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__Opcional *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__Opcional(struct soap *soap, const char *tag, std::vector<ns3__Opcional *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__Opcional(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns3__Opcional *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip_ns3__Opcional, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Opcional, sizeof(ns3__Opcional), 1, afip_finsert, afip_fbase))
				break;
			if (!soap_in_PointerTons3__Opcional(soap, tag, NULL, "ns3:Opcional"))
				break;
		}
		else
		{	if (!soap_in_PointerTons3__Opcional(soap, tag, &n, "ns3:Opcional"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__Opcional *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__Opcional(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__Opcional(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns3__Opcional *> *p;
	size_t k = sizeof(std::vector<ns3__Opcional *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Opcional, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns3__Opcional *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns3__Opcional *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns3__Opcional *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__AlicIva(struct soap *soap, std::vector<ns3__AlicIva *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__AlicIva(struct soap *soap, const std::vector<ns3__AlicIva *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns3__AlicIva *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__AlicIva(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__AlicIva(struct soap *soap, const char *tag, int id, const std::vector<ns3__AlicIva *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns3__AlicIva *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__AlicIva(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__AlicIva *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__AlicIva(struct soap *soap, const char *tag, std::vector<ns3__AlicIva *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__AlicIva(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns3__AlicIva *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip_ns3__AlicIva, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__AlicIva, sizeof(ns3__AlicIva), 1, afip_finsert, afip_fbase))
				break;
			if (!soap_in_PointerTons3__AlicIva(soap, tag, NULL, "ns3:AlicIva"))
				break;
		}
		else
		{	if (!soap_in_PointerTons3__AlicIva(soap, tag, &n, "ns3:AlicIva"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__AlicIva *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__AlicIva(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__AlicIva(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns3__AlicIva *> *p;
	size_t k = sizeof(std::vector<ns3__AlicIva *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__AlicIva, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns3__AlicIva *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns3__AlicIva *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns3__AlicIva *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__Tributo(struct soap *soap, std::vector<ns3__Tributo *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__Tributo(struct soap *soap, const std::vector<ns3__Tributo *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns3__Tributo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__Tributo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__Tributo(struct soap *soap, const char *tag, int id, const std::vector<ns3__Tributo *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns3__Tributo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__Tributo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__Tributo *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__Tributo(struct soap *soap, const char *tag, std::vector<ns3__Tributo *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__Tributo(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns3__Tributo *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip_ns3__Tributo, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Tributo, sizeof(ns3__Tributo), 1, afip_finsert, afip_fbase))
				break;
			if (!soap_in_PointerTons3__Tributo(soap, tag, NULL, "ns3:Tributo"))
				break;
		}
		else
		{	if (!soap_in_PointerTons3__Tributo(soap, tag, &n, "ns3:Tributo"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__Tributo *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__Tributo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__Tributo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns3__Tributo *> *p;
	size_t k = sizeof(std::vector<ns3__Tributo *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__Tributo, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns3__Tributo *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns3__Tributo *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns3__Tributo *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__CbteAsoc(struct soap *soap, std::vector<ns3__CbteAsoc *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__CbteAsoc(struct soap *soap, const std::vector<ns3__CbteAsoc *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns3__CbteAsoc *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__CbteAsoc(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__CbteAsoc(struct soap *soap, const char *tag, int id, const std::vector<ns3__CbteAsoc *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns3__CbteAsoc *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__CbteAsoc(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__CbteAsoc *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__CbteAsoc(struct soap *soap, const char *tag, std::vector<ns3__CbteAsoc *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__CbteAsoc(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns3__CbteAsoc *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip_ns3__CbteAsoc, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__CbteAsoc, sizeof(ns3__CbteAsoc), 1, afip_finsert, afip_fbase))
				break;
			if (!soap_in_PointerTons3__CbteAsoc(soap, tag, NULL, "ns3:CbteAsoc"))
				break;
		}
		else
		{	if (!soap_in_PointerTons3__CbteAsoc(soap, tag, &n, "ns3:CbteAsoc"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__CbteAsoc *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__CbteAsoc(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__CbteAsoc(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns3__CbteAsoc *> *p;
	size_t k = sizeof(std::vector<ns3__CbteAsoc *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__CbteAsoc, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns3__CbteAsoc *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns3__CbteAsoc *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns3__CbteAsoc *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__FECAEDetRequest(struct soap *soap, std::vector<ns3__FECAEDetRequest *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__FECAEDetRequest(struct soap *soap, const std::vector<ns3__FECAEDetRequest *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns3__FECAEDetRequest *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__FECAEDetRequest(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__FECAEDetRequest(struct soap *soap, const char *tag, int id, const std::vector<ns3__FECAEDetRequest *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns3__FECAEDetRequest *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__FECAEDetRequest(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__FECAEDetRequest *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__FECAEDetRequest(struct soap *soap, const char *tag, std::vector<ns3__FECAEDetRequest *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__FECAEDetRequest(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns3__FECAEDetRequest *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip_ns3__FECAEDetRequest, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__FECAEDetRequest, sizeof(ns3__FECAEDetRequest), 1, afip_finsert, afip_fbase))
				break;
			if (!soap_in_PointerTons3__FECAEDetRequest(soap, tag, NULL, "ns3:FECAEDetRequest"))
				break;
		}
		else
		{	if (!soap_in_PointerTons3__FECAEDetRequest(soap, tag, &n, "ns3:FECAEDetRequest"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__FECAEDetRequest *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__FECAEDetRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__FECAEDetRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns3__FECAEDetRequest *> *p;
	size_t k = sizeof(std::vector<ns3__FECAEDetRequest *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip_std__vectorTemplateOfPointerTons3__FECAEDetRequest, n, afip_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns3__FECAEDetRequest *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns3__FECAEDetRequest *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns3__FECAEDetRequest *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

} // namespace afip


#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of afipC.cpp */
