/* soapC.cpp
   Generated by gSOAP 2.8.89 for soap/afip_soap.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.89 2019-08-29 04:28:22 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
	}
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code == NULL)
		soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason == NULL)
		soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
				return NULL;
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_subcode(struct soap *soap)
{
	const char **s = soap_faultsubcode(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_string(struct soap *soap)
{
	const char **s = soap_faultstring(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
			soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
		soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_detail(struct soap *soap)
{
	const char **s = soap_faultdetail(soap);
	return s ? *s : NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, NULL, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, const char *tag, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, tag, NULL, "xsd:byte");
	case SOAP_TYPE_short:
		return soap_in_short(soap, tag, NULL, "xsd:short");
	case SOAP_TYPE_int:
		return soap_in_int(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, tag, NULL, "xsd:long");
	case SOAP_TYPE_double:
		return soap_in_double(soap, tag, NULL, "xsd:double");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_afip3__PaisTipo:
		return soap_in_afip3__PaisTipo(soap, tag, NULL, "afip3:PaisTipo");
	case SOAP_TYPE_afip3__ArrayOfPaisTipo:
		return soap_in_afip3__ArrayOfPaisTipo(soap, tag, NULL, "afip3:ArrayOfPaisTipo");
	case SOAP_TYPE_afip3__FEPaisResponse:
		return soap_in_afip3__FEPaisResponse(soap, tag, NULL, "afip3:FEPaisResponse");
	case SOAP_TYPE_afip3__DocTipo:
		return soap_in_afip3__DocTipo(soap, tag, NULL, "afip3:DocTipo");
	case SOAP_TYPE_afip3__ArrayOfDocTipo:
		return soap_in_afip3__ArrayOfDocTipo(soap, tag, NULL, "afip3:ArrayOfDocTipo");
	case SOAP_TYPE_afip3__DocTipoResponse:
		return soap_in_afip3__DocTipoResponse(soap, tag, NULL, "afip3:DocTipoResponse");
	case SOAP_TYPE_afip3__CbteTipo:
		return soap_in_afip3__CbteTipo(soap, tag, NULL, "afip3:CbteTipo");
	case SOAP_TYPE_afip3__ArrayOfCbteTipo:
		return soap_in_afip3__ArrayOfCbteTipo(soap, tag, NULL, "afip3:ArrayOfCbteTipo");
	case SOAP_TYPE_afip3__CbteTipoResponse:
		return soap_in_afip3__CbteTipoResponse(soap, tag, NULL, "afip3:CbteTipoResponse");
	case SOAP_TYPE_afip3__PtoVenta:
		return soap_in_afip3__PtoVenta(soap, tag, NULL, "afip3:PtoVenta");
	case SOAP_TYPE_afip3__ArrayOfPtoVenta:
		return soap_in_afip3__ArrayOfPtoVenta(soap, tag, NULL, "afip3:ArrayOfPtoVenta");
	case SOAP_TYPE_afip3__FEPtoVentaResponse:
		return soap_in_afip3__FEPtoVentaResponse(soap, tag, NULL, "afip3:FEPtoVentaResponse");
	case SOAP_TYPE_afip3__ConceptoTipo:
		return soap_in_afip3__ConceptoTipo(soap, tag, NULL, "afip3:ConceptoTipo");
	case SOAP_TYPE_afip3__ArrayOfConceptoTipo:
		return soap_in_afip3__ArrayOfConceptoTipo(soap, tag, NULL, "afip3:ArrayOfConceptoTipo");
	case SOAP_TYPE_afip3__ConceptoTipoResponse:
		return soap_in_afip3__ConceptoTipoResponse(soap, tag, NULL, "afip3:ConceptoTipoResponse");
	case SOAP_TYPE_afip3__OpcionalTipo:
		return soap_in_afip3__OpcionalTipo(soap, tag, NULL, "afip3:OpcionalTipo");
	case SOAP_TYPE_afip3__ArrayOfOpcionalTipo:
		return soap_in_afip3__ArrayOfOpcionalTipo(soap, tag, NULL, "afip3:ArrayOfOpcionalTipo");
	case SOAP_TYPE_afip3__OpcionalTipoResponse:
		return soap_in_afip3__OpcionalTipoResponse(soap, tag, NULL, "afip3:OpcionalTipoResponse");
	case SOAP_TYPE_afip3__IvaTipo:
		return soap_in_afip3__IvaTipo(soap, tag, NULL, "afip3:IvaTipo");
	case SOAP_TYPE_afip3__ArrayOfIvaTipo:
		return soap_in_afip3__ArrayOfIvaTipo(soap, tag, NULL, "afip3:ArrayOfIvaTipo");
	case SOAP_TYPE_afip3__IvaTipoResponse:
		return soap_in_afip3__IvaTipoResponse(soap, tag, NULL, "afip3:IvaTipoResponse");
	case SOAP_TYPE_afip3__Moneda:
		return soap_in_afip3__Moneda(soap, tag, NULL, "afip3:Moneda");
	case SOAP_TYPE_afip3__ArrayOfMoneda:
		return soap_in_afip3__ArrayOfMoneda(soap, tag, NULL, "afip3:ArrayOfMoneda");
	case SOAP_TYPE_afip3__MonedaResponse:
		return soap_in_afip3__MonedaResponse(soap, tag, NULL, "afip3:MonedaResponse");
	case SOAP_TYPE_afip3__TributoTipo:
		return soap_in_afip3__TributoTipo(soap, tag, NULL, "afip3:TributoTipo");
	case SOAP_TYPE_afip3__ArrayOfTributoTipo:
		return soap_in_afip3__ArrayOfTributoTipo(soap, tag, NULL, "afip3:ArrayOfTributoTipo");
	case SOAP_TYPE_afip3__FETributoResponse:
		return soap_in_afip3__FETributoResponse(soap, tag, NULL, "afip3:FETributoResponse");
	case SOAP_TYPE_afip3__Cotizacion:
		return soap_in_afip3__Cotizacion(soap, tag, NULL, "afip3:Cotizacion");
	case SOAP_TYPE_afip3__FECotizacionResponse:
		return soap_in_afip3__FECotizacionResponse(soap, tag, NULL, "afip3:FECotizacionResponse");
	case SOAP_TYPE_afip3__FECAEASinMovResponse:
		return soap_in_afip3__FECAEASinMovResponse(soap, tag, NULL, "afip3:FECAEASinMovResponse");
	case SOAP_TYPE_afip3__FECAEASinMov:
		return soap_in_afip3__FECAEASinMov(soap, tag, NULL, "afip3:FECAEASinMov");
	case SOAP_TYPE_afip3__ArrayOfFECAEASinMov:
		return soap_in_afip3__ArrayOfFECAEASinMov(soap, tag, NULL, "afip3:ArrayOfFECAEASinMov");
	case SOAP_TYPE_afip3__FECAEASinMovConsResponse:
		return soap_in_afip3__FECAEASinMovConsResponse(soap, tag, NULL, "afip3:FECAEASinMovConsResponse");
	case SOAP_TYPE_afip3__FECAEAGet:
		return soap_in_afip3__FECAEAGet(soap, tag, NULL, "afip3:FECAEAGet");
	case SOAP_TYPE_afip3__FECAEAGetResponse:
		return soap_in_afip3__FECAEAGetResponse(soap, tag, NULL, "afip3:FECAEAGetResponse");
	case SOAP_TYPE_afip3__FECAEADetResponse:
		return soap_in_afip3__FECAEADetResponse(soap, tag, NULL, "afip3:FECAEADetResponse");
	case SOAP_TYPE_afip3__ArrayOfFECAEADetResponse:
		return soap_in_afip3__ArrayOfFECAEADetResponse(soap, tag, NULL, "afip3:ArrayOfFECAEADetResponse");
	case SOAP_TYPE_afip3__FECAEACabResponse:
		return soap_in_afip3__FECAEACabResponse(soap, tag, NULL, "afip3:FECAEACabResponse");
	case SOAP_TYPE_afip3__FECAEAResponse:
		return soap_in_afip3__FECAEAResponse(soap, tag, NULL, "afip3:FECAEAResponse");
	case SOAP_TYPE_afip3__FECAEADetRequest:
		return soap_in_afip3__FECAEADetRequest(soap, tag, NULL, "afip3:FECAEADetRequest");
	case SOAP_TYPE_afip3__ArrayOfFECAEADetRequest:
		return soap_in_afip3__ArrayOfFECAEADetRequest(soap, tag, NULL, "afip3:ArrayOfFECAEADetRequest");
	case SOAP_TYPE_afip3__FECAEACabRequest:
		return soap_in_afip3__FECAEACabRequest(soap, tag, NULL, "afip3:FECAEACabRequest");
	case SOAP_TYPE_afip3__FECAEARequest:
		return soap_in_afip3__FECAEARequest(soap, tag, NULL, "afip3:FECAEARequest");
	case SOAP_TYPE_afip3__FECompConsResponse:
		return soap_in_afip3__FECompConsResponse(soap, tag, NULL, "afip3:FECompConsResponse");
	case SOAP_TYPE_afip3__FECompConsultaResponse:
		return soap_in_afip3__FECompConsultaResponse(soap, tag, NULL, "afip3:FECompConsultaResponse");
	case SOAP_TYPE_afip3__FECompConsultaReq:
		return soap_in_afip3__FECompConsultaReq(soap, tag, NULL, "afip3:FECompConsultaReq");
	case SOAP_TYPE_afip3__FERecuperaLastCbteResponse:
		return soap_in_afip3__FERecuperaLastCbteResponse(soap, tag, NULL, "afip3:FERecuperaLastCbteResponse");
	case SOAP_TYPE_afip3__DummyResponse:
		return soap_in_afip3__DummyResponse(soap, tag, NULL, "afip3:DummyResponse");
	case SOAP_TYPE_afip3__FERegXReqResponse:
		return soap_in_afip3__FERegXReqResponse(soap, tag, NULL, "afip3:FERegXReqResponse");
	case SOAP_TYPE_afip3__Err:
		return soap_in_afip3__Err(soap, tag, NULL, "afip3:Err");
	case SOAP_TYPE_afip3__ArrayOfErr:
		return soap_in_afip3__ArrayOfErr(soap, tag, NULL, "afip3:ArrayOfErr");
	case SOAP_TYPE_afip3__Evt:
		return soap_in_afip3__Evt(soap, tag, NULL, "afip3:Evt");
	case SOAP_TYPE_afip3__ArrayOfEvt:
		return soap_in_afip3__ArrayOfEvt(soap, tag, NULL, "afip3:ArrayOfEvt");
	case SOAP_TYPE_afip3__Obs:
		return soap_in_afip3__Obs(soap, tag, NULL, "afip3:Obs");
	case SOAP_TYPE_afip3__ArrayOfObs:
		return soap_in_afip3__ArrayOfObs(soap, tag, NULL, "afip3:ArrayOfObs");
	case SOAP_TYPE_afip3__FEDetResponse:
		return soap_in_afip3__FEDetResponse(soap, tag, NULL, "afip3:FEDetResponse");
	case SOAP_TYPE_afip3__FECAEDetResponse:
		return soap_in_afip3__FECAEDetResponse(soap, tag, NULL, "afip3:FECAEDetResponse");
	case SOAP_TYPE_afip3__ArrayOfFECAEDetResponse:
		return soap_in_afip3__ArrayOfFECAEDetResponse(soap, tag, NULL, "afip3:ArrayOfFECAEDetResponse");
	case SOAP_TYPE_afip3__FECabResponse:
		return soap_in_afip3__FECabResponse(soap, tag, NULL, "afip3:FECabResponse");
	case SOAP_TYPE_afip3__FECAECabResponse:
		return soap_in_afip3__FECAECabResponse(soap, tag, NULL, "afip3:FECAECabResponse");
	case SOAP_TYPE_afip3__FECAEResponse:
		return soap_in_afip3__FECAEResponse(soap, tag, NULL, "afip3:FECAEResponse");
	case SOAP_TYPE_afip3__Comprador:
		return soap_in_afip3__Comprador(soap, tag, NULL, "afip3:Comprador");
	case SOAP_TYPE_afip3__ArrayOfComprador:
		return soap_in_afip3__ArrayOfComprador(soap, tag, NULL, "afip3:ArrayOfComprador");
	case SOAP_TYPE_afip3__Opcional:
		return soap_in_afip3__Opcional(soap, tag, NULL, "afip3:Opcional");
	case SOAP_TYPE_afip3__ArrayOfOpcional:
		return soap_in_afip3__ArrayOfOpcional(soap, tag, NULL, "afip3:ArrayOfOpcional");
	case SOAP_TYPE_afip3__AlicIva:
		return soap_in_afip3__AlicIva(soap, tag, NULL, "afip3:AlicIva");
	case SOAP_TYPE_afip3__ArrayOfAlicIva:
		return soap_in_afip3__ArrayOfAlicIva(soap, tag, NULL, "afip3:ArrayOfAlicIva");
	case SOAP_TYPE_afip3__Tributo:
		return soap_in_afip3__Tributo(soap, tag, NULL, "afip3:Tributo");
	case SOAP_TYPE_afip3__ArrayOfTributo:
		return soap_in_afip3__ArrayOfTributo(soap, tag, NULL, "afip3:ArrayOfTributo");
	case SOAP_TYPE_afip3__CbteAsoc:
		return soap_in_afip3__CbteAsoc(soap, tag, NULL, "afip3:CbteAsoc");
	case SOAP_TYPE_afip3__ArrayOfCbteAsoc:
		return soap_in_afip3__ArrayOfCbteAsoc(soap, tag, NULL, "afip3:ArrayOfCbteAsoc");
	case SOAP_TYPE_afip3__FEDetRequest:
		return soap_in_afip3__FEDetRequest(soap, tag, NULL, "afip3:FEDetRequest");
	case SOAP_TYPE_afip3__FECAEDetRequest:
		return soap_in_afip3__FECAEDetRequest(soap, tag, NULL, "afip3:FECAEDetRequest");
	case SOAP_TYPE_afip3__ArrayOfFECAEDetRequest:
		return soap_in_afip3__ArrayOfFECAEDetRequest(soap, tag, NULL, "afip3:ArrayOfFECAEDetRequest");
	case SOAP_TYPE_afip3__FECabRequest:
		return soap_in_afip3__FECabRequest(soap, tag, NULL, "afip3:FECabRequest");
	case SOAP_TYPE_afip3__FECAECabRequest:
		return soap_in_afip3__FECAECabRequest(soap, tag, NULL, "afip3:FECAECabRequest");
	case SOAP_TYPE_afip3__FECAERequest:
		return soap_in_afip3__FECAERequest(soap, tag, NULL, "afip3:FECAERequest");
	case SOAP_TYPE_afip3__FEAuthRequest:
		return soap_in_afip3__FEAuthRequest(soap, tag, NULL, "afip3:FEAuthRequest");
	case SOAP_TYPE_afip2__LoginFault:
		return soap_in_afip2__LoginFault(soap, tag, NULL, "afip2:LoginFault");
	case SOAP_TYPE_PointerTo_afip3__FEParamGetTiposPaises:
		return soap_in_PointerTo_afip3__FEParamGetTiposPaises(soap, tag, NULL, "afip3:FEParamGetTiposPaises");
	case SOAP_TYPE_PointerTo_afip3__FEParamGetTiposDoc:
		return soap_in_PointerTo_afip3__FEParamGetTiposDoc(soap, tag, NULL, "afip3:FEParamGetTiposDoc");
	case SOAP_TYPE_PointerTo_afip3__FEParamGetTiposCbte:
		return soap_in_PointerTo_afip3__FEParamGetTiposCbte(soap, tag, NULL, "afip3:FEParamGetTiposCbte");
	case SOAP_TYPE_PointerTo_afip3__FEParamGetPtosVenta:
		return soap_in_PointerTo_afip3__FEParamGetPtosVenta(soap, tag, NULL, "afip3:FEParamGetPtosVenta");
	case SOAP_TYPE_PointerTo_afip3__FEParamGetTiposConcepto:
		return soap_in_PointerTo_afip3__FEParamGetTiposConcepto(soap, tag, NULL, "afip3:FEParamGetTiposConcepto");
	case SOAP_TYPE_PointerTo_afip3__FEParamGetTiposOpcional:
		return soap_in_PointerTo_afip3__FEParamGetTiposOpcional(soap, tag, NULL, "afip3:FEParamGetTiposOpcional");
	case SOAP_TYPE_PointerTo_afip3__FEParamGetTiposIva:
		return soap_in_PointerTo_afip3__FEParamGetTiposIva(soap, tag, NULL, "afip3:FEParamGetTiposIva");
	case SOAP_TYPE_PointerTo_afip3__FEParamGetTiposMonedas:
		return soap_in_PointerTo_afip3__FEParamGetTiposMonedas(soap, tag, NULL, "afip3:FEParamGetTiposMonedas");
	case SOAP_TYPE_PointerTo_afip3__FEParamGetTiposTributos:
		return soap_in_PointerTo_afip3__FEParamGetTiposTributos(soap, tag, NULL, "afip3:FEParamGetTiposTributos");
	case SOAP_TYPE_PointerTo_afip3__FEParamGetCotizacion:
		return soap_in_PointerTo_afip3__FEParamGetCotizacion(soap, tag, NULL, "afip3:FEParamGetCotizacion");
	case SOAP_TYPE_PointerTo_afip3__FECAEAConsultar:
		return soap_in_PointerTo_afip3__FECAEAConsultar(soap, tag, NULL, "afip3:FECAEAConsultar");
	case SOAP_TYPE_PointerTo_afip3__FECAEASinMovimientoInformar:
		return soap_in_PointerTo_afip3__FECAEASinMovimientoInformar(soap, tag, NULL, "afip3:FECAEASinMovimientoInformar");
	case SOAP_TYPE_PointerTo_afip3__FECAEASinMovimientoConsultar:
		return soap_in_PointerTo_afip3__FECAEASinMovimientoConsultar(soap, tag, NULL, "afip3:FECAEASinMovimientoConsultar");
	case SOAP_TYPE_PointerTo_afip3__FECAEASolicitar:
		return soap_in_PointerTo_afip3__FECAEASolicitar(soap, tag, NULL, "afip3:FECAEASolicitar");
	case SOAP_TYPE_PointerTo_afip3__FECAEARegInformativo:
		return soap_in_PointerTo_afip3__FECAEARegInformativo(soap, tag, NULL, "afip3:FECAEARegInformativo");
	case SOAP_TYPE_PointerTo_afip3__FECompConsultar:
		return soap_in_PointerTo_afip3__FECompConsultar(soap, tag, NULL, "afip3:FECompConsultar");
	case SOAP_TYPE_PointerTo_afip3__FECompUltimoAutorizado:
		return soap_in_PointerTo_afip3__FECompUltimoAutorizado(soap, tag, NULL, "afip3:FECompUltimoAutorizado");
	case SOAP_TYPE_PointerTo_afip3__FEDummy:
		return soap_in_PointerTo_afip3__FEDummy(soap, tag, NULL, "afip3:FEDummy");
	case SOAP_TYPE_PointerTo_afip3__FECompTotXRequest:
		return soap_in_PointerTo_afip3__FECompTotXRequest(soap, tag, NULL, "afip3:FECompTotXRequest");
	case SOAP_TYPE_PointerTo_afip3__FECAESolicitar:
		return soap_in_PointerTo_afip3__FECAESolicitar(soap, tag, NULL, "afip3:FECAESolicitar");
	case SOAP_TYPE_PointerTo_afip1__loginCms:
		return soap_in_PointerTo_afip1__loginCms(soap, tag, NULL, "afip1:loginCms");
	case SOAP_TYPE_PointerToafip2__LoginFault:
		return soap_in_PointerToafip2__LoginFault(soap, tag, NULL, "afip2:LoginFault");
	case SOAP_TYPE_PointerToafip3__FEPaisResponse:
		return soap_in_PointerToafip3__FEPaisResponse(soap, tag, NULL, "afip3:FEPaisResponse");
	case SOAP_TYPE_PointerToafip3__DocTipoResponse:
		return soap_in_PointerToafip3__DocTipoResponse(soap, tag, NULL, "afip3:DocTipoResponse");
	case SOAP_TYPE_PointerToafip3__CbteTipoResponse:
		return soap_in_PointerToafip3__CbteTipoResponse(soap, tag, NULL, "afip3:CbteTipoResponse");
	case SOAP_TYPE_PointerToafip3__FEPtoVentaResponse:
		return soap_in_PointerToafip3__FEPtoVentaResponse(soap, tag, NULL, "afip3:FEPtoVentaResponse");
	case SOAP_TYPE_PointerToafip3__ConceptoTipoResponse:
		return soap_in_PointerToafip3__ConceptoTipoResponse(soap, tag, NULL, "afip3:ConceptoTipoResponse");
	case SOAP_TYPE_PointerToafip3__OpcionalTipoResponse:
		return soap_in_PointerToafip3__OpcionalTipoResponse(soap, tag, NULL, "afip3:OpcionalTipoResponse");
	case SOAP_TYPE_PointerToafip3__IvaTipoResponse:
		return soap_in_PointerToafip3__IvaTipoResponse(soap, tag, NULL, "afip3:IvaTipoResponse");
	case SOAP_TYPE_PointerToafip3__MonedaResponse:
		return soap_in_PointerToafip3__MonedaResponse(soap, tag, NULL, "afip3:MonedaResponse");
	case SOAP_TYPE_PointerToafip3__FETributoResponse:
		return soap_in_PointerToafip3__FETributoResponse(soap, tag, NULL, "afip3:FETributoResponse");
	case SOAP_TYPE_PointerToafip3__FECotizacionResponse:
		return soap_in_PointerToafip3__FECotizacionResponse(soap, tag, NULL, "afip3:FECotizacionResponse");
	case SOAP_TYPE_PointerToafip3__FECAEASinMovResponse:
		return soap_in_PointerToafip3__FECAEASinMovResponse(soap, tag, NULL, "afip3:FECAEASinMovResponse");
	case SOAP_TYPE_PointerToafip3__FECAEASinMovConsResponse:
		return soap_in_PointerToafip3__FECAEASinMovConsResponse(soap, tag, NULL, "afip3:FECAEASinMovConsResponse");
	case SOAP_TYPE_PointerToafip3__FECAEAGetResponse:
		return soap_in_PointerToafip3__FECAEAGetResponse(soap, tag, NULL, "afip3:FECAEAGetResponse");
	case SOAP_TYPE_PointerToafip3__FECAEAResponse:
		return soap_in_PointerToafip3__FECAEAResponse(soap, tag, NULL, "afip3:FECAEAResponse");
	case SOAP_TYPE_PointerToafip3__FECAEARequest:
		return soap_in_PointerToafip3__FECAEARequest(soap, tag, NULL, "afip3:FECAEARequest");
	case SOAP_TYPE_PointerToafip3__FECompConsultaResponse:
		return soap_in_PointerToafip3__FECompConsultaResponse(soap, tag, NULL, "afip3:FECompConsultaResponse");
	case SOAP_TYPE_PointerToafip3__FECompConsultaReq:
		return soap_in_PointerToafip3__FECompConsultaReq(soap, tag, NULL, "afip3:FECompConsultaReq");
	case SOAP_TYPE_PointerToafip3__FERecuperaLastCbteResponse:
		return soap_in_PointerToafip3__FERecuperaLastCbteResponse(soap, tag, NULL, "afip3:FERecuperaLastCbteResponse");
	case SOAP_TYPE_PointerToafip3__DummyResponse:
		return soap_in_PointerToafip3__DummyResponse(soap, tag, NULL, "afip3:DummyResponse");
	case SOAP_TYPE_PointerToafip3__FERegXReqResponse:
		return soap_in_PointerToafip3__FERegXReqResponse(soap, tag, NULL, "afip3:FERegXReqResponse");
	case SOAP_TYPE_PointerToafip3__FECAEResponse:
		return soap_in_PointerToafip3__FECAEResponse(soap, tag, NULL, "afip3:FECAEResponse");
	case SOAP_TYPE_PointerToafip3__FECAERequest:
		return soap_in_PointerToafip3__FECAERequest(soap, tag, NULL, "afip3:FECAERequest");
	case SOAP_TYPE_PointerToafip3__FEAuthRequest:
		return soap_in_PointerToafip3__FEAuthRequest(soap, tag, NULL, "afip3:FEAuthRequest");
	case SOAP_TYPE_PointerToafip3__PaisTipo:
		return soap_in_PointerToafip3__PaisTipo(soap, tag, NULL, "afip3:PaisTipo");
	case SOAP_TYPE_PointerToafip3__ArrayOfPaisTipo:
		return soap_in_PointerToafip3__ArrayOfPaisTipo(soap, tag, NULL, "afip3:ArrayOfPaisTipo");
	case SOAP_TYPE_PointerToafip3__DocTipo:
		return soap_in_PointerToafip3__DocTipo(soap, tag, NULL, "afip3:DocTipo");
	case SOAP_TYPE_PointerToafip3__ArrayOfDocTipo:
		return soap_in_PointerToafip3__ArrayOfDocTipo(soap, tag, NULL, "afip3:ArrayOfDocTipo");
	case SOAP_TYPE_PointerToafip3__CbteTipo:
		return soap_in_PointerToafip3__CbteTipo(soap, tag, NULL, "afip3:CbteTipo");
	case SOAP_TYPE_PointerToafip3__ArrayOfCbteTipo:
		return soap_in_PointerToafip3__ArrayOfCbteTipo(soap, tag, NULL, "afip3:ArrayOfCbteTipo");
	case SOAP_TYPE_PointerToafip3__PtoVenta:
		return soap_in_PointerToafip3__PtoVenta(soap, tag, NULL, "afip3:PtoVenta");
	case SOAP_TYPE_PointerToafip3__ArrayOfPtoVenta:
		return soap_in_PointerToafip3__ArrayOfPtoVenta(soap, tag, NULL, "afip3:ArrayOfPtoVenta");
	case SOAP_TYPE_PointerToafip3__ConceptoTipo:
		return soap_in_PointerToafip3__ConceptoTipo(soap, tag, NULL, "afip3:ConceptoTipo");
	case SOAP_TYPE_PointerToafip3__ArrayOfConceptoTipo:
		return soap_in_PointerToafip3__ArrayOfConceptoTipo(soap, tag, NULL, "afip3:ArrayOfConceptoTipo");
	case SOAP_TYPE_PointerToafip3__OpcionalTipo:
		return soap_in_PointerToafip3__OpcionalTipo(soap, tag, NULL, "afip3:OpcionalTipo");
	case SOAP_TYPE_PointerToafip3__ArrayOfOpcionalTipo:
		return soap_in_PointerToafip3__ArrayOfOpcionalTipo(soap, tag, NULL, "afip3:ArrayOfOpcionalTipo");
	case SOAP_TYPE_PointerToafip3__IvaTipo:
		return soap_in_PointerToafip3__IvaTipo(soap, tag, NULL, "afip3:IvaTipo");
	case SOAP_TYPE_PointerToafip3__ArrayOfIvaTipo:
		return soap_in_PointerToafip3__ArrayOfIvaTipo(soap, tag, NULL, "afip3:ArrayOfIvaTipo");
	case SOAP_TYPE_PointerToafip3__Moneda:
		return soap_in_PointerToafip3__Moneda(soap, tag, NULL, "afip3:Moneda");
	case SOAP_TYPE_PointerToafip3__ArrayOfMoneda:
		return soap_in_PointerToafip3__ArrayOfMoneda(soap, tag, NULL, "afip3:ArrayOfMoneda");
	case SOAP_TYPE_PointerToafip3__TributoTipo:
		return soap_in_PointerToafip3__TributoTipo(soap, tag, NULL, "afip3:TributoTipo");
	case SOAP_TYPE_PointerToafip3__ArrayOfTributoTipo:
		return soap_in_PointerToafip3__ArrayOfTributoTipo(soap, tag, NULL, "afip3:ArrayOfTributoTipo");
	case SOAP_TYPE_PointerToafip3__Cotizacion:
		return soap_in_PointerToafip3__Cotizacion(soap, tag, NULL, "afip3:Cotizacion");
	case SOAP_TYPE_PointerToafip3__FECAEASinMov:
		return soap_in_PointerToafip3__FECAEASinMov(soap, tag, NULL, "afip3:FECAEASinMov");
	case SOAP_TYPE_PointerToafip3__ArrayOfFECAEASinMov:
		return soap_in_PointerToafip3__ArrayOfFECAEASinMov(soap, tag, NULL, "afip3:ArrayOfFECAEASinMov");
	case SOAP_TYPE_PointerToafip3__FECAEAGet:
		return soap_in_PointerToafip3__FECAEAGet(soap, tag, NULL, "afip3:FECAEAGet");
	case SOAP_TYPE_PointerToafip3__FECAEADetResponse:
		return soap_in_PointerToafip3__FECAEADetResponse(soap, tag, NULL, "afip3:FECAEADetResponse");
	case SOAP_TYPE_PointerToafip3__ArrayOfFECAEADetResponse:
		return soap_in_PointerToafip3__ArrayOfFECAEADetResponse(soap, tag, NULL, "afip3:ArrayOfFECAEADetResponse");
	case SOAP_TYPE_PointerToafip3__FECAEACabResponse:
		return soap_in_PointerToafip3__FECAEACabResponse(soap, tag, NULL, "afip3:FECAEACabResponse");
	case SOAP_TYPE_PointerToafip3__FECAEADetRequest:
		return soap_in_PointerToafip3__FECAEADetRequest(soap, tag, NULL, "afip3:FECAEADetRequest");
	case SOAP_TYPE_PointerToafip3__ArrayOfFECAEADetRequest:
		return soap_in_PointerToafip3__ArrayOfFECAEADetRequest(soap, tag, NULL, "afip3:ArrayOfFECAEADetRequest");
	case SOAP_TYPE_PointerToafip3__FECAEACabRequest:
		return soap_in_PointerToafip3__FECAEACabRequest(soap, tag, NULL, "afip3:FECAEACabRequest");
	case SOAP_TYPE_PointerToafip3__FECompConsResponse:
		return soap_in_PointerToafip3__FECompConsResponse(soap, tag, NULL, "afip3:FECompConsResponse");
	case SOAP_TYPE_PointerToafip3__Err:
		return soap_in_PointerToafip3__Err(soap, tag, NULL, "afip3:Err");
	case SOAP_TYPE_PointerToafip3__Evt:
		return soap_in_PointerToafip3__Evt(soap, tag, NULL, "afip3:Evt");
	case SOAP_TYPE_PointerToafip3__Obs:
		return soap_in_PointerToafip3__Obs(soap, tag, NULL, "afip3:Obs");
	case SOAP_TYPE_PointerToafip3__ArrayOfObs:
		return soap_in_PointerToafip3__ArrayOfObs(soap, tag, NULL, "afip3:ArrayOfObs");
	case SOAP_TYPE_PointerToafip3__FECAEDetResponse:
		return soap_in_PointerToafip3__FECAEDetResponse(soap, tag, NULL, "afip3:FECAEDetResponse");
	case SOAP_TYPE_PointerToafip3__ArrayOfErr:
		return soap_in_PointerToafip3__ArrayOfErr(soap, tag, NULL, "afip3:ArrayOfErr");
	case SOAP_TYPE_PointerToafip3__ArrayOfEvt:
		return soap_in_PointerToafip3__ArrayOfEvt(soap, tag, NULL, "afip3:ArrayOfEvt");
	case SOAP_TYPE_PointerToafip3__ArrayOfFECAEDetResponse:
		return soap_in_PointerToafip3__ArrayOfFECAEDetResponse(soap, tag, NULL, "afip3:ArrayOfFECAEDetResponse");
	case SOAP_TYPE_PointerToafip3__FECAECabResponse:
		return soap_in_PointerToafip3__FECAECabResponse(soap, tag, NULL, "afip3:FECAECabResponse");
	case SOAP_TYPE_PointerToafip3__Comprador:
		return soap_in_PointerToafip3__Comprador(soap, tag, NULL, "afip3:Comprador");
	case SOAP_TYPE_PointerToafip3__Opcional:
		return soap_in_PointerToafip3__Opcional(soap, tag, NULL, "afip3:Opcional");
	case SOAP_TYPE_PointerToafip3__AlicIva:
		return soap_in_PointerToafip3__AlicIva(soap, tag, NULL, "afip3:AlicIva");
	case SOAP_TYPE_PointerToafip3__Tributo:
		return soap_in_PointerToafip3__Tributo(soap, tag, NULL, "afip3:Tributo");
	case SOAP_TYPE_PointerToafip3__CbteAsoc:
		return soap_in_PointerToafip3__CbteAsoc(soap, tag, NULL, "afip3:CbteAsoc");
	case SOAP_TYPE_PointerToafip3__ArrayOfComprador:
		return soap_in_PointerToafip3__ArrayOfComprador(soap, tag, NULL, "afip3:ArrayOfComprador");
	case SOAP_TYPE_PointerToafip3__ArrayOfOpcional:
		return soap_in_PointerToafip3__ArrayOfOpcional(soap, tag, NULL, "afip3:ArrayOfOpcional");
	case SOAP_TYPE_PointerToafip3__ArrayOfAlicIva:
		return soap_in_PointerToafip3__ArrayOfAlicIva(soap, tag, NULL, "afip3:ArrayOfAlicIva");
	case SOAP_TYPE_PointerToafip3__ArrayOfTributo:
		return soap_in_PointerToafip3__ArrayOfTributo(soap, tag, NULL, "afip3:ArrayOfTributo");
	case SOAP_TYPE_PointerToafip3__ArrayOfCbteAsoc:
		return soap_in_PointerToafip3__ArrayOfCbteAsoc(soap, tag, NULL, "afip3:ArrayOfCbteAsoc");
	case SOAP_TYPE_PointerToafip3__FECAEDetRequest:
		return soap_in_PointerToafip3__FECAEDetRequest(soap, tag, NULL, "afip3:FECAEDetRequest");
	case SOAP_TYPE_PointerToafip3__ArrayOfFECAEDetRequest:
		return soap_in_PointerToafip3__ArrayOfFECAEDetRequest(soap, tag, NULL, "afip3:ArrayOfFECAEDetRequest");
	case SOAP_TYPE_PointerToafip3__FECAECabRequest:
		return soap_in_PointerToafip3__FECAECabRequest(soap, tag, NULL, "afip3:FECAECabRequest");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, tag, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:PaisTipo"))
		{	*type = SOAP_TYPE_afip3__PaisTipo;
			return soap_in_afip3__PaisTipo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:ArrayOfPaisTipo"))
		{	*type = SOAP_TYPE_afip3__ArrayOfPaisTipo;
			return soap_in_afip3__ArrayOfPaisTipo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FEPaisResponse"))
		{	*type = SOAP_TYPE_afip3__FEPaisResponse;
			return soap_in_afip3__FEPaisResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:DocTipo"))
		{	*type = SOAP_TYPE_afip3__DocTipo;
			return soap_in_afip3__DocTipo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:ArrayOfDocTipo"))
		{	*type = SOAP_TYPE_afip3__ArrayOfDocTipo;
			return soap_in_afip3__ArrayOfDocTipo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:DocTipoResponse"))
		{	*type = SOAP_TYPE_afip3__DocTipoResponse;
			return soap_in_afip3__DocTipoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:CbteTipo"))
		{	*type = SOAP_TYPE_afip3__CbteTipo;
			return soap_in_afip3__CbteTipo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:ArrayOfCbteTipo"))
		{	*type = SOAP_TYPE_afip3__ArrayOfCbteTipo;
			return soap_in_afip3__ArrayOfCbteTipo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:CbteTipoResponse"))
		{	*type = SOAP_TYPE_afip3__CbteTipoResponse;
			return soap_in_afip3__CbteTipoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:PtoVenta"))
		{	*type = SOAP_TYPE_afip3__PtoVenta;
			return soap_in_afip3__PtoVenta(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:ArrayOfPtoVenta"))
		{	*type = SOAP_TYPE_afip3__ArrayOfPtoVenta;
			return soap_in_afip3__ArrayOfPtoVenta(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FEPtoVentaResponse"))
		{	*type = SOAP_TYPE_afip3__FEPtoVentaResponse;
			return soap_in_afip3__FEPtoVentaResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:ConceptoTipo"))
		{	*type = SOAP_TYPE_afip3__ConceptoTipo;
			return soap_in_afip3__ConceptoTipo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:ArrayOfConceptoTipo"))
		{	*type = SOAP_TYPE_afip3__ArrayOfConceptoTipo;
			return soap_in_afip3__ArrayOfConceptoTipo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:ConceptoTipoResponse"))
		{	*type = SOAP_TYPE_afip3__ConceptoTipoResponse;
			return soap_in_afip3__ConceptoTipoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:OpcionalTipo"))
		{	*type = SOAP_TYPE_afip3__OpcionalTipo;
			return soap_in_afip3__OpcionalTipo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:ArrayOfOpcionalTipo"))
		{	*type = SOAP_TYPE_afip3__ArrayOfOpcionalTipo;
			return soap_in_afip3__ArrayOfOpcionalTipo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:OpcionalTipoResponse"))
		{	*type = SOAP_TYPE_afip3__OpcionalTipoResponse;
			return soap_in_afip3__OpcionalTipoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:IvaTipo"))
		{	*type = SOAP_TYPE_afip3__IvaTipo;
			return soap_in_afip3__IvaTipo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:ArrayOfIvaTipo"))
		{	*type = SOAP_TYPE_afip3__ArrayOfIvaTipo;
			return soap_in_afip3__ArrayOfIvaTipo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:IvaTipoResponse"))
		{	*type = SOAP_TYPE_afip3__IvaTipoResponse;
			return soap_in_afip3__IvaTipoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:Moneda"))
		{	*type = SOAP_TYPE_afip3__Moneda;
			return soap_in_afip3__Moneda(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:ArrayOfMoneda"))
		{	*type = SOAP_TYPE_afip3__ArrayOfMoneda;
			return soap_in_afip3__ArrayOfMoneda(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:MonedaResponse"))
		{	*type = SOAP_TYPE_afip3__MonedaResponse;
			return soap_in_afip3__MonedaResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:TributoTipo"))
		{	*type = SOAP_TYPE_afip3__TributoTipo;
			return soap_in_afip3__TributoTipo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:ArrayOfTributoTipo"))
		{	*type = SOAP_TYPE_afip3__ArrayOfTributoTipo;
			return soap_in_afip3__ArrayOfTributoTipo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FETributoResponse"))
		{	*type = SOAP_TYPE_afip3__FETributoResponse;
			return soap_in_afip3__FETributoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:Cotizacion"))
		{	*type = SOAP_TYPE_afip3__Cotizacion;
			return soap_in_afip3__Cotizacion(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECotizacionResponse"))
		{	*type = SOAP_TYPE_afip3__FECotizacionResponse;
			return soap_in_afip3__FECotizacionResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECAEASinMovResponse"))
		{	*type = SOAP_TYPE_afip3__FECAEASinMovResponse;
			return soap_in_afip3__FECAEASinMovResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECAEASinMov"))
		{	*type = SOAP_TYPE_afip3__FECAEASinMov;
			return soap_in_afip3__FECAEASinMov(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:ArrayOfFECAEASinMov"))
		{	*type = SOAP_TYPE_afip3__ArrayOfFECAEASinMov;
			return soap_in_afip3__ArrayOfFECAEASinMov(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECAEASinMovConsResponse"))
		{	*type = SOAP_TYPE_afip3__FECAEASinMovConsResponse;
			return soap_in_afip3__FECAEASinMovConsResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECAEAGet"))
		{	*type = SOAP_TYPE_afip3__FECAEAGet;
			return soap_in_afip3__FECAEAGet(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECAEAGetResponse"))
		{	*type = SOAP_TYPE_afip3__FECAEAGetResponse;
			return soap_in_afip3__FECAEAGetResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECAEADetResponse"))
		{	*type = SOAP_TYPE_afip3__FECAEADetResponse;
			return soap_in_afip3__FECAEADetResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:ArrayOfFECAEADetResponse"))
		{	*type = SOAP_TYPE_afip3__ArrayOfFECAEADetResponse;
			return soap_in_afip3__ArrayOfFECAEADetResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECAEACabResponse"))
		{	*type = SOAP_TYPE_afip3__FECAEACabResponse;
			return soap_in_afip3__FECAEACabResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECAEAResponse"))
		{	*type = SOAP_TYPE_afip3__FECAEAResponse;
			return soap_in_afip3__FECAEAResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECAEADetRequest"))
		{	*type = SOAP_TYPE_afip3__FECAEADetRequest;
			return soap_in_afip3__FECAEADetRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:ArrayOfFECAEADetRequest"))
		{	*type = SOAP_TYPE_afip3__ArrayOfFECAEADetRequest;
			return soap_in_afip3__ArrayOfFECAEADetRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECAEACabRequest"))
		{	*type = SOAP_TYPE_afip3__FECAEACabRequest;
			return soap_in_afip3__FECAEACabRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECAEARequest"))
		{	*type = SOAP_TYPE_afip3__FECAEARequest;
			return soap_in_afip3__FECAEARequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECompConsResponse"))
		{	*type = SOAP_TYPE_afip3__FECompConsResponse;
			return soap_in_afip3__FECompConsResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECompConsultaResponse"))
		{	*type = SOAP_TYPE_afip3__FECompConsultaResponse;
			return soap_in_afip3__FECompConsultaResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECompConsultaReq"))
		{	*type = SOAP_TYPE_afip3__FECompConsultaReq;
			return soap_in_afip3__FECompConsultaReq(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FERecuperaLastCbteResponse"))
		{	*type = SOAP_TYPE_afip3__FERecuperaLastCbteResponse;
			return soap_in_afip3__FERecuperaLastCbteResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:DummyResponse"))
		{	*type = SOAP_TYPE_afip3__DummyResponse;
			return soap_in_afip3__DummyResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FERegXReqResponse"))
		{	*type = SOAP_TYPE_afip3__FERegXReqResponse;
			return soap_in_afip3__FERegXReqResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:Err"))
		{	*type = SOAP_TYPE_afip3__Err;
			return soap_in_afip3__Err(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:ArrayOfErr"))
		{	*type = SOAP_TYPE_afip3__ArrayOfErr;
			return soap_in_afip3__ArrayOfErr(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:Evt"))
		{	*type = SOAP_TYPE_afip3__Evt;
			return soap_in_afip3__Evt(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:ArrayOfEvt"))
		{	*type = SOAP_TYPE_afip3__ArrayOfEvt;
			return soap_in_afip3__ArrayOfEvt(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:Obs"))
		{	*type = SOAP_TYPE_afip3__Obs;
			return soap_in_afip3__Obs(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:ArrayOfObs"))
		{	*type = SOAP_TYPE_afip3__ArrayOfObs;
			return soap_in_afip3__ArrayOfObs(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FEDetResponse"))
		{	*type = SOAP_TYPE_afip3__FEDetResponse;
			return soap_in_afip3__FEDetResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECAEDetResponse"))
		{	*type = SOAP_TYPE_afip3__FECAEDetResponse;
			return soap_in_afip3__FECAEDetResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:ArrayOfFECAEDetResponse"))
		{	*type = SOAP_TYPE_afip3__ArrayOfFECAEDetResponse;
			return soap_in_afip3__ArrayOfFECAEDetResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECabResponse"))
		{	*type = SOAP_TYPE_afip3__FECabResponse;
			return soap_in_afip3__FECabResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECAECabResponse"))
		{	*type = SOAP_TYPE_afip3__FECAECabResponse;
			return soap_in_afip3__FECAECabResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECAEResponse"))
		{	*type = SOAP_TYPE_afip3__FECAEResponse;
			return soap_in_afip3__FECAEResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:Comprador"))
		{	*type = SOAP_TYPE_afip3__Comprador;
			return soap_in_afip3__Comprador(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:ArrayOfComprador"))
		{	*type = SOAP_TYPE_afip3__ArrayOfComprador;
			return soap_in_afip3__ArrayOfComprador(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:Opcional"))
		{	*type = SOAP_TYPE_afip3__Opcional;
			return soap_in_afip3__Opcional(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:ArrayOfOpcional"))
		{	*type = SOAP_TYPE_afip3__ArrayOfOpcional;
			return soap_in_afip3__ArrayOfOpcional(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:AlicIva"))
		{	*type = SOAP_TYPE_afip3__AlicIva;
			return soap_in_afip3__AlicIva(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:ArrayOfAlicIva"))
		{	*type = SOAP_TYPE_afip3__ArrayOfAlicIva;
			return soap_in_afip3__ArrayOfAlicIva(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:Tributo"))
		{	*type = SOAP_TYPE_afip3__Tributo;
			return soap_in_afip3__Tributo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:ArrayOfTributo"))
		{	*type = SOAP_TYPE_afip3__ArrayOfTributo;
			return soap_in_afip3__ArrayOfTributo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:CbteAsoc"))
		{	*type = SOAP_TYPE_afip3__CbteAsoc;
			return soap_in_afip3__CbteAsoc(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:ArrayOfCbteAsoc"))
		{	*type = SOAP_TYPE_afip3__ArrayOfCbteAsoc;
			return soap_in_afip3__ArrayOfCbteAsoc(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FEDetRequest"))
		{	*type = SOAP_TYPE_afip3__FEDetRequest;
			return soap_in_afip3__FEDetRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECAEDetRequest"))
		{	*type = SOAP_TYPE_afip3__FECAEDetRequest;
			return soap_in_afip3__FECAEDetRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:ArrayOfFECAEDetRequest"))
		{	*type = SOAP_TYPE_afip3__ArrayOfFECAEDetRequest;
			return soap_in_afip3__ArrayOfFECAEDetRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECabRequest"))
		{	*type = SOAP_TYPE_afip3__FECabRequest;
			return soap_in_afip3__FECabRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECAECabRequest"))
		{	*type = SOAP_TYPE_afip3__FECAECabRequest;
			return soap_in_afip3__FECAECabRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECAERequest"))
		{	*type = SOAP_TYPE_afip3__FECAERequest;
			return soap_in_afip3__FECAERequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FEAuthRequest"))
		{	*type = SOAP_TYPE_afip3__FEAuthRequest;
			return soap_in_afip3__FEAuthRequest(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip2:LoginFault"))
		{	*type = SOAP_TYPE_afip2__LoginFault;
			return soap_in_afip2__LoginFault(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:short"))
		{	*type = SOAP_TYPE_short;
			return soap_in_short(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "afip3:FEParamGetTiposPaisesResponse"))
		{	*type = SOAP_TYPE__afip3__FEParamGetTiposPaisesResponse;
			return soap_in__afip3__FEParamGetTiposPaisesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FEParamGetTiposPaises"))
		{	*type = SOAP_TYPE__afip3__FEParamGetTiposPaises;
			return soap_in__afip3__FEParamGetTiposPaises(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FEParamGetTiposDocResponse"))
		{	*type = SOAP_TYPE__afip3__FEParamGetTiposDocResponse;
			return soap_in__afip3__FEParamGetTiposDocResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FEParamGetTiposDoc"))
		{	*type = SOAP_TYPE__afip3__FEParamGetTiposDoc;
			return soap_in__afip3__FEParamGetTiposDoc(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FEParamGetTiposCbteResponse"))
		{	*type = SOAP_TYPE__afip3__FEParamGetTiposCbteResponse;
			return soap_in__afip3__FEParamGetTiposCbteResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FEParamGetTiposCbte"))
		{	*type = SOAP_TYPE__afip3__FEParamGetTiposCbte;
			return soap_in__afip3__FEParamGetTiposCbte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FEParamGetPtosVentaResponse"))
		{	*type = SOAP_TYPE__afip3__FEParamGetPtosVentaResponse;
			return soap_in__afip3__FEParamGetPtosVentaResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FEParamGetPtosVenta"))
		{	*type = SOAP_TYPE__afip3__FEParamGetPtosVenta;
			return soap_in__afip3__FEParamGetPtosVenta(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FEParamGetTiposConceptoResponse"))
		{	*type = SOAP_TYPE__afip3__FEParamGetTiposConceptoResponse;
			return soap_in__afip3__FEParamGetTiposConceptoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FEParamGetTiposConcepto"))
		{	*type = SOAP_TYPE__afip3__FEParamGetTiposConcepto;
			return soap_in__afip3__FEParamGetTiposConcepto(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FEParamGetTiposOpcionalResponse"))
		{	*type = SOAP_TYPE__afip3__FEParamGetTiposOpcionalResponse;
			return soap_in__afip3__FEParamGetTiposOpcionalResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FEParamGetTiposOpcional"))
		{	*type = SOAP_TYPE__afip3__FEParamGetTiposOpcional;
			return soap_in__afip3__FEParamGetTiposOpcional(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FEParamGetTiposIvaResponse"))
		{	*type = SOAP_TYPE__afip3__FEParamGetTiposIvaResponse;
			return soap_in__afip3__FEParamGetTiposIvaResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FEParamGetTiposIva"))
		{	*type = SOAP_TYPE__afip3__FEParamGetTiposIva;
			return soap_in__afip3__FEParamGetTiposIva(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FEParamGetTiposMonedasResponse"))
		{	*type = SOAP_TYPE__afip3__FEParamGetTiposMonedasResponse;
			return soap_in__afip3__FEParamGetTiposMonedasResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FEParamGetTiposMonedas"))
		{	*type = SOAP_TYPE__afip3__FEParamGetTiposMonedas;
			return soap_in__afip3__FEParamGetTiposMonedas(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FEParamGetTiposTributosResponse"))
		{	*type = SOAP_TYPE__afip3__FEParamGetTiposTributosResponse;
			return soap_in__afip3__FEParamGetTiposTributosResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FEParamGetTiposTributos"))
		{	*type = SOAP_TYPE__afip3__FEParamGetTiposTributos;
			return soap_in__afip3__FEParamGetTiposTributos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FEParamGetCotizacionResponse"))
		{	*type = SOAP_TYPE__afip3__FEParamGetCotizacionResponse;
			return soap_in__afip3__FEParamGetCotizacionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FEParamGetCotizacion"))
		{	*type = SOAP_TYPE__afip3__FEParamGetCotizacion;
			return soap_in__afip3__FEParamGetCotizacion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECAEAConsultarResponse"))
		{	*type = SOAP_TYPE__afip3__FECAEAConsultarResponse;
			return soap_in__afip3__FECAEAConsultarResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECAEAConsultar"))
		{	*type = SOAP_TYPE__afip3__FECAEAConsultar;
			return soap_in__afip3__FECAEAConsultar(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECAEASinMovimientoInformarResponse"))
		{	*type = SOAP_TYPE__afip3__FECAEASinMovimientoInformarResponse;
			return soap_in__afip3__FECAEASinMovimientoInformarResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECAEASinMovimientoInformar"))
		{	*type = SOAP_TYPE__afip3__FECAEASinMovimientoInformar;
			return soap_in__afip3__FECAEASinMovimientoInformar(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECAEASinMovimientoConsultarResponse"))
		{	*type = SOAP_TYPE__afip3__FECAEASinMovimientoConsultarResponse;
			return soap_in__afip3__FECAEASinMovimientoConsultarResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECAEASinMovimientoConsultar"))
		{	*type = SOAP_TYPE__afip3__FECAEASinMovimientoConsultar;
			return soap_in__afip3__FECAEASinMovimientoConsultar(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECAEASolicitarResponse"))
		{	*type = SOAP_TYPE__afip3__FECAEASolicitarResponse;
			return soap_in__afip3__FECAEASolicitarResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECAEASolicitar"))
		{	*type = SOAP_TYPE__afip3__FECAEASolicitar;
			return soap_in__afip3__FECAEASolicitar(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECAEARegInformativoResponse"))
		{	*type = SOAP_TYPE__afip3__FECAEARegInformativoResponse;
			return soap_in__afip3__FECAEARegInformativoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECAEARegInformativo"))
		{	*type = SOAP_TYPE__afip3__FECAEARegInformativo;
			return soap_in__afip3__FECAEARegInformativo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECompConsultarResponse"))
		{	*type = SOAP_TYPE__afip3__FECompConsultarResponse;
			return soap_in__afip3__FECompConsultarResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECompConsultar"))
		{	*type = SOAP_TYPE__afip3__FECompConsultar;
			return soap_in__afip3__FECompConsultar(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECompUltimoAutorizadoResponse"))
		{	*type = SOAP_TYPE__afip3__FECompUltimoAutorizadoResponse;
			return soap_in__afip3__FECompUltimoAutorizadoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECompUltimoAutorizado"))
		{	*type = SOAP_TYPE__afip3__FECompUltimoAutorizado;
			return soap_in__afip3__FECompUltimoAutorizado(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FEDummyResponse"))
		{	*type = SOAP_TYPE__afip3__FEDummyResponse;
			return soap_in__afip3__FEDummyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FEDummy"))
		{	*type = SOAP_TYPE__afip3__FEDummy;
			return soap_in__afip3__FEDummy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECompTotXRequestResponse"))
		{	*type = SOAP_TYPE__afip3__FECompTotXRequestResponse;
			return soap_in__afip3__FECompTotXRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECompTotXRequest"))
		{	*type = SOAP_TYPE__afip3__FECompTotXRequest;
			return soap_in__afip3__FECompTotXRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECAESolicitarResponse"))
		{	*type = SOAP_TYPE__afip3__FECAESolicitarResponse;
			return soap_in__afip3__FECAESolicitarResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip3:FECAESolicitar"))
		{	*type = SOAP_TYPE__afip3__FECAESolicitar;
			return soap_in__afip3__FECAESolicitar(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip1:loginCmsResponse"))
		{	*type = SOAP_TYPE__afip1__loginCmsResponse;
			return soap_in__afip1__loginCmsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "afip1:loginCms"))
		{	*type = SOAP_TYPE__afip1__loginCms;
			return soap_in__afip1__loginCms(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && !soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, NULL, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_short:
		return soap_out_short(soap, tag, id, (const short *)ptr, "xsd:short");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE__afip3__FEParamGetTiposPaisesResponse:
		return ((_afip3__FEParamGetTiposPaisesResponse *)ptr)->soap_out(soap, "afip3:FEParamGetTiposPaisesResponse", id, "");
	case SOAP_TYPE__afip3__FEParamGetTiposPaises:
		return ((_afip3__FEParamGetTiposPaises *)ptr)->soap_out(soap, "afip3:FEParamGetTiposPaises", id, "");
	case SOAP_TYPE__afip3__FEParamGetTiposDocResponse:
		return ((_afip3__FEParamGetTiposDocResponse *)ptr)->soap_out(soap, "afip3:FEParamGetTiposDocResponse", id, "");
	case SOAP_TYPE__afip3__FEParamGetTiposDoc:
		return ((_afip3__FEParamGetTiposDoc *)ptr)->soap_out(soap, "afip3:FEParamGetTiposDoc", id, "");
	case SOAP_TYPE__afip3__FEParamGetTiposCbteResponse:
		return ((_afip3__FEParamGetTiposCbteResponse *)ptr)->soap_out(soap, "afip3:FEParamGetTiposCbteResponse", id, "");
	case SOAP_TYPE__afip3__FEParamGetTiposCbte:
		return ((_afip3__FEParamGetTiposCbte *)ptr)->soap_out(soap, "afip3:FEParamGetTiposCbte", id, "");
	case SOAP_TYPE__afip3__FEParamGetPtosVentaResponse:
		return ((_afip3__FEParamGetPtosVentaResponse *)ptr)->soap_out(soap, "afip3:FEParamGetPtosVentaResponse", id, "");
	case SOAP_TYPE__afip3__FEParamGetPtosVenta:
		return ((_afip3__FEParamGetPtosVenta *)ptr)->soap_out(soap, "afip3:FEParamGetPtosVenta", id, "");
	case SOAP_TYPE__afip3__FEParamGetTiposConceptoResponse:
		return ((_afip3__FEParamGetTiposConceptoResponse *)ptr)->soap_out(soap, "afip3:FEParamGetTiposConceptoResponse", id, "");
	case SOAP_TYPE__afip3__FEParamGetTiposConcepto:
		return ((_afip3__FEParamGetTiposConcepto *)ptr)->soap_out(soap, "afip3:FEParamGetTiposConcepto", id, "");
	case SOAP_TYPE__afip3__FEParamGetTiposOpcionalResponse:
		return ((_afip3__FEParamGetTiposOpcionalResponse *)ptr)->soap_out(soap, "afip3:FEParamGetTiposOpcionalResponse", id, "");
	case SOAP_TYPE__afip3__FEParamGetTiposOpcional:
		return ((_afip3__FEParamGetTiposOpcional *)ptr)->soap_out(soap, "afip3:FEParamGetTiposOpcional", id, "");
	case SOAP_TYPE__afip3__FEParamGetTiposIvaResponse:
		return ((_afip3__FEParamGetTiposIvaResponse *)ptr)->soap_out(soap, "afip3:FEParamGetTiposIvaResponse", id, "");
	case SOAP_TYPE__afip3__FEParamGetTiposIva:
		return ((_afip3__FEParamGetTiposIva *)ptr)->soap_out(soap, "afip3:FEParamGetTiposIva", id, "");
	case SOAP_TYPE__afip3__FEParamGetTiposMonedasResponse:
		return ((_afip3__FEParamGetTiposMonedasResponse *)ptr)->soap_out(soap, "afip3:FEParamGetTiposMonedasResponse", id, "");
	case SOAP_TYPE__afip3__FEParamGetTiposMonedas:
		return ((_afip3__FEParamGetTiposMonedas *)ptr)->soap_out(soap, "afip3:FEParamGetTiposMonedas", id, "");
	case SOAP_TYPE__afip3__FEParamGetTiposTributosResponse:
		return ((_afip3__FEParamGetTiposTributosResponse *)ptr)->soap_out(soap, "afip3:FEParamGetTiposTributosResponse", id, "");
	case SOAP_TYPE__afip3__FEParamGetTiposTributos:
		return ((_afip3__FEParamGetTiposTributos *)ptr)->soap_out(soap, "afip3:FEParamGetTiposTributos", id, "");
	case SOAP_TYPE__afip3__FEParamGetCotizacionResponse:
		return ((_afip3__FEParamGetCotizacionResponse *)ptr)->soap_out(soap, "afip3:FEParamGetCotizacionResponse", id, "");
	case SOAP_TYPE__afip3__FEParamGetCotizacion:
		return ((_afip3__FEParamGetCotizacion *)ptr)->soap_out(soap, "afip3:FEParamGetCotizacion", id, "");
	case SOAP_TYPE__afip3__FECAEAConsultarResponse:
		return ((_afip3__FECAEAConsultarResponse *)ptr)->soap_out(soap, "afip3:FECAEAConsultarResponse", id, "");
	case SOAP_TYPE__afip3__FECAEAConsultar:
		return ((_afip3__FECAEAConsultar *)ptr)->soap_out(soap, "afip3:FECAEAConsultar", id, "");
	case SOAP_TYPE__afip3__FECAEASinMovimientoInformarResponse:
		return ((_afip3__FECAEASinMovimientoInformarResponse *)ptr)->soap_out(soap, "afip3:FECAEASinMovimientoInformarResponse", id, "");
	case SOAP_TYPE__afip3__FECAEASinMovimientoInformar:
		return ((_afip3__FECAEASinMovimientoInformar *)ptr)->soap_out(soap, "afip3:FECAEASinMovimientoInformar", id, "");
	case SOAP_TYPE__afip3__FECAEASinMovimientoConsultarResponse:
		return ((_afip3__FECAEASinMovimientoConsultarResponse *)ptr)->soap_out(soap, "afip3:FECAEASinMovimientoConsultarResponse", id, "");
	case SOAP_TYPE__afip3__FECAEASinMovimientoConsultar:
		return ((_afip3__FECAEASinMovimientoConsultar *)ptr)->soap_out(soap, "afip3:FECAEASinMovimientoConsultar", id, "");
	case SOAP_TYPE__afip3__FECAEASolicitarResponse:
		return ((_afip3__FECAEASolicitarResponse *)ptr)->soap_out(soap, "afip3:FECAEASolicitarResponse", id, "");
	case SOAP_TYPE__afip3__FECAEASolicitar:
		return ((_afip3__FECAEASolicitar *)ptr)->soap_out(soap, "afip3:FECAEASolicitar", id, "");
	case SOAP_TYPE__afip3__FECAEARegInformativoResponse:
		return ((_afip3__FECAEARegInformativoResponse *)ptr)->soap_out(soap, "afip3:FECAEARegInformativoResponse", id, "");
	case SOAP_TYPE__afip3__FECAEARegInformativo:
		return ((_afip3__FECAEARegInformativo *)ptr)->soap_out(soap, "afip3:FECAEARegInformativo", id, "");
	case SOAP_TYPE__afip3__FECompConsultarResponse:
		return ((_afip3__FECompConsultarResponse *)ptr)->soap_out(soap, "afip3:FECompConsultarResponse", id, "");
	case SOAP_TYPE__afip3__FECompConsultar:
		return ((_afip3__FECompConsultar *)ptr)->soap_out(soap, "afip3:FECompConsultar", id, "");
	case SOAP_TYPE__afip3__FECompUltimoAutorizadoResponse:
		return ((_afip3__FECompUltimoAutorizadoResponse *)ptr)->soap_out(soap, "afip3:FECompUltimoAutorizadoResponse", id, "");
	case SOAP_TYPE__afip3__FECompUltimoAutorizado:
		return ((_afip3__FECompUltimoAutorizado *)ptr)->soap_out(soap, "afip3:FECompUltimoAutorizado", id, "");
	case SOAP_TYPE__afip3__FEDummyResponse:
		return ((_afip3__FEDummyResponse *)ptr)->soap_out(soap, "afip3:FEDummyResponse", id, "");
	case SOAP_TYPE__afip3__FEDummy:
		return ((_afip3__FEDummy *)ptr)->soap_out(soap, "afip3:FEDummy", id, "");
	case SOAP_TYPE__afip3__FECompTotXRequestResponse:
		return ((_afip3__FECompTotXRequestResponse *)ptr)->soap_out(soap, "afip3:FECompTotXRequestResponse", id, "");
	case SOAP_TYPE__afip3__FECompTotXRequest:
		return ((_afip3__FECompTotXRequest *)ptr)->soap_out(soap, "afip3:FECompTotXRequest", id, "");
	case SOAP_TYPE__afip3__FECAESolicitarResponse:
		return ((_afip3__FECAESolicitarResponse *)ptr)->soap_out(soap, "afip3:FECAESolicitarResponse", id, "");
	case SOAP_TYPE__afip3__FECAESolicitar:
		return ((_afip3__FECAESolicitar *)ptr)->soap_out(soap, "afip3:FECAESolicitar", id, "");
	case SOAP_TYPE_afip3__PaisTipo:
		return ((afip3__PaisTipo *)ptr)->soap_out(soap, tag, id, "afip3:PaisTipo");
	case SOAP_TYPE_afip3__ArrayOfPaisTipo:
		return ((afip3__ArrayOfPaisTipo *)ptr)->soap_out(soap, tag, id, "afip3:ArrayOfPaisTipo");
	case SOAP_TYPE_afip3__FEPaisResponse:
		return ((afip3__FEPaisResponse *)ptr)->soap_out(soap, tag, id, "afip3:FEPaisResponse");
	case SOAP_TYPE_afip3__DocTipo:
		return ((afip3__DocTipo *)ptr)->soap_out(soap, tag, id, "afip3:DocTipo");
	case SOAP_TYPE_afip3__ArrayOfDocTipo:
		return ((afip3__ArrayOfDocTipo *)ptr)->soap_out(soap, tag, id, "afip3:ArrayOfDocTipo");
	case SOAP_TYPE_afip3__DocTipoResponse:
		return ((afip3__DocTipoResponse *)ptr)->soap_out(soap, tag, id, "afip3:DocTipoResponse");
	case SOAP_TYPE_afip3__CbteTipo:
		return ((afip3__CbteTipo *)ptr)->soap_out(soap, tag, id, "afip3:CbteTipo");
	case SOAP_TYPE_afip3__ArrayOfCbteTipo:
		return ((afip3__ArrayOfCbteTipo *)ptr)->soap_out(soap, tag, id, "afip3:ArrayOfCbteTipo");
	case SOAP_TYPE_afip3__CbteTipoResponse:
		return ((afip3__CbteTipoResponse *)ptr)->soap_out(soap, tag, id, "afip3:CbteTipoResponse");
	case SOAP_TYPE_afip3__PtoVenta:
		return ((afip3__PtoVenta *)ptr)->soap_out(soap, tag, id, "afip3:PtoVenta");
	case SOAP_TYPE_afip3__ArrayOfPtoVenta:
		return ((afip3__ArrayOfPtoVenta *)ptr)->soap_out(soap, tag, id, "afip3:ArrayOfPtoVenta");
	case SOAP_TYPE_afip3__FEPtoVentaResponse:
		return ((afip3__FEPtoVentaResponse *)ptr)->soap_out(soap, tag, id, "afip3:FEPtoVentaResponse");
	case SOAP_TYPE_afip3__ConceptoTipo:
		return ((afip3__ConceptoTipo *)ptr)->soap_out(soap, tag, id, "afip3:ConceptoTipo");
	case SOAP_TYPE_afip3__ArrayOfConceptoTipo:
		return ((afip3__ArrayOfConceptoTipo *)ptr)->soap_out(soap, tag, id, "afip3:ArrayOfConceptoTipo");
	case SOAP_TYPE_afip3__ConceptoTipoResponse:
		return ((afip3__ConceptoTipoResponse *)ptr)->soap_out(soap, tag, id, "afip3:ConceptoTipoResponse");
	case SOAP_TYPE_afip3__OpcionalTipo:
		return ((afip3__OpcionalTipo *)ptr)->soap_out(soap, tag, id, "afip3:OpcionalTipo");
	case SOAP_TYPE_afip3__ArrayOfOpcionalTipo:
		return ((afip3__ArrayOfOpcionalTipo *)ptr)->soap_out(soap, tag, id, "afip3:ArrayOfOpcionalTipo");
	case SOAP_TYPE_afip3__OpcionalTipoResponse:
		return ((afip3__OpcionalTipoResponse *)ptr)->soap_out(soap, tag, id, "afip3:OpcionalTipoResponse");
	case SOAP_TYPE_afip3__IvaTipo:
		return ((afip3__IvaTipo *)ptr)->soap_out(soap, tag, id, "afip3:IvaTipo");
	case SOAP_TYPE_afip3__ArrayOfIvaTipo:
		return ((afip3__ArrayOfIvaTipo *)ptr)->soap_out(soap, tag, id, "afip3:ArrayOfIvaTipo");
	case SOAP_TYPE_afip3__IvaTipoResponse:
		return ((afip3__IvaTipoResponse *)ptr)->soap_out(soap, tag, id, "afip3:IvaTipoResponse");
	case SOAP_TYPE_afip3__Moneda:
		return ((afip3__Moneda *)ptr)->soap_out(soap, tag, id, "afip3:Moneda");
	case SOAP_TYPE_afip3__ArrayOfMoneda:
		return ((afip3__ArrayOfMoneda *)ptr)->soap_out(soap, tag, id, "afip3:ArrayOfMoneda");
	case SOAP_TYPE_afip3__MonedaResponse:
		return ((afip3__MonedaResponse *)ptr)->soap_out(soap, tag, id, "afip3:MonedaResponse");
	case SOAP_TYPE_afip3__TributoTipo:
		return ((afip3__TributoTipo *)ptr)->soap_out(soap, tag, id, "afip3:TributoTipo");
	case SOAP_TYPE_afip3__ArrayOfTributoTipo:
		return ((afip3__ArrayOfTributoTipo *)ptr)->soap_out(soap, tag, id, "afip3:ArrayOfTributoTipo");
	case SOAP_TYPE_afip3__FETributoResponse:
		return ((afip3__FETributoResponse *)ptr)->soap_out(soap, tag, id, "afip3:FETributoResponse");
	case SOAP_TYPE_afip3__Cotizacion:
		return ((afip3__Cotizacion *)ptr)->soap_out(soap, tag, id, "afip3:Cotizacion");
	case SOAP_TYPE_afip3__FECotizacionResponse:
		return ((afip3__FECotizacionResponse *)ptr)->soap_out(soap, tag, id, "afip3:FECotizacionResponse");
	case SOAP_TYPE_afip3__FECAEASinMovResponse:
		return ((afip3__FECAEASinMovResponse *)ptr)->soap_out(soap, tag, id, "afip3:FECAEASinMovResponse");
	case SOAP_TYPE_afip3__FECAEASinMov:
		return ((afip3__FECAEASinMov *)ptr)->soap_out(soap, tag, id, "afip3:FECAEASinMov");
	case SOAP_TYPE_afip3__ArrayOfFECAEASinMov:
		return ((afip3__ArrayOfFECAEASinMov *)ptr)->soap_out(soap, tag, id, "afip3:ArrayOfFECAEASinMov");
	case SOAP_TYPE_afip3__FECAEASinMovConsResponse:
		return ((afip3__FECAEASinMovConsResponse *)ptr)->soap_out(soap, tag, id, "afip3:FECAEASinMovConsResponse");
	case SOAP_TYPE_afip3__FECAEAGet:
		return ((afip3__FECAEAGet *)ptr)->soap_out(soap, tag, id, "afip3:FECAEAGet");
	case SOAP_TYPE_afip3__FECAEAGetResponse:
		return ((afip3__FECAEAGetResponse *)ptr)->soap_out(soap, tag, id, "afip3:FECAEAGetResponse");
	case SOAP_TYPE_afip3__FECAEADetResponse:
		return ((afip3__FECAEADetResponse *)ptr)->soap_out(soap, tag, id, "afip3:FECAEADetResponse");
	case SOAP_TYPE_afip3__ArrayOfFECAEADetResponse:
		return ((afip3__ArrayOfFECAEADetResponse *)ptr)->soap_out(soap, tag, id, "afip3:ArrayOfFECAEADetResponse");
	case SOAP_TYPE_afip3__FECAEACabResponse:
		return ((afip3__FECAEACabResponse *)ptr)->soap_out(soap, tag, id, "afip3:FECAEACabResponse");
	case SOAP_TYPE_afip3__FECAEAResponse:
		return ((afip3__FECAEAResponse *)ptr)->soap_out(soap, tag, id, "afip3:FECAEAResponse");
	case SOAP_TYPE_afip3__FECAEADetRequest:
		return ((afip3__FECAEADetRequest *)ptr)->soap_out(soap, tag, id, "afip3:FECAEADetRequest");
	case SOAP_TYPE_afip3__ArrayOfFECAEADetRequest:
		return ((afip3__ArrayOfFECAEADetRequest *)ptr)->soap_out(soap, tag, id, "afip3:ArrayOfFECAEADetRequest");
	case SOAP_TYPE_afip3__FECAEACabRequest:
		return ((afip3__FECAEACabRequest *)ptr)->soap_out(soap, tag, id, "afip3:FECAEACabRequest");
	case SOAP_TYPE_afip3__FECAEARequest:
		return ((afip3__FECAEARequest *)ptr)->soap_out(soap, tag, id, "afip3:FECAEARequest");
	case SOAP_TYPE_afip3__FECompConsResponse:
		return ((afip3__FECompConsResponse *)ptr)->soap_out(soap, tag, id, "afip3:FECompConsResponse");
	case SOAP_TYPE_afip3__FECompConsultaResponse:
		return ((afip3__FECompConsultaResponse *)ptr)->soap_out(soap, tag, id, "afip3:FECompConsultaResponse");
	case SOAP_TYPE_afip3__FECompConsultaReq:
		return ((afip3__FECompConsultaReq *)ptr)->soap_out(soap, tag, id, "afip3:FECompConsultaReq");
	case SOAP_TYPE_afip3__FERecuperaLastCbteResponse:
		return ((afip3__FERecuperaLastCbteResponse *)ptr)->soap_out(soap, tag, id, "afip3:FERecuperaLastCbteResponse");
	case SOAP_TYPE_afip3__DummyResponse:
		return ((afip3__DummyResponse *)ptr)->soap_out(soap, tag, id, "afip3:DummyResponse");
	case SOAP_TYPE_afip3__FERegXReqResponse:
		return ((afip3__FERegXReqResponse *)ptr)->soap_out(soap, tag, id, "afip3:FERegXReqResponse");
	case SOAP_TYPE_afip3__Err:
		return ((afip3__Err *)ptr)->soap_out(soap, tag, id, "afip3:Err");
	case SOAP_TYPE_afip3__ArrayOfErr:
		return ((afip3__ArrayOfErr *)ptr)->soap_out(soap, tag, id, "afip3:ArrayOfErr");
	case SOAP_TYPE_afip3__Evt:
		return ((afip3__Evt *)ptr)->soap_out(soap, tag, id, "afip3:Evt");
	case SOAP_TYPE_afip3__ArrayOfEvt:
		return ((afip3__ArrayOfEvt *)ptr)->soap_out(soap, tag, id, "afip3:ArrayOfEvt");
	case SOAP_TYPE_afip3__Obs:
		return ((afip3__Obs *)ptr)->soap_out(soap, tag, id, "afip3:Obs");
	case SOAP_TYPE_afip3__ArrayOfObs:
		return ((afip3__ArrayOfObs *)ptr)->soap_out(soap, tag, id, "afip3:ArrayOfObs");
	case SOAP_TYPE_afip3__FEDetResponse:
		return ((afip3__FEDetResponse *)ptr)->soap_out(soap, tag, id, "afip3:FEDetResponse");
	case SOAP_TYPE_afip3__FECAEDetResponse:
		return ((afip3__FECAEDetResponse *)ptr)->soap_out(soap, tag, id, "afip3:FECAEDetResponse");
	case SOAP_TYPE_afip3__ArrayOfFECAEDetResponse:
		return ((afip3__ArrayOfFECAEDetResponse *)ptr)->soap_out(soap, tag, id, "afip3:ArrayOfFECAEDetResponse");
	case SOAP_TYPE_afip3__FECabResponse:
		return ((afip3__FECabResponse *)ptr)->soap_out(soap, tag, id, "afip3:FECabResponse");
	case SOAP_TYPE_afip3__FECAECabResponse:
		return ((afip3__FECAECabResponse *)ptr)->soap_out(soap, tag, id, "afip3:FECAECabResponse");
	case SOAP_TYPE_afip3__FECAEResponse:
		return ((afip3__FECAEResponse *)ptr)->soap_out(soap, tag, id, "afip3:FECAEResponse");
	case SOAP_TYPE_afip3__Comprador:
		return ((afip3__Comprador *)ptr)->soap_out(soap, tag, id, "afip3:Comprador");
	case SOAP_TYPE_afip3__ArrayOfComprador:
		return ((afip3__ArrayOfComprador *)ptr)->soap_out(soap, tag, id, "afip3:ArrayOfComprador");
	case SOAP_TYPE_afip3__Opcional:
		return ((afip3__Opcional *)ptr)->soap_out(soap, tag, id, "afip3:Opcional");
	case SOAP_TYPE_afip3__ArrayOfOpcional:
		return ((afip3__ArrayOfOpcional *)ptr)->soap_out(soap, tag, id, "afip3:ArrayOfOpcional");
	case SOAP_TYPE_afip3__AlicIva:
		return ((afip3__AlicIva *)ptr)->soap_out(soap, tag, id, "afip3:AlicIva");
	case SOAP_TYPE_afip3__ArrayOfAlicIva:
		return ((afip3__ArrayOfAlicIva *)ptr)->soap_out(soap, tag, id, "afip3:ArrayOfAlicIva");
	case SOAP_TYPE_afip3__Tributo:
		return ((afip3__Tributo *)ptr)->soap_out(soap, tag, id, "afip3:Tributo");
	case SOAP_TYPE_afip3__ArrayOfTributo:
		return ((afip3__ArrayOfTributo *)ptr)->soap_out(soap, tag, id, "afip3:ArrayOfTributo");
	case SOAP_TYPE_afip3__CbteAsoc:
		return ((afip3__CbteAsoc *)ptr)->soap_out(soap, tag, id, "afip3:CbteAsoc");
	case SOAP_TYPE_afip3__ArrayOfCbteAsoc:
		return ((afip3__ArrayOfCbteAsoc *)ptr)->soap_out(soap, tag, id, "afip3:ArrayOfCbteAsoc");
	case SOAP_TYPE_afip3__FEDetRequest:
		return ((afip3__FEDetRequest *)ptr)->soap_out(soap, tag, id, "afip3:FEDetRequest");
	case SOAP_TYPE_afip3__FECAEDetRequest:
		return ((afip3__FECAEDetRequest *)ptr)->soap_out(soap, tag, id, "afip3:FECAEDetRequest");
	case SOAP_TYPE_afip3__ArrayOfFECAEDetRequest:
		return ((afip3__ArrayOfFECAEDetRequest *)ptr)->soap_out(soap, tag, id, "afip3:ArrayOfFECAEDetRequest");
	case SOAP_TYPE_afip3__FECabRequest:
		return ((afip3__FECabRequest *)ptr)->soap_out(soap, tag, id, "afip3:FECabRequest");
	case SOAP_TYPE_afip3__FECAECabRequest:
		return ((afip3__FECAECabRequest *)ptr)->soap_out(soap, tag, id, "afip3:FECAECabRequest");
	case SOAP_TYPE_afip3__FECAERequest:
		return ((afip3__FECAERequest *)ptr)->soap_out(soap, tag, id, "afip3:FECAERequest");
	case SOAP_TYPE_afip3__FEAuthRequest:
		return ((afip3__FEAuthRequest *)ptr)->soap_out(soap, tag, id, "afip3:FEAuthRequest");
	case SOAP_TYPE_afip2__LoginFault:
		return ((afip2__LoginFault *)ptr)->soap_out(soap, tag, id, "afip2:LoginFault");
	case SOAP_TYPE__afip1__loginCmsResponse:
		return ((_afip1__loginCmsResponse *)ptr)->soap_out(soap, "afip1:loginCmsResponse", id, "");
	case SOAP_TYPE__afip1__loginCms:
		return ((_afip1__loginCms *)ptr)->soap_out(soap, "afip1:loginCms", id, "");
	case SOAP_TYPE_PointerTo_afip3__FEParamGetTiposPaises:
		return soap_out_PointerTo_afip3__FEParamGetTiposPaises(soap, tag, id, (_afip3__FEParamGetTiposPaises *const*)ptr, "afip3:FEParamGetTiposPaises");
	case SOAP_TYPE_PointerTo_afip3__FEParamGetTiposDoc:
		return soap_out_PointerTo_afip3__FEParamGetTiposDoc(soap, tag, id, (_afip3__FEParamGetTiposDoc *const*)ptr, "afip3:FEParamGetTiposDoc");
	case SOAP_TYPE_PointerTo_afip3__FEParamGetTiposCbte:
		return soap_out_PointerTo_afip3__FEParamGetTiposCbte(soap, tag, id, (_afip3__FEParamGetTiposCbte *const*)ptr, "afip3:FEParamGetTiposCbte");
	case SOAP_TYPE_PointerTo_afip3__FEParamGetPtosVenta:
		return soap_out_PointerTo_afip3__FEParamGetPtosVenta(soap, tag, id, (_afip3__FEParamGetPtosVenta *const*)ptr, "afip3:FEParamGetPtosVenta");
	case SOAP_TYPE_PointerTo_afip3__FEParamGetTiposConcepto:
		return soap_out_PointerTo_afip3__FEParamGetTiposConcepto(soap, tag, id, (_afip3__FEParamGetTiposConcepto *const*)ptr, "afip3:FEParamGetTiposConcepto");
	case SOAP_TYPE_PointerTo_afip3__FEParamGetTiposOpcional:
		return soap_out_PointerTo_afip3__FEParamGetTiposOpcional(soap, tag, id, (_afip3__FEParamGetTiposOpcional *const*)ptr, "afip3:FEParamGetTiposOpcional");
	case SOAP_TYPE_PointerTo_afip3__FEParamGetTiposIva:
		return soap_out_PointerTo_afip3__FEParamGetTiposIva(soap, tag, id, (_afip3__FEParamGetTiposIva *const*)ptr, "afip3:FEParamGetTiposIva");
	case SOAP_TYPE_PointerTo_afip3__FEParamGetTiposMonedas:
		return soap_out_PointerTo_afip3__FEParamGetTiposMonedas(soap, tag, id, (_afip3__FEParamGetTiposMonedas *const*)ptr, "afip3:FEParamGetTiposMonedas");
	case SOAP_TYPE_PointerTo_afip3__FEParamGetTiposTributos:
		return soap_out_PointerTo_afip3__FEParamGetTiposTributos(soap, tag, id, (_afip3__FEParamGetTiposTributos *const*)ptr, "afip3:FEParamGetTiposTributos");
	case SOAP_TYPE_PointerTo_afip3__FEParamGetCotizacion:
		return soap_out_PointerTo_afip3__FEParamGetCotizacion(soap, tag, id, (_afip3__FEParamGetCotizacion *const*)ptr, "afip3:FEParamGetCotizacion");
	case SOAP_TYPE_PointerTo_afip3__FECAEAConsultar:
		return soap_out_PointerTo_afip3__FECAEAConsultar(soap, tag, id, (_afip3__FECAEAConsultar *const*)ptr, "afip3:FECAEAConsultar");
	case SOAP_TYPE_PointerTo_afip3__FECAEASinMovimientoInformar:
		return soap_out_PointerTo_afip3__FECAEASinMovimientoInformar(soap, tag, id, (_afip3__FECAEASinMovimientoInformar *const*)ptr, "afip3:FECAEASinMovimientoInformar");
	case SOAP_TYPE_PointerTo_afip3__FECAEASinMovimientoConsultar:
		return soap_out_PointerTo_afip3__FECAEASinMovimientoConsultar(soap, tag, id, (_afip3__FECAEASinMovimientoConsultar *const*)ptr, "afip3:FECAEASinMovimientoConsultar");
	case SOAP_TYPE_PointerTo_afip3__FECAEASolicitar:
		return soap_out_PointerTo_afip3__FECAEASolicitar(soap, tag, id, (_afip3__FECAEASolicitar *const*)ptr, "afip3:FECAEASolicitar");
	case SOAP_TYPE_PointerTo_afip3__FECAEARegInformativo:
		return soap_out_PointerTo_afip3__FECAEARegInformativo(soap, tag, id, (_afip3__FECAEARegInformativo *const*)ptr, "afip3:FECAEARegInformativo");
	case SOAP_TYPE_PointerTo_afip3__FECompConsultar:
		return soap_out_PointerTo_afip3__FECompConsultar(soap, tag, id, (_afip3__FECompConsultar *const*)ptr, "afip3:FECompConsultar");
	case SOAP_TYPE_PointerTo_afip3__FECompUltimoAutorizado:
		return soap_out_PointerTo_afip3__FECompUltimoAutorizado(soap, tag, id, (_afip3__FECompUltimoAutorizado *const*)ptr, "afip3:FECompUltimoAutorizado");
	case SOAP_TYPE_PointerTo_afip3__FEDummy:
		return soap_out_PointerTo_afip3__FEDummy(soap, tag, id, (_afip3__FEDummy *const*)ptr, "afip3:FEDummy");
	case SOAP_TYPE_PointerTo_afip3__FECompTotXRequest:
		return soap_out_PointerTo_afip3__FECompTotXRequest(soap, tag, id, (_afip3__FECompTotXRequest *const*)ptr, "afip3:FECompTotXRequest");
	case SOAP_TYPE_PointerTo_afip3__FECAESolicitar:
		return soap_out_PointerTo_afip3__FECAESolicitar(soap, tag, id, (_afip3__FECAESolicitar *const*)ptr, "afip3:FECAESolicitar");
	case SOAP_TYPE_PointerTo_afip1__loginCms:
		return soap_out_PointerTo_afip1__loginCms(soap, tag, id, (_afip1__loginCms *const*)ptr, "afip1:loginCms");
	case SOAP_TYPE_PointerToafip2__LoginFault:
		return soap_out_PointerToafip2__LoginFault(soap, tag, id, (afip2__LoginFault *const*)ptr, "afip2:LoginFault");
	case SOAP_TYPE_PointerToafip3__FEPaisResponse:
		return soap_out_PointerToafip3__FEPaisResponse(soap, tag, id, (afip3__FEPaisResponse *const*)ptr, "afip3:FEPaisResponse");
	case SOAP_TYPE_PointerToafip3__DocTipoResponse:
		return soap_out_PointerToafip3__DocTipoResponse(soap, tag, id, (afip3__DocTipoResponse *const*)ptr, "afip3:DocTipoResponse");
	case SOAP_TYPE_PointerToafip3__CbteTipoResponse:
		return soap_out_PointerToafip3__CbteTipoResponse(soap, tag, id, (afip3__CbteTipoResponse *const*)ptr, "afip3:CbteTipoResponse");
	case SOAP_TYPE_PointerToafip3__FEPtoVentaResponse:
		return soap_out_PointerToafip3__FEPtoVentaResponse(soap, tag, id, (afip3__FEPtoVentaResponse *const*)ptr, "afip3:FEPtoVentaResponse");
	case SOAP_TYPE_PointerToafip3__ConceptoTipoResponse:
		return soap_out_PointerToafip3__ConceptoTipoResponse(soap, tag, id, (afip3__ConceptoTipoResponse *const*)ptr, "afip3:ConceptoTipoResponse");
	case SOAP_TYPE_PointerToafip3__OpcionalTipoResponse:
		return soap_out_PointerToafip3__OpcionalTipoResponse(soap, tag, id, (afip3__OpcionalTipoResponse *const*)ptr, "afip3:OpcionalTipoResponse");
	case SOAP_TYPE_PointerToafip3__IvaTipoResponse:
		return soap_out_PointerToafip3__IvaTipoResponse(soap, tag, id, (afip3__IvaTipoResponse *const*)ptr, "afip3:IvaTipoResponse");
	case SOAP_TYPE_PointerToafip3__MonedaResponse:
		return soap_out_PointerToafip3__MonedaResponse(soap, tag, id, (afip3__MonedaResponse *const*)ptr, "afip3:MonedaResponse");
	case SOAP_TYPE_PointerToafip3__FETributoResponse:
		return soap_out_PointerToafip3__FETributoResponse(soap, tag, id, (afip3__FETributoResponse *const*)ptr, "afip3:FETributoResponse");
	case SOAP_TYPE_PointerToafip3__FECotizacionResponse:
		return soap_out_PointerToafip3__FECotizacionResponse(soap, tag, id, (afip3__FECotizacionResponse *const*)ptr, "afip3:FECotizacionResponse");
	case SOAP_TYPE_PointerToafip3__FECAEASinMovResponse:
		return soap_out_PointerToafip3__FECAEASinMovResponse(soap, tag, id, (afip3__FECAEASinMovResponse *const*)ptr, "afip3:FECAEASinMovResponse");
	case SOAP_TYPE_PointerToafip3__FECAEASinMovConsResponse:
		return soap_out_PointerToafip3__FECAEASinMovConsResponse(soap, tag, id, (afip3__FECAEASinMovConsResponse *const*)ptr, "afip3:FECAEASinMovConsResponse");
	case SOAP_TYPE_PointerToafip3__FECAEAGetResponse:
		return soap_out_PointerToafip3__FECAEAGetResponse(soap, tag, id, (afip3__FECAEAGetResponse *const*)ptr, "afip3:FECAEAGetResponse");
	case SOAP_TYPE_PointerToafip3__FECAEAResponse:
		return soap_out_PointerToafip3__FECAEAResponse(soap, tag, id, (afip3__FECAEAResponse *const*)ptr, "afip3:FECAEAResponse");
	case SOAP_TYPE_PointerToafip3__FECAEARequest:
		return soap_out_PointerToafip3__FECAEARequest(soap, tag, id, (afip3__FECAEARequest *const*)ptr, "afip3:FECAEARequest");
	case SOAP_TYPE_PointerToafip3__FECompConsultaResponse:
		return soap_out_PointerToafip3__FECompConsultaResponse(soap, tag, id, (afip3__FECompConsultaResponse *const*)ptr, "afip3:FECompConsultaResponse");
	case SOAP_TYPE_PointerToafip3__FECompConsultaReq:
		return soap_out_PointerToafip3__FECompConsultaReq(soap, tag, id, (afip3__FECompConsultaReq *const*)ptr, "afip3:FECompConsultaReq");
	case SOAP_TYPE_PointerToafip3__FERecuperaLastCbteResponse:
		return soap_out_PointerToafip3__FERecuperaLastCbteResponse(soap, tag, id, (afip3__FERecuperaLastCbteResponse *const*)ptr, "afip3:FERecuperaLastCbteResponse");
	case SOAP_TYPE_PointerToafip3__DummyResponse:
		return soap_out_PointerToafip3__DummyResponse(soap, tag, id, (afip3__DummyResponse *const*)ptr, "afip3:DummyResponse");
	case SOAP_TYPE_PointerToafip3__FERegXReqResponse:
		return soap_out_PointerToafip3__FERegXReqResponse(soap, tag, id, (afip3__FERegXReqResponse *const*)ptr, "afip3:FERegXReqResponse");
	case SOAP_TYPE_PointerToafip3__FECAEResponse:
		return soap_out_PointerToafip3__FECAEResponse(soap, tag, id, (afip3__FECAEResponse *const*)ptr, "afip3:FECAEResponse");
	case SOAP_TYPE_PointerToafip3__FECAERequest:
		return soap_out_PointerToafip3__FECAERequest(soap, tag, id, (afip3__FECAERequest *const*)ptr, "afip3:FECAERequest");
	case SOAP_TYPE_PointerToafip3__FEAuthRequest:
		return soap_out_PointerToafip3__FEAuthRequest(soap, tag, id, (afip3__FEAuthRequest *const*)ptr, "afip3:FEAuthRequest");
	case SOAP_TYPE_PointerToafip3__PaisTipo:
		return soap_out_PointerToafip3__PaisTipo(soap, tag, id, (afip3__PaisTipo *const*)ptr, "afip3:PaisTipo");
	case SOAP_TYPE_PointerToafip3__ArrayOfPaisTipo:
		return soap_out_PointerToafip3__ArrayOfPaisTipo(soap, tag, id, (afip3__ArrayOfPaisTipo *const*)ptr, "afip3:ArrayOfPaisTipo");
	case SOAP_TYPE_PointerToafip3__DocTipo:
		return soap_out_PointerToafip3__DocTipo(soap, tag, id, (afip3__DocTipo *const*)ptr, "afip3:DocTipo");
	case SOAP_TYPE_PointerToafip3__ArrayOfDocTipo:
		return soap_out_PointerToafip3__ArrayOfDocTipo(soap, tag, id, (afip3__ArrayOfDocTipo *const*)ptr, "afip3:ArrayOfDocTipo");
	case SOAP_TYPE_PointerToafip3__CbteTipo:
		return soap_out_PointerToafip3__CbteTipo(soap, tag, id, (afip3__CbteTipo *const*)ptr, "afip3:CbteTipo");
	case SOAP_TYPE_PointerToafip3__ArrayOfCbteTipo:
		return soap_out_PointerToafip3__ArrayOfCbteTipo(soap, tag, id, (afip3__ArrayOfCbteTipo *const*)ptr, "afip3:ArrayOfCbteTipo");
	case SOAP_TYPE_PointerToafip3__PtoVenta:
		return soap_out_PointerToafip3__PtoVenta(soap, tag, id, (afip3__PtoVenta *const*)ptr, "afip3:PtoVenta");
	case SOAP_TYPE_PointerToafip3__ArrayOfPtoVenta:
		return soap_out_PointerToafip3__ArrayOfPtoVenta(soap, tag, id, (afip3__ArrayOfPtoVenta *const*)ptr, "afip3:ArrayOfPtoVenta");
	case SOAP_TYPE_PointerToafip3__ConceptoTipo:
		return soap_out_PointerToafip3__ConceptoTipo(soap, tag, id, (afip3__ConceptoTipo *const*)ptr, "afip3:ConceptoTipo");
	case SOAP_TYPE_PointerToafip3__ArrayOfConceptoTipo:
		return soap_out_PointerToafip3__ArrayOfConceptoTipo(soap, tag, id, (afip3__ArrayOfConceptoTipo *const*)ptr, "afip3:ArrayOfConceptoTipo");
	case SOAP_TYPE_PointerToafip3__OpcionalTipo:
		return soap_out_PointerToafip3__OpcionalTipo(soap, tag, id, (afip3__OpcionalTipo *const*)ptr, "afip3:OpcionalTipo");
	case SOAP_TYPE_PointerToafip3__ArrayOfOpcionalTipo:
		return soap_out_PointerToafip3__ArrayOfOpcionalTipo(soap, tag, id, (afip3__ArrayOfOpcionalTipo *const*)ptr, "afip3:ArrayOfOpcionalTipo");
	case SOAP_TYPE_PointerToafip3__IvaTipo:
		return soap_out_PointerToafip3__IvaTipo(soap, tag, id, (afip3__IvaTipo *const*)ptr, "afip3:IvaTipo");
	case SOAP_TYPE_PointerToafip3__ArrayOfIvaTipo:
		return soap_out_PointerToafip3__ArrayOfIvaTipo(soap, tag, id, (afip3__ArrayOfIvaTipo *const*)ptr, "afip3:ArrayOfIvaTipo");
	case SOAP_TYPE_PointerToafip3__Moneda:
		return soap_out_PointerToafip3__Moneda(soap, tag, id, (afip3__Moneda *const*)ptr, "afip3:Moneda");
	case SOAP_TYPE_PointerToafip3__ArrayOfMoneda:
		return soap_out_PointerToafip3__ArrayOfMoneda(soap, tag, id, (afip3__ArrayOfMoneda *const*)ptr, "afip3:ArrayOfMoneda");
	case SOAP_TYPE_PointerToafip3__TributoTipo:
		return soap_out_PointerToafip3__TributoTipo(soap, tag, id, (afip3__TributoTipo *const*)ptr, "afip3:TributoTipo");
	case SOAP_TYPE_PointerToafip3__ArrayOfTributoTipo:
		return soap_out_PointerToafip3__ArrayOfTributoTipo(soap, tag, id, (afip3__ArrayOfTributoTipo *const*)ptr, "afip3:ArrayOfTributoTipo");
	case SOAP_TYPE_PointerToafip3__Cotizacion:
		return soap_out_PointerToafip3__Cotizacion(soap, tag, id, (afip3__Cotizacion *const*)ptr, "afip3:Cotizacion");
	case SOAP_TYPE_PointerToafip3__FECAEASinMov:
		return soap_out_PointerToafip3__FECAEASinMov(soap, tag, id, (afip3__FECAEASinMov *const*)ptr, "afip3:FECAEASinMov");
	case SOAP_TYPE_PointerToafip3__ArrayOfFECAEASinMov:
		return soap_out_PointerToafip3__ArrayOfFECAEASinMov(soap, tag, id, (afip3__ArrayOfFECAEASinMov *const*)ptr, "afip3:ArrayOfFECAEASinMov");
	case SOAP_TYPE_PointerToafip3__FECAEAGet:
		return soap_out_PointerToafip3__FECAEAGet(soap, tag, id, (afip3__FECAEAGet *const*)ptr, "afip3:FECAEAGet");
	case SOAP_TYPE_PointerToafip3__FECAEADetResponse:
		return soap_out_PointerToafip3__FECAEADetResponse(soap, tag, id, (afip3__FECAEADetResponse *const*)ptr, "afip3:FECAEADetResponse");
	case SOAP_TYPE_PointerToafip3__ArrayOfFECAEADetResponse:
		return soap_out_PointerToafip3__ArrayOfFECAEADetResponse(soap, tag, id, (afip3__ArrayOfFECAEADetResponse *const*)ptr, "afip3:ArrayOfFECAEADetResponse");
	case SOAP_TYPE_PointerToafip3__FECAEACabResponse:
		return soap_out_PointerToafip3__FECAEACabResponse(soap, tag, id, (afip3__FECAEACabResponse *const*)ptr, "afip3:FECAEACabResponse");
	case SOAP_TYPE_PointerToafip3__FECAEADetRequest:
		return soap_out_PointerToafip3__FECAEADetRequest(soap, tag, id, (afip3__FECAEADetRequest *const*)ptr, "afip3:FECAEADetRequest");
	case SOAP_TYPE_PointerToafip3__ArrayOfFECAEADetRequest:
		return soap_out_PointerToafip3__ArrayOfFECAEADetRequest(soap, tag, id, (afip3__ArrayOfFECAEADetRequest *const*)ptr, "afip3:ArrayOfFECAEADetRequest");
	case SOAP_TYPE_PointerToafip3__FECAEACabRequest:
		return soap_out_PointerToafip3__FECAEACabRequest(soap, tag, id, (afip3__FECAEACabRequest *const*)ptr, "afip3:FECAEACabRequest");
	case SOAP_TYPE_PointerToafip3__FECompConsResponse:
		return soap_out_PointerToafip3__FECompConsResponse(soap, tag, id, (afip3__FECompConsResponse *const*)ptr, "afip3:FECompConsResponse");
	case SOAP_TYPE_PointerToafip3__Err:
		return soap_out_PointerToafip3__Err(soap, tag, id, (afip3__Err *const*)ptr, "afip3:Err");
	case SOAP_TYPE_PointerToafip3__Evt:
		return soap_out_PointerToafip3__Evt(soap, tag, id, (afip3__Evt *const*)ptr, "afip3:Evt");
	case SOAP_TYPE_PointerToafip3__Obs:
		return soap_out_PointerToafip3__Obs(soap, tag, id, (afip3__Obs *const*)ptr, "afip3:Obs");
	case SOAP_TYPE_PointerToafip3__ArrayOfObs:
		return soap_out_PointerToafip3__ArrayOfObs(soap, tag, id, (afip3__ArrayOfObs *const*)ptr, "afip3:ArrayOfObs");
	case SOAP_TYPE_PointerToafip3__FECAEDetResponse:
		return soap_out_PointerToafip3__FECAEDetResponse(soap, tag, id, (afip3__FECAEDetResponse *const*)ptr, "afip3:FECAEDetResponse");
	case SOAP_TYPE_PointerToafip3__ArrayOfErr:
		return soap_out_PointerToafip3__ArrayOfErr(soap, tag, id, (afip3__ArrayOfErr *const*)ptr, "afip3:ArrayOfErr");
	case SOAP_TYPE_PointerToafip3__ArrayOfEvt:
		return soap_out_PointerToafip3__ArrayOfEvt(soap, tag, id, (afip3__ArrayOfEvt *const*)ptr, "afip3:ArrayOfEvt");
	case SOAP_TYPE_PointerToafip3__ArrayOfFECAEDetResponse:
		return soap_out_PointerToafip3__ArrayOfFECAEDetResponse(soap, tag, id, (afip3__ArrayOfFECAEDetResponse *const*)ptr, "afip3:ArrayOfFECAEDetResponse");
	case SOAP_TYPE_PointerToafip3__FECAECabResponse:
		return soap_out_PointerToafip3__FECAECabResponse(soap, tag, id, (afip3__FECAECabResponse *const*)ptr, "afip3:FECAECabResponse");
	case SOAP_TYPE_PointerToafip3__Comprador:
		return soap_out_PointerToafip3__Comprador(soap, tag, id, (afip3__Comprador *const*)ptr, "afip3:Comprador");
	case SOAP_TYPE_PointerToafip3__Opcional:
		return soap_out_PointerToafip3__Opcional(soap, tag, id, (afip3__Opcional *const*)ptr, "afip3:Opcional");
	case SOAP_TYPE_PointerToafip3__AlicIva:
		return soap_out_PointerToafip3__AlicIva(soap, tag, id, (afip3__AlicIva *const*)ptr, "afip3:AlicIva");
	case SOAP_TYPE_PointerToafip3__Tributo:
		return soap_out_PointerToafip3__Tributo(soap, tag, id, (afip3__Tributo *const*)ptr, "afip3:Tributo");
	case SOAP_TYPE_PointerToafip3__CbteAsoc:
		return soap_out_PointerToafip3__CbteAsoc(soap, tag, id, (afip3__CbteAsoc *const*)ptr, "afip3:CbteAsoc");
	case SOAP_TYPE_PointerToafip3__ArrayOfComprador:
		return soap_out_PointerToafip3__ArrayOfComprador(soap, tag, id, (afip3__ArrayOfComprador *const*)ptr, "afip3:ArrayOfComprador");
	case SOAP_TYPE_PointerToafip3__ArrayOfOpcional:
		return soap_out_PointerToafip3__ArrayOfOpcional(soap, tag, id, (afip3__ArrayOfOpcional *const*)ptr, "afip3:ArrayOfOpcional");
	case SOAP_TYPE_PointerToafip3__ArrayOfAlicIva:
		return soap_out_PointerToafip3__ArrayOfAlicIva(soap, tag, id, (afip3__ArrayOfAlicIva *const*)ptr, "afip3:ArrayOfAlicIva");
	case SOAP_TYPE_PointerToafip3__ArrayOfTributo:
		return soap_out_PointerToafip3__ArrayOfTributo(soap, tag, id, (afip3__ArrayOfTributo *const*)ptr, "afip3:ArrayOfTributo");
	case SOAP_TYPE_PointerToafip3__ArrayOfCbteAsoc:
		return soap_out_PointerToafip3__ArrayOfCbteAsoc(soap, tag, id, (afip3__ArrayOfCbteAsoc *const*)ptr, "afip3:ArrayOfCbteAsoc");
	case SOAP_TYPE_PointerToafip3__FECAEDetRequest:
		return soap_out_PointerToafip3__FECAEDetRequest(soap, tag, id, (afip3__FECAEDetRequest *const*)ptr, "afip3:FECAEDetRequest");
	case SOAP_TYPE_PointerToafip3__ArrayOfFECAEDetRequest:
		return soap_out_PointerToafip3__ArrayOfFECAEDetRequest(soap, tag, id, (afip3__ArrayOfFECAEDetRequest *const*)ptr, "afip3:ArrayOfFECAEDetRequest");
	case SOAP_TYPE_PointerToafip3__FECAECabRequest:
		return soap_out_PointerToafip3__FECAECabRequest(soap, tag, id, (afip3__FECAECabRequest *const*)ptr, "afip3:FECAECabRequest");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case 0:
		return SOAP_OK;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in AFIPServer/soap/soapC.cpp\n", tag ? tag : "", type));
	return soap_element_empty(soap, tag); /* unknown type to serialize */
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposPaisesResponse:
		((_afip3__FEParamGetTiposPaisesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposPaises:
		((_afip3__FEParamGetTiposPaises *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposDocResponse:
		((_afip3__FEParamGetTiposDocResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposDoc:
		((_afip3__FEParamGetTiposDoc *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposCbteResponse:
		((_afip3__FEParamGetTiposCbteResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposCbte:
		((_afip3__FEParamGetTiposCbte *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FEParamGetPtosVentaResponse:
		((_afip3__FEParamGetPtosVentaResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FEParamGetPtosVenta:
		((_afip3__FEParamGetPtosVenta *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposConceptoResponse:
		((_afip3__FEParamGetTiposConceptoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposConcepto:
		((_afip3__FEParamGetTiposConcepto *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposOpcionalResponse:
		((_afip3__FEParamGetTiposOpcionalResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposOpcional:
		((_afip3__FEParamGetTiposOpcional *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposIvaResponse:
		((_afip3__FEParamGetTiposIvaResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposIva:
		((_afip3__FEParamGetTiposIva *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposMonedasResponse:
		((_afip3__FEParamGetTiposMonedasResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposMonedas:
		((_afip3__FEParamGetTiposMonedas *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposTributosResponse:
		((_afip3__FEParamGetTiposTributosResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposTributos:
		((_afip3__FEParamGetTiposTributos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FEParamGetCotizacionResponse:
		((_afip3__FEParamGetCotizacionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FEParamGetCotizacion:
		((_afip3__FEParamGetCotizacion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FECAEAConsultarResponse:
		((_afip3__FECAEAConsultarResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FECAEAConsultar:
		((_afip3__FECAEAConsultar *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FECAEASinMovimientoInformarResponse:
		((_afip3__FECAEASinMovimientoInformarResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FECAEASinMovimientoInformar:
		((_afip3__FECAEASinMovimientoInformar *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FECAEASinMovimientoConsultarResponse:
		((_afip3__FECAEASinMovimientoConsultarResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FECAEASinMovimientoConsultar:
		((_afip3__FECAEASinMovimientoConsultar *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FECAEASolicitarResponse:
		((_afip3__FECAEASolicitarResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FECAEASolicitar:
		((_afip3__FECAEASolicitar *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FECAEARegInformativoResponse:
		((_afip3__FECAEARegInformativoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FECAEARegInformativo:
		((_afip3__FECAEARegInformativo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FECompConsultarResponse:
		((_afip3__FECompConsultarResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FECompConsultar:
		((_afip3__FECompConsultar *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FECompUltimoAutorizadoResponse:
		((_afip3__FECompUltimoAutorizadoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FECompUltimoAutorizado:
		((_afip3__FECompUltimoAutorizado *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FEDummyResponse:
		((_afip3__FEDummyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FEDummy:
		((_afip3__FEDummy *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FECompTotXRequestResponse:
		((_afip3__FECompTotXRequestResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FECompTotXRequest:
		((_afip3__FECompTotXRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FECAESolicitarResponse:
		((_afip3__FECAESolicitarResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip3__FECAESolicitar:
		((_afip3__FECAESolicitar *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__PaisTipo:
		((afip3__PaisTipo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__ArrayOfPaisTipo:
		((afip3__ArrayOfPaisTipo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__FEPaisResponse:
		((afip3__FEPaisResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__DocTipo:
		((afip3__DocTipo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__ArrayOfDocTipo:
		((afip3__ArrayOfDocTipo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__DocTipoResponse:
		((afip3__DocTipoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__CbteTipo:
		((afip3__CbteTipo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__ArrayOfCbteTipo:
		((afip3__ArrayOfCbteTipo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__CbteTipoResponse:
		((afip3__CbteTipoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__PtoVenta:
		((afip3__PtoVenta *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__ArrayOfPtoVenta:
		((afip3__ArrayOfPtoVenta *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__FEPtoVentaResponse:
		((afip3__FEPtoVentaResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__ConceptoTipo:
		((afip3__ConceptoTipo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__ArrayOfConceptoTipo:
		((afip3__ArrayOfConceptoTipo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__ConceptoTipoResponse:
		((afip3__ConceptoTipoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__OpcionalTipo:
		((afip3__OpcionalTipo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__ArrayOfOpcionalTipo:
		((afip3__ArrayOfOpcionalTipo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__OpcionalTipoResponse:
		((afip3__OpcionalTipoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__IvaTipo:
		((afip3__IvaTipo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__ArrayOfIvaTipo:
		((afip3__ArrayOfIvaTipo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__IvaTipoResponse:
		((afip3__IvaTipoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__Moneda:
		((afip3__Moneda *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__ArrayOfMoneda:
		((afip3__ArrayOfMoneda *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__MonedaResponse:
		((afip3__MonedaResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__TributoTipo:
		((afip3__TributoTipo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__ArrayOfTributoTipo:
		((afip3__ArrayOfTributoTipo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__FETributoResponse:
		((afip3__FETributoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__Cotizacion:
		((afip3__Cotizacion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__FECotizacionResponse:
		((afip3__FECotizacionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__FECAEASinMovResponse:
		((afip3__FECAEASinMovResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__FECAEASinMov:
		((afip3__FECAEASinMov *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__ArrayOfFECAEASinMov:
		((afip3__ArrayOfFECAEASinMov *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__FECAEASinMovConsResponse:
		((afip3__FECAEASinMovConsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__FECAEAGet:
		((afip3__FECAEAGet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__FECAEAGetResponse:
		((afip3__FECAEAGetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__FECAEADetResponse:
		((afip3__FECAEADetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__ArrayOfFECAEADetResponse:
		((afip3__ArrayOfFECAEADetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__FECAEACabResponse:
		((afip3__FECAEACabResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__FECAEAResponse:
		((afip3__FECAEAResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__FECAEADetRequest:
		((afip3__FECAEADetRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__ArrayOfFECAEADetRequest:
		((afip3__ArrayOfFECAEADetRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__FECAEACabRequest:
		((afip3__FECAEACabRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__FECAEARequest:
		((afip3__FECAEARequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__FECompConsResponse:
		((afip3__FECompConsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__FECompConsultaResponse:
		((afip3__FECompConsultaResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__FECompConsultaReq:
		((afip3__FECompConsultaReq *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__FERecuperaLastCbteResponse:
		((afip3__FERecuperaLastCbteResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__DummyResponse:
		((afip3__DummyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__FERegXReqResponse:
		((afip3__FERegXReqResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__Err:
		((afip3__Err *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__ArrayOfErr:
		((afip3__ArrayOfErr *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__Evt:
		((afip3__Evt *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__ArrayOfEvt:
		((afip3__ArrayOfEvt *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__Obs:
		((afip3__Obs *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__ArrayOfObs:
		((afip3__ArrayOfObs *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__FEDetResponse:
		((afip3__FEDetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__FECAEDetResponse:
		((afip3__FECAEDetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__ArrayOfFECAEDetResponse:
		((afip3__ArrayOfFECAEDetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__FECabResponse:
		((afip3__FECabResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__FECAECabResponse:
		((afip3__FECAECabResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__FECAEResponse:
		((afip3__FECAEResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__Comprador:
		((afip3__Comprador *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__ArrayOfComprador:
		((afip3__ArrayOfComprador *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__Opcional:
		((afip3__Opcional *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__ArrayOfOpcional:
		((afip3__ArrayOfOpcional *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__AlicIva:
		((afip3__AlicIva *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__ArrayOfAlicIva:
		((afip3__ArrayOfAlicIva *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__Tributo:
		((afip3__Tributo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__ArrayOfTributo:
		((afip3__ArrayOfTributo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__CbteAsoc:
		((afip3__CbteAsoc *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__ArrayOfCbteAsoc:
		((afip3__ArrayOfCbteAsoc *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__FEDetRequest:
		((afip3__FEDetRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__FECAEDetRequest:
		((afip3__FECAEDetRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__ArrayOfFECAEDetRequest:
		((afip3__ArrayOfFECAEDetRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__FECabRequest:
		((afip3__FECabRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__FECAECabRequest:
		((afip3__FECAECabRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__FECAERequest:
		((afip3__FECAERequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip3__FEAuthRequest:
		((afip3__FEAuthRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_afip2__LoginFault:
		((afip2__LoginFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip1__loginCmsResponse:
		((_afip1__loginCmsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__afip1__loginCms:
		((_afip1__loginCms *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___afip5__FEParamGetTiposPaises:
		soap_serialize___afip5__FEParamGetTiposPaises(soap, (const struct __afip5__FEParamGetTiposPaises *)ptr);
		break;
	case SOAP_TYPE___afip5__FEParamGetTiposDoc:
		soap_serialize___afip5__FEParamGetTiposDoc(soap, (const struct __afip5__FEParamGetTiposDoc *)ptr);
		break;
	case SOAP_TYPE___afip5__FEParamGetTiposCbte:
		soap_serialize___afip5__FEParamGetTiposCbte(soap, (const struct __afip5__FEParamGetTiposCbte *)ptr);
		break;
	case SOAP_TYPE___afip5__FEParamGetPtosVenta:
		soap_serialize___afip5__FEParamGetPtosVenta(soap, (const struct __afip5__FEParamGetPtosVenta *)ptr);
		break;
	case SOAP_TYPE___afip5__FEParamGetTiposConcepto:
		soap_serialize___afip5__FEParamGetTiposConcepto(soap, (const struct __afip5__FEParamGetTiposConcepto *)ptr);
		break;
	case SOAP_TYPE___afip5__FEParamGetTiposOpcional:
		soap_serialize___afip5__FEParamGetTiposOpcional(soap, (const struct __afip5__FEParamGetTiposOpcional *)ptr);
		break;
	case SOAP_TYPE___afip5__FEParamGetTiposIva:
		soap_serialize___afip5__FEParamGetTiposIva(soap, (const struct __afip5__FEParamGetTiposIva *)ptr);
		break;
	case SOAP_TYPE___afip5__FEParamGetTiposMonedas:
		soap_serialize___afip5__FEParamGetTiposMonedas(soap, (const struct __afip5__FEParamGetTiposMonedas *)ptr);
		break;
	case SOAP_TYPE___afip5__FEParamGetTiposTributos:
		soap_serialize___afip5__FEParamGetTiposTributos(soap, (const struct __afip5__FEParamGetTiposTributos *)ptr);
		break;
	case SOAP_TYPE___afip5__FEParamGetCotizacion:
		soap_serialize___afip5__FEParamGetCotizacion(soap, (const struct __afip5__FEParamGetCotizacion *)ptr);
		break;
	case SOAP_TYPE___afip5__FECAEAConsultar:
		soap_serialize___afip5__FECAEAConsultar(soap, (const struct __afip5__FECAEAConsultar *)ptr);
		break;
	case SOAP_TYPE___afip5__FECAEASinMovimientoInformar:
		soap_serialize___afip5__FECAEASinMovimientoInformar(soap, (const struct __afip5__FECAEASinMovimientoInformar *)ptr);
		break;
	case SOAP_TYPE___afip5__FECAEASinMovimientoConsultar:
		soap_serialize___afip5__FECAEASinMovimientoConsultar(soap, (const struct __afip5__FECAEASinMovimientoConsultar *)ptr);
		break;
	case SOAP_TYPE___afip5__FECAEASolicitar:
		soap_serialize___afip5__FECAEASolicitar(soap, (const struct __afip5__FECAEASolicitar *)ptr);
		break;
	case SOAP_TYPE___afip5__FECAEARegInformativo:
		soap_serialize___afip5__FECAEARegInformativo(soap, (const struct __afip5__FECAEARegInformativo *)ptr);
		break;
	case SOAP_TYPE___afip5__FECompConsultar:
		soap_serialize___afip5__FECompConsultar(soap, (const struct __afip5__FECompConsultar *)ptr);
		break;
	case SOAP_TYPE___afip5__FECompUltimoAutorizado:
		soap_serialize___afip5__FECompUltimoAutorizado(soap, (const struct __afip5__FECompUltimoAutorizado *)ptr);
		break;
	case SOAP_TYPE___afip5__FEDummy:
		soap_serialize___afip5__FEDummy(soap, (const struct __afip5__FEDummy *)ptr);
		break;
	case SOAP_TYPE___afip5__FECompTotXRequest:
		soap_serialize___afip5__FECompTotXRequest(soap, (const struct __afip5__FECompTotXRequest *)ptr);
		break;
	case SOAP_TYPE___afip5__FECAESolicitar:
		soap_serialize___afip5__FECAESolicitar(soap, (const struct __afip5__FECAESolicitar *)ptr);
		break;
	case SOAP_TYPE___afip4__FEParamGetTiposPaises:
		soap_serialize___afip4__FEParamGetTiposPaises(soap, (const struct __afip4__FEParamGetTiposPaises *)ptr);
		break;
	case SOAP_TYPE___afip4__FEParamGetTiposDoc:
		soap_serialize___afip4__FEParamGetTiposDoc(soap, (const struct __afip4__FEParamGetTiposDoc *)ptr);
		break;
	case SOAP_TYPE___afip4__FEParamGetTiposCbte:
		soap_serialize___afip4__FEParamGetTiposCbte(soap, (const struct __afip4__FEParamGetTiposCbte *)ptr);
		break;
	case SOAP_TYPE___afip4__FEParamGetPtosVenta:
		soap_serialize___afip4__FEParamGetPtosVenta(soap, (const struct __afip4__FEParamGetPtosVenta *)ptr);
		break;
	case SOAP_TYPE___afip4__FEParamGetTiposConcepto:
		soap_serialize___afip4__FEParamGetTiposConcepto(soap, (const struct __afip4__FEParamGetTiposConcepto *)ptr);
		break;
	case SOAP_TYPE___afip4__FEParamGetTiposOpcional:
		soap_serialize___afip4__FEParamGetTiposOpcional(soap, (const struct __afip4__FEParamGetTiposOpcional *)ptr);
		break;
	case SOAP_TYPE___afip4__FEParamGetTiposIva:
		soap_serialize___afip4__FEParamGetTiposIva(soap, (const struct __afip4__FEParamGetTiposIva *)ptr);
		break;
	case SOAP_TYPE___afip4__FEParamGetTiposMonedas:
		soap_serialize___afip4__FEParamGetTiposMonedas(soap, (const struct __afip4__FEParamGetTiposMonedas *)ptr);
		break;
	case SOAP_TYPE___afip4__FEParamGetTiposTributos:
		soap_serialize___afip4__FEParamGetTiposTributos(soap, (const struct __afip4__FEParamGetTiposTributos *)ptr);
		break;
	case SOAP_TYPE___afip4__FEParamGetCotizacion:
		soap_serialize___afip4__FEParamGetCotizacion(soap, (const struct __afip4__FEParamGetCotizacion *)ptr);
		break;
	case SOAP_TYPE___afip4__FECAEAConsultar:
		soap_serialize___afip4__FECAEAConsultar(soap, (const struct __afip4__FECAEAConsultar *)ptr);
		break;
	case SOAP_TYPE___afip4__FECAEASinMovimientoInformar:
		soap_serialize___afip4__FECAEASinMovimientoInformar(soap, (const struct __afip4__FECAEASinMovimientoInformar *)ptr);
		break;
	case SOAP_TYPE___afip4__FECAEASinMovimientoConsultar:
		soap_serialize___afip4__FECAEASinMovimientoConsultar(soap, (const struct __afip4__FECAEASinMovimientoConsultar *)ptr);
		break;
	case SOAP_TYPE___afip4__FECAEASolicitar:
		soap_serialize___afip4__FECAEASolicitar(soap, (const struct __afip4__FECAEASolicitar *)ptr);
		break;
	case SOAP_TYPE___afip4__FECAEARegInformativo:
		soap_serialize___afip4__FECAEARegInformativo(soap, (const struct __afip4__FECAEARegInformativo *)ptr);
		break;
	case SOAP_TYPE___afip4__FECompConsultar:
		soap_serialize___afip4__FECompConsultar(soap, (const struct __afip4__FECompConsultar *)ptr);
		break;
	case SOAP_TYPE___afip4__FECompUltimoAutorizado:
		soap_serialize___afip4__FECompUltimoAutorizado(soap, (const struct __afip4__FECompUltimoAutorizado *)ptr);
		break;
	case SOAP_TYPE___afip4__FEDummy:
		soap_serialize___afip4__FEDummy(soap, (const struct __afip4__FEDummy *)ptr);
		break;
	case SOAP_TYPE___afip4__FECompTotXRequest:
		soap_serialize___afip4__FECompTotXRequest(soap, (const struct __afip4__FECompTotXRequest *)ptr);
		break;
	case SOAP_TYPE___afip4__FECAESolicitar:
		soap_serialize___afip4__FECAESolicitar(soap, (const struct __afip4__FECAESolicitar *)ptr);
		break;
	case SOAP_TYPE___afip2__loginCms:
		soap_serialize___afip2__loginCms(soap, (const struct __afip2__loginCms *)ptr);
		break;
	case SOAP_TYPE_PointerTo_afip3__FEParamGetTiposPaises:
		soap_serialize_PointerTo_afip3__FEParamGetTiposPaises(soap, (_afip3__FEParamGetTiposPaises *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_afip3__FEParamGetTiposDoc:
		soap_serialize_PointerTo_afip3__FEParamGetTiposDoc(soap, (_afip3__FEParamGetTiposDoc *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_afip3__FEParamGetTiposCbte:
		soap_serialize_PointerTo_afip3__FEParamGetTiposCbte(soap, (_afip3__FEParamGetTiposCbte *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_afip3__FEParamGetPtosVenta:
		soap_serialize_PointerTo_afip3__FEParamGetPtosVenta(soap, (_afip3__FEParamGetPtosVenta *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_afip3__FEParamGetTiposConcepto:
		soap_serialize_PointerTo_afip3__FEParamGetTiposConcepto(soap, (_afip3__FEParamGetTiposConcepto *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_afip3__FEParamGetTiposOpcional:
		soap_serialize_PointerTo_afip3__FEParamGetTiposOpcional(soap, (_afip3__FEParamGetTiposOpcional *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_afip3__FEParamGetTiposIva:
		soap_serialize_PointerTo_afip3__FEParamGetTiposIva(soap, (_afip3__FEParamGetTiposIva *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_afip3__FEParamGetTiposMonedas:
		soap_serialize_PointerTo_afip3__FEParamGetTiposMonedas(soap, (_afip3__FEParamGetTiposMonedas *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_afip3__FEParamGetTiposTributos:
		soap_serialize_PointerTo_afip3__FEParamGetTiposTributos(soap, (_afip3__FEParamGetTiposTributos *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_afip3__FEParamGetCotizacion:
		soap_serialize_PointerTo_afip3__FEParamGetCotizacion(soap, (_afip3__FEParamGetCotizacion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_afip3__FECAEAConsultar:
		soap_serialize_PointerTo_afip3__FECAEAConsultar(soap, (_afip3__FECAEAConsultar *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_afip3__FECAEASinMovimientoInformar:
		soap_serialize_PointerTo_afip3__FECAEASinMovimientoInformar(soap, (_afip3__FECAEASinMovimientoInformar *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_afip3__FECAEASinMovimientoConsultar:
		soap_serialize_PointerTo_afip3__FECAEASinMovimientoConsultar(soap, (_afip3__FECAEASinMovimientoConsultar *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_afip3__FECAEASolicitar:
		soap_serialize_PointerTo_afip3__FECAEASolicitar(soap, (_afip3__FECAEASolicitar *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_afip3__FECAEARegInformativo:
		soap_serialize_PointerTo_afip3__FECAEARegInformativo(soap, (_afip3__FECAEARegInformativo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_afip3__FECompConsultar:
		soap_serialize_PointerTo_afip3__FECompConsultar(soap, (_afip3__FECompConsultar *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_afip3__FECompUltimoAutorizado:
		soap_serialize_PointerTo_afip3__FECompUltimoAutorizado(soap, (_afip3__FECompUltimoAutorizado *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_afip3__FEDummy:
		soap_serialize_PointerTo_afip3__FEDummy(soap, (_afip3__FEDummy *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_afip3__FECompTotXRequest:
		soap_serialize_PointerTo_afip3__FECompTotXRequest(soap, (_afip3__FECompTotXRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_afip3__FECAESolicitar:
		soap_serialize_PointerTo_afip3__FECAESolicitar(soap, (_afip3__FECAESolicitar *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_afip1__loginCms:
		soap_serialize_PointerTo_afip1__loginCms(soap, (_afip1__loginCms *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip2__LoginFault:
		soap_serialize_PointerToafip2__LoginFault(soap, (afip2__LoginFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__FEPaisResponse:
		soap_serialize_PointerToafip3__FEPaisResponse(soap, (afip3__FEPaisResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__DocTipoResponse:
		soap_serialize_PointerToafip3__DocTipoResponse(soap, (afip3__DocTipoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__CbteTipoResponse:
		soap_serialize_PointerToafip3__CbteTipoResponse(soap, (afip3__CbteTipoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__FEPtoVentaResponse:
		soap_serialize_PointerToafip3__FEPtoVentaResponse(soap, (afip3__FEPtoVentaResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__ConceptoTipoResponse:
		soap_serialize_PointerToafip3__ConceptoTipoResponse(soap, (afip3__ConceptoTipoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__OpcionalTipoResponse:
		soap_serialize_PointerToafip3__OpcionalTipoResponse(soap, (afip3__OpcionalTipoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__IvaTipoResponse:
		soap_serialize_PointerToafip3__IvaTipoResponse(soap, (afip3__IvaTipoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__MonedaResponse:
		soap_serialize_PointerToafip3__MonedaResponse(soap, (afip3__MonedaResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__FETributoResponse:
		soap_serialize_PointerToafip3__FETributoResponse(soap, (afip3__FETributoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__FECotizacionResponse:
		soap_serialize_PointerToafip3__FECotizacionResponse(soap, (afip3__FECotizacionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__FECAEASinMovResponse:
		soap_serialize_PointerToafip3__FECAEASinMovResponse(soap, (afip3__FECAEASinMovResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__FECAEASinMovConsResponse:
		soap_serialize_PointerToafip3__FECAEASinMovConsResponse(soap, (afip3__FECAEASinMovConsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__FECAEAGetResponse:
		soap_serialize_PointerToafip3__FECAEAGetResponse(soap, (afip3__FECAEAGetResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__FECAEAResponse:
		soap_serialize_PointerToafip3__FECAEAResponse(soap, (afip3__FECAEAResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__FECAEARequest:
		soap_serialize_PointerToafip3__FECAEARequest(soap, (afip3__FECAEARequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__FECompConsultaResponse:
		soap_serialize_PointerToafip3__FECompConsultaResponse(soap, (afip3__FECompConsultaResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__FECompConsultaReq:
		soap_serialize_PointerToafip3__FECompConsultaReq(soap, (afip3__FECompConsultaReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__FERecuperaLastCbteResponse:
		soap_serialize_PointerToafip3__FERecuperaLastCbteResponse(soap, (afip3__FERecuperaLastCbteResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__DummyResponse:
		soap_serialize_PointerToafip3__DummyResponse(soap, (afip3__DummyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__FERegXReqResponse:
		soap_serialize_PointerToafip3__FERegXReqResponse(soap, (afip3__FERegXReqResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__FECAEResponse:
		soap_serialize_PointerToafip3__FECAEResponse(soap, (afip3__FECAEResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__FECAERequest:
		soap_serialize_PointerToafip3__FECAERequest(soap, (afip3__FECAERequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__FEAuthRequest:
		soap_serialize_PointerToafip3__FEAuthRequest(soap, (afip3__FEAuthRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__PaisTipo:
		soap_serialize_PointerToafip3__PaisTipo(soap, (afip3__PaisTipo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__ArrayOfPaisTipo:
		soap_serialize_PointerToafip3__ArrayOfPaisTipo(soap, (afip3__ArrayOfPaisTipo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__DocTipo:
		soap_serialize_PointerToafip3__DocTipo(soap, (afip3__DocTipo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__ArrayOfDocTipo:
		soap_serialize_PointerToafip3__ArrayOfDocTipo(soap, (afip3__ArrayOfDocTipo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__CbteTipo:
		soap_serialize_PointerToafip3__CbteTipo(soap, (afip3__CbteTipo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__ArrayOfCbteTipo:
		soap_serialize_PointerToafip3__ArrayOfCbteTipo(soap, (afip3__ArrayOfCbteTipo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__PtoVenta:
		soap_serialize_PointerToafip3__PtoVenta(soap, (afip3__PtoVenta *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__ArrayOfPtoVenta:
		soap_serialize_PointerToafip3__ArrayOfPtoVenta(soap, (afip3__ArrayOfPtoVenta *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__ConceptoTipo:
		soap_serialize_PointerToafip3__ConceptoTipo(soap, (afip3__ConceptoTipo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__ArrayOfConceptoTipo:
		soap_serialize_PointerToafip3__ArrayOfConceptoTipo(soap, (afip3__ArrayOfConceptoTipo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__OpcionalTipo:
		soap_serialize_PointerToafip3__OpcionalTipo(soap, (afip3__OpcionalTipo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__ArrayOfOpcionalTipo:
		soap_serialize_PointerToafip3__ArrayOfOpcionalTipo(soap, (afip3__ArrayOfOpcionalTipo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__IvaTipo:
		soap_serialize_PointerToafip3__IvaTipo(soap, (afip3__IvaTipo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__ArrayOfIvaTipo:
		soap_serialize_PointerToafip3__ArrayOfIvaTipo(soap, (afip3__ArrayOfIvaTipo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__Moneda:
		soap_serialize_PointerToafip3__Moneda(soap, (afip3__Moneda *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__ArrayOfMoneda:
		soap_serialize_PointerToafip3__ArrayOfMoneda(soap, (afip3__ArrayOfMoneda *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__TributoTipo:
		soap_serialize_PointerToafip3__TributoTipo(soap, (afip3__TributoTipo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__ArrayOfTributoTipo:
		soap_serialize_PointerToafip3__ArrayOfTributoTipo(soap, (afip3__ArrayOfTributoTipo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__Cotizacion:
		soap_serialize_PointerToafip3__Cotizacion(soap, (afip3__Cotizacion *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__FECAEASinMov:
		soap_serialize_PointerToafip3__FECAEASinMov(soap, (afip3__FECAEASinMov *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__ArrayOfFECAEASinMov:
		soap_serialize_PointerToafip3__ArrayOfFECAEASinMov(soap, (afip3__ArrayOfFECAEASinMov *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__FECAEAGet:
		soap_serialize_PointerToafip3__FECAEAGet(soap, (afip3__FECAEAGet *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__FECAEADetResponse:
		soap_serialize_PointerToafip3__FECAEADetResponse(soap, (afip3__FECAEADetResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__ArrayOfFECAEADetResponse:
		soap_serialize_PointerToafip3__ArrayOfFECAEADetResponse(soap, (afip3__ArrayOfFECAEADetResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__FECAEACabResponse:
		soap_serialize_PointerToafip3__FECAEACabResponse(soap, (afip3__FECAEACabResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__FECAEADetRequest:
		soap_serialize_PointerToafip3__FECAEADetRequest(soap, (afip3__FECAEADetRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__ArrayOfFECAEADetRequest:
		soap_serialize_PointerToafip3__ArrayOfFECAEADetRequest(soap, (afip3__ArrayOfFECAEADetRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__FECAEACabRequest:
		soap_serialize_PointerToafip3__FECAEACabRequest(soap, (afip3__FECAEACabRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__FECompConsResponse:
		soap_serialize_PointerToafip3__FECompConsResponse(soap, (afip3__FECompConsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__Err:
		soap_serialize_PointerToafip3__Err(soap, (afip3__Err *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__Evt:
		soap_serialize_PointerToafip3__Evt(soap, (afip3__Evt *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__Obs:
		soap_serialize_PointerToafip3__Obs(soap, (afip3__Obs *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__ArrayOfObs:
		soap_serialize_PointerToafip3__ArrayOfObs(soap, (afip3__ArrayOfObs *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__FECAEDetResponse:
		soap_serialize_PointerToafip3__FECAEDetResponse(soap, (afip3__FECAEDetResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__ArrayOfErr:
		soap_serialize_PointerToafip3__ArrayOfErr(soap, (afip3__ArrayOfErr *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__ArrayOfEvt:
		soap_serialize_PointerToafip3__ArrayOfEvt(soap, (afip3__ArrayOfEvt *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__ArrayOfFECAEDetResponse:
		soap_serialize_PointerToafip3__ArrayOfFECAEDetResponse(soap, (afip3__ArrayOfFECAEDetResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__FECAECabResponse:
		soap_serialize_PointerToafip3__FECAECabResponse(soap, (afip3__FECAECabResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__Comprador:
		soap_serialize_PointerToafip3__Comprador(soap, (afip3__Comprador *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__Opcional:
		soap_serialize_PointerToafip3__Opcional(soap, (afip3__Opcional *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__AlicIva:
		soap_serialize_PointerToafip3__AlicIva(soap, (afip3__AlicIva *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__Tributo:
		soap_serialize_PointerToafip3__Tributo(soap, (afip3__Tributo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__CbteAsoc:
		soap_serialize_PointerToafip3__CbteAsoc(soap, (afip3__CbteAsoc *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__ArrayOfComprador:
		soap_serialize_PointerToafip3__ArrayOfComprador(soap, (afip3__ArrayOfComprador *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__ArrayOfOpcional:
		soap_serialize_PointerToafip3__ArrayOfOpcional(soap, (afip3__ArrayOfOpcional *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__ArrayOfAlicIva:
		soap_serialize_PointerToafip3__ArrayOfAlicIva(soap, (afip3__ArrayOfAlicIva *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__ArrayOfTributo:
		soap_serialize_PointerToafip3__ArrayOfTributo(soap, (afip3__ArrayOfTributo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__ArrayOfCbteAsoc:
		soap_serialize_PointerToafip3__ArrayOfCbteAsoc(soap, (afip3__ArrayOfCbteAsoc *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__FECAEDetRequest:
		soap_serialize_PointerToafip3__FECAEDetRequest(soap, (afip3__FECAEDetRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__ArrayOfFECAEDetRequest:
		soap_serialize_PointerToafip3__ArrayOfFECAEDetRequest(soap, (afip3__ArrayOfFECAEDetRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerToafip3__FECAECabRequest:
		soap_serialize_PointerToafip3__FECAECabRequest(soap, (afip3__FECAECabRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip1__loginCms:
		return (void*)soap_instantiate__afip1__loginCms(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip1__loginCmsResponse:
		return (void*)soap_instantiate__afip1__loginCmsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip2__LoginFault:
		return (void*)soap_instantiate_afip2__LoginFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__FEAuthRequest:
		return (void*)soap_instantiate_afip3__FEAuthRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__FECAERequest:
		return (void*)soap_instantiate_afip3__FECAERequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__FECabRequest:
		return (void*)soap_instantiate_afip3__FECabRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__ArrayOfFECAEDetRequest:
		return (void*)soap_instantiate_afip3__ArrayOfFECAEDetRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__FEDetRequest:
		return (void*)soap_instantiate_afip3__FEDetRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__ArrayOfCbteAsoc:
		return (void*)soap_instantiate_afip3__ArrayOfCbteAsoc(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__CbteAsoc:
		return (void*)soap_instantiate_afip3__CbteAsoc(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__ArrayOfTributo:
		return (void*)soap_instantiate_afip3__ArrayOfTributo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__Tributo:
		return (void*)soap_instantiate_afip3__Tributo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__ArrayOfAlicIva:
		return (void*)soap_instantiate_afip3__ArrayOfAlicIva(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__AlicIva:
		return (void*)soap_instantiate_afip3__AlicIva(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__ArrayOfOpcional:
		return (void*)soap_instantiate_afip3__ArrayOfOpcional(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__Opcional:
		return (void*)soap_instantiate_afip3__Opcional(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__ArrayOfComprador:
		return (void*)soap_instantiate_afip3__ArrayOfComprador(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__Comprador:
		return (void*)soap_instantiate_afip3__Comprador(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__FECAEResponse:
		return (void*)soap_instantiate_afip3__FECAEResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__FECabResponse:
		return (void*)soap_instantiate_afip3__FECabResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__ArrayOfFECAEDetResponse:
		return (void*)soap_instantiate_afip3__ArrayOfFECAEDetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__FEDetResponse:
		return (void*)soap_instantiate_afip3__FEDetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__ArrayOfObs:
		return (void*)soap_instantiate_afip3__ArrayOfObs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__Obs:
		return (void*)soap_instantiate_afip3__Obs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__ArrayOfEvt:
		return (void*)soap_instantiate_afip3__ArrayOfEvt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__Evt:
		return (void*)soap_instantiate_afip3__Evt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__ArrayOfErr:
		return (void*)soap_instantiate_afip3__ArrayOfErr(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__Err:
		return (void*)soap_instantiate_afip3__Err(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__FERegXReqResponse:
		return (void*)soap_instantiate_afip3__FERegXReqResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__DummyResponse:
		return (void*)soap_instantiate_afip3__DummyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__FERecuperaLastCbteResponse:
		return (void*)soap_instantiate_afip3__FERecuperaLastCbteResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__FECompConsultaReq:
		return (void*)soap_instantiate_afip3__FECompConsultaReq(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__FECompConsultaResponse:
		return (void*)soap_instantiate_afip3__FECompConsultaResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__FECAEARequest:
		return (void*)soap_instantiate_afip3__FECAEARequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__ArrayOfFECAEADetRequest:
		return (void*)soap_instantiate_afip3__ArrayOfFECAEADetRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__FECAEAResponse:
		return (void*)soap_instantiate_afip3__FECAEAResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__ArrayOfFECAEADetResponse:
		return (void*)soap_instantiate_afip3__ArrayOfFECAEADetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__FECAEAGetResponse:
		return (void*)soap_instantiate_afip3__FECAEAGetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__FECAEAGet:
		return (void*)soap_instantiate_afip3__FECAEAGet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__FECAEASinMovConsResponse:
		return (void*)soap_instantiate_afip3__FECAEASinMovConsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__ArrayOfFECAEASinMov:
		return (void*)soap_instantiate_afip3__ArrayOfFECAEASinMov(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__FECAEASinMov:
		return (void*)soap_instantiate_afip3__FECAEASinMov(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__FECotizacionResponse:
		return (void*)soap_instantiate_afip3__FECotizacionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__Cotizacion:
		return (void*)soap_instantiate_afip3__Cotizacion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__FETributoResponse:
		return (void*)soap_instantiate_afip3__FETributoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__ArrayOfTributoTipo:
		return (void*)soap_instantiate_afip3__ArrayOfTributoTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__TributoTipo:
		return (void*)soap_instantiate_afip3__TributoTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__MonedaResponse:
		return (void*)soap_instantiate_afip3__MonedaResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__ArrayOfMoneda:
		return (void*)soap_instantiate_afip3__ArrayOfMoneda(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__Moneda:
		return (void*)soap_instantiate_afip3__Moneda(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__IvaTipoResponse:
		return (void*)soap_instantiate_afip3__IvaTipoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__ArrayOfIvaTipo:
		return (void*)soap_instantiate_afip3__ArrayOfIvaTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__IvaTipo:
		return (void*)soap_instantiate_afip3__IvaTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__OpcionalTipoResponse:
		return (void*)soap_instantiate_afip3__OpcionalTipoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__ArrayOfOpcionalTipo:
		return (void*)soap_instantiate_afip3__ArrayOfOpcionalTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__OpcionalTipo:
		return (void*)soap_instantiate_afip3__OpcionalTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__ConceptoTipoResponse:
		return (void*)soap_instantiate_afip3__ConceptoTipoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__ArrayOfConceptoTipo:
		return (void*)soap_instantiate_afip3__ArrayOfConceptoTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__ConceptoTipo:
		return (void*)soap_instantiate_afip3__ConceptoTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__FEPtoVentaResponse:
		return (void*)soap_instantiate_afip3__FEPtoVentaResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__ArrayOfPtoVenta:
		return (void*)soap_instantiate_afip3__ArrayOfPtoVenta(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__PtoVenta:
		return (void*)soap_instantiate_afip3__PtoVenta(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__CbteTipoResponse:
		return (void*)soap_instantiate_afip3__CbteTipoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__ArrayOfCbteTipo:
		return (void*)soap_instantiate_afip3__ArrayOfCbteTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__CbteTipo:
		return (void*)soap_instantiate_afip3__CbteTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__DocTipoResponse:
		return (void*)soap_instantiate_afip3__DocTipoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__ArrayOfDocTipo:
		return (void*)soap_instantiate_afip3__ArrayOfDocTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__DocTipo:
		return (void*)soap_instantiate_afip3__DocTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__FEPaisResponse:
		return (void*)soap_instantiate_afip3__FEPaisResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__ArrayOfPaisTipo:
		return (void*)soap_instantiate_afip3__ArrayOfPaisTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__PaisTipo:
		return (void*)soap_instantiate_afip3__PaisTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FECAESolicitar:
		return (void*)soap_instantiate__afip3__FECAESolicitar(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FECAESolicitarResponse:
		return (void*)soap_instantiate__afip3__FECAESolicitarResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FECompTotXRequest:
		return (void*)soap_instantiate__afip3__FECompTotXRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FECompTotXRequestResponse:
		return (void*)soap_instantiate__afip3__FECompTotXRequestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FEDummy:
		return (void*)soap_instantiate__afip3__FEDummy(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FEDummyResponse:
		return (void*)soap_instantiate__afip3__FEDummyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FECompUltimoAutorizado:
		return (void*)soap_instantiate__afip3__FECompUltimoAutorizado(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FECompUltimoAutorizadoResponse:
		return (void*)soap_instantiate__afip3__FECompUltimoAutorizadoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FECompConsultar:
		return (void*)soap_instantiate__afip3__FECompConsultar(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FECompConsultarResponse:
		return (void*)soap_instantiate__afip3__FECompConsultarResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FECAEARegInformativo:
		return (void*)soap_instantiate__afip3__FECAEARegInformativo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FECAEARegInformativoResponse:
		return (void*)soap_instantiate__afip3__FECAEARegInformativoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FECAEASolicitar:
		return (void*)soap_instantiate__afip3__FECAEASolicitar(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FECAEASolicitarResponse:
		return (void*)soap_instantiate__afip3__FECAEASolicitarResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FECAEASinMovimientoConsultar:
		return (void*)soap_instantiate__afip3__FECAEASinMovimientoConsultar(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FECAEASinMovimientoConsultarResponse:
		return (void*)soap_instantiate__afip3__FECAEASinMovimientoConsultarResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FECAEASinMovimientoInformar:
		return (void*)soap_instantiate__afip3__FECAEASinMovimientoInformar(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FECAEASinMovimientoInformarResponse:
		return (void*)soap_instantiate__afip3__FECAEASinMovimientoInformarResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FECAEAConsultar:
		return (void*)soap_instantiate__afip3__FECAEAConsultar(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FECAEAConsultarResponse:
		return (void*)soap_instantiate__afip3__FECAEAConsultarResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FEParamGetCotizacion:
		return (void*)soap_instantiate__afip3__FEParamGetCotizacion(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FEParamGetCotizacionResponse:
		return (void*)soap_instantiate__afip3__FEParamGetCotizacionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FEParamGetTiposTributos:
		return (void*)soap_instantiate__afip3__FEParamGetTiposTributos(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FEParamGetTiposTributosResponse:
		return (void*)soap_instantiate__afip3__FEParamGetTiposTributosResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FEParamGetTiposMonedas:
		return (void*)soap_instantiate__afip3__FEParamGetTiposMonedas(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FEParamGetTiposMonedasResponse:
		return (void*)soap_instantiate__afip3__FEParamGetTiposMonedasResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FEParamGetTiposIva:
		return (void*)soap_instantiate__afip3__FEParamGetTiposIva(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FEParamGetTiposIvaResponse:
		return (void*)soap_instantiate__afip3__FEParamGetTiposIvaResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FEParamGetTiposOpcional:
		return (void*)soap_instantiate__afip3__FEParamGetTiposOpcional(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FEParamGetTiposOpcionalResponse:
		return (void*)soap_instantiate__afip3__FEParamGetTiposOpcionalResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FEParamGetTiposConcepto:
		return (void*)soap_instantiate__afip3__FEParamGetTiposConcepto(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FEParamGetTiposConceptoResponse:
		return (void*)soap_instantiate__afip3__FEParamGetTiposConceptoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FEParamGetPtosVenta:
		return (void*)soap_instantiate__afip3__FEParamGetPtosVenta(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FEParamGetPtosVentaResponse:
		return (void*)soap_instantiate__afip3__FEParamGetPtosVentaResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FEParamGetTiposCbte:
		return (void*)soap_instantiate__afip3__FEParamGetTiposCbte(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FEParamGetTiposCbteResponse:
		return (void*)soap_instantiate__afip3__FEParamGetTiposCbteResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FEParamGetTiposDoc:
		return (void*)soap_instantiate__afip3__FEParamGetTiposDoc(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FEParamGetTiposDocResponse:
		return (void*)soap_instantiate__afip3__FEParamGetTiposDocResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FEParamGetTiposPaises:
		return (void*)soap_instantiate__afip3__FEParamGetTiposPaises(soap, -1, type, arrayType, n);
	case SOAP_TYPE__afip3__FEParamGetTiposPaisesResponse:
		return (void*)soap_instantiate__afip3__FEParamGetTiposPaisesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__FECAECabRequest:
		return (void*)soap_instantiate_afip3__FECAECabRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__FECAEDetRequest:
		return (void*)soap_instantiate_afip3__FECAEDetRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__FECAECabResponse:
		return (void*)soap_instantiate_afip3__FECAECabResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__FECAEDetResponse:
		return (void*)soap_instantiate_afip3__FECAEDetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__FECAEACabRequest:
		return (void*)soap_instantiate_afip3__FECAEACabRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__FECAEADetRequest:
		return (void*)soap_instantiate_afip3__FECAEADetRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__FECAEACabResponse:
		return (void*)soap_instantiate_afip3__FECAEACabResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__FECAEADetResponse:
		return (void*)soap_instantiate_afip3__FECAEADetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__FECAEASinMovResponse:
		return (void*)soap_instantiate_afip3__FECAEASinMovResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_afip3__FECompConsResponse:
		return (void*)soap_instantiate_afip3__FECompConsResponse(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE___afip2__loginCms:
		return (void*)soap_instantiate___afip2__loginCms(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip4__FECAESolicitar:
		return (void*)soap_instantiate___afip4__FECAESolicitar(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip4__FECompTotXRequest:
		return (void*)soap_instantiate___afip4__FECompTotXRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip4__FEDummy:
		return (void*)soap_instantiate___afip4__FEDummy(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip4__FECompUltimoAutorizado:
		return (void*)soap_instantiate___afip4__FECompUltimoAutorizado(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip4__FECompConsultar:
		return (void*)soap_instantiate___afip4__FECompConsultar(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip4__FECAEARegInformativo:
		return (void*)soap_instantiate___afip4__FECAEARegInformativo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip4__FECAEASolicitar:
		return (void*)soap_instantiate___afip4__FECAEASolicitar(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip4__FECAEASinMovimientoConsultar:
		return (void*)soap_instantiate___afip4__FECAEASinMovimientoConsultar(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip4__FECAEASinMovimientoInformar:
		return (void*)soap_instantiate___afip4__FECAEASinMovimientoInformar(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip4__FECAEAConsultar:
		return (void*)soap_instantiate___afip4__FECAEAConsultar(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip4__FEParamGetCotizacion:
		return (void*)soap_instantiate___afip4__FEParamGetCotizacion(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip4__FEParamGetTiposTributos:
		return (void*)soap_instantiate___afip4__FEParamGetTiposTributos(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip4__FEParamGetTiposMonedas:
		return (void*)soap_instantiate___afip4__FEParamGetTiposMonedas(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip4__FEParamGetTiposIva:
		return (void*)soap_instantiate___afip4__FEParamGetTiposIva(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip4__FEParamGetTiposOpcional:
		return (void*)soap_instantiate___afip4__FEParamGetTiposOpcional(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip4__FEParamGetTiposConcepto:
		return (void*)soap_instantiate___afip4__FEParamGetTiposConcepto(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip4__FEParamGetPtosVenta:
		return (void*)soap_instantiate___afip4__FEParamGetPtosVenta(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip4__FEParamGetTiposCbte:
		return (void*)soap_instantiate___afip4__FEParamGetTiposCbte(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip4__FEParamGetTiposDoc:
		return (void*)soap_instantiate___afip4__FEParamGetTiposDoc(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip4__FEParamGetTiposPaises:
		return (void*)soap_instantiate___afip4__FEParamGetTiposPaises(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip5__FECAESolicitar:
		return (void*)soap_instantiate___afip5__FECAESolicitar(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip5__FECompTotXRequest:
		return (void*)soap_instantiate___afip5__FECompTotXRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip5__FEDummy:
		return (void*)soap_instantiate___afip5__FEDummy(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip5__FECompUltimoAutorizado:
		return (void*)soap_instantiate___afip5__FECompUltimoAutorizado(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip5__FECompConsultar:
		return (void*)soap_instantiate___afip5__FECompConsultar(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip5__FECAEARegInformativo:
		return (void*)soap_instantiate___afip5__FECAEARegInformativo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip5__FECAEASolicitar:
		return (void*)soap_instantiate___afip5__FECAEASolicitar(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip5__FECAEASinMovimientoConsultar:
		return (void*)soap_instantiate___afip5__FECAEASinMovimientoConsultar(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip5__FECAEASinMovimientoInformar:
		return (void*)soap_instantiate___afip5__FECAEASinMovimientoInformar(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip5__FECAEAConsultar:
		return (void*)soap_instantiate___afip5__FECAEAConsultar(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip5__FEParamGetCotizacion:
		return (void*)soap_instantiate___afip5__FEParamGetCotizacion(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip5__FEParamGetTiposTributos:
		return (void*)soap_instantiate___afip5__FEParamGetTiposTributos(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip5__FEParamGetTiposMonedas:
		return (void*)soap_instantiate___afip5__FEParamGetTiposMonedas(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip5__FEParamGetTiposIva:
		return (void*)soap_instantiate___afip5__FEParamGetTiposIva(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip5__FEParamGetTiposOpcional:
		return (void*)soap_instantiate___afip5__FEParamGetTiposOpcional(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip5__FEParamGetTiposConcepto:
		return (void*)soap_instantiate___afip5__FEParamGetTiposConcepto(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip5__FEParamGetPtosVenta:
		return (void*)soap_instantiate___afip5__FEParamGetPtosVenta(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip5__FEParamGetTiposCbte:
		return (void*)soap_instantiate___afip5__FEParamGetTiposCbte(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip5__FEParamGetTiposDoc:
		return (void*)soap_instantiate___afip5__FEParamGetTiposDoc(soap, -1, type, arrayType, n);
	case SOAP_TYPE___afip5__FEParamGetTiposPaises:
		return (void*)soap_instantiate___afip5__FEParamGetTiposPaises(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__PaisTipo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToafip3__PaisTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__DocTipo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToafip3__DocTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__CbteTipo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToafip3__CbteTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__PtoVenta:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToafip3__PtoVenta(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__ConceptoTipo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToafip3__ConceptoTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__OpcionalTipo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToafip3__OpcionalTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__IvaTipo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToafip3__IvaTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Moneda:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToafip3__Moneda(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__TributoTipo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToafip3__TributoTipo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEASinMov:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToafip3__FECAEASinMov(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEADetResponse:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToafip3__FECAEADetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEADetRequest:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToafip3__FECAEADetRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Err:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToafip3__Err(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Evt:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToafip3__Evt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Obs:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToafip3__Obs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEDetResponse:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToafip3__FECAEDetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Comprador:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToafip3__Comprador(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Opcional:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToafip3__Opcional(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__AlicIva:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToafip3__AlicIva(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Tributo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToafip3__Tributo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__CbteAsoc:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToafip3__CbteAsoc(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEDetRequest:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToafip3__FECAEDetRequest(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap *soap, struct soap_clist *p)
{
	(void)soap; /* appease -Wall -Werror */
	if (!p->ptr)
		return SOAP_OK;
	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE__afip1__loginCms:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip1__loginCms*>(p->ptr), _afip1__loginCms);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip1__loginCms*>(p->ptr), _afip1__loginCms);
		break;
	case SOAP_TYPE__afip1__loginCmsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip1__loginCmsResponse*>(p->ptr), _afip1__loginCmsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip1__loginCmsResponse*>(p->ptr), _afip1__loginCmsResponse);
		break;
	case SOAP_TYPE_afip2__LoginFault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip2__LoginFault*>(p->ptr), afip2__LoginFault);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip2__LoginFault*>(p->ptr), afip2__LoginFault);
		break;
	case SOAP_TYPE_afip3__FEAuthRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__FEAuthRequest*>(p->ptr), afip3__FEAuthRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__FEAuthRequest*>(p->ptr), afip3__FEAuthRequest);
		break;
	case SOAP_TYPE_afip3__FECAERequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__FECAERequest*>(p->ptr), afip3__FECAERequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__FECAERequest*>(p->ptr), afip3__FECAERequest);
		break;
	case SOAP_TYPE_afip3__FECabRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__FECabRequest*>(p->ptr), afip3__FECabRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__FECabRequest*>(p->ptr), afip3__FECabRequest);
		break;
	case SOAP_TYPE_afip3__ArrayOfFECAEDetRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__ArrayOfFECAEDetRequest*>(p->ptr), afip3__ArrayOfFECAEDetRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__ArrayOfFECAEDetRequest*>(p->ptr), afip3__ArrayOfFECAEDetRequest);
		break;
	case SOAP_TYPE_afip3__FEDetRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__FEDetRequest*>(p->ptr), afip3__FEDetRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__FEDetRequest*>(p->ptr), afip3__FEDetRequest);
		break;
	case SOAP_TYPE_afip3__ArrayOfCbteAsoc:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__ArrayOfCbteAsoc*>(p->ptr), afip3__ArrayOfCbteAsoc);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__ArrayOfCbteAsoc*>(p->ptr), afip3__ArrayOfCbteAsoc);
		break;
	case SOAP_TYPE_afip3__CbteAsoc:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__CbteAsoc*>(p->ptr), afip3__CbteAsoc);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__CbteAsoc*>(p->ptr), afip3__CbteAsoc);
		break;
	case SOAP_TYPE_afip3__ArrayOfTributo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__ArrayOfTributo*>(p->ptr), afip3__ArrayOfTributo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__ArrayOfTributo*>(p->ptr), afip3__ArrayOfTributo);
		break;
	case SOAP_TYPE_afip3__Tributo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__Tributo*>(p->ptr), afip3__Tributo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__Tributo*>(p->ptr), afip3__Tributo);
		break;
	case SOAP_TYPE_afip3__ArrayOfAlicIva:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__ArrayOfAlicIva*>(p->ptr), afip3__ArrayOfAlicIva);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__ArrayOfAlicIva*>(p->ptr), afip3__ArrayOfAlicIva);
		break;
	case SOAP_TYPE_afip3__AlicIva:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__AlicIva*>(p->ptr), afip3__AlicIva);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__AlicIva*>(p->ptr), afip3__AlicIva);
		break;
	case SOAP_TYPE_afip3__ArrayOfOpcional:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__ArrayOfOpcional*>(p->ptr), afip3__ArrayOfOpcional);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__ArrayOfOpcional*>(p->ptr), afip3__ArrayOfOpcional);
		break;
	case SOAP_TYPE_afip3__Opcional:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__Opcional*>(p->ptr), afip3__Opcional);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__Opcional*>(p->ptr), afip3__Opcional);
		break;
	case SOAP_TYPE_afip3__ArrayOfComprador:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__ArrayOfComprador*>(p->ptr), afip3__ArrayOfComprador);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__ArrayOfComprador*>(p->ptr), afip3__ArrayOfComprador);
		break;
	case SOAP_TYPE_afip3__Comprador:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__Comprador*>(p->ptr), afip3__Comprador);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__Comprador*>(p->ptr), afip3__Comprador);
		break;
	case SOAP_TYPE_afip3__FECAEResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__FECAEResponse*>(p->ptr), afip3__FECAEResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__FECAEResponse*>(p->ptr), afip3__FECAEResponse);
		break;
	case SOAP_TYPE_afip3__FECabResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__FECabResponse*>(p->ptr), afip3__FECabResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__FECabResponse*>(p->ptr), afip3__FECabResponse);
		break;
	case SOAP_TYPE_afip3__ArrayOfFECAEDetResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__ArrayOfFECAEDetResponse*>(p->ptr), afip3__ArrayOfFECAEDetResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__ArrayOfFECAEDetResponse*>(p->ptr), afip3__ArrayOfFECAEDetResponse);
		break;
	case SOAP_TYPE_afip3__FEDetResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__FEDetResponse*>(p->ptr), afip3__FEDetResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__FEDetResponse*>(p->ptr), afip3__FEDetResponse);
		break;
	case SOAP_TYPE_afip3__ArrayOfObs:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__ArrayOfObs*>(p->ptr), afip3__ArrayOfObs);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__ArrayOfObs*>(p->ptr), afip3__ArrayOfObs);
		break;
	case SOAP_TYPE_afip3__Obs:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__Obs*>(p->ptr), afip3__Obs);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__Obs*>(p->ptr), afip3__Obs);
		break;
	case SOAP_TYPE_afip3__ArrayOfEvt:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__ArrayOfEvt*>(p->ptr), afip3__ArrayOfEvt);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__ArrayOfEvt*>(p->ptr), afip3__ArrayOfEvt);
		break;
	case SOAP_TYPE_afip3__Evt:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__Evt*>(p->ptr), afip3__Evt);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__Evt*>(p->ptr), afip3__Evt);
		break;
	case SOAP_TYPE_afip3__ArrayOfErr:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__ArrayOfErr*>(p->ptr), afip3__ArrayOfErr);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__ArrayOfErr*>(p->ptr), afip3__ArrayOfErr);
		break;
	case SOAP_TYPE_afip3__Err:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__Err*>(p->ptr), afip3__Err);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__Err*>(p->ptr), afip3__Err);
		break;
	case SOAP_TYPE_afip3__FERegXReqResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__FERegXReqResponse*>(p->ptr), afip3__FERegXReqResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__FERegXReqResponse*>(p->ptr), afip3__FERegXReqResponse);
		break;
	case SOAP_TYPE_afip3__DummyResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__DummyResponse*>(p->ptr), afip3__DummyResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__DummyResponse*>(p->ptr), afip3__DummyResponse);
		break;
	case SOAP_TYPE_afip3__FERecuperaLastCbteResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__FERecuperaLastCbteResponse*>(p->ptr), afip3__FERecuperaLastCbteResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__FERecuperaLastCbteResponse*>(p->ptr), afip3__FERecuperaLastCbteResponse);
		break;
	case SOAP_TYPE_afip3__FECompConsultaReq:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__FECompConsultaReq*>(p->ptr), afip3__FECompConsultaReq);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__FECompConsultaReq*>(p->ptr), afip3__FECompConsultaReq);
		break;
	case SOAP_TYPE_afip3__FECompConsultaResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__FECompConsultaResponse*>(p->ptr), afip3__FECompConsultaResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__FECompConsultaResponse*>(p->ptr), afip3__FECompConsultaResponse);
		break;
	case SOAP_TYPE_afip3__FECAEARequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__FECAEARequest*>(p->ptr), afip3__FECAEARequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__FECAEARequest*>(p->ptr), afip3__FECAEARequest);
		break;
	case SOAP_TYPE_afip3__ArrayOfFECAEADetRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__ArrayOfFECAEADetRequest*>(p->ptr), afip3__ArrayOfFECAEADetRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__ArrayOfFECAEADetRequest*>(p->ptr), afip3__ArrayOfFECAEADetRequest);
		break;
	case SOAP_TYPE_afip3__FECAEAResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__FECAEAResponse*>(p->ptr), afip3__FECAEAResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__FECAEAResponse*>(p->ptr), afip3__FECAEAResponse);
		break;
	case SOAP_TYPE_afip3__ArrayOfFECAEADetResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__ArrayOfFECAEADetResponse*>(p->ptr), afip3__ArrayOfFECAEADetResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__ArrayOfFECAEADetResponse*>(p->ptr), afip3__ArrayOfFECAEADetResponse);
		break;
	case SOAP_TYPE_afip3__FECAEAGetResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__FECAEAGetResponse*>(p->ptr), afip3__FECAEAGetResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__FECAEAGetResponse*>(p->ptr), afip3__FECAEAGetResponse);
		break;
	case SOAP_TYPE_afip3__FECAEAGet:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__FECAEAGet*>(p->ptr), afip3__FECAEAGet);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__FECAEAGet*>(p->ptr), afip3__FECAEAGet);
		break;
	case SOAP_TYPE_afip3__FECAEASinMovConsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__FECAEASinMovConsResponse*>(p->ptr), afip3__FECAEASinMovConsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__FECAEASinMovConsResponse*>(p->ptr), afip3__FECAEASinMovConsResponse);
		break;
	case SOAP_TYPE_afip3__ArrayOfFECAEASinMov:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__ArrayOfFECAEASinMov*>(p->ptr), afip3__ArrayOfFECAEASinMov);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__ArrayOfFECAEASinMov*>(p->ptr), afip3__ArrayOfFECAEASinMov);
		break;
	case SOAP_TYPE_afip3__FECAEASinMov:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__FECAEASinMov*>(p->ptr), afip3__FECAEASinMov);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__FECAEASinMov*>(p->ptr), afip3__FECAEASinMov);
		break;
	case SOAP_TYPE_afip3__FECotizacionResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__FECotizacionResponse*>(p->ptr), afip3__FECotizacionResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__FECotizacionResponse*>(p->ptr), afip3__FECotizacionResponse);
		break;
	case SOAP_TYPE_afip3__Cotizacion:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__Cotizacion*>(p->ptr), afip3__Cotizacion);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__Cotizacion*>(p->ptr), afip3__Cotizacion);
		break;
	case SOAP_TYPE_afip3__FETributoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__FETributoResponse*>(p->ptr), afip3__FETributoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__FETributoResponse*>(p->ptr), afip3__FETributoResponse);
		break;
	case SOAP_TYPE_afip3__ArrayOfTributoTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__ArrayOfTributoTipo*>(p->ptr), afip3__ArrayOfTributoTipo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__ArrayOfTributoTipo*>(p->ptr), afip3__ArrayOfTributoTipo);
		break;
	case SOAP_TYPE_afip3__TributoTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__TributoTipo*>(p->ptr), afip3__TributoTipo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__TributoTipo*>(p->ptr), afip3__TributoTipo);
		break;
	case SOAP_TYPE_afip3__MonedaResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__MonedaResponse*>(p->ptr), afip3__MonedaResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__MonedaResponse*>(p->ptr), afip3__MonedaResponse);
		break;
	case SOAP_TYPE_afip3__ArrayOfMoneda:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__ArrayOfMoneda*>(p->ptr), afip3__ArrayOfMoneda);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__ArrayOfMoneda*>(p->ptr), afip3__ArrayOfMoneda);
		break;
	case SOAP_TYPE_afip3__Moneda:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__Moneda*>(p->ptr), afip3__Moneda);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__Moneda*>(p->ptr), afip3__Moneda);
		break;
	case SOAP_TYPE_afip3__IvaTipoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__IvaTipoResponse*>(p->ptr), afip3__IvaTipoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__IvaTipoResponse*>(p->ptr), afip3__IvaTipoResponse);
		break;
	case SOAP_TYPE_afip3__ArrayOfIvaTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__ArrayOfIvaTipo*>(p->ptr), afip3__ArrayOfIvaTipo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__ArrayOfIvaTipo*>(p->ptr), afip3__ArrayOfIvaTipo);
		break;
	case SOAP_TYPE_afip3__IvaTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__IvaTipo*>(p->ptr), afip3__IvaTipo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__IvaTipo*>(p->ptr), afip3__IvaTipo);
		break;
	case SOAP_TYPE_afip3__OpcionalTipoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__OpcionalTipoResponse*>(p->ptr), afip3__OpcionalTipoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__OpcionalTipoResponse*>(p->ptr), afip3__OpcionalTipoResponse);
		break;
	case SOAP_TYPE_afip3__ArrayOfOpcionalTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__ArrayOfOpcionalTipo*>(p->ptr), afip3__ArrayOfOpcionalTipo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__ArrayOfOpcionalTipo*>(p->ptr), afip3__ArrayOfOpcionalTipo);
		break;
	case SOAP_TYPE_afip3__OpcionalTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__OpcionalTipo*>(p->ptr), afip3__OpcionalTipo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__OpcionalTipo*>(p->ptr), afip3__OpcionalTipo);
		break;
	case SOAP_TYPE_afip3__ConceptoTipoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__ConceptoTipoResponse*>(p->ptr), afip3__ConceptoTipoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__ConceptoTipoResponse*>(p->ptr), afip3__ConceptoTipoResponse);
		break;
	case SOAP_TYPE_afip3__ArrayOfConceptoTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__ArrayOfConceptoTipo*>(p->ptr), afip3__ArrayOfConceptoTipo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__ArrayOfConceptoTipo*>(p->ptr), afip3__ArrayOfConceptoTipo);
		break;
	case SOAP_TYPE_afip3__ConceptoTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__ConceptoTipo*>(p->ptr), afip3__ConceptoTipo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__ConceptoTipo*>(p->ptr), afip3__ConceptoTipo);
		break;
	case SOAP_TYPE_afip3__FEPtoVentaResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__FEPtoVentaResponse*>(p->ptr), afip3__FEPtoVentaResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__FEPtoVentaResponse*>(p->ptr), afip3__FEPtoVentaResponse);
		break;
	case SOAP_TYPE_afip3__ArrayOfPtoVenta:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__ArrayOfPtoVenta*>(p->ptr), afip3__ArrayOfPtoVenta);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__ArrayOfPtoVenta*>(p->ptr), afip3__ArrayOfPtoVenta);
		break;
	case SOAP_TYPE_afip3__PtoVenta:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__PtoVenta*>(p->ptr), afip3__PtoVenta);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__PtoVenta*>(p->ptr), afip3__PtoVenta);
		break;
	case SOAP_TYPE_afip3__CbteTipoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__CbteTipoResponse*>(p->ptr), afip3__CbteTipoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__CbteTipoResponse*>(p->ptr), afip3__CbteTipoResponse);
		break;
	case SOAP_TYPE_afip3__ArrayOfCbteTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__ArrayOfCbteTipo*>(p->ptr), afip3__ArrayOfCbteTipo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__ArrayOfCbteTipo*>(p->ptr), afip3__ArrayOfCbteTipo);
		break;
	case SOAP_TYPE_afip3__CbteTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__CbteTipo*>(p->ptr), afip3__CbteTipo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__CbteTipo*>(p->ptr), afip3__CbteTipo);
		break;
	case SOAP_TYPE_afip3__DocTipoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__DocTipoResponse*>(p->ptr), afip3__DocTipoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__DocTipoResponse*>(p->ptr), afip3__DocTipoResponse);
		break;
	case SOAP_TYPE_afip3__ArrayOfDocTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__ArrayOfDocTipo*>(p->ptr), afip3__ArrayOfDocTipo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__ArrayOfDocTipo*>(p->ptr), afip3__ArrayOfDocTipo);
		break;
	case SOAP_TYPE_afip3__DocTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__DocTipo*>(p->ptr), afip3__DocTipo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__DocTipo*>(p->ptr), afip3__DocTipo);
		break;
	case SOAP_TYPE_afip3__FEPaisResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__FEPaisResponse*>(p->ptr), afip3__FEPaisResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__FEPaisResponse*>(p->ptr), afip3__FEPaisResponse);
		break;
	case SOAP_TYPE_afip3__ArrayOfPaisTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__ArrayOfPaisTipo*>(p->ptr), afip3__ArrayOfPaisTipo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__ArrayOfPaisTipo*>(p->ptr), afip3__ArrayOfPaisTipo);
		break;
	case SOAP_TYPE_afip3__PaisTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__PaisTipo*>(p->ptr), afip3__PaisTipo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__PaisTipo*>(p->ptr), afip3__PaisTipo);
		break;
	case SOAP_TYPE__afip3__FECAESolicitar:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FECAESolicitar*>(p->ptr), _afip3__FECAESolicitar);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FECAESolicitar*>(p->ptr), _afip3__FECAESolicitar);
		break;
	case SOAP_TYPE__afip3__FECAESolicitarResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FECAESolicitarResponse*>(p->ptr), _afip3__FECAESolicitarResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FECAESolicitarResponse*>(p->ptr), _afip3__FECAESolicitarResponse);
		break;
	case SOAP_TYPE__afip3__FECompTotXRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FECompTotXRequest*>(p->ptr), _afip3__FECompTotXRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FECompTotXRequest*>(p->ptr), _afip3__FECompTotXRequest);
		break;
	case SOAP_TYPE__afip3__FECompTotXRequestResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FECompTotXRequestResponse*>(p->ptr), _afip3__FECompTotXRequestResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FECompTotXRequestResponse*>(p->ptr), _afip3__FECompTotXRequestResponse);
		break;
	case SOAP_TYPE__afip3__FEDummy:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FEDummy*>(p->ptr), _afip3__FEDummy);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FEDummy*>(p->ptr), _afip3__FEDummy);
		break;
	case SOAP_TYPE__afip3__FEDummyResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FEDummyResponse*>(p->ptr), _afip3__FEDummyResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FEDummyResponse*>(p->ptr), _afip3__FEDummyResponse);
		break;
	case SOAP_TYPE__afip3__FECompUltimoAutorizado:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FECompUltimoAutorizado*>(p->ptr), _afip3__FECompUltimoAutorizado);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FECompUltimoAutorizado*>(p->ptr), _afip3__FECompUltimoAutorizado);
		break;
	case SOAP_TYPE__afip3__FECompUltimoAutorizadoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FECompUltimoAutorizadoResponse*>(p->ptr), _afip3__FECompUltimoAutorizadoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FECompUltimoAutorizadoResponse*>(p->ptr), _afip3__FECompUltimoAutorizadoResponse);
		break;
	case SOAP_TYPE__afip3__FECompConsultar:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FECompConsultar*>(p->ptr), _afip3__FECompConsultar);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FECompConsultar*>(p->ptr), _afip3__FECompConsultar);
		break;
	case SOAP_TYPE__afip3__FECompConsultarResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FECompConsultarResponse*>(p->ptr), _afip3__FECompConsultarResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FECompConsultarResponse*>(p->ptr), _afip3__FECompConsultarResponse);
		break;
	case SOAP_TYPE__afip3__FECAEARegInformativo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FECAEARegInformativo*>(p->ptr), _afip3__FECAEARegInformativo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FECAEARegInformativo*>(p->ptr), _afip3__FECAEARegInformativo);
		break;
	case SOAP_TYPE__afip3__FECAEARegInformativoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FECAEARegInformativoResponse*>(p->ptr), _afip3__FECAEARegInformativoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FECAEARegInformativoResponse*>(p->ptr), _afip3__FECAEARegInformativoResponse);
		break;
	case SOAP_TYPE__afip3__FECAEASolicitar:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FECAEASolicitar*>(p->ptr), _afip3__FECAEASolicitar);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FECAEASolicitar*>(p->ptr), _afip3__FECAEASolicitar);
		break;
	case SOAP_TYPE__afip3__FECAEASolicitarResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FECAEASolicitarResponse*>(p->ptr), _afip3__FECAEASolicitarResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FECAEASolicitarResponse*>(p->ptr), _afip3__FECAEASolicitarResponse);
		break;
	case SOAP_TYPE__afip3__FECAEASinMovimientoConsultar:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FECAEASinMovimientoConsultar*>(p->ptr), _afip3__FECAEASinMovimientoConsultar);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FECAEASinMovimientoConsultar*>(p->ptr), _afip3__FECAEASinMovimientoConsultar);
		break;
	case SOAP_TYPE__afip3__FECAEASinMovimientoConsultarResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FECAEASinMovimientoConsultarResponse*>(p->ptr), _afip3__FECAEASinMovimientoConsultarResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FECAEASinMovimientoConsultarResponse*>(p->ptr), _afip3__FECAEASinMovimientoConsultarResponse);
		break;
	case SOAP_TYPE__afip3__FECAEASinMovimientoInformar:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FECAEASinMovimientoInformar*>(p->ptr), _afip3__FECAEASinMovimientoInformar);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FECAEASinMovimientoInformar*>(p->ptr), _afip3__FECAEASinMovimientoInformar);
		break;
	case SOAP_TYPE__afip3__FECAEASinMovimientoInformarResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FECAEASinMovimientoInformarResponse*>(p->ptr), _afip3__FECAEASinMovimientoInformarResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FECAEASinMovimientoInformarResponse*>(p->ptr), _afip3__FECAEASinMovimientoInformarResponse);
		break;
	case SOAP_TYPE__afip3__FECAEAConsultar:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FECAEAConsultar*>(p->ptr), _afip3__FECAEAConsultar);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FECAEAConsultar*>(p->ptr), _afip3__FECAEAConsultar);
		break;
	case SOAP_TYPE__afip3__FECAEAConsultarResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FECAEAConsultarResponse*>(p->ptr), _afip3__FECAEAConsultarResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FECAEAConsultarResponse*>(p->ptr), _afip3__FECAEAConsultarResponse);
		break;
	case SOAP_TYPE__afip3__FEParamGetCotizacion:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FEParamGetCotizacion*>(p->ptr), _afip3__FEParamGetCotizacion);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FEParamGetCotizacion*>(p->ptr), _afip3__FEParamGetCotizacion);
		break;
	case SOAP_TYPE__afip3__FEParamGetCotizacionResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FEParamGetCotizacionResponse*>(p->ptr), _afip3__FEParamGetCotizacionResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FEParamGetCotizacionResponse*>(p->ptr), _afip3__FEParamGetCotizacionResponse);
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposTributos:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FEParamGetTiposTributos*>(p->ptr), _afip3__FEParamGetTiposTributos);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FEParamGetTiposTributos*>(p->ptr), _afip3__FEParamGetTiposTributos);
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposTributosResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FEParamGetTiposTributosResponse*>(p->ptr), _afip3__FEParamGetTiposTributosResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FEParamGetTiposTributosResponse*>(p->ptr), _afip3__FEParamGetTiposTributosResponse);
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposMonedas:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FEParamGetTiposMonedas*>(p->ptr), _afip3__FEParamGetTiposMonedas);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FEParamGetTiposMonedas*>(p->ptr), _afip3__FEParamGetTiposMonedas);
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposMonedasResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FEParamGetTiposMonedasResponse*>(p->ptr), _afip3__FEParamGetTiposMonedasResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FEParamGetTiposMonedasResponse*>(p->ptr), _afip3__FEParamGetTiposMonedasResponse);
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposIva:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FEParamGetTiposIva*>(p->ptr), _afip3__FEParamGetTiposIva);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FEParamGetTiposIva*>(p->ptr), _afip3__FEParamGetTiposIva);
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposIvaResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FEParamGetTiposIvaResponse*>(p->ptr), _afip3__FEParamGetTiposIvaResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FEParamGetTiposIvaResponse*>(p->ptr), _afip3__FEParamGetTiposIvaResponse);
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposOpcional:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FEParamGetTiposOpcional*>(p->ptr), _afip3__FEParamGetTiposOpcional);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FEParamGetTiposOpcional*>(p->ptr), _afip3__FEParamGetTiposOpcional);
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposOpcionalResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FEParamGetTiposOpcionalResponse*>(p->ptr), _afip3__FEParamGetTiposOpcionalResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FEParamGetTiposOpcionalResponse*>(p->ptr), _afip3__FEParamGetTiposOpcionalResponse);
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposConcepto:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FEParamGetTiposConcepto*>(p->ptr), _afip3__FEParamGetTiposConcepto);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FEParamGetTiposConcepto*>(p->ptr), _afip3__FEParamGetTiposConcepto);
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposConceptoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FEParamGetTiposConceptoResponse*>(p->ptr), _afip3__FEParamGetTiposConceptoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FEParamGetTiposConceptoResponse*>(p->ptr), _afip3__FEParamGetTiposConceptoResponse);
		break;
	case SOAP_TYPE__afip3__FEParamGetPtosVenta:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FEParamGetPtosVenta*>(p->ptr), _afip3__FEParamGetPtosVenta);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FEParamGetPtosVenta*>(p->ptr), _afip3__FEParamGetPtosVenta);
		break;
	case SOAP_TYPE__afip3__FEParamGetPtosVentaResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FEParamGetPtosVentaResponse*>(p->ptr), _afip3__FEParamGetPtosVentaResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FEParamGetPtosVentaResponse*>(p->ptr), _afip3__FEParamGetPtosVentaResponse);
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposCbte:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FEParamGetTiposCbte*>(p->ptr), _afip3__FEParamGetTiposCbte);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FEParamGetTiposCbte*>(p->ptr), _afip3__FEParamGetTiposCbte);
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposCbteResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FEParamGetTiposCbteResponse*>(p->ptr), _afip3__FEParamGetTiposCbteResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FEParamGetTiposCbteResponse*>(p->ptr), _afip3__FEParamGetTiposCbteResponse);
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposDoc:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FEParamGetTiposDoc*>(p->ptr), _afip3__FEParamGetTiposDoc);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FEParamGetTiposDoc*>(p->ptr), _afip3__FEParamGetTiposDoc);
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposDocResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FEParamGetTiposDocResponse*>(p->ptr), _afip3__FEParamGetTiposDocResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FEParamGetTiposDocResponse*>(p->ptr), _afip3__FEParamGetTiposDocResponse);
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposPaises:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FEParamGetTiposPaises*>(p->ptr), _afip3__FEParamGetTiposPaises);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FEParamGetTiposPaises*>(p->ptr), _afip3__FEParamGetTiposPaises);
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposPaisesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_afip3__FEParamGetTiposPaisesResponse*>(p->ptr), _afip3__FEParamGetTiposPaisesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_afip3__FEParamGetTiposPaisesResponse*>(p->ptr), _afip3__FEParamGetTiposPaisesResponse);
		break;
	case SOAP_TYPE_afip3__FECAECabRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__FECAECabRequest*>(p->ptr), afip3__FECAECabRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__FECAECabRequest*>(p->ptr), afip3__FECAECabRequest);
		break;
	case SOAP_TYPE_afip3__FECAEDetRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__FECAEDetRequest*>(p->ptr), afip3__FECAEDetRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__FECAEDetRequest*>(p->ptr), afip3__FECAEDetRequest);
		break;
	case SOAP_TYPE_afip3__FECAECabResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__FECAECabResponse*>(p->ptr), afip3__FECAECabResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__FECAECabResponse*>(p->ptr), afip3__FECAECabResponse);
		break;
	case SOAP_TYPE_afip3__FECAEDetResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__FECAEDetResponse*>(p->ptr), afip3__FECAEDetResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__FECAEDetResponse*>(p->ptr), afip3__FECAEDetResponse);
		break;
	case SOAP_TYPE_afip3__FECAEACabRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__FECAEACabRequest*>(p->ptr), afip3__FECAEACabRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__FECAEACabRequest*>(p->ptr), afip3__FECAEACabRequest);
		break;
	case SOAP_TYPE_afip3__FECAEADetRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__FECAEADetRequest*>(p->ptr), afip3__FECAEADetRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__FECAEADetRequest*>(p->ptr), afip3__FECAEADetRequest);
		break;
	case SOAP_TYPE_afip3__FECAEACabResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__FECAEACabResponse*>(p->ptr), afip3__FECAEACabResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__FECAEACabResponse*>(p->ptr), afip3__FECAEACabResponse);
		break;
	case SOAP_TYPE_afip3__FECAEADetResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__FECAEADetResponse*>(p->ptr), afip3__FECAEADetResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__FECAEADetResponse*>(p->ptr), afip3__FECAEADetResponse);
		break;
	case SOAP_TYPE_afip3__FECAEASinMovResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__FECAEASinMovResponse*>(p->ptr), afip3__FECAEASinMovResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__FECAEASinMovResponse*>(p->ptr), afip3__FECAEASinMovResponse);
		break;
	case SOAP_TYPE_afip3__FECompConsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<afip3__FECompConsResponse*>(p->ptr), afip3__FECompConsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<afip3__FECompConsResponse*>(p->ptr), afip3__FECompConsResponse);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		break;
#endif
	case SOAP_TYPE___afip2__loginCms:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip2__loginCms*>(p->ptr), struct __afip2__loginCms);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip2__loginCms*>(p->ptr), struct __afip2__loginCms);
		break;
	case SOAP_TYPE___afip4__FECAESolicitar:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip4__FECAESolicitar*>(p->ptr), struct __afip4__FECAESolicitar);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip4__FECAESolicitar*>(p->ptr), struct __afip4__FECAESolicitar);
		break;
	case SOAP_TYPE___afip4__FECompTotXRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip4__FECompTotXRequest*>(p->ptr), struct __afip4__FECompTotXRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip4__FECompTotXRequest*>(p->ptr), struct __afip4__FECompTotXRequest);
		break;
	case SOAP_TYPE___afip4__FEDummy:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip4__FEDummy*>(p->ptr), struct __afip4__FEDummy);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip4__FEDummy*>(p->ptr), struct __afip4__FEDummy);
		break;
	case SOAP_TYPE___afip4__FECompUltimoAutorizado:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip4__FECompUltimoAutorizado*>(p->ptr), struct __afip4__FECompUltimoAutorizado);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip4__FECompUltimoAutorizado*>(p->ptr), struct __afip4__FECompUltimoAutorizado);
		break;
	case SOAP_TYPE___afip4__FECompConsultar:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip4__FECompConsultar*>(p->ptr), struct __afip4__FECompConsultar);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip4__FECompConsultar*>(p->ptr), struct __afip4__FECompConsultar);
		break;
	case SOAP_TYPE___afip4__FECAEARegInformativo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip4__FECAEARegInformativo*>(p->ptr), struct __afip4__FECAEARegInformativo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip4__FECAEARegInformativo*>(p->ptr), struct __afip4__FECAEARegInformativo);
		break;
	case SOAP_TYPE___afip4__FECAEASolicitar:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip4__FECAEASolicitar*>(p->ptr), struct __afip4__FECAEASolicitar);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip4__FECAEASolicitar*>(p->ptr), struct __afip4__FECAEASolicitar);
		break;
	case SOAP_TYPE___afip4__FECAEASinMovimientoConsultar:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip4__FECAEASinMovimientoConsultar*>(p->ptr), struct __afip4__FECAEASinMovimientoConsultar);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip4__FECAEASinMovimientoConsultar*>(p->ptr), struct __afip4__FECAEASinMovimientoConsultar);
		break;
	case SOAP_TYPE___afip4__FECAEASinMovimientoInformar:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip4__FECAEASinMovimientoInformar*>(p->ptr), struct __afip4__FECAEASinMovimientoInformar);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip4__FECAEASinMovimientoInformar*>(p->ptr), struct __afip4__FECAEASinMovimientoInformar);
		break;
	case SOAP_TYPE___afip4__FECAEAConsultar:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip4__FECAEAConsultar*>(p->ptr), struct __afip4__FECAEAConsultar);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip4__FECAEAConsultar*>(p->ptr), struct __afip4__FECAEAConsultar);
		break;
	case SOAP_TYPE___afip4__FEParamGetCotizacion:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip4__FEParamGetCotizacion*>(p->ptr), struct __afip4__FEParamGetCotizacion);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip4__FEParamGetCotizacion*>(p->ptr), struct __afip4__FEParamGetCotizacion);
		break;
	case SOAP_TYPE___afip4__FEParamGetTiposTributos:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip4__FEParamGetTiposTributos*>(p->ptr), struct __afip4__FEParamGetTiposTributos);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip4__FEParamGetTiposTributos*>(p->ptr), struct __afip4__FEParamGetTiposTributos);
		break;
	case SOAP_TYPE___afip4__FEParamGetTiposMonedas:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip4__FEParamGetTiposMonedas*>(p->ptr), struct __afip4__FEParamGetTiposMonedas);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip4__FEParamGetTiposMonedas*>(p->ptr), struct __afip4__FEParamGetTiposMonedas);
		break;
	case SOAP_TYPE___afip4__FEParamGetTiposIva:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip4__FEParamGetTiposIva*>(p->ptr), struct __afip4__FEParamGetTiposIva);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip4__FEParamGetTiposIva*>(p->ptr), struct __afip4__FEParamGetTiposIva);
		break;
	case SOAP_TYPE___afip4__FEParamGetTiposOpcional:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip4__FEParamGetTiposOpcional*>(p->ptr), struct __afip4__FEParamGetTiposOpcional);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip4__FEParamGetTiposOpcional*>(p->ptr), struct __afip4__FEParamGetTiposOpcional);
		break;
	case SOAP_TYPE___afip4__FEParamGetTiposConcepto:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip4__FEParamGetTiposConcepto*>(p->ptr), struct __afip4__FEParamGetTiposConcepto);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip4__FEParamGetTiposConcepto*>(p->ptr), struct __afip4__FEParamGetTiposConcepto);
		break;
	case SOAP_TYPE___afip4__FEParamGetPtosVenta:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip4__FEParamGetPtosVenta*>(p->ptr), struct __afip4__FEParamGetPtosVenta);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip4__FEParamGetPtosVenta*>(p->ptr), struct __afip4__FEParamGetPtosVenta);
		break;
	case SOAP_TYPE___afip4__FEParamGetTiposCbte:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip4__FEParamGetTiposCbte*>(p->ptr), struct __afip4__FEParamGetTiposCbte);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip4__FEParamGetTiposCbte*>(p->ptr), struct __afip4__FEParamGetTiposCbte);
		break;
	case SOAP_TYPE___afip4__FEParamGetTiposDoc:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip4__FEParamGetTiposDoc*>(p->ptr), struct __afip4__FEParamGetTiposDoc);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip4__FEParamGetTiposDoc*>(p->ptr), struct __afip4__FEParamGetTiposDoc);
		break;
	case SOAP_TYPE___afip4__FEParamGetTiposPaises:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip4__FEParamGetTiposPaises*>(p->ptr), struct __afip4__FEParamGetTiposPaises);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip4__FEParamGetTiposPaises*>(p->ptr), struct __afip4__FEParamGetTiposPaises);
		break;
	case SOAP_TYPE___afip5__FECAESolicitar:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip5__FECAESolicitar*>(p->ptr), struct __afip5__FECAESolicitar);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip5__FECAESolicitar*>(p->ptr), struct __afip5__FECAESolicitar);
		break;
	case SOAP_TYPE___afip5__FECompTotXRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip5__FECompTotXRequest*>(p->ptr), struct __afip5__FECompTotXRequest);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip5__FECompTotXRequest*>(p->ptr), struct __afip5__FECompTotXRequest);
		break;
	case SOAP_TYPE___afip5__FEDummy:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip5__FEDummy*>(p->ptr), struct __afip5__FEDummy);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip5__FEDummy*>(p->ptr), struct __afip5__FEDummy);
		break;
	case SOAP_TYPE___afip5__FECompUltimoAutorizado:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip5__FECompUltimoAutorizado*>(p->ptr), struct __afip5__FECompUltimoAutorizado);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip5__FECompUltimoAutorizado*>(p->ptr), struct __afip5__FECompUltimoAutorizado);
		break;
	case SOAP_TYPE___afip5__FECompConsultar:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip5__FECompConsultar*>(p->ptr), struct __afip5__FECompConsultar);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip5__FECompConsultar*>(p->ptr), struct __afip5__FECompConsultar);
		break;
	case SOAP_TYPE___afip5__FECAEARegInformativo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip5__FECAEARegInformativo*>(p->ptr), struct __afip5__FECAEARegInformativo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip5__FECAEARegInformativo*>(p->ptr), struct __afip5__FECAEARegInformativo);
		break;
	case SOAP_TYPE___afip5__FECAEASolicitar:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip5__FECAEASolicitar*>(p->ptr), struct __afip5__FECAEASolicitar);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip5__FECAEASolicitar*>(p->ptr), struct __afip5__FECAEASolicitar);
		break;
	case SOAP_TYPE___afip5__FECAEASinMovimientoConsultar:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip5__FECAEASinMovimientoConsultar*>(p->ptr), struct __afip5__FECAEASinMovimientoConsultar);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip5__FECAEASinMovimientoConsultar*>(p->ptr), struct __afip5__FECAEASinMovimientoConsultar);
		break;
	case SOAP_TYPE___afip5__FECAEASinMovimientoInformar:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip5__FECAEASinMovimientoInformar*>(p->ptr), struct __afip5__FECAEASinMovimientoInformar);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip5__FECAEASinMovimientoInformar*>(p->ptr), struct __afip5__FECAEASinMovimientoInformar);
		break;
	case SOAP_TYPE___afip5__FECAEAConsultar:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip5__FECAEAConsultar*>(p->ptr), struct __afip5__FECAEAConsultar);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip5__FECAEAConsultar*>(p->ptr), struct __afip5__FECAEAConsultar);
		break;
	case SOAP_TYPE___afip5__FEParamGetCotizacion:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip5__FEParamGetCotizacion*>(p->ptr), struct __afip5__FEParamGetCotizacion);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip5__FEParamGetCotizacion*>(p->ptr), struct __afip5__FEParamGetCotizacion);
		break;
	case SOAP_TYPE___afip5__FEParamGetTiposTributos:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip5__FEParamGetTiposTributos*>(p->ptr), struct __afip5__FEParamGetTiposTributos);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip5__FEParamGetTiposTributos*>(p->ptr), struct __afip5__FEParamGetTiposTributos);
		break;
	case SOAP_TYPE___afip5__FEParamGetTiposMonedas:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip5__FEParamGetTiposMonedas*>(p->ptr), struct __afip5__FEParamGetTiposMonedas);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip5__FEParamGetTiposMonedas*>(p->ptr), struct __afip5__FEParamGetTiposMonedas);
		break;
	case SOAP_TYPE___afip5__FEParamGetTiposIva:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip5__FEParamGetTiposIva*>(p->ptr), struct __afip5__FEParamGetTiposIva);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip5__FEParamGetTiposIva*>(p->ptr), struct __afip5__FEParamGetTiposIva);
		break;
	case SOAP_TYPE___afip5__FEParamGetTiposOpcional:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip5__FEParamGetTiposOpcional*>(p->ptr), struct __afip5__FEParamGetTiposOpcional);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip5__FEParamGetTiposOpcional*>(p->ptr), struct __afip5__FEParamGetTiposOpcional);
		break;
	case SOAP_TYPE___afip5__FEParamGetTiposConcepto:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip5__FEParamGetTiposConcepto*>(p->ptr), struct __afip5__FEParamGetTiposConcepto);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip5__FEParamGetTiposConcepto*>(p->ptr), struct __afip5__FEParamGetTiposConcepto);
		break;
	case SOAP_TYPE___afip5__FEParamGetPtosVenta:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip5__FEParamGetPtosVenta*>(p->ptr), struct __afip5__FEParamGetPtosVenta);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip5__FEParamGetPtosVenta*>(p->ptr), struct __afip5__FEParamGetPtosVenta);
		break;
	case SOAP_TYPE___afip5__FEParamGetTiposCbte:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip5__FEParamGetTiposCbte*>(p->ptr), struct __afip5__FEParamGetTiposCbte);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip5__FEParamGetTiposCbte*>(p->ptr), struct __afip5__FEParamGetTiposCbte);
		break;
	case SOAP_TYPE___afip5__FEParamGetTiposDoc:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip5__FEParamGetTiposDoc*>(p->ptr), struct __afip5__FEParamGetTiposDoc);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip5__FEParamGetTiposDoc*>(p->ptr), struct __afip5__FEParamGetTiposDoc);
		break;
	case SOAP_TYPE___afip5__FEParamGetTiposPaises:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __afip5__FEParamGetTiposPaises*>(p->ptr), struct __afip5__FEParamGetTiposPaises);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __afip5__FEParamGetTiposPaises*>(p->ptr), struct __afip5__FEParamGetTiposPaises);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		break;
#endif
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__PaisTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<afip3__PaisTipo *> *>(p->ptr), std::vector<afip3__PaisTipo *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<afip3__PaisTipo *> *>(p->ptr), std::vector<afip3__PaisTipo *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__DocTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<afip3__DocTipo *> *>(p->ptr), std::vector<afip3__DocTipo *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<afip3__DocTipo *> *>(p->ptr), std::vector<afip3__DocTipo *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__CbteTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<afip3__CbteTipo *> *>(p->ptr), std::vector<afip3__CbteTipo *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<afip3__CbteTipo *> *>(p->ptr), std::vector<afip3__CbteTipo *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__PtoVenta:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<afip3__PtoVenta *> *>(p->ptr), std::vector<afip3__PtoVenta *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<afip3__PtoVenta *> *>(p->ptr), std::vector<afip3__PtoVenta *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__ConceptoTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<afip3__ConceptoTipo *> *>(p->ptr), std::vector<afip3__ConceptoTipo *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<afip3__ConceptoTipo *> *>(p->ptr), std::vector<afip3__ConceptoTipo *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__OpcionalTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<afip3__OpcionalTipo *> *>(p->ptr), std::vector<afip3__OpcionalTipo *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<afip3__OpcionalTipo *> *>(p->ptr), std::vector<afip3__OpcionalTipo *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__IvaTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<afip3__IvaTipo *> *>(p->ptr), std::vector<afip3__IvaTipo *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<afip3__IvaTipo *> *>(p->ptr), std::vector<afip3__IvaTipo *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Moneda:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<afip3__Moneda *> *>(p->ptr), std::vector<afip3__Moneda *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<afip3__Moneda *> *>(p->ptr), std::vector<afip3__Moneda *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__TributoTipo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<afip3__TributoTipo *> *>(p->ptr), std::vector<afip3__TributoTipo *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<afip3__TributoTipo *> *>(p->ptr), std::vector<afip3__TributoTipo *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEASinMov:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<afip3__FECAEASinMov *> *>(p->ptr), std::vector<afip3__FECAEASinMov *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<afip3__FECAEASinMov *> *>(p->ptr), std::vector<afip3__FECAEASinMov *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEADetResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<afip3__FECAEADetResponse *> *>(p->ptr), std::vector<afip3__FECAEADetResponse *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<afip3__FECAEADetResponse *> *>(p->ptr), std::vector<afip3__FECAEADetResponse *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEADetRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<afip3__FECAEADetRequest *> *>(p->ptr), std::vector<afip3__FECAEADetRequest *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<afip3__FECAEADetRequest *> *>(p->ptr), std::vector<afip3__FECAEADetRequest *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Err:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<afip3__Err *> *>(p->ptr), std::vector<afip3__Err *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<afip3__Err *> *>(p->ptr), std::vector<afip3__Err *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Evt:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<afip3__Evt *> *>(p->ptr), std::vector<afip3__Evt *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<afip3__Evt *> *>(p->ptr), std::vector<afip3__Evt *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Obs:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<afip3__Obs *> *>(p->ptr), std::vector<afip3__Obs *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<afip3__Obs *> *>(p->ptr), std::vector<afip3__Obs *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEDetResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<afip3__FECAEDetResponse *> *>(p->ptr), std::vector<afip3__FECAEDetResponse *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<afip3__FECAEDetResponse *> *>(p->ptr), std::vector<afip3__FECAEDetResponse *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Comprador:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<afip3__Comprador *> *>(p->ptr), std::vector<afip3__Comprador *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<afip3__Comprador *> *>(p->ptr), std::vector<afip3__Comprador *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Opcional:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<afip3__Opcional *> *>(p->ptr), std::vector<afip3__Opcional *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<afip3__Opcional *> *>(p->ptr), std::vector<afip3__Opcional *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__AlicIva:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<afip3__AlicIva *> *>(p->ptr), std::vector<afip3__AlicIva *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<afip3__AlicIva *> *>(p->ptr), std::vector<afip3__AlicIva *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Tributo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<afip3__Tributo *> *>(p->ptr), std::vector<afip3__Tributo *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<afip3__Tributo *> *>(p->ptr), std::vector<afip3__Tributo *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__CbteAsoc:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<afip3__CbteAsoc *> *>(p->ptr), std::vector<afip3__CbteAsoc *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<afip3__CbteAsoc *> *>(p->ptr), std::vector<afip3__CbteAsoc *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEDetRequest:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<afip3__FECAEDetRequest *> *>(p->ptr), std::vector<afip3__FECAEDetRequest *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<afip3__FECAEDetRequest *> *>(p->ptr), std::vector<afip3__FECAEDetRequest *> );
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{
	do
	{	switch (t)
		{

		case SOAP_TYPE_afip3__FECAECabRequest: t = SOAP_TYPE_afip3__FECabRequest; break;
		case SOAP_TYPE_afip3__FECAEDetRequest: t = SOAP_TYPE_afip3__FEDetRequest; break;
		case SOAP_TYPE_afip3__FECAECabResponse: t = SOAP_TYPE_afip3__FECabResponse; break;
		case SOAP_TYPE_afip3__FECAEDetResponse: t = SOAP_TYPE_afip3__FEDetResponse; break;
		case SOAP_TYPE_afip3__FECAEACabRequest: t = SOAP_TYPE_afip3__FECabRequest; break;
		case SOAP_TYPE_afip3__FECAEADetRequest: t = SOAP_TYPE_afip3__FEDetRequest; break;
		case SOAP_TYPE_afip3__FECAEACabResponse: t = SOAP_TYPE_afip3__FECabResponse; break;
		case SOAP_TYPE_afip3__FECAEADetResponse: t = SOAP_TYPE_afip3__FEDetResponse; break;
		case SOAP_TYPE_afip3__FECAEASinMovResponse: t = SOAP_TYPE_afip3__FECAEASinMov; break;
		case SOAP_TYPE_afip3__FECompConsResponse: t = SOAP_TYPE_afip3__FECAEDetRequest; break;
		default: return 0;
		}
	}
	while (t != b);
	return 1;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__PaisTipo:
		if (t == SOAP_TYPE_afip3__PaisTipo || soap_fbase(t, SOAP_TYPE_afip3__PaisTipo))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<afip3__PaisTipo *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<afip3__PaisTipo *> *)p)[index] = *(afip3__PaisTipo **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__DocTipo:
		if (t == SOAP_TYPE_afip3__DocTipo || soap_fbase(t, SOAP_TYPE_afip3__DocTipo))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<afip3__DocTipo *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<afip3__DocTipo *> *)p)[index] = *(afip3__DocTipo **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__CbteTipo:
		if (t == SOAP_TYPE_afip3__CbteTipo || soap_fbase(t, SOAP_TYPE_afip3__CbteTipo))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<afip3__CbteTipo *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<afip3__CbteTipo *> *)p)[index] = *(afip3__CbteTipo **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__PtoVenta:
		if (t == SOAP_TYPE_afip3__PtoVenta || soap_fbase(t, SOAP_TYPE_afip3__PtoVenta))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<afip3__PtoVenta *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<afip3__PtoVenta *> *)p)[index] = *(afip3__PtoVenta **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__ConceptoTipo:
		if (t == SOAP_TYPE_afip3__ConceptoTipo || soap_fbase(t, SOAP_TYPE_afip3__ConceptoTipo))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<afip3__ConceptoTipo *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<afip3__ConceptoTipo *> *)p)[index] = *(afip3__ConceptoTipo **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__OpcionalTipo:
		if (t == SOAP_TYPE_afip3__OpcionalTipo || soap_fbase(t, SOAP_TYPE_afip3__OpcionalTipo))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<afip3__OpcionalTipo *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<afip3__OpcionalTipo *> *)p)[index] = *(afip3__OpcionalTipo **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__IvaTipo:
		if (t == SOAP_TYPE_afip3__IvaTipo || soap_fbase(t, SOAP_TYPE_afip3__IvaTipo))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<afip3__IvaTipo *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<afip3__IvaTipo *> *)p)[index] = *(afip3__IvaTipo **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Moneda:
		if (t == SOAP_TYPE_afip3__Moneda || soap_fbase(t, SOAP_TYPE_afip3__Moneda))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<afip3__Moneda *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<afip3__Moneda *> *)p)[index] = *(afip3__Moneda **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__TributoTipo:
		if (t == SOAP_TYPE_afip3__TributoTipo || soap_fbase(t, SOAP_TYPE_afip3__TributoTipo))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<afip3__TributoTipo *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<afip3__TributoTipo *> *)p)[index] = *(afip3__TributoTipo **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEASinMov:
		if (t == SOAP_TYPE_afip3__FECAEASinMov || soap_fbase(t, SOAP_TYPE_afip3__FECAEASinMov))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<afip3__FECAEASinMov *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<afip3__FECAEASinMov *> *)p)[index] = *(afip3__FECAEASinMov **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEADetResponse:
		if (t == SOAP_TYPE_afip3__FECAEADetResponse || soap_fbase(t, SOAP_TYPE_afip3__FECAEADetResponse))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<afip3__FECAEADetResponse *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<afip3__FECAEADetResponse *> *)p)[index] = *(afip3__FECAEADetResponse **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEADetRequest:
		if (t == SOAP_TYPE_afip3__FECAEADetRequest || soap_fbase(t, SOAP_TYPE_afip3__FECAEADetRequest))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<afip3__FECAEADetRequest *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<afip3__FECAEADetRequest *> *)p)[index] = *(afip3__FECAEADetRequest **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Err:
		if (t == SOAP_TYPE_afip3__Err || soap_fbase(t, SOAP_TYPE_afip3__Err))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<afip3__Err *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<afip3__Err *> *)p)[index] = *(afip3__Err **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Evt:
		if (t == SOAP_TYPE_afip3__Evt || soap_fbase(t, SOAP_TYPE_afip3__Evt))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<afip3__Evt *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<afip3__Evt *> *)p)[index] = *(afip3__Evt **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Obs:
		if (t == SOAP_TYPE_afip3__Obs || soap_fbase(t, SOAP_TYPE_afip3__Obs))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<afip3__Obs *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<afip3__Obs *> *)p)[index] = *(afip3__Obs **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEDetResponse:
		if (t == SOAP_TYPE_afip3__FECAEDetResponse || soap_fbase(t, SOAP_TYPE_afip3__FECAEDetResponse))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<afip3__FECAEDetResponse *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<afip3__FECAEDetResponse *> *)p)[index] = *(afip3__FECAEDetResponse **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Comprador:
		if (t == SOAP_TYPE_afip3__Comprador || soap_fbase(t, SOAP_TYPE_afip3__Comprador))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<afip3__Comprador *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<afip3__Comprador *> *)p)[index] = *(afip3__Comprador **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Opcional:
		if (t == SOAP_TYPE_afip3__Opcional || soap_fbase(t, SOAP_TYPE_afip3__Opcional))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<afip3__Opcional *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<afip3__Opcional *> *)p)[index] = *(afip3__Opcional **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__AlicIva:
		if (t == SOAP_TYPE_afip3__AlicIva || soap_fbase(t, SOAP_TYPE_afip3__AlicIva))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<afip3__AlicIva *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<afip3__AlicIva *> *)p)[index] = *(afip3__AlicIva **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Tributo:
		if (t == SOAP_TYPE_afip3__Tributo || soap_fbase(t, SOAP_TYPE_afip3__Tributo))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<afip3__Tributo *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<afip3__Tributo *> *)p)[index] = *(afip3__Tributo **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__CbteAsoc:
		if (t == SOAP_TYPE_afip3__CbteAsoc || soap_fbase(t, SOAP_TYPE_afip3__CbteAsoc))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<afip3__CbteAsoc *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<afip3__CbteAsoc *> *)p)[index] = *(afip3__CbteAsoc **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEDetRequest:
		if (t == SOAP_TYPE_afip3__FECAEDetRequest || soap_fbase(t, SOAP_TYPE_afip3__FECAEDetRequest))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<afip3__FECAEDetRequest *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<afip3__FECAEDetRequest *> *)p)[index] = *(afip3__FECAEDetRequest **)q;
		}
		break;
	case SOAP_TYPE_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE__afip1__loginCms:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip1__loginCms type=%d location=%p object=%p\n", t, p, q));
		*(_afip1__loginCms*)p = *(_afip1__loginCms*)q;
		break;
	case SOAP_TYPE__afip1__loginCmsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip1__loginCmsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_afip1__loginCmsResponse*)p = *(_afip1__loginCmsResponse*)q;
		break;
	case SOAP_TYPE_afip2__LoginFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip2__LoginFault type=%d location=%p object=%p\n", t, p, q));
		*(afip2__LoginFault*)p = *(afip2__LoginFault*)q;
		break;
	case SOAP_TYPE_afip3__FEAuthRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__FEAuthRequest type=%d location=%p object=%p\n", t, p, q));
		*(afip3__FEAuthRequest*)p = *(afip3__FEAuthRequest*)q;
		break;
	case SOAP_TYPE_afip3__FECAERequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__FECAERequest type=%d location=%p object=%p\n", t, p, q));
		*(afip3__FECAERequest*)p = *(afip3__FECAERequest*)q;
		break;
	case SOAP_TYPE_afip3__FECabRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__FECabRequest type=%d location=%p object=%p\n", t, p, q));
		*(afip3__FECabRequest*)p = *(afip3__FECabRequest*)q;
		break;
	case SOAP_TYPE_afip3__ArrayOfFECAEDetRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__ArrayOfFECAEDetRequest type=%d location=%p object=%p\n", t, p, q));
		*(afip3__ArrayOfFECAEDetRequest*)p = *(afip3__ArrayOfFECAEDetRequest*)q;
		break;
	case SOAP_TYPE_afip3__FEDetRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__FEDetRequest type=%d location=%p object=%p\n", t, p, q));
		*(afip3__FEDetRequest*)p = *(afip3__FEDetRequest*)q;
		break;
	case SOAP_TYPE_afip3__ArrayOfCbteAsoc:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__ArrayOfCbteAsoc type=%d location=%p object=%p\n", t, p, q));
		*(afip3__ArrayOfCbteAsoc*)p = *(afip3__ArrayOfCbteAsoc*)q;
		break;
	case SOAP_TYPE_afip3__CbteAsoc:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__CbteAsoc type=%d location=%p object=%p\n", t, p, q));
		*(afip3__CbteAsoc*)p = *(afip3__CbteAsoc*)q;
		break;
	case SOAP_TYPE_afip3__ArrayOfTributo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__ArrayOfTributo type=%d location=%p object=%p\n", t, p, q));
		*(afip3__ArrayOfTributo*)p = *(afip3__ArrayOfTributo*)q;
		break;
	case SOAP_TYPE_afip3__Tributo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__Tributo type=%d location=%p object=%p\n", t, p, q));
		*(afip3__Tributo*)p = *(afip3__Tributo*)q;
		break;
	case SOAP_TYPE_afip3__ArrayOfAlicIva:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__ArrayOfAlicIva type=%d location=%p object=%p\n", t, p, q));
		*(afip3__ArrayOfAlicIva*)p = *(afip3__ArrayOfAlicIva*)q;
		break;
	case SOAP_TYPE_afip3__AlicIva:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__AlicIva type=%d location=%p object=%p\n", t, p, q));
		*(afip3__AlicIva*)p = *(afip3__AlicIva*)q;
		break;
	case SOAP_TYPE_afip3__ArrayOfOpcional:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__ArrayOfOpcional type=%d location=%p object=%p\n", t, p, q));
		*(afip3__ArrayOfOpcional*)p = *(afip3__ArrayOfOpcional*)q;
		break;
	case SOAP_TYPE_afip3__Opcional:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__Opcional type=%d location=%p object=%p\n", t, p, q));
		*(afip3__Opcional*)p = *(afip3__Opcional*)q;
		break;
	case SOAP_TYPE_afip3__ArrayOfComprador:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__ArrayOfComprador type=%d location=%p object=%p\n", t, p, q));
		*(afip3__ArrayOfComprador*)p = *(afip3__ArrayOfComprador*)q;
		break;
	case SOAP_TYPE_afip3__Comprador:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__Comprador type=%d location=%p object=%p\n", t, p, q));
		*(afip3__Comprador*)p = *(afip3__Comprador*)q;
		break;
	case SOAP_TYPE_afip3__FECAEResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__FECAEResponse type=%d location=%p object=%p\n", t, p, q));
		*(afip3__FECAEResponse*)p = *(afip3__FECAEResponse*)q;
		break;
	case SOAP_TYPE_afip3__FECabResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__FECabResponse type=%d location=%p object=%p\n", t, p, q));
		*(afip3__FECabResponse*)p = *(afip3__FECabResponse*)q;
		break;
	case SOAP_TYPE_afip3__ArrayOfFECAEDetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__ArrayOfFECAEDetResponse type=%d location=%p object=%p\n", t, p, q));
		*(afip3__ArrayOfFECAEDetResponse*)p = *(afip3__ArrayOfFECAEDetResponse*)q;
		break;
	case SOAP_TYPE_afip3__FEDetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__FEDetResponse type=%d location=%p object=%p\n", t, p, q));
		*(afip3__FEDetResponse*)p = *(afip3__FEDetResponse*)q;
		break;
	case SOAP_TYPE_afip3__ArrayOfObs:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__ArrayOfObs type=%d location=%p object=%p\n", t, p, q));
		*(afip3__ArrayOfObs*)p = *(afip3__ArrayOfObs*)q;
		break;
	case SOAP_TYPE_afip3__Obs:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__Obs type=%d location=%p object=%p\n", t, p, q));
		*(afip3__Obs*)p = *(afip3__Obs*)q;
		break;
	case SOAP_TYPE_afip3__ArrayOfEvt:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__ArrayOfEvt type=%d location=%p object=%p\n", t, p, q));
		*(afip3__ArrayOfEvt*)p = *(afip3__ArrayOfEvt*)q;
		break;
	case SOAP_TYPE_afip3__Evt:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__Evt type=%d location=%p object=%p\n", t, p, q));
		*(afip3__Evt*)p = *(afip3__Evt*)q;
		break;
	case SOAP_TYPE_afip3__ArrayOfErr:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__ArrayOfErr type=%d location=%p object=%p\n", t, p, q));
		*(afip3__ArrayOfErr*)p = *(afip3__ArrayOfErr*)q;
		break;
	case SOAP_TYPE_afip3__Err:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__Err type=%d location=%p object=%p\n", t, p, q));
		*(afip3__Err*)p = *(afip3__Err*)q;
		break;
	case SOAP_TYPE_afip3__FERegXReqResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__FERegXReqResponse type=%d location=%p object=%p\n", t, p, q));
		*(afip3__FERegXReqResponse*)p = *(afip3__FERegXReqResponse*)q;
		break;
	case SOAP_TYPE_afip3__DummyResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__DummyResponse type=%d location=%p object=%p\n", t, p, q));
		*(afip3__DummyResponse*)p = *(afip3__DummyResponse*)q;
		break;
	case SOAP_TYPE_afip3__FERecuperaLastCbteResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__FERecuperaLastCbteResponse type=%d location=%p object=%p\n", t, p, q));
		*(afip3__FERecuperaLastCbteResponse*)p = *(afip3__FERecuperaLastCbteResponse*)q;
		break;
	case SOAP_TYPE_afip3__FECompConsultaReq:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__FECompConsultaReq type=%d location=%p object=%p\n", t, p, q));
		*(afip3__FECompConsultaReq*)p = *(afip3__FECompConsultaReq*)q;
		break;
	case SOAP_TYPE_afip3__FECompConsultaResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__FECompConsultaResponse type=%d location=%p object=%p\n", t, p, q));
		*(afip3__FECompConsultaResponse*)p = *(afip3__FECompConsultaResponse*)q;
		break;
	case SOAP_TYPE_afip3__FECAEARequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__FECAEARequest type=%d location=%p object=%p\n", t, p, q));
		*(afip3__FECAEARequest*)p = *(afip3__FECAEARequest*)q;
		break;
	case SOAP_TYPE_afip3__ArrayOfFECAEADetRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__ArrayOfFECAEADetRequest type=%d location=%p object=%p\n", t, p, q));
		*(afip3__ArrayOfFECAEADetRequest*)p = *(afip3__ArrayOfFECAEADetRequest*)q;
		break;
	case SOAP_TYPE_afip3__FECAEAResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__FECAEAResponse type=%d location=%p object=%p\n", t, p, q));
		*(afip3__FECAEAResponse*)p = *(afip3__FECAEAResponse*)q;
		break;
	case SOAP_TYPE_afip3__ArrayOfFECAEADetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__ArrayOfFECAEADetResponse type=%d location=%p object=%p\n", t, p, q));
		*(afip3__ArrayOfFECAEADetResponse*)p = *(afip3__ArrayOfFECAEADetResponse*)q;
		break;
	case SOAP_TYPE_afip3__FECAEAGetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__FECAEAGetResponse type=%d location=%p object=%p\n", t, p, q));
		*(afip3__FECAEAGetResponse*)p = *(afip3__FECAEAGetResponse*)q;
		break;
	case SOAP_TYPE_afip3__FECAEAGet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__FECAEAGet type=%d location=%p object=%p\n", t, p, q));
		*(afip3__FECAEAGet*)p = *(afip3__FECAEAGet*)q;
		break;
	case SOAP_TYPE_afip3__FECAEASinMovConsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__FECAEASinMovConsResponse type=%d location=%p object=%p\n", t, p, q));
		*(afip3__FECAEASinMovConsResponse*)p = *(afip3__FECAEASinMovConsResponse*)q;
		break;
	case SOAP_TYPE_afip3__ArrayOfFECAEASinMov:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__ArrayOfFECAEASinMov type=%d location=%p object=%p\n", t, p, q));
		*(afip3__ArrayOfFECAEASinMov*)p = *(afip3__ArrayOfFECAEASinMov*)q;
		break;
	case SOAP_TYPE_afip3__FECAEASinMov:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__FECAEASinMov type=%d location=%p object=%p\n", t, p, q));
		*(afip3__FECAEASinMov*)p = *(afip3__FECAEASinMov*)q;
		break;
	case SOAP_TYPE_afip3__FECotizacionResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__FECotizacionResponse type=%d location=%p object=%p\n", t, p, q));
		*(afip3__FECotizacionResponse*)p = *(afip3__FECotizacionResponse*)q;
		break;
	case SOAP_TYPE_afip3__Cotizacion:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__Cotizacion type=%d location=%p object=%p\n", t, p, q));
		*(afip3__Cotizacion*)p = *(afip3__Cotizacion*)q;
		break;
	case SOAP_TYPE_afip3__FETributoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__FETributoResponse type=%d location=%p object=%p\n", t, p, q));
		*(afip3__FETributoResponse*)p = *(afip3__FETributoResponse*)q;
		break;
	case SOAP_TYPE_afip3__ArrayOfTributoTipo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__ArrayOfTributoTipo type=%d location=%p object=%p\n", t, p, q));
		*(afip3__ArrayOfTributoTipo*)p = *(afip3__ArrayOfTributoTipo*)q;
		break;
	case SOAP_TYPE_afip3__TributoTipo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__TributoTipo type=%d location=%p object=%p\n", t, p, q));
		*(afip3__TributoTipo*)p = *(afip3__TributoTipo*)q;
		break;
	case SOAP_TYPE_afip3__MonedaResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__MonedaResponse type=%d location=%p object=%p\n", t, p, q));
		*(afip3__MonedaResponse*)p = *(afip3__MonedaResponse*)q;
		break;
	case SOAP_TYPE_afip3__ArrayOfMoneda:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__ArrayOfMoneda type=%d location=%p object=%p\n", t, p, q));
		*(afip3__ArrayOfMoneda*)p = *(afip3__ArrayOfMoneda*)q;
		break;
	case SOAP_TYPE_afip3__Moneda:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__Moneda type=%d location=%p object=%p\n", t, p, q));
		*(afip3__Moneda*)p = *(afip3__Moneda*)q;
		break;
	case SOAP_TYPE_afip3__IvaTipoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__IvaTipoResponse type=%d location=%p object=%p\n", t, p, q));
		*(afip3__IvaTipoResponse*)p = *(afip3__IvaTipoResponse*)q;
		break;
	case SOAP_TYPE_afip3__ArrayOfIvaTipo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__ArrayOfIvaTipo type=%d location=%p object=%p\n", t, p, q));
		*(afip3__ArrayOfIvaTipo*)p = *(afip3__ArrayOfIvaTipo*)q;
		break;
	case SOAP_TYPE_afip3__IvaTipo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__IvaTipo type=%d location=%p object=%p\n", t, p, q));
		*(afip3__IvaTipo*)p = *(afip3__IvaTipo*)q;
		break;
	case SOAP_TYPE_afip3__OpcionalTipoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__OpcionalTipoResponse type=%d location=%p object=%p\n", t, p, q));
		*(afip3__OpcionalTipoResponse*)p = *(afip3__OpcionalTipoResponse*)q;
		break;
	case SOAP_TYPE_afip3__ArrayOfOpcionalTipo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__ArrayOfOpcionalTipo type=%d location=%p object=%p\n", t, p, q));
		*(afip3__ArrayOfOpcionalTipo*)p = *(afip3__ArrayOfOpcionalTipo*)q;
		break;
	case SOAP_TYPE_afip3__OpcionalTipo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__OpcionalTipo type=%d location=%p object=%p\n", t, p, q));
		*(afip3__OpcionalTipo*)p = *(afip3__OpcionalTipo*)q;
		break;
	case SOAP_TYPE_afip3__ConceptoTipoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__ConceptoTipoResponse type=%d location=%p object=%p\n", t, p, q));
		*(afip3__ConceptoTipoResponse*)p = *(afip3__ConceptoTipoResponse*)q;
		break;
	case SOAP_TYPE_afip3__ArrayOfConceptoTipo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__ArrayOfConceptoTipo type=%d location=%p object=%p\n", t, p, q));
		*(afip3__ArrayOfConceptoTipo*)p = *(afip3__ArrayOfConceptoTipo*)q;
		break;
	case SOAP_TYPE_afip3__ConceptoTipo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__ConceptoTipo type=%d location=%p object=%p\n", t, p, q));
		*(afip3__ConceptoTipo*)p = *(afip3__ConceptoTipo*)q;
		break;
	case SOAP_TYPE_afip3__FEPtoVentaResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__FEPtoVentaResponse type=%d location=%p object=%p\n", t, p, q));
		*(afip3__FEPtoVentaResponse*)p = *(afip3__FEPtoVentaResponse*)q;
		break;
	case SOAP_TYPE_afip3__ArrayOfPtoVenta:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__ArrayOfPtoVenta type=%d location=%p object=%p\n", t, p, q));
		*(afip3__ArrayOfPtoVenta*)p = *(afip3__ArrayOfPtoVenta*)q;
		break;
	case SOAP_TYPE_afip3__PtoVenta:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__PtoVenta type=%d location=%p object=%p\n", t, p, q));
		*(afip3__PtoVenta*)p = *(afip3__PtoVenta*)q;
		break;
	case SOAP_TYPE_afip3__CbteTipoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__CbteTipoResponse type=%d location=%p object=%p\n", t, p, q));
		*(afip3__CbteTipoResponse*)p = *(afip3__CbteTipoResponse*)q;
		break;
	case SOAP_TYPE_afip3__ArrayOfCbteTipo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__ArrayOfCbteTipo type=%d location=%p object=%p\n", t, p, q));
		*(afip3__ArrayOfCbteTipo*)p = *(afip3__ArrayOfCbteTipo*)q;
		break;
	case SOAP_TYPE_afip3__CbteTipo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__CbteTipo type=%d location=%p object=%p\n", t, p, q));
		*(afip3__CbteTipo*)p = *(afip3__CbteTipo*)q;
		break;
	case SOAP_TYPE_afip3__DocTipoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__DocTipoResponse type=%d location=%p object=%p\n", t, p, q));
		*(afip3__DocTipoResponse*)p = *(afip3__DocTipoResponse*)q;
		break;
	case SOAP_TYPE_afip3__ArrayOfDocTipo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__ArrayOfDocTipo type=%d location=%p object=%p\n", t, p, q));
		*(afip3__ArrayOfDocTipo*)p = *(afip3__ArrayOfDocTipo*)q;
		break;
	case SOAP_TYPE_afip3__DocTipo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__DocTipo type=%d location=%p object=%p\n", t, p, q));
		*(afip3__DocTipo*)p = *(afip3__DocTipo*)q;
		break;
	case SOAP_TYPE_afip3__FEPaisResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__FEPaisResponse type=%d location=%p object=%p\n", t, p, q));
		*(afip3__FEPaisResponse*)p = *(afip3__FEPaisResponse*)q;
		break;
	case SOAP_TYPE_afip3__ArrayOfPaisTipo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__ArrayOfPaisTipo type=%d location=%p object=%p\n", t, p, q));
		*(afip3__ArrayOfPaisTipo*)p = *(afip3__ArrayOfPaisTipo*)q;
		break;
	case SOAP_TYPE_afip3__PaisTipo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__PaisTipo type=%d location=%p object=%p\n", t, p, q));
		*(afip3__PaisTipo*)p = *(afip3__PaisTipo*)q;
		break;
	case SOAP_TYPE__afip3__FECAESolicitar:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FECAESolicitar type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FECAESolicitar*)p = *(_afip3__FECAESolicitar*)q;
		break;
	case SOAP_TYPE__afip3__FECAESolicitarResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FECAESolicitarResponse type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FECAESolicitarResponse*)p = *(_afip3__FECAESolicitarResponse*)q;
		break;
	case SOAP_TYPE__afip3__FECompTotXRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FECompTotXRequest type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FECompTotXRequest*)p = *(_afip3__FECompTotXRequest*)q;
		break;
	case SOAP_TYPE__afip3__FECompTotXRequestResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FECompTotXRequestResponse type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FECompTotXRequestResponse*)p = *(_afip3__FECompTotXRequestResponse*)q;
		break;
	case SOAP_TYPE__afip3__FEDummy:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FEDummy type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FEDummy*)p = *(_afip3__FEDummy*)q;
		break;
	case SOAP_TYPE__afip3__FEDummyResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FEDummyResponse type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FEDummyResponse*)p = *(_afip3__FEDummyResponse*)q;
		break;
	case SOAP_TYPE__afip3__FECompUltimoAutorizado:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FECompUltimoAutorizado type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FECompUltimoAutorizado*)p = *(_afip3__FECompUltimoAutorizado*)q;
		break;
	case SOAP_TYPE__afip3__FECompUltimoAutorizadoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FECompUltimoAutorizadoResponse type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FECompUltimoAutorizadoResponse*)p = *(_afip3__FECompUltimoAutorizadoResponse*)q;
		break;
	case SOAP_TYPE__afip3__FECompConsultar:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FECompConsultar type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FECompConsultar*)p = *(_afip3__FECompConsultar*)q;
		break;
	case SOAP_TYPE__afip3__FECompConsultarResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FECompConsultarResponse type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FECompConsultarResponse*)p = *(_afip3__FECompConsultarResponse*)q;
		break;
	case SOAP_TYPE__afip3__FECAEARegInformativo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FECAEARegInformativo type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FECAEARegInformativo*)p = *(_afip3__FECAEARegInformativo*)q;
		break;
	case SOAP_TYPE__afip3__FECAEARegInformativoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FECAEARegInformativoResponse type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FECAEARegInformativoResponse*)p = *(_afip3__FECAEARegInformativoResponse*)q;
		break;
	case SOAP_TYPE__afip3__FECAEASolicitar:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FECAEASolicitar type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FECAEASolicitar*)p = *(_afip3__FECAEASolicitar*)q;
		break;
	case SOAP_TYPE__afip3__FECAEASolicitarResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FECAEASolicitarResponse type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FECAEASolicitarResponse*)p = *(_afip3__FECAEASolicitarResponse*)q;
		break;
	case SOAP_TYPE__afip3__FECAEASinMovimientoConsultar:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FECAEASinMovimientoConsultar type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FECAEASinMovimientoConsultar*)p = *(_afip3__FECAEASinMovimientoConsultar*)q;
		break;
	case SOAP_TYPE__afip3__FECAEASinMovimientoConsultarResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FECAEASinMovimientoConsultarResponse type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FECAEASinMovimientoConsultarResponse*)p = *(_afip3__FECAEASinMovimientoConsultarResponse*)q;
		break;
	case SOAP_TYPE__afip3__FECAEASinMovimientoInformar:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FECAEASinMovimientoInformar type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FECAEASinMovimientoInformar*)p = *(_afip3__FECAEASinMovimientoInformar*)q;
		break;
	case SOAP_TYPE__afip3__FECAEASinMovimientoInformarResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FECAEASinMovimientoInformarResponse type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FECAEASinMovimientoInformarResponse*)p = *(_afip3__FECAEASinMovimientoInformarResponse*)q;
		break;
	case SOAP_TYPE__afip3__FECAEAConsultar:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FECAEAConsultar type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FECAEAConsultar*)p = *(_afip3__FECAEAConsultar*)q;
		break;
	case SOAP_TYPE__afip3__FECAEAConsultarResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FECAEAConsultarResponse type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FECAEAConsultarResponse*)p = *(_afip3__FECAEAConsultarResponse*)q;
		break;
	case SOAP_TYPE__afip3__FEParamGetCotizacion:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FEParamGetCotizacion type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FEParamGetCotizacion*)p = *(_afip3__FEParamGetCotizacion*)q;
		break;
	case SOAP_TYPE__afip3__FEParamGetCotizacionResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FEParamGetCotizacionResponse type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FEParamGetCotizacionResponse*)p = *(_afip3__FEParamGetCotizacionResponse*)q;
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposTributos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FEParamGetTiposTributos type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FEParamGetTiposTributos*)p = *(_afip3__FEParamGetTiposTributos*)q;
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposTributosResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FEParamGetTiposTributosResponse type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FEParamGetTiposTributosResponse*)p = *(_afip3__FEParamGetTiposTributosResponse*)q;
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposMonedas:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FEParamGetTiposMonedas type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FEParamGetTiposMonedas*)p = *(_afip3__FEParamGetTiposMonedas*)q;
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposMonedasResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FEParamGetTiposMonedasResponse type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FEParamGetTiposMonedasResponse*)p = *(_afip3__FEParamGetTiposMonedasResponse*)q;
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposIva:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FEParamGetTiposIva type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FEParamGetTiposIva*)p = *(_afip3__FEParamGetTiposIva*)q;
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposIvaResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FEParamGetTiposIvaResponse type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FEParamGetTiposIvaResponse*)p = *(_afip3__FEParamGetTiposIvaResponse*)q;
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposOpcional:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FEParamGetTiposOpcional type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FEParamGetTiposOpcional*)p = *(_afip3__FEParamGetTiposOpcional*)q;
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposOpcionalResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FEParamGetTiposOpcionalResponse type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FEParamGetTiposOpcionalResponse*)p = *(_afip3__FEParamGetTiposOpcionalResponse*)q;
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposConcepto:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FEParamGetTiposConcepto type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FEParamGetTiposConcepto*)p = *(_afip3__FEParamGetTiposConcepto*)q;
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposConceptoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FEParamGetTiposConceptoResponse type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FEParamGetTiposConceptoResponse*)p = *(_afip3__FEParamGetTiposConceptoResponse*)q;
		break;
	case SOAP_TYPE__afip3__FEParamGetPtosVenta:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FEParamGetPtosVenta type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FEParamGetPtosVenta*)p = *(_afip3__FEParamGetPtosVenta*)q;
		break;
	case SOAP_TYPE__afip3__FEParamGetPtosVentaResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FEParamGetPtosVentaResponse type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FEParamGetPtosVentaResponse*)p = *(_afip3__FEParamGetPtosVentaResponse*)q;
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposCbte:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FEParamGetTiposCbte type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FEParamGetTiposCbte*)p = *(_afip3__FEParamGetTiposCbte*)q;
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposCbteResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FEParamGetTiposCbteResponse type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FEParamGetTiposCbteResponse*)p = *(_afip3__FEParamGetTiposCbteResponse*)q;
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposDoc:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FEParamGetTiposDoc type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FEParamGetTiposDoc*)p = *(_afip3__FEParamGetTiposDoc*)q;
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposDocResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FEParamGetTiposDocResponse type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FEParamGetTiposDocResponse*)p = *(_afip3__FEParamGetTiposDocResponse*)q;
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposPaises:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FEParamGetTiposPaises type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FEParamGetTiposPaises*)p = *(_afip3__FEParamGetTiposPaises*)q;
		break;
	case SOAP_TYPE__afip3__FEParamGetTiposPaisesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _afip3__FEParamGetTiposPaisesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_afip3__FEParamGetTiposPaisesResponse*)p = *(_afip3__FEParamGetTiposPaisesResponse*)q;
		break;
	case SOAP_TYPE_afip3__FECAECabRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__FECAECabRequest type=%d location=%p object=%p\n", t, p, q));
		*(afip3__FECAECabRequest*)p = *(afip3__FECAECabRequest*)q;
		break;
	case SOAP_TYPE_afip3__FECAEDetRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__FECAEDetRequest type=%d location=%p object=%p\n", t, p, q));
		*(afip3__FECAEDetRequest*)p = *(afip3__FECAEDetRequest*)q;
		break;
	case SOAP_TYPE_afip3__FECAECabResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__FECAECabResponse type=%d location=%p object=%p\n", t, p, q));
		*(afip3__FECAECabResponse*)p = *(afip3__FECAECabResponse*)q;
		break;
	case SOAP_TYPE_afip3__FECAEDetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__FECAEDetResponse type=%d location=%p object=%p\n", t, p, q));
		*(afip3__FECAEDetResponse*)p = *(afip3__FECAEDetResponse*)q;
		break;
	case SOAP_TYPE_afip3__FECAEACabRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__FECAEACabRequest type=%d location=%p object=%p\n", t, p, q));
		*(afip3__FECAEACabRequest*)p = *(afip3__FECAEACabRequest*)q;
		break;
	case SOAP_TYPE_afip3__FECAEADetRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__FECAEADetRequest type=%d location=%p object=%p\n", t, p, q));
		*(afip3__FECAEADetRequest*)p = *(afip3__FECAEADetRequest*)q;
		break;
	case SOAP_TYPE_afip3__FECAEACabResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__FECAEACabResponse type=%d location=%p object=%p\n", t, p, q));
		*(afip3__FECAEACabResponse*)p = *(afip3__FECAEACabResponse*)q;
		break;
	case SOAP_TYPE_afip3__FECAEADetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__FECAEADetResponse type=%d location=%p object=%p\n", t, p, q));
		*(afip3__FECAEADetResponse*)p = *(afip3__FECAEADetResponse*)q;
		break;
	case SOAP_TYPE_afip3__FECAEASinMovResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__FECAEASinMovResponse type=%d location=%p object=%p\n", t, p, q));
		*(afip3__FECAEASinMovResponse*)p = *(afip3__FECAEASinMovResponse*)q;
		break;
	case SOAP_TYPE_afip3__FECompConsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy afip3__FECompConsResponse type=%d location=%p object=%p\n", t, p, q));
		*(afip3__FECompConsResponse*)p = *(afip3__FECompConsResponse*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
	case SOAP_TYPE___afip2__loginCms:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip2__loginCms type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip2__loginCms*)p = *(struct __afip2__loginCms*)q;
		break;
	case SOAP_TYPE___afip4__FECAESolicitar:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip4__FECAESolicitar type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip4__FECAESolicitar*)p = *(struct __afip4__FECAESolicitar*)q;
		break;
	case SOAP_TYPE___afip4__FECompTotXRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip4__FECompTotXRequest type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip4__FECompTotXRequest*)p = *(struct __afip4__FECompTotXRequest*)q;
		break;
	case SOAP_TYPE___afip4__FEDummy:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip4__FEDummy type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip4__FEDummy*)p = *(struct __afip4__FEDummy*)q;
		break;
	case SOAP_TYPE___afip4__FECompUltimoAutorizado:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip4__FECompUltimoAutorizado type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip4__FECompUltimoAutorizado*)p = *(struct __afip4__FECompUltimoAutorizado*)q;
		break;
	case SOAP_TYPE___afip4__FECompConsultar:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip4__FECompConsultar type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip4__FECompConsultar*)p = *(struct __afip4__FECompConsultar*)q;
		break;
	case SOAP_TYPE___afip4__FECAEARegInformativo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip4__FECAEARegInformativo type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip4__FECAEARegInformativo*)p = *(struct __afip4__FECAEARegInformativo*)q;
		break;
	case SOAP_TYPE___afip4__FECAEASolicitar:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip4__FECAEASolicitar type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip4__FECAEASolicitar*)p = *(struct __afip4__FECAEASolicitar*)q;
		break;
	case SOAP_TYPE___afip4__FECAEASinMovimientoConsultar:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip4__FECAEASinMovimientoConsultar type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip4__FECAEASinMovimientoConsultar*)p = *(struct __afip4__FECAEASinMovimientoConsultar*)q;
		break;
	case SOAP_TYPE___afip4__FECAEASinMovimientoInformar:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip4__FECAEASinMovimientoInformar type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip4__FECAEASinMovimientoInformar*)p = *(struct __afip4__FECAEASinMovimientoInformar*)q;
		break;
	case SOAP_TYPE___afip4__FECAEAConsultar:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip4__FECAEAConsultar type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip4__FECAEAConsultar*)p = *(struct __afip4__FECAEAConsultar*)q;
		break;
	case SOAP_TYPE___afip4__FEParamGetCotizacion:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip4__FEParamGetCotizacion type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip4__FEParamGetCotizacion*)p = *(struct __afip4__FEParamGetCotizacion*)q;
		break;
	case SOAP_TYPE___afip4__FEParamGetTiposTributos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip4__FEParamGetTiposTributos type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip4__FEParamGetTiposTributos*)p = *(struct __afip4__FEParamGetTiposTributos*)q;
		break;
	case SOAP_TYPE___afip4__FEParamGetTiposMonedas:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip4__FEParamGetTiposMonedas type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip4__FEParamGetTiposMonedas*)p = *(struct __afip4__FEParamGetTiposMonedas*)q;
		break;
	case SOAP_TYPE___afip4__FEParamGetTiposIva:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip4__FEParamGetTiposIva type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip4__FEParamGetTiposIva*)p = *(struct __afip4__FEParamGetTiposIva*)q;
		break;
	case SOAP_TYPE___afip4__FEParamGetTiposOpcional:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip4__FEParamGetTiposOpcional type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip4__FEParamGetTiposOpcional*)p = *(struct __afip4__FEParamGetTiposOpcional*)q;
		break;
	case SOAP_TYPE___afip4__FEParamGetTiposConcepto:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip4__FEParamGetTiposConcepto type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip4__FEParamGetTiposConcepto*)p = *(struct __afip4__FEParamGetTiposConcepto*)q;
		break;
	case SOAP_TYPE___afip4__FEParamGetPtosVenta:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip4__FEParamGetPtosVenta type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip4__FEParamGetPtosVenta*)p = *(struct __afip4__FEParamGetPtosVenta*)q;
		break;
	case SOAP_TYPE___afip4__FEParamGetTiposCbte:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip4__FEParamGetTiposCbte type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip4__FEParamGetTiposCbte*)p = *(struct __afip4__FEParamGetTiposCbte*)q;
		break;
	case SOAP_TYPE___afip4__FEParamGetTiposDoc:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip4__FEParamGetTiposDoc type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip4__FEParamGetTiposDoc*)p = *(struct __afip4__FEParamGetTiposDoc*)q;
		break;
	case SOAP_TYPE___afip4__FEParamGetTiposPaises:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip4__FEParamGetTiposPaises type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip4__FEParamGetTiposPaises*)p = *(struct __afip4__FEParamGetTiposPaises*)q;
		break;
	case SOAP_TYPE___afip5__FECAESolicitar:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip5__FECAESolicitar type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip5__FECAESolicitar*)p = *(struct __afip5__FECAESolicitar*)q;
		break;
	case SOAP_TYPE___afip5__FECompTotXRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip5__FECompTotXRequest type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip5__FECompTotXRequest*)p = *(struct __afip5__FECompTotXRequest*)q;
		break;
	case SOAP_TYPE___afip5__FEDummy:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip5__FEDummy type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip5__FEDummy*)p = *(struct __afip5__FEDummy*)q;
		break;
	case SOAP_TYPE___afip5__FECompUltimoAutorizado:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip5__FECompUltimoAutorizado type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip5__FECompUltimoAutorizado*)p = *(struct __afip5__FECompUltimoAutorizado*)q;
		break;
	case SOAP_TYPE___afip5__FECompConsultar:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip5__FECompConsultar type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip5__FECompConsultar*)p = *(struct __afip5__FECompConsultar*)q;
		break;
	case SOAP_TYPE___afip5__FECAEARegInformativo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip5__FECAEARegInformativo type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip5__FECAEARegInformativo*)p = *(struct __afip5__FECAEARegInformativo*)q;
		break;
	case SOAP_TYPE___afip5__FECAEASolicitar:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip5__FECAEASolicitar type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip5__FECAEASolicitar*)p = *(struct __afip5__FECAEASolicitar*)q;
		break;
	case SOAP_TYPE___afip5__FECAEASinMovimientoConsultar:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip5__FECAEASinMovimientoConsultar type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip5__FECAEASinMovimientoConsultar*)p = *(struct __afip5__FECAEASinMovimientoConsultar*)q;
		break;
	case SOAP_TYPE___afip5__FECAEASinMovimientoInformar:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip5__FECAEASinMovimientoInformar type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip5__FECAEASinMovimientoInformar*)p = *(struct __afip5__FECAEASinMovimientoInformar*)q;
		break;
	case SOAP_TYPE___afip5__FECAEAConsultar:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip5__FECAEAConsultar type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip5__FECAEAConsultar*)p = *(struct __afip5__FECAEAConsultar*)q;
		break;
	case SOAP_TYPE___afip5__FEParamGetCotizacion:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip5__FEParamGetCotizacion type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip5__FEParamGetCotizacion*)p = *(struct __afip5__FEParamGetCotizacion*)q;
		break;
	case SOAP_TYPE___afip5__FEParamGetTiposTributos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip5__FEParamGetTiposTributos type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip5__FEParamGetTiposTributos*)p = *(struct __afip5__FEParamGetTiposTributos*)q;
		break;
	case SOAP_TYPE___afip5__FEParamGetTiposMonedas:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip5__FEParamGetTiposMonedas type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip5__FEParamGetTiposMonedas*)p = *(struct __afip5__FEParamGetTiposMonedas*)q;
		break;
	case SOAP_TYPE___afip5__FEParamGetTiposIva:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip5__FEParamGetTiposIva type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip5__FEParamGetTiposIva*)p = *(struct __afip5__FEParamGetTiposIva*)q;
		break;
	case SOAP_TYPE___afip5__FEParamGetTiposOpcional:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip5__FEParamGetTiposOpcional type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip5__FEParamGetTiposOpcional*)p = *(struct __afip5__FEParamGetTiposOpcional*)q;
		break;
	case SOAP_TYPE___afip5__FEParamGetTiposConcepto:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip5__FEParamGetTiposConcepto type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip5__FEParamGetTiposConcepto*)p = *(struct __afip5__FEParamGetTiposConcepto*)q;
		break;
	case SOAP_TYPE___afip5__FEParamGetPtosVenta:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip5__FEParamGetPtosVenta type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip5__FEParamGetPtosVenta*)p = *(struct __afip5__FEParamGetPtosVenta*)q;
		break;
	case SOAP_TYPE___afip5__FEParamGetTiposCbte:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip5__FEParamGetTiposCbte type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip5__FEParamGetTiposCbte*)p = *(struct __afip5__FEParamGetTiposCbte*)q;
		break;
	case SOAP_TYPE___afip5__FEParamGetTiposDoc:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip5__FEParamGetTiposDoc type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip5__FEParamGetTiposDoc*)p = *(struct __afip5__FEParamGetTiposDoc*)q;
		break;
	case SOAP_TYPE___afip5__FEParamGetTiposPaises:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __afip5__FEParamGetTiposPaises type=%d location=%p object=%p\n", t, p, q));
		*(struct __afip5__FEParamGetTiposPaises*)p = *(struct __afip5__FEParamGetTiposPaises*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_short(struct soap *soap, const char *tag, int id, const short *a, const char *type)
{
	return soap_outshort(soap, tag, id, a, type, SOAP_TYPE_short);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_in_short(struct soap *soap, const char *tag, short *a, const char *type)
{
	a = soap_inshort(soap, tag, a, type, SOAP_TYPE_short);
	return a;
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_new_short(struct soap *soap, int n)
{
	short *a = static_cast<short *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(short)));
	for (short *p = a; p && n--; ++p)
		soap_default_short(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_short(struct soap *soap, const short *a, const char *tag, const char *type)
{
	if (soap_out_short(soap, tag ? tag : "short", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_get_short(struct soap *soap, short *p, const char *tag, const char *type)
{
	if ((p = soap_in_short(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	a = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return a;
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_new_LONG64(struct soap *soap, int n)
{
	LONG64 *a = static_cast<LONG64 *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(LONG64)));
	for (LONG64 *p = a; p && n--; ++p)
		soap_default_LONG64(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	if (soap_out_LONG64(soap, tag ? tag : "long", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	a = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return a;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_new_double(struct soap *soap, int n)
{
	double *a = static_cast<double *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(double)));
	for (double *p = a; p && n--; ++p)
		soap_default_double(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	if (soap_out_double(soap, tag ? tag : "double", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FEParamGetTiposPaisesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FEParamGetTiposPaisesResponse::FEParamGetTiposPaisesResult = NULL;
}

void _afip3__FEParamGetTiposPaisesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FEPaisResponse(soap, &this->_afip3__FEParamGetTiposPaisesResponse::FEParamGetTiposPaisesResult);
#endif
}

int _afip3__FEParamGetTiposPaisesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FEParamGetTiposPaisesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FEParamGetTiposPaisesResponse(struct soap *soap, const char *tag, int id, const _afip3__FEParamGetTiposPaisesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FEParamGetTiposPaisesResponse), type))
		return soap->error;
	if (a->FEParamGetTiposPaisesResult)
		soap_element_result(soap, "afip3:FEParamGetTiposPaisesResult");
	if (soap_out_PointerToafip3__FEPaisResponse(soap, "afip3:FEParamGetTiposPaisesResult", -1, &a->_afip3__FEParamGetTiposPaisesResponse::FEParamGetTiposPaisesResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FEParamGetTiposPaisesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FEParamGetTiposPaisesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FEParamGetTiposPaisesResponse * SOAP_FMAC4 soap_in__afip3__FEParamGetTiposPaisesResponse(struct soap *soap, const char *tag, _afip3__FEParamGetTiposPaisesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FEParamGetTiposPaisesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FEParamGetTiposPaisesResponse, sizeof(_afip3__FEParamGetTiposPaisesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FEParamGetTiposPaisesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FEParamGetTiposPaisesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FEParamGetTiposPaisesResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FEParamGetTiposPaisesResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FEPaisResponse(soap, "afip3:FEParamGetTiposPaisesResult", &a->_afip3__FEParamGetTiposPaisesResponse::FEParamGetTiposPaisesResult, "afip3:FEPaisResponse"))
				{	soap_flag_FEParamGetTiposPaisesResult1--;
					continue;
				}
			}
			soap_check_result(soap, "afip3:FEParamGetTiposPaisesResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FEParamGetTiposPaisesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FEParamGetTiposPaisesResponse, SOAP_TYPE__afip3__FEParamGetTiposPaisesResponse, sizeof(_afip3__FEParamGetTiposPaisesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FEParamGetTiposPaisesResponse * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetTiposPaisesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FEParamGetTiposPaisesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FEParamGetTiposPaisesResponse *p;
	size_t k = sizeof(_afip3__FEParamGetTiposPaisesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FEParamGetTiposPaisesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FEParamGetTiposPaisesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FEParamGetTiposPaisesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FEParamGetTiposPaisesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FEParamGetTiposPaisesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FEParamGetTiposPaisesResponse(soap, tag ? tag : "afip3:FEParamGetTiposPaisesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FEParamGetTiposPaisesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FEParamGetTiposPaisesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FEParamGetTiposPaisesResponse * SOAP_FMAC4 soap_get__afip3__FEParamGetTiposPaisesResponse(struct soap *soap, _afip3__FEParamGetTiposPaisesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FEParamGetTiposPaisesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FEParamGetTiposPaises::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FEParamGetTiposPaises::Auth = NULL;
}

void _afip3__FEParamGetTiposPaises::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FEAuthRequest(soap, &this->_afip3__FEParamGetTiposPaises::Auth);
#endif
}

int _afip3__FEParamGetTiposPaises::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FEParamGetTiposPaises(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FEParamGetTiposPaises(struct soap *soap, const char *tag, int id, const _afip3__FEParamGetTiposPaises *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FEParamGetTiposPaises), type))
		return soap->error;
	if (soap_out_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", -1, &a->_afip3__FEParamGetTiposPaises::Auth, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FEParamGetTiposPaises::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FEParamGetTiposPaises(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FEParamGetTiposPaises * SOAP_FMAC4 soap_in__afip3__FEParamGetTiposPaises(struct soap *soap, const char *tag, _afip3__FEParamGetTiposPaises *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FEParamGetTiposPaises*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FEParamGetTiposPaises, sizeof(_afip3__FEParamGetTiposPaises), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FEParamGetTiposPaises)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FEParamGetTiposPaises *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", &a->_afip3__FEParamGetTiposPaises::Auth, "afip3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FEParamGetTiposPaises *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FEParamGetTiposPaises, SOAP_TYPE__afip3__FEParamGetTiposPaises, sizeof(_afip3__FEParamGetTiposPaises), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FEParamGetTiposPaises * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetTiposPaises(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FEParamGetTiposPaises(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FEParamGetTiposPaises *p;
	size_t k = sizeof(_afip3__FEParamGetTiposPaises);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FEParamGetTiposPaises, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FEParamGetTiposPaises);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FEParamGetTiposPaises, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FEParamGetTiposPaises location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FEParamGetTiposPaises::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FEParamGetTiposPaises(soap, tag ? tag : "afip3:FEParamGetTiposPaises", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FEParamGetTiposPaises::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FEParamGetTiposPaises(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FEParamGetTiposPaises * SOAP_FMAC4 soap_get__afip3__FEParamGetTiposPaises(struct soap *soap, _afip3__FEParamGetTiposPaises *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FEParamGetTiposPaises(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FEParamGetTiposDocResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FEParamGetTiposDocResponse::FEParamGetTiposDocResult = NULL;
}

void _afip3__FEParamGetTiposDocResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__DocTipoResponse(soap, &this->_afip3__FEParamGetTiposDocResponse::FEParamGetTiposDocResult);
#endif
}

int _afip3__FEParamGetTiposDocResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FEParamGetTiposDocResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FEParamGetTiposDocResponse(struct soap *soap, const char *tag, int id, const _afip3__FEParamGetTiposDocResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FEParamGetTiposDocResponse), type))
		return soap->error;
	if (a->FEParamGetTiposDocResult)
		soap_element_result(soap, "afip3:FEParamGetTiposDocResult");
	if (soap_out_PointerToafip3__DocTipoResponse(soap, "afip3:FEParamGetTiposDocResult", -1, &a->_afip3__FEParamGetTiposDocResponse::FEParamGetTiposDocResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FEParamGetTiposDocResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FEParamGetTiposDocResponse(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FEParamGetTiposDocResponse * SOAP_FMAC4 soap_in__afip3__FEParamGetTiposDocResponse(struct soap *soap, const char *tag, _afip3__FEParamGetTiposDocResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FEParamGetTiposDocResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FEParamGetTiposDocResponse, sizeof(_afip3__FEParamGetTiposDocResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FEParamGetTiposDocResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FEParamGetTiposDocResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FEParamGetTiposDocResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FEParamGetTiposDocResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__DocTipoResponse(soap, "afip3:FEParamGetTiposDocResult", &a->_afip3__FEParamGetTiposDocResponse::FEParamGetTiposDocResult, "afip3:DocTipoResponse"))
				{	soap_flag_FEParamGetTiposDocResult1--;
					continue;
				}
			}
			soap_check_result(soap, "afip3:FEParamGetTiposDocResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FEParamGetTiposDocResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FEParamGetTiposDocResponse, SOAP_TYPE__afip3__FEParamGetTiposDocResponse, sizeof(_afip3__FEParamGetTiposDocResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FEParamGetTiposDocResponse * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetTiposDocResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FEParamGetTiposDocResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FEParamGetTiposDocResponse *p;
	size_t k = sizeof(_afip3__FEParamGetTiposDocResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FEParamGetTiposDocResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FEParamGetTiposDocResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FEParamGetTiposDocResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FEParamGetTiposDocResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FEParamGetTiposDocResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FEParamGetTiposDocResponse(soap, tag ? tag : "afip3:FEParamGetTiposDocResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FEParamGetTiposDocResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FEParamGetTiposDocResponse(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FEParamGetTiposDocResponse * SOAP_FMAC4 soap_get__afip3__FEParamGetTiposDocResponse(struct soap *soap, _afip3__FEParamGetTiposDocResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FEParamGetTiposDocResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FEParamGetTiposDoc::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FEParamGetTiposDoc::Auth = NULL;
}

void _afip3__FEParamGetTiposDoc::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FEAuthRequest(soap, &this->_afip3__FEParamGetTiposDoc::Auth);
#endif
}

int _afip3__FEParamGetTiposDoc::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FEParamGetTiposDoc(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FEParamGetTiposDoc(struct soap *soap, const char *tag, int id, const _afip3__FEParamGetTiposDoc *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FEParamGetTiposDoc), type))
		return soap->error;
	if (soap_out_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", -1, &a->_afip3__FEParamGetTiposDoc::Auth, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FEParamGetTiposDoc::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FEParamGetTiposDoc(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FEParamGetTiposDoc * SOAP_FMAC4 soap_in__afip3__FEParamGetTiposDoc(struct soap *soap, const char *tag, _afip3__FEParamGetTiposDoc *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FEParamGetTiposDoc*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FEParamGetTiposDoc, sizeof(_afip3__FEParamGetTiposDoc), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FEParamGetTiposDoc)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FEParamGetTiposDoc *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", &a->_afip3__FEParamGetTiposDoc::Auth, "afip3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FEParamGetTiposDoc *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FEParamGetTiposDoc, SOAP_TYPE__afip3__FEParamGetTiposDoc, sizeof(_afip3__FEParamGetTiposDoc), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FEParamGetTiposDoc * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetTiposDoc(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FEParamGetTiposDoc(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FEParamGetTiposDoc *p;
	size_t k = sizeof(_afip3__FEParamGetTiposDoc);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FEParamGetTiposDoc, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FEParamGetTiposDoc);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FEParamGetTiposDoc, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FEParamGetTiposDoc location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FEParamGetTiposDoc::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FEParamGetTiposDoc(soap, tag ? tag : "afip3:FEParamGetTiposDoc", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FEParamGetTiposDoc::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FEParamGetTiposDoc(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FEParamGetTiposDoc * SOAP_FMAC4 soap_get__afip3__FEParamGetTiposDoc(struct soap *soap, _afip3__FEParamGetTiposDoc *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FEParamGetTiposDoc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FEParamGetTiposCbteResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FEParamGetTiposCbteResponse::FEParamGetTiposCbteResult = NULL;
}

void _afip3__FEParamGetTiposCbteResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__CbteTipoResponse(soap, &this->_afip3__FEParamGetTiposCbteResponse::FEParamGetTiposCbteResult);
#endif
}

int _afip3__FEParamGetTiposCbteResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FEParamGetTiposCbteResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FEParamGetTiposCbteResponse(struct soap *soap, const char *tag, int id, const _afip3__FEParamGetTiposCbteResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FEParamGetTiposCbteResponse), type))
		return soap->error;
	if (a->FEParamGetTiposCbteResult)
		soap_element_result(soap, "afip3:FEParamGetTiposCbteResult");
	if (soap_out_PointerToafip3__CbteTipoResponse(soap, "afip3:FEParamGetTiposCbteResult", -1, &a->_afip3__FEParamGetTiposCbteResponse::FEParamGetTiposCbteResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FEParamGetTiposCbteResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FEParamGetTiposCbteResponse(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FEParamGetTiposCbteResponse * SOAP_FMAC4 soap_in__afip3__FEParamGetTiposCbteResponse(struct soap *soap, const char *tag, _afip3__FEParamGetTiposCbteResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FEParamGetTiposCbteResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FEParamGetTiposCbteResponse, sizeof(_afip3__FEParamGetTiposCbteResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FEParamGetTiposCbteResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FEParamGetTiposCbteResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FEParamGetTiposCbteResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FEParamGetTiposCbteResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__CbteTipoResponse(soap, "afip3:FEParamGetTiposCbteResult", &a->_afip3__FEParamGetTiposCbteResponse::FEParamGetTiposCbteResult, "afip3:CbteTipoResponse"))
				{	soap_flag_FEParamGetTiposCbteResult1--;
					continue;
				}
			}
			soap_check_result(soap, "afip3:FEParamGetTiposCbteResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FEParamGetTiposCbteResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FEParamGetTiposCbteResponse, SOAP_TYPE__afip3__FEParamGetTiposCbteResponse, sizeof(_afip3__FEParamGetTiposCbteResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FEParamGetTiposCbteResponse * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetTiposCbteResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FEParamGetTiposCbteResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FEParamGetTiposCbteResponse *p;
	size_t k = sizeof(_afip3__FEParamGetTiposCbteResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FEParamGetTiposCbteResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FEParamGetTiposCbteResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FEParamGetTiposCbteResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FEParamGetTiposCbteResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FEParamGetTiposCbteResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FEParamGetTiposCbteResponse(soap, tag ? tag : "afip3:FEParamGetTiposCbteResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FEParamGetTiposCbteResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FEParamGetTiposCbteResponse(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FEParamGetTiposCbteResponse * SOAP_FMAC4 soap_get__afip3__FEParamGetTiposCbteResponse(struct soap *soap, _afip3__FEParamGetTiposCbteResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FEParamGetTiposCbteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FEParamGetTiposCbte::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FEParamGetTiposCbte::Auth = NULL;
}

void _afip3__FEParamGetTiposCbte::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FEAuthRequest(soap, &this->_afip3__FEParamGetTiposCbte::Auth);
#endif
}

int _afip3__FEParamGetTiposCbte::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FEParamGetTiposCbte(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FEParamGetTiposCbte(struct soap *soap, const char *tag, int id, const _afip3__FEParamGetTiposCbte *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FEParamGetTiposCbte), type))
		return soap->error;
	if (soap_out_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", -1, &a->_afip3__FEParamGetTiposCbte::Auth, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FEParamGetTiposCbte::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FEParamGetTiposCbte(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FEParamGetTiposCbte * SOAP_FMAC4 soap_in__afip3__FEParamGetTiposCbte(struct soap *soap, const char *tag, _afip3__FEParamGetTiposCbte *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FEParamGetTiposCbte*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FEParamGetTiposCbte, sizeof(_afip3__FEParamGetTiposCbte), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FEParamGetTiposCbte)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FEParamGetTiposCbte *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", &a->_afip3__FEParamGetTiposCbte::Auth, "afip3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FEParamGetTiposCbte *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FEParamGetTiposCbte, SOAP_TYPE__afip3__FEParamGetTiposCbte, sizeof(_afip3__FEParamGetTiposCbte), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FEParamGetTiposCbte * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetTiposCbte(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FEParamGetTiposCbte(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FEParamGetTiposCbte *p;
	size_t k = sizeof(_afip3__FEParamGetTiposCbte);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FEParamGetTiposCbte, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FEParamGetTiposCbte);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FEParamGetTiposCbte, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FEParamGetTiposCbte location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FEParamGetTiposCbte::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FEParamGetTiposCbte(soap, tag ? tag : "afip3:FEParamGetTiposCbte", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FEParamGetTiposCbte::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FEParamGetTiposCbte(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FEParamGetTiposCbte * SOAP_FMAC4 soap_get__afip3__FEParamGetTiposCbte(struct soap *soap, _afip3__FEParamGetTiposCbte *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FEParamGetTiposCbte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FEParamGetPtosVentaResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FEParamGetPtosVentaResponse::FEParamGetPtosVentaResult = NULL;
}

void _afip3__FEParamGetPtosVentaResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FEPtoVentaResponse(soap, &this->_afip3__FEParamGetPtosVentaResponse::FEParamGetPtosVentaResult);
#endif
}

int _afip3__FEParamGetPtosVentaResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FEParamGetPtosVentaResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FEParamGetPtosVentaResponse(struct soap *soap, const char *tag, int id, const _afip3__FEParamGetPtosVentaResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FEParamGetPtosVentaResponse), type))
		return soap->error;
	if (a->FEParamGetPtosVentaResult)
		soap_element_result(soap, "afip3:FEParamGetPtosVentaResult");
	if (soap_out_PointerToafip3__FEPtoVentaResponse(soap, "afip3:FEParamGetPtosVentaResult", -1, &a->_afip3__FEParamGetPtosVentaResponse::FEParamGetPtosVentaResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FEParamGetPtosVentaResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FEParamGetPtosVentaResponse(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FEParamGetPtosVentaResponse * SOAP_FMAC4 soap_in__afip3__FEParamGetPtosVentaResponse(struct soap *soap, const char *tag, _afip3__FEParamGetPtosVentaResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FEParamGetPtosVentaResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FEParamGetPtosVentaResponse, sizeof(_afip3__FEParamGetPtosVentaResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FEParamGetPtosVentaResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FEParamGetPtosVentaResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FEParamGetPtosVentaResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FEParamGetPtosVentaResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FEPtoVentaResponse(soap, "afip3:FEParamGetPtosVentaResult", &a->_afip3__FEParamGetPtosVentaResponse::FEParamGetPtosVentaResult, "afip3:FEPtoVentaResponse"))
				{	soap_flag_FEParamGetPtosVentaResult1--;
					continue;
				}
			}
			soap_check_result(soap, "afip3:FEParamGetPtosVentaResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FEParamGetPtosVentaResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FEParamGetPtosVentaResponse, SOAP_TYPE__afip3__FEParamGetPtosVentaResponse, sizeof(_afip3__FEParamGetPtosVentaResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FEParamGetPtosVentaResponse * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetPtosVentaResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FEParamGetPtosVentaResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FEParamGetPtosVentaResponse *p;
	size_t k = sizeof(_afip3__FEParamGetPtosVentaResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FEParamGetPtosVentaResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FEParamGetPtosVentaResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FEParamGetPtosVentaResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FEParamGetPtosVentaResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FEParamGetPtosVentaResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FEParamGetPtosVentaResponse(soap, tag ? tag : "afip3:FEParamGetPtosVentaResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FEParamGetPtosVentaResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FEParamGetPtosVentaResponse(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FEParamGetPtosVentaResponse * SOAP_FMAC4 soap_get__afip3__FEParamGetPtosVentaResponse(struct soap *soap, _afip3__FEParamGetPtosVentaResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FEParamGetPtosVentaResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FEParamGetPtosVenta::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FEParamGetPtosVenta::Auth = NULL;
}

void _afip3__FEParamGetPtosVenta::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FEAuthRequest(soap, &this->_afip3__FEParamGetPtosVenta::Auth);
#endif
}

int _afip3__FEParamGetPtosVenta::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FEParamGetPtosVenta(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FEParamGetPtosVenta(struct soap *soap, const char *tag, int id, const _afip3__FEParamGetPtosVenta *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FEParamGetPtosVenta), type))
		return soap->error;
	if (soap_out_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", -1, &a->_afip3__FEParamGetPtosVenta::Auth, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FEParamGetPtosVenta::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FEParamGetPtosVenta(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FEParamGetPtosVenta * SOAP_FMAC4 soap_in__afip3__FEParamGetPtosVenta(struct soap *soap, const char *tag, _afip3__FEParamGetPtosVenta *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FEParamGetPtosVenta*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FEParamGetPtosVenta, sizeof(_afip3__FEParamGetPtosVenta), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FEParamGetPtosVenta)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FEParamGetPtosVenta *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", &a->_afip3__FEParamGetPtosVenta::Auth, "afip3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FEParamGetPtosVenta *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FEParamGetPtosVenta, SOAP_TYPE__afip3__FEParamGetPtosVenta, sizeof(_afip3__FEParamGetPtosVenta), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FEParamGetPtosVenta * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetPtosVenta(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FEParamGetPtosVenta(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FEParamGetPtosVenta *p;
	size_t k = sizeof(_afip3__FEParamGetPtosVenta);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FEParamGetPtosVenta, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FEParamGetPtosVenta);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FEParamGetPtosVenta, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FEParamGetPtosVenta location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FEParamGetPtosVenta::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FEParamGetPtosVenta(soap, tag ? tag : "afip3:FEParamGetPtosVenta", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FEParamGetPtosVenta::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FEParamGetPtosVenta(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FEParamGetPtosVenta * SOAP_FMAC4 soap_get__afip3__FEParamGetPtosVenta(struct soap *soap, _afip3__FEParamGetPtosVenta *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FEParamGetPtosVenta(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FEParamGetTiposConceptoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FEParamGetTiposConceptoResponse::FEParamGetTiposConceptoResult = NULL;
}

void _afip3__FEParamGetTiposConceptoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__ConceptoTipoResponse(soap, &this->_afip3__FEParamGetTiposConceptoResponse::FEParamGetTiposConceptoResult);
#endif
}

int _afip3__FEParamGetTiposConceptoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FEParamGetTiposConceptoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FEParamGetTiposConceptoResponse(struct soap *soap, const char *tag, int id, const _afip3__FEParamGetTiposConceptoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FEParamGetTiposConceptoResponse), type))
		return soap->error;
	if (a->FEParamGetTiposConceptoResult)
		soap_element_result(soap, "afip3:FEParamGetTiposConceptoResult");
	if (soap_out_PointerToafip3__ConceptoTipoResponse(soap, "afip3:FEParamGetTiposConceptoResult", -1, &a->_afip3__FEParamGetTiposConceptoResponse::FEParamGetTiposConceptoResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FEParamGetTiposConceptoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FEParamGetTiposConceptoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FEParamGetTiposConceptoResponse * SOAP_FMAC4 soap_in__afip3__FEParamGetTiposConceptoResponse(struct soap *soap, const char *tag, _afip3__FEParamGetTiposConceptoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FEParamGetTiposConceptoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FEParamGetTiposConceptoResponse, sizeof(_afip3__FEParamGetTiposConceptoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FEParamGetTiposConceptoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FEParamGetTiposConceptoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FEParamGetTiposConceptoResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FEParamGetTiposConceptoResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ConceptoTipoResponse(soap, "afip3:FEParamGetTiposConceptoResult", &a->_afip3__FEParamGetTiposConceptoResponse::FEParamGetTiposConceptoResult, "afip3:ConceptoTipoResponse"))
				{	soap_flag_FEParamGetTiposConceptoResult1--;
					continue;
				}
			}
			soap_check_result(soap, "afip3:FEParamGetTiposConceptoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FEParamGetTiposConceptoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FEParamGetTiposConceptoResponse, SOAP_TYPE__afip3__FEParamGetTiposConceptoResponse, sizeof(_afip3__FEParamGetTiposConceptoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FEParamGetTiposConceptoResponse * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetTiposConceptoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FEParamGetTiposConceptoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FEParamGetTiposConceptoResponse *p;
	size_t k = sizeof(_afip3__FEParamGetTiposConceptoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FEParamGetTiposConceptoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FEParamGetTiposConceptoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FEParamGetTiposConceptoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FEParamGetTiposConceptoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FEParamGetTiposConceptoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FEParamGetTiposConceptoResponse(soap, tag ? tag : "afip3:FEParamGetTiposConceptoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FEParamGetTiposConceptoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FEParamGetTiposConceptoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FEParamGetTiposConceptoResponse * SOAP_FMAC4 soap_get__afip3__FEParamGetTiposConceptoResponse(struct soap *soap, _afip3__FEParamGetTiposConceptoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FEParamGetTiposConceptoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FEParamGetTiposConcepto::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FEParamGetTiposConcepto::Auth = NULL;
}

void _afip3__FEParamGetTiposConcepto::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FEAuthRequest(soap, &this->_afip3__FEParamGetTiposConcepto::Auth);
#endif
}

int _afip3__FEParamGetTiposConcepto::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FEParamGetTiposConcepto(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FEParamGetTiposConcepto(struct soap *soap, const char *tag, int id, const _afip3__FEParamGetTiposConcepto *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FEParamGetTiposConcepto), type))
		return soap->error;
	if (soap_out_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", -1, &a->_afip3__FEParamGetTiposConcepto::Auth, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FEParamGetTiposConcepto::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FEParamGetTiposConcepto(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FEParamGetTiposConcepto * SOAP_FMAC4 soap_in__afip3__FEParamGetTiposConcepto(struct soap *soap, const char *tag, _afip3__FEParamGetTiposConcepto *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FEParamGetTiposConcepto*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FEParamGetTiposConcepto, sizeof(_afip3__FEParamGetTiposConcepto), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FEParamGetTiposConcepto)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FEParamGetTiposConcepto *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", &a->_afip3__FEParamGetTiposConcepto::Auth, "afip3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FEParamGetTiposConcepto *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FEParamGetTiposConcepto, SOAP_TYPE__afip3__FEParamGetTiposConcepto, sizeof(_afip3__FEParamGetTiposConcepto), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FEParamGetTiposConcepto * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetTiposConcepto(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FEParamGetTiposConcepto(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FEParamGetTiposConcepto *p;
	size_t k = sizeof(_afip3__FEParamGetTiposConcepto);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FEParamGetTiposConcepto, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FEParamGetTiposConcepto);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FEParamGetTiposConcepto, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FEParamGetTiposConcepto location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FEParamGetTiposConcepto::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FEParamGetTiposConcepto(soap, tag ? tag : "afip3:FEParamGetTiposConcepto", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FEParamGetTiposConcepto::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FEParamGetTiposConcepto(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FEParamGetTiposConcepto * SOAP_FMAC4 soap_get__afip3__FEParamGetTiposConcepto(struct soap *soap, _afip3__FEParamGetTiposConcepto *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FEParamGetTiposConcepto(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FEParamGetTiposOpcionalResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FEParamGetTiposOpcionalResponse::FEParamGetTiposOpcionalResult = NULL;
}

void _afip3__FEParamGetTiposOpcionalResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__OpcionalTipoResponse(soap, &this->_afip3__FEParamGetTiposOpcionalResponse::FEParamGetTiposOpcionalResult);
#endif
}

int _afip3__FEParamGetTiposOpcionalResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FEParamGetTiposOpcionalResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FEParamGetTiposOpcionalResponse(struct soap *soap, const char *tag, int id, const _afip3__FEParamGetTiposOpcionalResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FEParamGetTiposOpcionalResponse), type))
		return soap->error;
	if (a->FEParamGetTiposOpcionalResult)
		soap_element_result(soap, "afip3:FEParamGetTiposOpcionalResult");
	if (soap_out_PointerToafip3__OpcionalTipoResponse(soap, "afip3:FEParamGetTiposOpcionalResult", -1, &a->_afip3__FEParamGetTiposOpcionalResponse::FEParamGetTiposOpcionalResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FEParamGetTiposOpcionalResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FEParamGetTiposOpcionalResponse(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FEParamGetTiposOpcionalResponse * SOAP_FMAC4 soap_in__afip3__FEParamGetTiposOpcionalResponse(struct soap *soap, const char *tag, _afip3__FEParamGetTiposOpcionalResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FEParamGetTiposOpcionalResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FEParamGetTiposOpcionalResponse, sizeof(_afip3__FEParamGetTiposOpcionalResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FEParamGetTiposOpcionalResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FEParamGetTiposOpcionalResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FEParamGetTiposOpcionalResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FEParamGetTiposOpcionalResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__OpcionalTipoResponse(soap, "afip3:FEParamGetTiposOpcionalResult", &a->_afip3__FEParamGetTiposOpcionalResponse::FEParamGetTiposOpcionalResult, "afip3:OpcionalTipoResponse"))
				{	soap_flag_FEParamGetTiposOpcionalResult1--;
					continue;
				}
			}
			soap_check_result(soap, "afip3:FEParamGetTiposOpcionalResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FEParamGetTiposOpcionalResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FEParamGetTiposOpcionalResponse, SOAP_TYPE__afip3__FEParamGetTiposOpcionalResponse, sizeof(_afip3__FEParamGetTiposOpcionalResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FEParamGetTiposOpcionalResponse * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetTiposOpcionalResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FEParamGetTiposOpcionalResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FEParamGetTiposOpcionalResponse *p;
	size_t k = sizeof(_afip3__FEParamGetTiposOpcionalResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FEParamGetTiposOpcionalResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FEParamGetTiposOpcionalResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FEParamGetTiposOpcionalResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FEParamGetTiposOpcionalResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FEParamGetTiposOpcionalResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FEParamGetTiposOpcionalResponse(soap, tag ? tag : "afip3:FEParamGetTiposOpcionalResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FEParamGetTiposOpcionalResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FEParamGetTiposOpcionalResponse(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FEParamGetTiposOpcionalResponse * SOAP_FMAC4 soap_get__afip3__FEParamGetTiposOpcionalResponse(struct soap *soap, _afip3__FEParamGetTiposOpcionalResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FEParamGetTiposOpcionalResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FEParamGetTiposOpcional::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FEParamGetTiposOpcional::Auth = NULL;
}

void _afip3__FEParamGetTiposOpcional::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FEAuthRequest(soap, &this->_afip3__FEParamGetTiposOpcional::Auth);
#endif
}

int _afip3__FEParamGetTiposOpcional::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FEParamGetTiposOpcional(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FEParamGetTiposOpcional(struct soap *soap, const char *tag, int id, const _afip3__FEParamGetTiposOpcional *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FEParamGetTiposOpcional), type))
		return soap->error;
	if (soap_out_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", -1, &a->_afip3__FEParamGetTiposOpcional::Auth, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FEParamGetTiposOpcional::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FEParamGetTiposOpcional(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FEParamGetTiposOpcional * SOAP_FMAC4 soap_in__afip3__FEParamGetTiposOpcional(struct soap *soap, const char *tag, _afip3__FEParamGetTiposOpcional *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FEParamGetTiposOpcional*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FEParamGetTiposOpcional, sizeof(_afip3__FEParamGetTiposOpcional), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FEParamGetTiposOpcional)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FEParamGetTiposOpcional *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", &a->_afip3__FEParamGetTiposOpcional::Auth, "afip3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FEParamGetTiposOpcional *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FEParamGetTiposOpcional, SOAP_TYPE__afip3__FEParamGetTiposOpcional, sizeof(_afip3__FEParamGetTiposOpcional), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FEParamGetTiposOpcional * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetTiposOpcional(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FEParamGetTiposOpcional(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FEParamGetTiposOpcional *p;
	size_t k = sizeof(_afip3__FEParamGetTiposOpcional);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FEParamGetTiposOpcional, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FEParamGetTiposOpcional);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FEParamGetTiposOpcional, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FEParamGetTiposOpcional location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FEParamGetTiposOpcional::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FEParamGetTiposOpcional(soap, tag ? tag : "afip3:FEParamGetTiposOpcional", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FEParamGetTiposOpcional::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FEParamGetTiposOpcional(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FEParamGetTiposOpcional * SOAP_FMAC4 soap_get__afip3__FEParamGetTiposOpcional(struct soap *soap, _afip3__FEParamGetTiposOpcional *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FEParamGetTiposOpcional(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FEParamGetTiposIvaResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FEParamGetTiposIvaResponse::FEParamGetTiposIvaResult = NULL;
}

void _afip3__FEParamGetTiposIvaResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__IvaTipoResponse(soap, &this->_afip3__FEParamGetTiposIvaResponse::FEParamGetTiposIvaResult);
#endif
}

int _afip3__FEParamGetTiposIvaResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FEParamGetTiposIvaResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FEParamGetTiposIvaResponse(struct soap *soap, const char *tag, int id, const _afip3__FEParamGetTiposIvaResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FEParamGetTiposIvaResponse), type))
		return soap->error;
	if (a->FEParamGetTiposIvaResult)
		soap_element_result(soap, "afip3:FEParamGetTiposIvaResult");
	if (soap_out_PointerToafip3__IvaTipoResponse(soap, "afip3:FEParamGetTiposIvaResult", -1, &a->_afip3__FEParamGetTiposIvaResponse::FEParamGetTiposIvaResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FEParamGetTiposIvaResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FEParamGetTiposIvaResponse(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FEParamGetTiposIvaResponse * SOAP_FMAC4 soap_in__afip3__FEParamGetTiposIvaResponse(struct soap *soap, const char *tag, _afip3__FEParamGetTiposIvaResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FEParamGetTiposIvaResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FEParamGetTiposIvaResponse, sizeof(_afip3__FEParamGetTiposIvaResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FEParamGetTiposIvaResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FEParamGetTiposIvaResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FEParamGetTiposIvaResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FEParamGetTiposIvaResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__IvaTipoResponse(soap, "afip3:FEParamGetTiposIvaResult", &a->_afip3__FEParamGetTiposIvaResponse::FEParamGetTiposIvaResult, "afip3:IvaTipoResponse"))
				{	soap_flag_FEParamGetTiposIvaResult1--;
					continue;
				}
			}
			soap_check_result(soap, "afip3:FEParamGetTiposIvaResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FEParamGetTiposIvaResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FEParamGetTiposIvaResponse, SOAP_TYPE__afip3__FEParamGetTiposIvaResponse, sizeof(_afip3__FEParamGetTiposIvaResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FEParamGetTiposIvaResponse * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetTiposIvaResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FEParamGetTiposIvaResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FEParamGetTiposIvaResponse *p;
	size_t k = sizeof(_afip3__FEParamGetTiposIvaResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FEParamGetTiposIvaResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FEParamGetTiposIvaResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FEParamGetTiposIvaResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FEParamGetTiposIvaResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FEParamGetTiposIvaResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FEParamGetTiposIvaResponse(soap, tag ? tag : "afip3:FEParamGetTiposIvaResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FEParamGetTiposIvaResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FEParamGetTiposIvaResponse(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FEParamGetTiposIvaResponse * SOAP_FMAC4 soap_get__afip3__FEParamGetTiposIvaResponse(struct soap *soap, _afip3__FEParamGetTiposIvaResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FEParamGetTiposIvaResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FEParamGetTiposIva::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FEParamGetTiposIva::Auth = NULL;
}

void _afip3__FEParamGetTiposIva::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FEAuthRequest(soap, &this->_afip3__FEParamGetTiposIva::Auth);
#endif
}

int _afip3__FEParamGetTiposIva::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FEParamGetTiposIva(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FEParamGetTiposIva(struct soap *soap, const char *tag, int id, const _afip3__FEParamGetTiposIva *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FEParamGetTiposIva), type))
		return soap->error;
	if (soap_out_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", -1, &a->_afip3__FEParamGetTiposIva::Auth, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FEParamGetTiposIva::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FEParamGetTiposIva(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FEParamGetTiposIva * SOAP_FMAC4 soap_in__afip3__FEParamGetTiposIva(struct soap *soap, const char *tag, _afip3__FEParamGetTiposIva *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FEParamGetTiposIva*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FEParamGetTiposIva, sizeof(_afip3__FEParamGetTiposIva), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FEParamGetTiposIva)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FEParamGetTiposIva *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", &a->_afip3__FEParamGetTiposIva::Auth, "afip3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FEParamGetTiposIva *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FEParamGetTiposIva, SOAP_TYPE__afip3__FEParamGetTiposIva, sizeof(_afip3__FEParamGetTiposIva), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FEParamGetTiposIva * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetTiposIva(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FEParamGetTiposIva(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FEParamGetTiposIva *p;
	size_t k = sizeof(_afip3__FEParamGetTiposIva);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FEParamGetTiposIva, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FEParamGetTiposIva);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FEParamGetTiposIva, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FEParamGetTiposIva location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FEParamGetTiposIva::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FEParamGetTiposIva(soap, tag ? tag : "afip3:FEParamGetTiposIva", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FEParamGetTiposIva::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FEParamGetTiposIva(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FEParamGetTiposIva * SOAP_FMAC4 soap_get__afip3__FEParamGetTiposIva(struct soap *soap, _afip3__FEParamGetTiposIva *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FEParamGetTiposIva(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FEParamGetTiposMonedasResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FEParamGetTiposMonedasResponse::FEParamGetTiposMonedasResult = NULL;
}

void _afip3__FEParamGetTiposMonedasResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__MonedaResponse(soap, &this->_afip3__FEParamGetTiposMonedasResponse::FEParamGetTiposMonedasResult);
#endif
}

int _afip3__FEParamGetTiposMonedasResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FEParamGetTiposMonedasResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FEParamGetTiposMonedasResponse(struct soap *soap, const char *tag, int id, const _afip3__FEParamGetTiposMonedasResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FEParamGetTiposMonedasResponse), type))
		return soap->error;
	if (a->FEParamGetTiposMonedasResult)
		soap_element_result(soap, "afip3:FEParamGetTiposMonedasResult");
	if (soap_out_PointerToafip3__MonedaResponse(soap, "afip3:FEParamGetTiposMonedasResult", -1, &a->_afip3__FEParamGetTiposMonedasResponse::FEParamGetTiposMonedasResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FEParamGetTiposMonedasResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FEParamGetTiposMonedasResponse(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FEParamGetTiposMonedasResponse * SOAP_FMAC4 soap_in__afip3__FEParamGetTiposMonedasResponse(struct soap *soap, const char *tag, _afip3__FEParamGetTiposMonedasResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FEParamGetTiposMonedasResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FEParamGetTiposMonedasResponse, sizeof(_afip3__FEParamGetTiposMonedasResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FEParamGetTiposMonedasResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FEParamGetTiposMonedasResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FEParamGetTiposMonedasResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FEParamGetTiposMonedasResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__MonedaResponse(soap, "afip3:FEParamGetTiposMonedasResult", &a->_afip3__FEParamGetTiposMonedasResponse::FEParamGetTiposMonedasResult, "afip3:MonedaResponse"))
				{	soap_flag_FEParamGetTiposMonedasResult1--;
					continue;
				}
			}
			soap_check_result(soap, "afip3:FEParamGetTiposMonedasResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FEParamGetTiposMonedasResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FEParamGetTiposMonedasResponse, SOAP_TYPE__afip3__FEParamGetTiposMonedasResponse, sizeof(_afip3__FEParamGetTiposMonedasResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FEParamGetTiposMonedasResponse * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetTiposMonedasResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FEParamGetTiposMonedasResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FEParamGetTiposMonedasResponse *p;
	size_t k = sizeof(_afip3__FEParamGetTiposMonedasResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FEParamGetTiposMonedasResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FEParamGetTiposMonedasResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FEParamGetTiposMonedasResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FEParamGetTiposMonedasResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FEParamGetTiposMonedasResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FEParamGetTiposMonedasResponse(soap, tag ? tag : "afip3:FEParamGetTiposMonedasResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FEParamGetTiposMonedasResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FEParamGetTiposMonedasResponse(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FEParamGetTiposMonedasResponse * SOAP_FMAC4 soap_get__afip3__FEParamGetTiposMonedasResponse(struct soap *soap, _afip3__FEParamGetTiposMonedasResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FEParamGetTiposMonedasResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FEParamGetTiposMonedas::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FEParamGetTiposMonedas::Auth = NULL;
}

void _afip3__FEParamGetTiposMonedas::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FEAuthRequest(soap, &this->_afip3__FEParamGetTiposMonedas::Auth);
#endif
}

int _afip3__FEParamGetTiposMonedas::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FEParamGetTiposMonedas(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FEParamGetTiposMonedas(struct soap *soap, const char *tag, int id, const _afip3__FEParamGetTiposMonedas *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FEParamGetTiposMonedas), type))
		return soap->error;
	if (soap_out_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", -1, &a->_afip3__FEParamGetTiposMonedas::Auth, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FEParamGetTiposMonedas::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FEParamGetTiposMonedas(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FEParamGetTiposMonedas * SOAP_FMAC4 soap_in__afip3__FEParamGetTiposMonedas(struct soap *soap, const char *tag, _afip3__FEParamGetTiposMonedas *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FEParamGetTiposMonedas*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FEParamGetTiposMonedas, sizeof(_afip3__FEParamGetTiposMonedas), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FEParamGetTiposMonedas)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FEParamGetTiposMonedas *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", &a->_afip3__FEParamGetTiposMonedas::Auth, "afip3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FEParamGetTiposMonedas *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FEParamGetTiposMonedas, SOAP_TYPE__afip3__FEParamGetTiposMonedas, sizeof(_afip3__FEParamGetTiposMonedas), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FEParamGetTiposMonedas * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetTiposMonedas(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FEParamGetTiposMonedas(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FEParamGetTiposMonedas *p;
	size_t k = sizeof(_afip3__FEParamGetTiposMonedas);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FEParamGetTiposMonedas, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FEParamGetTiposMonedas);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FEParamGetTiposMonedas, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FEParamGetTiposMonedas location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FEParamGetTiposMonedas::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FEParamGetTiposMonedas(soap, tag ? tag : "afip3:FEParamGetTiposMonedas", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FEParamGetTiposMonedas::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FEParamGetTiposMonedas(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FEParamGetTiposMonedas * SOAP_FMAC4 soap_get__afip3__FEParamGetTiposMonedas(struct soap *soap, _afip3__FEParamGetTiposMonedas *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FEParamGetTiposMonedas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FEParamGetTiposTributosResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FEParamGetTiposTributosResponse::FEParamGetTiposTributosResult = NULL;
}

void _afip3__FEParamGetTiposTributosResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FETributoResponse(soap, &this->_afip3__FEParamGetTiposTributosResponse::FEParamGetTiposTributosResult);
#endif
}

int _afip3__FEParamGetTiposTributosResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FEParamGetTiposTributosResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FEParamGetTiposTributosResponse(struct soap *soap, const char *tag, int id, const _afip3__FEParamGetTiposTributosResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FEParamGetTiposTributosResponse), type))
		return soap->error;
	if (a->FEParamGetTiposTributosResult)
		soap_element_result(soap, "afip3:FEParamGetTiposTributosResult");
	if (soap_out_PointerToafip3__FETributoResponse(soap, "afip3:FEParamGetTiposTributosResult", -1, &a->_afip3__FEParamGetTiposTributosResponse::FEParamGetTiposTributosResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FEParamGetTiposTributosResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FEParamGetTiposTributosResponse(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FEParamGetTiposTributosResponse * SOAP_FMAC4 soap_in__afip3__FEParamGetTiposTributosResponse(struct soap *soap, const char *tag, _afip3__FEParamGetTiposTributosResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FEParamGetTiposTributosResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FEParamGetTiposTributosResponse, sizeof(_afip3__FEParamGetTiposTributosResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FEParamGetTiposTributosResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FEParamGetTiposTributosResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FEParamGetTiposTributosResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FEParamGetTiposTributosResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FETributoResponse(soap, "afip3:FEParamGetTiposTributosResult", &a->_afip3__FEParamGetTiposTributosResponse::FEParamGetTiposTributosResult, "afip3:FETributoResponse"))
				{	soap_flag_FEParamGetTiposTributosResult1--;
					continue;
				}
			}
			soap_check_result(soap, "afip3:FEParamGetTiposTributosResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FEParamGetTiposTributosResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FEParamGetTiposTributosResponse, SOAP_TYPE__afip3__FEParamGetTiposTributosResponse, sizeof(_afip3__FEParamGetTiposTributosResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FEParamGetTiposTributosResponse * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetTiposTributosResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FEParamGetTiposTributosResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FEParamGetTiposTributosResponse *p;
	size_t k = sizeof(_afip3__FEParamGetTiposTributosResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FEParamGetTiposTributosResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FEParamGetTiposTributosResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FEParamGetTiposTributosResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FEParamGetTiposTributosResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FEParamGetTiposTributosResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FEParamGetTiposTributosResponse(soap, tag ? tag : "afip3:FEParamGetTiposTributosResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FEParamGetTiposTributosResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FEParamGetTiposTributosResponse(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FEParamGetTiposTributosResponse * SOAP_FMAC4 soap_get__afip3__FEParamGetTiposTributosResponse(struct soap *soap, _afip3__FEParamGetTiposTributosResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FEParamGetTiposTributosResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FEParamGetTiposTributos::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FEParamGetTiposTributos::Auth = NULL;
}

void _afip3__FEParamGetTiposTributos::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FEAuthRequest(soap, &this->_afip3__FEParamGetTiposTributos::Auth);
#endif
}

int _afip3__FEParamGetTiposTributos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FEParamGetTiposTributos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FEParamGetTiposTributos(struct soap *soap, const char *tag, int id, const _afip3__FEParamGetTiposTributos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FEParamGetTiposTributos), type))
		return soap->error;
	if (soap_out_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", -1, &a->_afip3__FEParamGetTiposTributos::Auth, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FEParamGetTiposTributos::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FEParamGetTiposTributos(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FEParamGetTiposTributos * SOAP_FMAC4 soap_in__afip3__FEParamGetTiposTributos(struct soap *soap, const char *tag, _afip3__FEParamGetTiposTributos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FEParamGetTiposTributos*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FEParamGetTiposTributos, sizeof(_afip3__FEParamGetTiposTributos), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FEParamGetTiposTributos)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FEParamGetTiposTributos *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", &a->_afip3__FEParamGetTiposTributos::Auth, "afip3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FEParamGetTiposTributos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FEParamGetTiposTributos, SOAP_TYPE__afip3__FEParamGetTiposTributos, sizeof(_afip3__FEParamGetTiposTributos), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FEParamGetTiposTributos * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetTiposTributos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FEParamGetTiposTributos(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FEParamGetTiposTributos *p;
	size_t k = sizeof(_afip3__FEParamGetTiposTributos);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FEParamGetTiposTributos, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FEParamGetTiposTributos);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FEParamGetTiposTributos, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FEParamGetTiposTributos location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FEParamGetTiposTributos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FEParamGetTiposTributos(soap, tag ? tag : "afip3:FEParamGetTiposTributos", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FEParamGetTiposTributos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FEParamGetTiposTributos(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FEParamGetTiposTributos * SOAP_FMAC4 soap_get__afip3__FEParamGetTiposTributos(struct soap *soap, _afip3__FEParamGetTiposTributos *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FEParamGetTiposTributos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FEParamGetCotizacionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FEParamGetCotizacionResponse::FEParamGetCotizacionResult = NULL;
}

void _afip3__FEParamGetCotizacionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FECotizacionResponse(soap, &this->_afip3__FEParamGetCotizacionResponse::FEParamGetCotizacionResult);
#endif
}

int _afip3__FEParamGetCotizacionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FEParamGetCotizacionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FEParamGetCotizacionResponse(struct soap *soap, const char *tag, int id, const _afip3__FEParamGetCotizacionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FEParamGetCotizacionResponse), type))
		return soap->error;
	if (a->FEParamGetCotizacionResult)
		soap_element_result(soap, "afip3:FEParamGetCotizacionResult");
	if (soap_out_PointerToafip3__FECotizacionResponse(soap, "afip3:FEParamGetCotizacionResult", -1, &a->_afip3__FEParamGetCotizacionResponse::FEParamGetCotizacionResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FEParamGetCotizacionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FEParamGetCotizacionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FEParamGetCotizacionResponse * SOAP_FMAC4 soap_in__afip3__FEParamGetCotizacionResponse(struct soap *soap, const char *tag, _afip3__FEParamGetCotizacionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FEParamGetCotizacionResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FEParamGetCotizacionResponse, sizeof(_afip3__FEParamGetCotizacionResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FEParamGetCotizacionResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FEParamGetCotizacionResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FEParamGetCotizacionResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FEParamGetCotizacionResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FECotizacionResponse(soap, "afip3:FEParamGetCotizacionResult", &a->_afip3__FEParamGetCotizacionResponse::FEParamGetCotizacionResult, "afip3:FECotizacionResponse"))
				{	soap_flag_FEParamGetCotizacionResult1--;
					continue;
				}
			}
			soap_check_result(soap, "afip3:FEParamGetCotizacionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FEParamGetCotizacionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FEParamGetCotizacionResponse, SOAP_TYPE__afip3__FEParamGetCotizacionResponse, sizeof(_afip3__FEParamGetCotizacionResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FEParamGetCotizacionResponse * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetCotizacionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FEParamGetCotizacionResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FEParamGetCotizacionResponse *p;
	size_t k = sizeof(_afip3__FEParamGetCotizacionResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FEParamGetCotizacionResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FEParamGetCotizacionResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FEParamGetCotizacionResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FEParamGetCotizacionResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FEParamGetCotizacionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FEParamGetCotizacionResponse(soap, tag ? tag : "afip3:FEParamGetCotizacionResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FEParamGetCotizacionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FEParamGetCotizacionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FEParamGetCotizacionResponse * SOAP_FMAC4 soap_get__afip3__FEParamGetCotizacionResponse(struct soap *soap, _afip3__FEParamGetCotizacionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FEParamGetCotizacionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FEParamGetCotizacion::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FEParamGetCotizacion::Auth = NULL;
	this->_afip3__FEParamGetCotizacion::MonId = NULL;
}

void _afip3__FEParamGetCotizacion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FEAuthRequest(soap, &this->_afip3__FEParamGetCotizacion::Auth);
	soap_serialize_PointerTostd__string(soap, &this->_afip3__FEParamGetCotizacion::MonId);
#endif
}

int _afip3__FEParamGetCotizacion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FEParamGetCotizacion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FEParamGetCotizacion(struct soap *soap, const char *tag, int id, const _afip3__FEParamGetCotizacion *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FEParamGetCotizacion), type))
		return soap->error;
	if (soap_out_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", -1, &a->_afip3__FEParamGetCotizacion::Auth, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:MonId", -1, &a->_afip3__FEParamGetCotizacion::MonId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FEParamGetCotizacion::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FEParamGetCotizacion(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FEParamGetCotizacion * SOAP_FMAC4 soap_in__afip3__FEParamGetCotizacion(struct soap *soap, const char *tag, _afip3__FEParamGetCotizacion *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FEParamGetCotizacion*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FEParamGetCotizacion, sizeof(_afip3__FEParamGetCotizacion), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FEParamGetCotizacion)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FEParamGetCotizacion *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	size_t soap_flag_MonId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", &a->_afip3__FEParamGetCotizacion::Auth, "afip3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap_flag_MonId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:MonId", &a->_afip3__FEParamGetCotizacion::MonId, "xsd:string"))
				{	soap_flag_MonId1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FEParamGetCotizacion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FEParamGetCotizacion, SOAP_TYPE__afip3__FEParamGetCotizacion, sizeof(_afip3__FEParamGetCotizacion), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FEParamGetCotizacion * SOAP_FMAC2 soap_instantiate__afip3__FEParamGetCotizacion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FEParamGetCotizacion(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FEParamGetCotizacion *p;
	size_t k = sizeof(_afip3__FEParamGetCotizacion);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FEParamGetCotizacion, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FEParamGetCotizacion);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FEParamGetCotizacion, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FEParamGetCotizacion location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FEParamGetCotizacion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FEParamGetCotizacion(soap, tag ? tag : "afip3:FEParamGetCotizacion", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FEParamGetCotizacion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FEParamGetCotizacion(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FEParamGetCotizacion * SOAP_FMAC4 soap_get__afip3__FEParamGetCotizacion(struct soap *soap, _afip3__FEParamGetCotizacion *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FEParamGetCotizacion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FECAEAConsultarResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FECAEAConsultarResponse::FECAEAConsultarResult = NULL;
}

void _afip3__FECAEAConsultarResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FECAEAGetResponse(soap, &this->_afip3__FECAEAConsultarResponse::FECAEAConsultarResult);
#endif
}

int _afip3__FECAEAConsultarResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FECAEAConsultarResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FECAEAConsultarResponse(struct soap *soap, const char *tag, int id, const _afip3__FECAEAConsultarResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FECAEAConsultarResponse), type))
		return soap->error;
	if (a->FECAEAConsultarResult)
		soap_element_result(soap, "afip3:FECAEAConsultarResult");
	if (soap_out_PointerToafip3__FECAEAGetResponse(soap, "afip3:FECAEAConsultarResult", -1, &a->_afip3__FECAEAConsultarResponse::FECAEAConsultarResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FECAEAConsultarResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FECAEAConsultarResponse(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FECAEAConsultarResponse * SOAP_FMAC4 soap_in__afip3__FECAEAConsultarResponse(struct soap *soap, const char *tag, _afip3__FECAEAConsultarResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FECAEAConsultarResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FECAEAConsultarResponse, sizeof(_afip3__FECAEAConsultarResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FECAEAConsultarResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FECAEAConsultarResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FECAEAConsultarResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FECAEAConsultarResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FECAEAGetResponse(soap, "afip3:FECAEAConsultarResult", &a->_afip3__FECAEAConsultarResponse::FECAEAConsultarResult, "afip3:FECAEAGetResponse"))
				{	soap_flag_FECAEAConsultarResult1--;
					continue;
				}
			}
			soap_check_result(soap, "afip3:FECAEAConsultarResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FECAEAConsultarResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FECAEAConsultarResponse, SOAP_TYPE__afip3__FECAEAConsultarResponse, sizeof(_afip3__FECAEAConsultarResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FECAEAConsultarResponse * SOAP_FMAC2 soap_instantiate__afip3__FECAEAConsultarResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FECAEAConsultarResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FECAEAConsultarResponse *p;
	size_t k = sizeof(_afip3__FECAEAConsultarResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FECAEAConsultarResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FECAEAConsultarResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FECAEAConsultarResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FECAEAConsultarResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FECAEAConsultarResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FECAEAConsultarResponse(soap, tag ? tag : "afip3:FECAEAConsultarResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FECAEAConsultarResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FECAEAConsultarResponse(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FECAEAConsultarResponse * SOAP_FMAC4 soap_get__afip3__FECAEAConsultarResponse(struct soap *soap, _afip3__FECAEAConsultarResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FECAEAConsultarResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FECAEAConsultar::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FECAEAConsultar::Auth = NULL;
	soap_default_int(soap, &this->_afip3__FECAEAConsultar::Periodo);
	soap_default_short(soap, &this->_afip3__FECAEAConsultar::Orden);
}

void _afip3__FECAEAConsultar::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FEAuthRequest(soap, &this->_afip3__FECAEAConsultar::Auth);
#endif
}

int _afip3__FECAEAConsultar::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FECAEAConsultar(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FECAEAConsultar(struct soap *soap, const char *tag, int id, const _afip3__FECAEAConsultar *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FECAEAConsultar), type))
		return soap->error;
	if (soap_out_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", -1, &a->_afip3__FECAEAConsultar::Auth, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:Periodo", -1, &a->_afip3__FECAEAConsultar::Periodo, ""))
		return soap->error;
	if (soap_out_short(soap, "afip3:Orden", -1, &a->_afip3__FECAEAConsultar::Orden, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FECAEAConsultar::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FECAEAConsultar(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FECAEAConsultar * SOAP_FMAC4 soap_in__afip3__FECAEAConsultar(struct soap *soap, const char *tag, _afip3__FECAEAConsultar *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FECAEAConsultar*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FECAEAConsultar, sizeof(_afip3__FECAEAConsultar), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FECAEAConsultar)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FECAEAConsultar *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	size_t soap_flag_Periodo1 = 1;
	size_t soap_flag_Orden1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", &a->_afip3__FECAEAConsultar::Auth, "afip3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap_flag_Periodo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:Periodo", &a->_afip3__FECAEAConsultar::Periodo, "xsd:int"))
				{	soap_flag_Periodo1--;
					continue;
				}
			}
			if (soap_flag_Orden1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_short(soap, "afip3:Orden", &a->_afip3__FECAEAConsultar::Orden, "xsd:short"))
				{	soap_flag_Orden1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Periodo1 > 0 || soap_flag_Orden1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_afip3__FECAEAConsultar *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FECAEAConsultar, SOAP_TYPE__afip3__FECAEAConsultar, sizeof(_afip3__FECAEAConsultar), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FECAEAConsultar * SOAP_FMAC2 soap_instantiate__afip3__FECAEAConsultar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FECAEAConsultar(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FECAEAConsultar *p;
	size_t k = sizeof(_afip3__FECAEAConsultar);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FECAEAConsultar, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FECAEAConsultar);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FECAEAConsultar, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FECAEAConsultar location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FECAEAConsultar::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FECAEAConsultar(soap, tag ? tag : "afip3:FECAEAConsultar", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FECAEAConsultar::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FECAEAConsultar(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FECAEAConsultar * SOAP_FMAC4 soap_get__afip3__FECAEAConsultar(struct soap *soap, _afip3__FECAEAConsultar *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FECAEAConsultar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FECAEASinMovimientoInformarResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FECAEASinMovimientoInformarResponse::FECAEASinMovimientoInformarResult = NULL;
}

void _afip3__FECAEASinMovimientoInformarResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FECAEASinMovResponse(soap, &this->_afip3__FECAEASinMovimientoInformarResponse::FECAEASinMovimientoInformarResult);
#endif
}

int _afip3__FECAEASinMovimientoInformarResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FECAEASinMovimientoInformarResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FECAEASinMovimientoInformarResponse(struct soap *soap, const char *tag, int id, const _afip3__FECAEASinMovimientoInformarResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FECAEASinMovimientoInformarResponse), type))
		return soap->error;
	if (a->FECAEASinMovimientoInformarResult)
		soap_element_result(soap, "afip3:FECAEASinMovimientoInformarResult");
	if (soap_out_PointerToafip3__FECAEASinMovResponse(soap, "afip3:FECAEASinMovimientoInformarResult", -1, &a->_afip3__FECAEASinMovimientoInformarResponse::FECAEASinMovimientoInformarResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FECAEASinMovimientoInformarResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FECAEASinMovimientoInformarResponse(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FECAEASinMovimientoInformarResponse * SOAP_FMAC4 soap_in__afip3__FECAEASinMovimientoInformarResponse(struct soap *soap, const char *tag, _afip3__FECAEASinMovimientoInformarResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FECAEASinMovimientoInformarResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FECAEASinMovimientoInformarResponse, sizeof(_afip3__FECAEASinMovimientoInformarResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FECAEASinMovimientoInformarResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FECAEASinMovimientoInformarResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FECAEASinMovimientoInformarResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FECAEASinMovimientoInformarResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FECAEASinMovResponse(soap, "afip3:FECAEASinMovimientoInformarResult", &a->_afip3__FECAEASinMovimientoInformarResponse::FECAEASinMovimientoInformarResult, "afip3:FECAEASinMovResponse"))
				{	soap_flag_FECAEASinMovimientoInformarResult1--;
					continue;
				}
			}
			soap_check_result(soap, "afip3:FECAEASinMovimientoInformarResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FECAEASinMovimientoInformarResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FECAEASinMovimientoInformarResponse, SOAP_TYPE__afip3__FECAEASinMovimientoInformarResponse, sizeof(_afip3__FECAEASinMovimientoInformarResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FECAEASinMovimientoInformarResponse * SOAP_FMAC2 soap_instantiate__afip3__FECAEASinMovimientoInformarResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FECAEASinMovimientoInformarResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FECAEASinMovimientoInformarResponse *p;
	size_t k = sizeof(_afip3__FECAEASinMovimientoInformarResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FECAEASinMovimientoInformarResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FECAEASinMovimientoInformarResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FECAEASinMovimientoInformarResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FECAEASinMovimientoInformarResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FECAEASinMovimientoInformarResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FECAEASinMovimientoInformarResponse(soap, tag ? tag : "afip3:FECAEASinMovimientoInformarResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FECAEASinMovimientoInformarResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FECAEASinMovimientoInformarResponse(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FECAEASinMovimientoInformarResponse * SOAP_FMAC4 soap_get__afip3__FECAEASinMovimientoInformarResponse(struct soap *soap, _afip3__FECAEASinMovimientoInformarResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FECAEASinMovimientoInformarResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FECAEASinMovimientoInformar::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FECAEASinMovimientoInformar::Auth = NULL;
	soap_default_int(soap, &this->_afip3__FECAEASinMovimientoInformar::PtoVta);
	this->_afip3__FECAEASinMovimientoInformar::CAEA = NULL;
}

void _afip3__FECAEASinMovimientoInformar::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FEAuthRequest(soap, &this->_afip3__FECAEASinMovimientoInformar::Auth);
	soap_serialize_PointerTostd__string(soap, &this->_afip3__FECAEASinMovimientoInformar::CAEA);
#endif
}

int _afip3__FECAEASinMovimientoInformar::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FECAEASinMovimientoInformar(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FECAEASinMovimientoInformar(struct soap *soap, const char *tag, int id, const _afip3__FECAEASinMovimientoInformar *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FECAEASinMovimientoInformar), type))
		return soap->error;
	if (soap_out_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", -1, &a->_afip3__FECAEASinMovimientoInformar::Auth, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:PtoVta", -1, &a->_afip3__FECAEASinMovimientoInformar::PtoVta, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:CAEA", -1, &a->_afip3__FECAEASinMovimientoInformar::CAEA, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FECAEASinMovimientoInformar::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FECAEASinMovimientoInformar(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FECAEASinMovimientoInformar * SOAP_FMAC4 soap_in__afip3__FECAEASinMovimientoInformar(struct soap *soap, const char *tag, _afip3__FECAEASinMovimientoInformar *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FECAEASinMovimientoInformar*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FECAEASinMovimientoInformar, sizeof(_afip3__FECAEASinMovimientoInformar), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FECAEASinMovimientoInformar)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FECAEASinMovimientoInformar *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	size_t soap_flag_PtoVta1 = 1;
	size_t soap_flag_CAEA1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", &a->_afip3__FECAEASinMovimientoInformar::Auth, "afip3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap_flag_PtoVta1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:PtoVta", &a->_afip3__FECAEASinMovimientoInformar::PtoVta, "xsd:int"))
				{	soap_flag_PtoVta1--;
					continue;
				}
			}
			if (soap_flag_CAEA1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:CAEA", &a->_afip3__FECAEASinMovimientoInformar::CAEA, "xsd:string"))
				{	soap_flag_CAEA1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PtoVta1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_afip3__FECAEASinMovimientoInformar *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FECAEASinMovimientoInformar, SOAP_TYPE__afip3__FECAEASinMovimientoInformar, sizeof(_afip3__FECAEASinMovimientoInformar), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FECAEASinMovimientoInformar * SOAP_FMAC2 soap_instantiate__afip3__FECAEASinMovimientoInformar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FECAEASinMovimientoInformar(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FECAEASinMovimientoInformar *p;
	size_t k = sizeof(_afip3__FECAEASinMovimientoInformar);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FECAEASinMovimientoInformar, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FECAEASinMovimientoInformar);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FECAEASinMovimientoInformar, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FECAEASinMovimientoInformar location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FECAEASinMovimientoInformar::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FECAEASinMovimientoInformar(soap, tag ? tag : "afip3:FECAEASinMovimientoInformar", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FECAEASinMovimientoInformar::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FECAEASinMovimientoInformar(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FECAEASinMovimientoInformar * SOAP_FMAC4 soap_get__afip3__FECAEASinMovimientoInformar(struct soap *soap, _afip3__FECAEASinMovimientoInformar *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FECAEASinMovimientoInformar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FECAEASinMovimientoConsultarResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FECAEASinMovimientoConsultarResponse::FECAEASinMovimientoConsultarResult = NULL;
}

void _afip3__FECAEASinMovimientoConsultarResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FECAEASinMovConsResponse(soap, &this->_afip3__FECAEASinMovimientoConsultarResponse::FECAEASinMovimientoConsultarResult);
#endif
}

int _afip3__FECAEASinMovimientoConsultarResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FECAEASinMovimientoConsultarResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FECAEASinMovimientoConsultarResponse(struct soap *soap, const char *tag, int id, const _afip3__FECAEASinMovimientoConsultarResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FECAEASinMovimientoConsultarResponse), type))
		return soap->error;
	if (a->FECAEASinMovimientoConsultarResult)
		soap_element_result(soap, "afip3:FECAEASinMovimientoConsultarResult");
	if (soap_out_PointerToafip3__FECAEASinMovConsResponse(soap, "afip3:FECAEASinMovimientoConsultarResult", -1, &a->_afip3__FECAEASinMovimientoConsultarResponse::FECAEASinMovimientoConsultarResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FECAEASinMovimientoConsultarResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FECAEASinMovimientoConsultarResponse(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FECAEASinMovimientoConsultarResponse * SOAP_FMAC4 soap_in__afip3__FECAEASinMovimientoConsultarResponse(struct soap *soap, const char *tag, _afip3__FECAEASinMovimientoConsultarResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FECAEASinMovimientoConsultarResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FECAEASinMovimientoConsultarResponse, sizeof(_afip3__FECAEASinMovimientoConsultarResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FECAEASinMovimientoConsultarResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FECAEASinMovimientoConsultarResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FECAEASinMovimientoConsultarResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FECAEASinMovimientoConsultarResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FECAEASinMovConsResponse(soap, "afip3:FECAEASinMovimientoConsultarResult", &a->_afip3__FECAEASinMovimientoConsultarResponse::FECAEASinMovimientoConsultarResult, "afip3:FECAEASinMovConsResponse"))
				{	soap_flag_FECAEASinMovimientoConsultarResult1--;
					continue;
				}
			}
			soap_check_result(soap, "afip3:FECAEASinMovimientoConsultarResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FECAEASinMovimientoConsultarResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FECAEASinMovimientoConsultarResponse, SOAP_TYPE__afip3__FECAEASinMovimientoConsultarResponse, sizeof(_afip3__FECAEASinMovimientoConsultarResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FECAEASinMovimientoConsultarResponse * SOAP_FMAC2 soap_instantiate__afip3__FECAEASinMovimientoConsultarResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FECAEASinMovimientoConsultarResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FECAEASinMovimientoConsultarResponse *p;
	size_t k = sizeof(_afip3__FECAEASinMovimientoConsultarResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FECAEASinMovimientoConsultarResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FECAEASinMovimientoConsultarResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FECAEASinMovimientoConsultarResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FECAEASinMovimientoConsultarResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FECAEASinMovimientoConsultarResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FECAEASinMovimientoConsultarResponse(soap, tag ? tag : "afip3:FECAEASinMovimientoConsultarResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FECAEASinMovimientoConsultarResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FECAEASinMovimientoConsultarResponse(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FECAEASinMovimientoConsultarResponse * SOAP_FMAC4 soap_get__afip3__FECAEASinMovimientoConsultarResponse(struct soap *soap, _afip3__FECAEASinMovimientoConsultarResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FECAEASinMovimientoConsultarResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FECAEASinMovimientoConsultar::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FECAEASinMovimientoConsultar::Auth = NULL;
	this->_afip3__FECAEASinMovimientoConsultar::CAEA = NULL;
	soap_default_int(soap, &this->_afip3__FECAEASinMovimientoConsultar::PtoVta);
}

void _afip3__FECAEASinMovimientoConsultar::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FEAuthRequest(soap, &this->_afip3__FECAEASinMovimientoConsultar::Auth);
	soap_serialize_PointerTostd__string(soap, &this->_afip3__FECAEASinMovimientoConsultar::CAEA);
#endif
}

int _afip3__FECAEASinMovimientoConsultar::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FECAEASinMovimientoConsultar(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FECAEASinMovimientoConsultar(struct soap *soap, const char *tag, int id, const _afip3__FECAEASinMovimientoConsultar *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FECAEASinMovimientoConsultar), type))
		return soap->error;
	if (soap_out_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", -1, &a->_afip3__FECAEASinMovimientoConsultar::Auth, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:CAEA", -1, &a->_afip3__FECAEASinMovimientoConsultar::CAEA, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:PtoVta", -1, &a->_afip3__FECAEASinMovimientoConsultar::PtoVta, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FECAEASinMovimientoConsultar::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FECAEASinMovimientoConsultar(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FECAEASinMovimientoConsultar * SOAP_FMAC4 soap_in__afip3__FECAEASinMovimientoConsultar(struct soap *soap, const char *tag, _afip3__FECAEASinMovimientoConsultar *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FECAEASinMovimientoConsultar*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FECAEASinMovimientoConsultar, sizeof(_afip3__FECAEASinMovimientoConsultar), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FECAEASinMovimientoConsultar)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FECAEASinMovimientoConsultar *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	size_t soap_flag_CAEA1 = 1;
	size_t soap_flag_PtoVta1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", &a->_afip3__FECAEASinMovimientoConsultar::Auth, "afip3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap_flag_CAEA1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:CAEA", &a->_afip3__FECAEASinMovimientoConsultar::CAEA, "xsd:string"))
				{	soap_flag_CAEA1--;
					continue;
				}
			}
			if (soap_flag_PtoVta1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:PtoVta", &a->_afip3__FECAEASinMovimientoConsultar::PtoVta, "xsd:int"))
				{	soap_flag_PtoVta1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PtoVta1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_afip3__FECAEASinMovimientoConsultar *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FECAEASinMovimientoConsultar, SOAP_TYPE__afip3__FECAEASinMovimientoConsultar, sizeof(_afip3__FECAEASinMovimientoConsultar), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FECAEASinMovimientoConsultar * SOAP_FMAC2 soap_instantiate__afip3__FECAEASinMovimientoConsultar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FECAEASinMovimientoConsultar(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FECAEASinMovimientoConsultar *p;
	size_t k = sizeof(_afip3__FECAEASinMovimientoConsultar);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FECAEASinMovimientoConsultar, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FECAEASinMovimientoConsultar);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FECAEASinMovimientoConsultar, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FECAEASinMovimientoConsultar location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FECAEASinMovimientoConsultar::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FECAEASinMovimientoConsultar(soap, tag ? tag : "afip3:FECAEASinMovimientoConsultar", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FECAEASinMovimientoConsultar::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FECAEASinMovimientoConsultar(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FECAEASinMovimientoConsultar * SOAP_FMAC4 soap_get__afip3__FECAEASinMovimientoConsultar(struct soap *soap, _afip3__FECAEASinMovimientoConsultar *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FECAEASinMovimientoConsultar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FECAEASolicitarResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FECAEASolicitarResponse::FECAEASolicitarResult = NULL;
}

void _afip3__FECAEASolicitarResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FECAEAGetResponse(soap, &this->_afip3__FECAEASolicitarResponse::FECAEASolicitarResult);
#endif
}

int _afip3__FECAEASolicitarResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FECAEASolicitarResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FECAEASolicitarResponse(struct soap *soap, const char *tag, int id, const _afip3__FECAEASolicitarResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FECAEASolicitarResponse), type))
		return soap->error;
	if (a->FECAEASolicitarResult)
		soap_element_result(soap, "afip3:FECAEASolicitarResult");
	if (soap_out_PointerToafip3__FECAEAGetResponse(soap, "afip3:FECAEASolicitarResult", -1, &a->_afip3__FECAEASolicitarResponse::FECAEASolicitarResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FECAEASolicitarResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FECAEASolicitarResponse(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FECAEASolicitarResponse * SOAP_FMAC4 soap_in__afip3__FECAEASolicitarResponse(struct soap *soap, const char *tag, _afip3__FECAEASolicitarResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FECAEASolicitarResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FECAEASolicitarResponse, sizeof(_afip3__FECAEASolicitarResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FECAEASolicitarResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FECAEASolicitarResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FECAEASolicitarResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FECAEASolicitarResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FECAEAGetResponse(soap, "afip3:FECAEASolicitarResult", &a->_afip3__FECAEASolicitarResponse::FECAEASolicitarResult, "afip3:FECAEAGetResponse"))
				{	soap_flag_FECAEASolicitarResult1--;
					continue;
				}
			}
			soap_check_result(soap, "afip3:FECAEASolicitarResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FECAEASolicitarResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FECAEASolicitarResponse, SOAP_TYPE__afip3__FECAEASolicitarResponse, sizeof(_afip3__FECAEASolicitarResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FECAEASolicitarResponse * SOAP_FMAC2 soap_instantiate__afip3__FECAEASolicitarResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FECAEASolicitarResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FECAEASolicitarResponse *p;
	size_t k = sizeof(_afip3__FECAEASolicitarResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FECAEASolicitarResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FECAEASolicitarResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FECAEASolicitarResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FECAEASolicitarResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FECAEASolicitarResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FECAEASolicitarResponse(soap, tag ? tag : "afip3:FECAEASolicitarResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FECAEASolicitarResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FECAEASolicitarResponse(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FECAEASolicitarResponse * SOAP_FMAC4 soap_get__afip3__FECAEASolicitarResponse(struct soap *soap, _afip3__FECAEASolicitarResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FECAEASolicitarResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FECAEASolicitar::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FECAEASolicitar::Auth = NULL;
	soap_default_int(soap, &this->_afip3__FECAEASolicitar::Periodo);
	soap_default_short(soap, &this->_afip3__FECAEASolicitar::Orden);
}

void _afip3__FECAEASolicitar::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FEAuthRequest(soap, &this->_afip3__FECAEASolicitar::Auth);
#endif
}

int _afip3__FECAEASolicitar::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FECAEASolicitar(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FECAEASolicitar(struct soap *soap, const char *tag, int id, const _afip3__FECAEASolicitar *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FECAEASolicitar), type))
		return soap->error;
	if (soap_out_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", -1, &a->_afip3__FECAEASolicitar::Auth, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:Periodo", -1, &a->_afip3__FECAEASolicitar::Periodo, ""))
		return soap->error;
	if (soap_out_short(soap, "afip3:Orden", -1, &a->_afip3__FECAEASolicitar::Orden, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FECAEASolicitar::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FECAEASolicitar(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FECAEASolicitar * SOAP_FMAC4 soap_in__afip3__FECAEASolicitar(struct soap *soap, const char *tag, _afip3__FECAEASolicitar *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FECAEASolicitar*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FECAEASolicitar, sizeof(_afip3__FECAEASolicitar), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FECAEASolicitar)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FECAEASolicitar *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	size_t soap_flag_Periodo1 = 1;
	size_t soap_flag_Orden1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", &a->_afip3__FECAEASolicitar::Auth, "afip3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap_flag_Periodo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:Periodo", &a->_afip3__FECAEASolicitar::Periodo, "xsd:int"))
				{	soap_flag_Periodo1--;
					continue;
				}
			}
			if (soap_flag_Orden1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_short(soap, "afip3:Orden", &a->_afip3__FECAEASolicitar::Orden, "xsd:short"))
				{	soap_flag_Orden1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Periodo1 > 0 || soap_flag_Orden1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_afip3__FECAEASolicitar *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FECAEASolicitar, SOAP_TYPE__afip3__FECAEASolicitar, sizeof(_afip3__FECAEASolicitar), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FECAEASolicitar * SOAP_FMAC2 soap_instantiate__afip3__FECAEASolicitar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FECAEASolicitar(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FECAEASolicitar *p;
	size_t k = sizeof(_afip3__FECAEASolicitar);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FECAEASolicitar, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FECAEASolicitar);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FECAEASolicitar, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FECAEASolicitar location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FECAEASolicitar::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FECAEASolicitar(soap, tag ? tag : "afip3:FECAEASolicitar", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FECAEASolicitar::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FECAEASolicitar(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FECAEASolicitar * SOAP_FMAC4 soap_get__afip3__FECAEASolicitar(struct soap *soap, _afip3__FECAEASolicitar *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FECAEASolicitar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FECAEARegInformativoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FECAEARegInformativoResponse::FECAEARegInformativoResult = NULL;
}

void _afip3__FECAEARegInformativoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FECAEAResponse(soap, &this->_afip3__FECAEARegInformativoResponse::FECAEARegInformativoResult);
#endif
}

int _afip3__FECAEARegInformativoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FECAEARegInformativoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FECAEARegInformativoResponse(struct soap *soap, const char *tag, int id, const _afip3__FECAEARegInformativoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FECAEARegInformativoResponse), type))
		return soap->error;
	if (a->FECAEARegInformativoResult)
		soap_element_result(soap, "afip3:FECAEARegInformativoResult");
	if (soap_out_PointerToafip3__FECAEAResponse(soap, "afip3:FECAEARegInformativoResult", -1, &a->_afip3__FECAEARegInformativoResponse::FECAEARegInformativoResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FECAEARegInformativoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FECAEARegInformativoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FECAEARegInformativoResponse * SOAP_FMAC4 soap_in__afip3__FECAEARegInformativoResponse(struct soap *soap, const char *tag, _afip3__FECAEARegInformativoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FECAEARegInformativoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FECAEARegInformativoResponse, sizeof(_afip3__FECAEARegInformativoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FECAEARegInformativoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FECAEARegInformativoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FECAEARegInformativoResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FECAEARegInformativoResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FECAEAResponse(soap, "afip3:FECAEARegInformativoResult", &a->_afip3__FECAEARegInformativoResponse::FECAEARegInformativoResult, "afip3:FECAEAResponse"))
				{	soap_flag_FECAEARegInformativoResult1--;
					continue;
				}
			}
			soap_check_result(soap, "afip3:FECAEARegInformativoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FECAEARegInformativoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FECAEARegInformativoResponse, SOAP_TYPE__afip3__FECAEARegInformativoResponse, sizeof(_afip3__FECAEARegInformativoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FECAEARegInformativoResponse * SOAP_FMAC2 soap_instantiate__afip3__FECAEARegInformativoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FECAEARegInformativoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FECAEARegInformativoResponse *p;
	size_t k = sizeof(_afip3__FECAEARegInformativoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FECAEARegInformativoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FECAEARegInformativoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FECAEARegInformativoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FECAEARegInformativoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FECAEARegInformativoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FECAEARegInformativoResponse(soap, tag ? tag : "afip3:FECAEARegInformativoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FECAEARegInformativoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FECAEARegInformativoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FECAEARegInformativoResponse * SOAP_FMAC4 soap_get__afip3__FECAEARegInformativoResponse(struct soap *soap, _afip3__FECAEARegInformativoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FECAEARegInformativoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FECAEARegInformativo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FECAEARegInformativo::Auth = NULL;
	this->_afip3__FECAEARegInformativo::FeCAEARegInfReq = NULL;
}

void _afip3__FECAEARegInformativo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FEAuthRequest(soap, &this->_afip3__FECAEARegInformativo::Auth);
	soap_serialize_PointerToafip3__FECAEARequest(soap, &this->_afip3__FECAEARegInformativo::FeCAEARegInfReq);
#endif
}

int _afip3__FECAEARegInformativo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FECAEARegInformativo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FECAEARegInformativo(struct soap *soap, const char *tag, int id, const _afip3__FECAEARegInformativo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FECAEARegInformativo), type))
		return soap->error;
	if (soap_out_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", -1, &a->_afip3__FECAEARegInformativo::Auth, ""))
		return soap->error;
	if (soap_out_PointerToafip3__FECAEARequest(soap, "afip3:FeCAEARegInfReq", -1, &a->_afip3__FECAEARegInformativo::FeCAEARegInfReq, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FECAEARegInformativo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FECAEARegInformativo(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FECAEARegInformativo * SOAP_FMAC4 soap_in__afip3__FECAEARegInformativo(struct soap *soap, const char *tag, _afip3__FECAEARegInformativo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FECAEARegInformativo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FECAEARegInformativo, sizeof(_afip3__FECAEARegInformativo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FECAEARegInformativo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FECAEARegInformativo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	size_t soap_flag_FeCAEARegInfReq1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", &a->_afip3__FECAEARegInformativo::Auth, "afip3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap_flag_FeCAEARegInfReq1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FECAEARequest(soap, "afip3:FeCAEARegInfReq", &a->_afip3__FECAEARegInformativo::FeCAEARegInfReq, "afip3:FECAEARequest"))
				{	soap_flag_FeCAEARegInfReq1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FECAEARegInformativo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FECAEARegInformativo, SOAP_TYPE__afip3__FECAEARegInformativo, sizeof(_afip3__FECAEARegInformativo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FECAEARegInformativo * SOAP_FMAC2 soap_instantiate__afip3__FECAEARegInformativo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FECAEARegInformativo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FECAEARegInformativo *p;
	size_t k = sizeof(_afip3__FECAEARegInformativo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FECAEARegInformativo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FECAEARegInformativo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FECAEARegInformativo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FECAEARegInformativo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FECAEARegInformativo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FECAEARegInformativo(soap, tag ? tag : "afip3:FECAEARegInformativo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FECAEARegInformativo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FECAEARegInformativo(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FECAEARegInformativo * SOAP_FMAC4 soap_get__afip3__FECAEARegInformativo(struct soap *soap, _afip3__FECAEARegInformativo *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FECAEARegInformativo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FECompConsultarResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FECompConsultarResponse::FECompConsultarResult = NULL;
}

void _afip3__FECompConsultarResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FECompConsultaResponse(soap, &this->_afip3__FECompConsultarResponse::FECompConsultarResult);
#endif
}

int _afip3__FECompConsultarResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FECompConsultarResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FECompConsultarResponse(struct soap *soap, const char *tag, int id, const _afip3__FECompConsultarResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FECompConsultarResponse), type))
		return soap->error;
	if (a->FECompConsultarResult)
		soap_element_result(soap, "afip3:FECompConsultarResult");
	if (soap_out_PointerToafip3__FECompConsultaResponse(soap, "afip3:FECompConsultarResult", -1, &a->_afip3__FECompConsultarResponse::FECompConsultarResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FECompConsultarResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FECompConsultarResponse(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FECompConsultarResponse * SOAP_FMAC4 soap_in__afip3__FECompConsultarResponse(struct soap *soap, const char *tag, _afip3__FECompConsultarResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FECompConsultarResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FECompConsultarResponse, sizeof(_afip3__FECompConsultarResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FECompConsultarResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FECompConsultarResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FECompConsultarResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FECompConsultarResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FECompConsultaResponse(soap, "afip3:FECompConsultarResult", &a->_afip3__FECompConsultarResponse::FECompConsultarResult, "afip3:FECompConsultaResponse"))
				{	soap_flag_FECompConsultarResult1--;
					continue;
				}
			}
			soap_check_result(soap, "afip3:FECompConsultarResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FECompConsultarResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FECompConsultarResponse, SOAP_TYPE__afip3__FECompConsultarResponse, sizeof(_afip3__FECompConsultarResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FECompConsultarResponse * SOAP_FMAC2 soap_instantiate__afip3__FECompConsultarResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FECompConsultarResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FECompConsultarResponse *p;
	size_t k = sizeof(_afip3__FECompConsultarResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FECompConsultarResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FECompConsultarResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FECompConsultarResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FECompConsultarResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FECompConsultarResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FECompConsultarResponse(soap, tag ? tag : "afip3:FECompConsultarResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FECompConsultarResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FECompConsultarResponse(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FECompConsultarResponse * SOAP_FMAC4 soap_get__afip3__FECompConsultarResponse(struct soap *soap, _afip3__FECompConsultarResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FECompConsultarResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FECompConsultar::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FECompConsultar::Auth = NULL;
	this->_afip3__FECompConsultar::FeCompConsReq = NULL;
}

void _afip3__FECompConsultar::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FEAuthRequest(soap, &this->_afip3__FECompConsultar::Auth);
	soap_serialize_PointerToafip3__FECompConsultaReq(soap, &this->_afip3__FECompConsultar::FeCompConsReq);
#endif
}

int _afip3__FECompConsultar::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FECompConsultar(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FECompConsultar(struct soap *soap, const char *tag, int id, const _afip3__FECompConsultar *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FECompConsultar), type))
		return soap->error;
	if (soap_out_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", -1, &a->_afip3__FECompConsultar::Auth, ""))
		return soap->error;
	if (soap_out_PointerToafip3__FECompConsultaReq(soap, "afip3:FeCompConsReq", -1, &a->_afip3__FECompConsultar::FeCompConsReq, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FECompConsultar::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FECompConsultar(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FECompConsultar * SOAP_FMAC4 soap_in__afip3__FECompConsultar(struct soap *soap, const char *tag, _afip3__FECompConsultar *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FECompConsultar*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FECompConsultar, sizeof(_afip3__FECompConsultar), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FECompConsultar)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FECompConsultar *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	size_t soap_flag_FeCompConsReq1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", &a->_afip3__FECompConsultar::Auth, "afip3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap_flag_FeCompConsReq1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FECompConsultaReq(soap, "afip3:FeCompConsReq", &a->_afip3__FECompConsultar::FeCompConsReq, "afip3:FECompConsultaReq"))
				{	soap_flag_FeCompConsReq1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FECompConsultar *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FECompConsultar, SOAP_TYPE__afip3__FECompConsultar, sizeof(_afip3__FECompConsultar), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FECompConsultar * SOAP_FMAC2 soap_instantiate__afip3__FECompConsultar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FECompConsultar(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FECompConsultar *p;
	size_t k = sizeof(_afip3__FECompConsultar);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FECompConsultar, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FECompConsultar);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FECompConsultar, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FECompConsultar location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FECompConsultar::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FECompConsultar(soap, tag ? tag : "afip3:FECompConsultar", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FECompConsultar::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FECompConsultar(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FECompConsultar * SOAP_FMAC4 soap_get__afip3__FECompConsultar(struct soap *soap, _afip3__FECompConsultar *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FECompConsultar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FECompUltimoAutorizadoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FECompUltimoAutorizadoResponse::FECompUltimoAutorizadoResult = NULL;
}

void _afip3__FECompUltimoAutorizadoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FERecuperaLastCbteResponse(soap, &this->_afip3__FECompUltimoAutorizadoResponse::FECompUltimoAutorizadoResult);
#endif
}

int _afip3__FECompUltimoAutorizadoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FECompUltimoAutorizadoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FECompUltimoAutorizadoResponse(struct soap *soap, const char *tag, int id, const _afip3__FECompUltimoAutorizadoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FECompUltimoAutorizadoResponse), type))
		return soap->error;
	if (a->FECompUltimoAutorizadoResult)
		soap_element_result(soap, "afip3:FECompUltimoAutorizadoResult");
	if (soap_out_PointerToafip3__FERecuperaLastCbteResponse(soap, "afip3:FECompUltimoAutorizadoResult", -1, &a->_afip3__FECompUltimoAutorizadoResponse::FECompUltimoAutorizadoResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FECompUltimoAutorizadoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FECompUltimoAutorizadoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FECompUltimoAutorizadoResponse * SOAP_FMAC4 soap_in__afip3__FECompUltimoAutorizadoResponse(struct soap *soap, const char *tag, _afip3__FECompUltimoAutorizadoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FECompUltimoAutorizadoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FECompUltimoAutorizadoResponse, sizeof(_afip3__FECompUltimoAutorizadoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FECompUltimoAutorizadoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FECompUltimoAutorizadoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FECompUltimoAutorizadoResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FECompUltimoAutorizadoResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FERecuperaLastCbteResponse(soap, "afip3:FECompUltimoAutorizadoResult", &a->_afip3__FECompUltimoAutorizadoResponse::FECompUltimoAutorizadoResult, "afip3:FERecuperaLastCbteResponse"))
				{	soap_flag_FECompUltimoAutorizadoResult1--;
					continue;
				}
			}
			soap_check_result(soap, "afip3:FECompUltimoAutorizadoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FECompUltimoAutorizadoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FECompUltimoAutorizadoResponse, SOAP_TYPE__afip3__FECompUltimoAutorizadoResponse, sizeof(_afip3__FECompUltimoAutorizadoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FECompUltimoAutorizadoResponse * SOAP_FMAC2 soap_instantiate__afip3__FECompUltimoAutorizadoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FECompUltimoAutorizadoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FECompUltimoAutorizadoResponse *p;
	size_t k = sizeof(_afip3__FECompUltimoAutorizadoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FECompUltimoAutorizadoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FECompUltimoAutorizadoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FECompUltimoAutorizadoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FECompUltimoAutorizadoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FECompUltimoAutorizadoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FECompUltimoAutorizadoResponse(soap, tag ? tag : "afip3:FECompUltimoAutorizadoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FECompUltimoAutorizadoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FECompUltimoAutorizadoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FECompUltimoAutorizadoResponse * SOAP_FMAC4 soap_get__afip3__FECompUltimoAutorizadoResponse(struct soap *soap, _afip3__FECompUltimoAutorizadoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FECompUltimoAutorizadoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FECompUltimoAutorizado::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FECompUltimoAutorizado::Auth = NULL;
	soap_default_int(soap, &this->_afip3__FECompUltimoAutorizado::PtoVta);
	soap_default_int(soap, &this->_afip3__FECompUltimoAutorizado::CbteTipo);
}

void _afip3__FECompUltimoAutorizado::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FEAuthRequest(soap, &this->_afip3__FECompUltimoAutorizado::Auth);
#endif
}

int _afip3__FECompUltimoAutorizado::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FECompUltimoAutorizado(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FECompUltimoAutorizado(struct soap *soap, const char *tag, int id, const _afip3__FECompUltimoAutorizado *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FECompUltimoAutorizado), type))
		return soap->error;
	if (soap_out_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", -1, &a->_afip3__FECompUltimoAutorizado::Auth, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:PtoVta", -1, &a->_afip3__FECompUltimoAutorizado::PtoVta, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:CbteTipo", -1, &a->_afip3__FECompUltimoAutorizado::CbteTipo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FECompUltimoAutorizado::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FECompUltimoAutorizado(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FECompUltimoAutorizado * SOAP_FMAC4 soap_in__afip3__FECompUltimoAutorizado(struct soap *soap, const char *tag, _afip3__FECompUltimoAutorizado *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FECompUltimoAutorizado*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FECompUltimoAutorizado, sizeof(_afip3__FECompUltimoAutorizado), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FECompUltimoAutorizado)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FECompUltimoAutorizado *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	size_t soap_flag_PtoVta1 = 1;
	size_t soap_flag_CbteTipo1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", &a->_afip3__FECompUltimoAutorizado::Auth, "afip3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap_flag_PtoVta1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:PtoVta", &a->_afip3__FECompUltimoAutorizado::PtoVta, "xsd:int"))
				{	soap_flag_PtoVta1--;
					continue;
				}
			}
			if (soap_flag_CbteTipo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:CbteTipo", &a->_afip3__FECompUltimoAutorizado::CbteTipo, "xsd:int"))
				{	soap_flag_CbteTipo1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PtoVta1 > 0 || soap_flag_CbteTipo1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_afip3__FECompUltimoAutorizado *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FECompUltimoAutorizado, SOAP_TYPE__afip3__FECompUltimoAutorizado, sizeof(_afip3__FECompUltimoAutorizado), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FECompUltimoAutorizado * SOAP_FMAC2 soap_instantiate__afip3__FECompUltimoAutorizado(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FECompUltimoAutorizado(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FECompUltimoAutorizado *p;
	size_t k = sizeof(_afip3__FECompUltimoAutorizado);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FECompUltimoAutorizado, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FECompUltimoAutorizado);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FECompUltimoAutorizado, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FECompUltimoAutorizado location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FECompUltimoAutorizado::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FECompUltimoAutorizado(soap, tag ? tag : "afip3:FECompUltimoAutorizado", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FECompUltimoAutorizado::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FECompUltimoAutorizado(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FECompUltimoAutorizado * SOAP_FMAC4 soap_get__afip3__FECompUltimoAutorizado(struct soap *soap, _afip3__FECompUltimoAutorizado *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FECompUltimoAutorizado(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FEDummyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FEDummyResponse::FEDummyResult = NULL;
}

void _afip3__FEDummyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__DummyResponse(soap, &this->_afip3__FEDummyResponse::FEDummyResult);
#endif
}

int _afip3__FEDummyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FEDummyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FEDummyResponse(struct soap *soap, const char *tag, int id, const _afip3__FEDummyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FEDummyResponse), type))
		return soap->error;
	if (a->FEDummyResult)
		soap_element_result(soap, "afip3:FEDummyResult");
	if (soap_out_PointerToafip3__DummyResponse(soap, "afip3:FEDummyResult", -1, &a->_afip3__FEDummyResponse::FEDummyResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FEDummyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FEDummyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FEDummyResponse * SOAP_FMAC4 soap_in__afip3__FEDummyResponse(struct soap *soap, const char *tag, _afip3__FEDummyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FEDummyResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FEDummyResponse, sizeof(_afip3__FEDummyResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FEDummyResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FEDummyResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FEDummyResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FEDummyResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__DummyResponse(soap, "afip3:FEDummyResult", &a->_afip3__FEDummyResponse::FEDummyResult, "afip3:DummyResponse"))
				{	soap_flag_FEDummyResult1--;
					continue;
				}
			}
			soap_check_result(soap, "afip3:FEDummyResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FEDummyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FEDummyResponse, SOAP_TYPE__afip3__FEDummyResponse, sizeof(_afip3__FEDummyResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FEDummyResponse * SOAP_FMAC2 soap_instantiate__afip3__FEDummyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FEDummyResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FEDummyResponse *p;
	size_t k = sizeof(_afip3__FEDummyResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FEDummyResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FEDummyResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FEDummyResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FEDummyResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FEDummyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FEDummyResponse(soap, tag ? tag : "afip3:FEDummyResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FEDummyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FEDummyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FEDummyResponse * SOAP_FMAC4 soap_get__afip3__FEDummyResponse(struct soap *soap, _afip3__FEDummyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FEDummyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FEDummy::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _afip3__FEDummy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _afip3__FEDummy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FEDummy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FEDummy(struct soap *soap, const char *tag, int id, const _afip3__FEDummy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FEDummy), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FEDummy::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FEDummy(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FEDummy * SOAP_FMAC4 soap_in__afip3__FEDummy(struct soap *soap, const char *tag, _afip3__FEDummy *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FEDummy*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FEDummy, sizeof(_afip3__FEDummy), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FEDummy)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FEDummy *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FEDummy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FEDummy, SOAP_TYPE__afip3__FEDummy, sizeof(_afip3__FEDummy), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FEDummy * SOAP_FMAC2 soap_instantiate__afip3__FEDummy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FEDummy(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FEDummy *p;
	size_t k = sizeof(_afip3__FEDummy);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FEDummy, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FEDummy);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FEDummy, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FEDummy location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FEDummy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FEDummy(soap, tag ? tag : "afip3:FEDummy", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FEDummy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FEDummy(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FEDummy * SOAP_FMAC4 soap_get__afip3__FEDummy(struct soap *soap, _afip3__FEDummy *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FEDummy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FECompTotXRequestResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FECompTotXRequestResponse::FECompTotXRequestResult = NULL;
}

void _afip3__FECompTotXRequestResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FERegXReqResponse(soap, &this->_afip3__FECompTotXRequestResponse::FECompTotXRequestResult);
#endif
}

int _afip3__FECompTotXRequestResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FECompTotXRequestResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FECompTotXRequestResponse(struct soap *soap, const char *tag, int id, const _afip3__FECompTotXRequestResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FECompTotXRequestResponse), type))
		return soap->error;
	if (a->FECompTotXRequestResult)
		soap_element_result(soap, "afip3:FECompTotXRequestResult");
	if (soap_out_PointerToafip3__FERegXReqResponse(soap, "afip3:FECompTotXRequestResult", -1, &a->_afip3__FECompTotXRequestResponse::FECompTotXRequestResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FECompTotXRequestResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FECompTotXRequestResponse(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FECompTotXRequestResponse * SOAP_FMAC4 soap_in__afip3__FECompTotXRequestResponse(struct soap *soap, const char *tag, _afip3__FECompTotXRequestResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FECompTotXRequestResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FECompTotXRequestResponse, sizeof(_afip3__FECompTotXRequestResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FECompTotXRequestResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FECompTotXRequestResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FECompTotXRequestResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FECompTotXRequestResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FERegXReqResponse(soap, "afip3:FECompTotXRequestResult", &a->_afip3__FECompTotXRequestResponse::FECompTotXRequestResult, "afip3:FERegXReqResponse"))
				{	soap_flag_FECompTotXRequestResult1--;
					continue;
				}
			}
			soap_check_result(soap, "afip3:FECompTotXRequestResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FECompTotXRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FECompTotXRequestResponse, SOAP_TYPE__afip3__FECompTotXRequestResponse, sizeof(_afip3__FECompTotXRequestResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FECompTotXRequestResponse * SOAP_FMAC2 soap_instantiate__afip3__FECompTotXRequestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FECompTotXRequestResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FECompTotXRequestResponse *p;
	size_t k = sizeof(_afip3__FECompTotXRequestResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FECompTotXRequestResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FECompTotXRequestResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FECompTotXRequestResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FECompTotXRequestResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FECompTotXRequestResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FECompTotXRequestResponse(soap, tag ? tag : "afip3:FECompTotXRequestResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FECompTotXRequestResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FECompTotXRequestResponse(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FECompTotXRequestResponse * SOAP_FMAC4 soap_get__afip3__FECompTotXRequestResponse(struct soap *soap, _afip3__FECompTotXRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FECompTotXRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FECompTotXRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FECompTotXRequest::Auth = NULL;
}

void _afip3__FECompTotXRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FEAuthRequest(soap, &this->_afip3__FECompTotXRequest::Auth);
#endif
}

int _afip3__FECompTotXRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FECompTotXRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FECompTotXRequest(struct soap *soap, const char *tag, int id, const _afip3__FECompTotXRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FECompTotXRequest), type))
		return soap->error;
	if (soap_out_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", -1, &a->_afip3__FECompTotXRequest::Auth, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FECompTotXRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FECompTotXRequest(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FECompTotXRequest * SOAP_FMAC4 soap_in__afip3__FECompTotXRequest(struct soap *soap, const char *tag, _afip3__FECompTotXRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FECompTotXRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FECompTotXRequest, sizeof(_afip3__FECompTotXRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FECompTotXRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FECompTotXRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", &a->_afip3__FECompTotXRequest::Auth, "afip3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FECompTotXRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FECompTotXRequest, SOAP_TYPE__afip3__FECompTotXRequest, sizeof(_afip3__FECompTotXRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FECompTotXRequest * SOAP_FMAC2 soap_instantiate__afip3__FECompTotXRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FECompTotXRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FECompTotXRequest *p;
	size_t k = sizeof(_afip3__FECompTotXRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FECompTotXRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FECompTotXRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FECompTotXRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FECompTotXRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FECompTotXRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FECompTotXRequest(soap, tag ? tag : "afip3:FECompTotXRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FECompTotXRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FECompTotXRequest(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FECompTotXRequest * SOAP_FMAC4 soap_get__afip3__FECompTotXRequest(struct soap *soap, _afip3__FECompTotXRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FECompTotXRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FECAESolicitarResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FECAESolicitarResponse::FECAESolicitarResult = NULL;
}

void _afip3__FECAESolicitarResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FECAEResponse(soap, &this->_afip3__FECAESolicitarResponse::FECAESolicitarResult);
#endif
}

int _afip3__FECAESolicitarResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FECAESolicitarResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FECAESolicitarResponse(struct soap *soap, const char *tag, int id, const _afip3__FECAESolicitarResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FECAESolicitarResponse), type))
		return soap->error;
	if (a->FECAESolicitarResult)
		soap_element_result(soap, "afip3:FECAESolicitarResult");
	if (soap_out_PointerToafip3__FECAEResponse(soap, "afip3:FECAESolicitarResult", -1, &a->_afip3__FECAESolicitarResponse::FECAESolicitarResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FECAESolicitarResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FECAESolicitarResponse(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FECAESolicitarResponse * SOAP_FMAC4 soap_in__afip3__FECAESolicitarResponse(struct soap *soap, const char *tag, _afip3__FECAESolicitarResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FECAESolicitarResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FECAESolicitarResponse, sizeof(_afip3__FECAESolicitarResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FECAESolicitarResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FECAESolicitarResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FECAESolicitarResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FECAESolicitarResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FECAEResponse(soap, "afip3:FECAESolicitarResult", &a->_afip3__FECAESolicitarResponse::FECAESolicitarResult, "afip3:FECAEResponse"))
				{	soap_flag_FECAESolicitarResult1--;
					continue;
				}
			}
			soap_check_result(soap, "afip3:FECAESolicitarResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FECAESolicitarResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FECAESolicitarResponse, SOAP_TYPE__afip3__FECAESolicitarResponse, sizeof(_afip3__FECAESolicitarResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FECAESolicitarResponse * SOAP_FMAC2 soap_instantiate__afip3__FECAESolicitarResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FECAESolicitarResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FECAESolicitarResponse *p;
	size_t k = sizeof(_afip3__FECAESolicitarResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FECAESolicitarResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FECAESolicitarResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FECAESolicitarResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FECAESolicitarResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FECAESolicitarResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FECAESolicitarResponse(soap, tag ? tag : "afip3:FECAESolicitarResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FECAESolicitarResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FECAESolicitarResponse(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FECAESolicitarResponse * SOAP_FMAC4 soap_get__afip3__FECAESolicitarResponse(struct soap *soap, _afip3__FECAESolicitarResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FECAESolicitarResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip3__FECAESolicitar::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_afip3__FECAESolicitar::Auth = NULL;
	this->_afip3__FECAESolicitar::FeCAEReq = NULL;
}

void _afip3__FECAESolicitar::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FEAuthRequest(soap, &this->_afip3__FECAESolicitar::Auth);
	soap_serialize_PointerToafip3__FECAERequest(soap, &this->_afip3__FECAESolicitar::FeCAEReq);
#endif
}

int _afip3__FECAESolicitar::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip3__FECAESolicitar(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip3__FECAESolicitar(struct soap *soap, const char *tag, int id, const _afip3__FECAESolicitar *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip3__FECAESolicitar), type))
		return soap->error;
	if (soap_out_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", -1, &a->_afip3__FECAESolicitar::Auth, ""))
		return soap->error;
	if (soap_out_PointerToafip3__FECAERequest(soap, "afip3:FeCAEReq", -1, &a->_afip3__FECAESolicitar::FeCAEReq, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip3__FECAESolicitar::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip3__FECAESolicitar(soap, tag, this, type);
}

SOAP_FMAC3 _afip3__FECAESolicitar * SOAP_FMAC4 soap_in__afip3__FECAESolicitar(struct soap *soap, const char *tag, _afip3__FECAESolicitar *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip3__FECAESolicitar*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip3__FECAESolicitar, sizeof(_afip3__FECAESolicitar), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip3__FECAESolicitar)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip3__FECAESolicitar *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auth1 = 1;
	size_t soap_flag_FeCAEReq1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FEAuthRequest(soap, "afip3:Auth", &a->_afip3__FECAESolicitar::Auth, "afip3:FEAuthRequest"))
				{	soap_flag_Auth1--;
					continue;
				}
			}
			if (soap_flag_FeCAEReq1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FECAERequest(soap, "afip3:FeCAEReq", &a->_afip3__FECAESolicitar::FeCAEReq, "afip3:FECAERequest"))
				{	soap_flag_FeCAEReq1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_afip3__FECAESolicitar *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip3__FECAESolicitar, SOAP_TYPE__afip3__FECAESolicitar, sizeof(_afip3__FECAESolicitar), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip3__FECAESolicitar * SOAP_FMAC2 soap_instantiate__afip3__FECAESolicitar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip3__FECAESolicitar(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip3__FECAESolicitar *p;
	size_t k = sizeof(_afip3__FECAESolicitar);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip3__FECAESolicitar, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip3__FECAESolicitar);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip3__FECAESolicitar, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip3__FECAESolicitar location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip3__FECAESolicitar::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip3__FECAESolicitar(soap, tag ? tag : "afip3:FECAESolicitar", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip3__FECAESolicitar::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip3__FECAESolicitar(soap, this, tag, type);
}

SOAP_FMAC3 _afip3__FECAESolicitar * SOAP_FMAC4 soap_get__afip3__FECAESolicitar(struct soap *soap, _afip3__FECAESolicitar *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip3__FECAESolicitar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__PaisTipo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_short(soap, &this->afip3__PaisTipo::Id);
	this->afip3__PaisTipo::Desc = NULL;
}

void afip3__PaisTipo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->afip3__PaisTipo::Desc);
#endif
}

int afip3__PaisTipo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__PaisTipo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__PaisTipo(struct soap *soap, const char *tag, int id, const afip3__PaisTipo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__PaisTipo), type))
		return soap->error;
	if (soap_out_short(soap, "afip3:Id", -1, &a->afip3__PaisTipo::Id, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:Desc", -1, &a->afip3__PaisTipo::Desc, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__PaisTipo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__PaisTipo(soap, tag, this, type);
}

SOAP_FMAC3 afip3__PaisTipo * SOAP_FMAC4 soap_in_afip3__PaisTipo(struct soap *soap, const char *tag, afip3__PaisTipo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__PaisTipo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__PaisTipo, sizeof(afip3__PaisTipo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__PaisTipo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__PaisTipo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_Desc1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_short(soap, "afip3:Id", &a->afip3__PaisTipo::Id, "xsd:short"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_Desc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:Desc", &a->afip3__PaisTipo::Desc, "xsd:string"))
				{	soap_flag_Desc1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__PaisTipo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__PaisTipo, SOAP_TYPE_afip3__PaisTipo, sizeof(afip3__PaisTipo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__PaisTipo * SOAP_FMAC2 soap_instantiate_afip3__PaisTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__PaisTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__PaisTipo *p;
	size_t k = sizeof(afip3__PaisTipo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__PaisTipo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__PaisTipo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__PaisTipo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__PaisTipo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__PaisTipo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__PaisTipo(soap, tag ? tag : "afip3:PaisTipo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__PaisTipo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__PaisTipo(soap, this, tag, type);
}

SOAP_FMAC3 afip3__PaisTipo * SOAP_FMAC4 soap_get_afip3__PaisTipo(struct soap *soap, afip3__PaisTipo *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__PaisTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__ArrayOfPaisTipo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToafip3__PaisTipo(soap, &this->afip3__ArrayOfPaisTipo::PaisTipo);
}

void afip3__ArrayOfPaisTipo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToafip3__PaisTipo(soap, &this->afip3__ArrayOfPaisTipo::PaisTipo);
#endif
}

int afip3__ArrayOfPaisTipo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__ArrayOfPaisTipo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__ArrayOfPaisTipo(struct soap *soap, const char *tag, int id, const afip3__ArrayOfPaisTipo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__ArrayOfPaisTipo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToafip3__PaisTipo(soap, "afip3:PaisTipo", -1, &a->afip3__ArrayOfPaisTipo::PaisTipo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__ArrayOfPaisTipo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__ArrayOfPaisTipo(soap, tag, this, type);
}

SOAP_FMAC3 afip3__ArrayOfPaisTipo * SOAP_FMAC4 soap_in_afip3__ArrayOfPaisTipo(struct soap *soap, const char *tag, afip3__ArrayOfPaisTipo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__ArrayOfPaisTipo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__ArrayOfPaisTipo, sizeof(afip3__ArrayOfPaisTipo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__ArrayOfPaisTipo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__ArrayOfPaisTipo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerToafip3__PaisTipo(soap, "afip3:PaisTipo", &a->afip3__ArrayOfPaisTipo::PaisTipo, "afip3:PaisTipo"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__ArrayOfPaisTipo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__ArrayOfPaisTipo, SOAP_TYPE_afip3__ArrayOfPaisTipo, sizeof(afip3__ArrayOfPaisTipo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__ArrayOfPaisTipo * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfPaisTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__ArrayOfPaisTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__ArrayOfPaisTipo *p;
	size_t k = sizeof(afip3__ArrayOfPaisTipo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__ArrayOfPaisTipo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__ArrayOfPaisTipo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__ArrayOfPaisTipo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__ArrayOfPaisTipo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__ArrayOfPaisTipo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__ArrayOfPaisTipo(soap, tag ? tag : "afip3:ArrayOfPaisTipo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__ArrayOfPaisTipo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__ArrayOfPaisTipo(soap, this, tag, type);
}

SOAP_FMAC3 afip3__ArrayOfPaisTipo * SOAP_FMAC4 soap_get_afip3__ArrayOfPaisTipo(struct soap *soap, afip3__ArrayOfPaisTipo *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__ArrayOfPaisTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__FEPaisResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__FEPaisResponse::ResultGet = NULL;
	this->afip3__FEPaisResponse::Errors = NULL;
	this->afip3__FEPaisResponse::Events = NULL;
}

void afip3__FEPaisResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__ArrayOfPaisTipo(soap, &this->afip3__FEPaisResponse::ResultGet);
	soap_serialize_PointerToafip3__ArrayOfErr(soap, &this->afip3__FEPaisResponse::Errors);
	soap_serialize_PointerToafip3__ArrayOfEvt(soap, &this->afip3__FEPaisResponse::Events);
#endif
}

int afip3__FEPaisResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__FEPaisResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__FEPaisResponse(struct soap *soap, const char *tag, int id, const afip3__FEPaisResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__FEPaisResponse), type))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfPaisTipo(soap, "afip3:ResultGet", -1, &a->afip3__FEPaisResponse::ResultGet, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", -1, &a->afip3__FEPaisResponse::Errors, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", -1, &a->afip3__FEPaisResponse::Events, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__FEPaisResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__FEPaisResponse(soap, tag, this, type);
}

SOAP_FMAC3 afip3__FEPaisResponse * SOAP_FMAC4 soap_in_afip3__FEPaisResponse(struct soap *soap, const char *tag, afip3__FEPaisResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__FEPaisResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__FEPaisResponse, sizeof(afip3__FEPaisResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__FEPaisResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__FEPaisResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResultGet1 = 1;
	size_t soap_flag_Errors1 = 1;
	size_t soap_flag_Events1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultGet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfPaisTipo(soap, "afip3:ResultGet", &a->afip3__FEPaisResponse::ResultGet, "afip3:ArrayOfPaisTipo"))
				{	soap_flag_ResultGet1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", &a->afip3__FEPaisResponse::Errors, "afip3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", &a->afip3__FEPaisResponse::Events, "afip3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__FEPaisResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__FEPaisResponse, SOAP_TYPE_afip3__FEPaisResponse, sizeof(afip3__FEPaisResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__FEPaisResponse * SOAP_FMAC2 soap_instantiate_afip3__FEPaisResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__FEPaisResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__FEPaisResponse *p;
	size_t k = sizeof(afip3__FEPaisResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__FEPaisResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__FEPaisResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__FEPaisResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__FEPaisResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__FEPaisResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__FEPaisResponse(soap, tag ? tag : "afip3:FEPaisResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__FEPaisResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__FEPaisResponse(soap, this, tag, type);
}

SOAP_FMAC3 afip3__FEPaisResponse * SOAP_FMAC4 soap_get_afip3__FEPaisResponse(struct soap *soap, afip3__FEPaisResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__FEPaisResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__DocTipo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->afip3__DocTipo::Id);
	this->afip3__DocTipo::Desc = NULL;
	this->afip3__DocTipo::FchDesde = NULL;
	this->afip3__DocTipo::FchHasta = NULL;
}

void afip3__DocTipo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->afip3__DocTipo::Desc);
	soap_serialize_PointerTostd__string(soap, &this->afip3__DocTipo::FchDesde);
	soap_serialize_PointerTostd__string(soap, &this->afip3__DocTipo::FchHasta);
#endif
}

int afip3__DocTipo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__DocTipo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__DocTipo(struct soap *soap, const char *tag, int id, const afip3__DocTipo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__DocTipo), type))
		return soap->error;
	if (soap_out_int(soap, "afip3:Id", -1, &a->afip3__DocTipo::Id, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:Desc", -1, &a->afip3__DocTipo::Desc, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchDesde", -1, &a->afip3__DocTipo::FchDesde, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchHasta", -1, &a->afip3__DocTipo::FchHasta, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__DocTipo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__DocTipo(soap, tag, this, type);
}

SOAP_FMAC3 afip3__DocTipo * SOAP_FMAC4 soap_in_afip3__DocTipo(struct soap *soap, const char *tag, afip3__DocTipo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__DocTipo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__DocTipo, sizeof(afip3__DocTipo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__DocTipo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__DocTipo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_Desc1 = 1;
	size_t soap_flag_FchDesde1 = 1;
	size_t soap_flag_FchHasta1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:Id", &a->afip3__DocTipo::Id, "xsd:int"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_Desc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:Desc", &a->afip3__DocTipo::Desc, "xsd:string"))
				{	soap_flag_Desc1--;
					continue;
				}
			}
			if (soap_flag_FchDesde1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchDesde", &a->afip3__DocTipo::FchDesde, "xsd:string"))
				{	soap_flag_FchDesde1--;
					continue;
				}
			}
			if (soap_flag_FchHasta1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchHasta", &a->afip3__DocTipo::FchHasta, "xsd:string"))
				{	soap_flag_FchHasta1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__DocTipo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__DocTipo, SOAP_TYPE_afip3__DocTipo, sizeof(afip3__DocTipo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__DocTipo * SOAP_FMAC2 soap_instantiate_afip3__DocTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__DocTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__DocTipo *p;
	size_t k = sizeof(afip3__DocTipo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__DocTipo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__DocTipo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__DocTipo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__DocTipo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__DocTipo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__DocTipo(soap, tag ? tag : "afip3:DocTipo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__DocTipo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__DocTipo(soap, this, tag, type);
}

SOAP_FMAC3 afip3__DocTipo * SOAP_FMAC4 soap_get_afip3__DocTipo(struct soap *soap, afip3__DocTipo *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__DocTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__ArrayOfDocTipo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToafip3__DocTipo(soap, &this->afip3__ArrayOfDocTipo::DocTipo);
}

void afip3__ArrayOfDocTipo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToafip3__DocTipo(soap, &this->afip3__ArrayOfDocTipo::DocTipo);
#endif
}

int afip3__ArrayOfDocTipo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__ArrayOfDocTipo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__ArrayOfDocTipo(struct soap *soap, const char *tag, int id, const afip3__ArrayOfDocTipo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__ArrayOfDocTipo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToafip3__DocTipo(soap, "afip3:DocTipo", -1, &a->afip3__ArrayOfDocTipo::DocTipo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__ArrayOfDocTipo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__ArrayOfDocTipo(soap, tag, this, type);
}

SOAP_FMAC3 afip3__ArrayOfDocTipo * SOAP_FMAC4 soap_in_afip3__ArrayOfDocTipo(struct soap *soap, const char *tag, afip3__ArrayOfDocTipo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__ArrayOfDocTipo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__ArrayOfDocTipo, sizeof(afip3__ArrayOfDocTipo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__ArrayOfDocTipo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__ArrayOfDocTipo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerToafip3__DocTipo(soap, "afip3:DocTipo", &a->afip3__ArrayOfDocTipo::DocTipo, "afip3:DocTipo"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__ArrayOfDocTipo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__ArrayOfDocTipo, SOAP_TYPE_afip3__ArrayOfDocTipo, sizeof(afip3__ArrayOfDocTipo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__ArrayOfDocTipo * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfDocTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__ArrayOfDocTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__ArrayOfDocTipo *p;
	size_t k = sizeof(afip3__ArrayOfDocTipo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__ArrayOfDocTipo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__ArrayOfDocTipo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__ArrayOfDocTipo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__ArrayOfDocTipo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__ArrayOfDocTipo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__ArrayOfDocTipo(soap, tag ? tag : "afip3:ArrayOfDocTipo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__ArrayOfDocTipo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__ArrayOfDocTipo(soap, this, tag, type);
}

SOAP_FMAC3 afip3__ArrayOfDocTipo * SOAP_FMAC4 soap_get_afip3__ArrayOfDocTipo(struct soap *soap, afip3__ArrayOfDocTipo *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__ArrayOfDocTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__DocTipoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__DocTipoResponse::ResultGet = NULL;
	this->afip3__DocTipoResponse::Errors = NULL;
	this->afip3__DocTipoResponse::Events = NULL;
}

void afip3__DocTipoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__ArrayOfDocTipo(soap, &this->afip3__DocTipoResponse::ResultGet);
	soap_serialize_PointerToafip3__ArrayOfErr(soap, &this->afip3__DocTipoResponse::Errors);
	soap_serialize_PointerToafip3__ArrayOfEvt(soap, &this->afip3__DocTipoResponse::Events);
#endif
}

int afip3__DocTipoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__DocTipoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__DocTipoResponse(struct soap *soap, const char *tag, int id, const afip3__DocTipoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__DocTipoResponse), type))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfDocTipo(soap, "afip3:ResultGet", -1, &a->afip3__DocTipoResponse::ResultGet, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", -1, &a->afip3__DocTipoResponse::Errors, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", -1, &a->afip3__DocTipoResponse::Events, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__DocTipoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__DocTipoResponse(soap, tag, this, type);
}

SOAP_FMAC3 afip3__DocTipoResponse * SOAP_FMAC4 soap_in_afip3__DocTipoResponse(struct soap *soap, const char *tag, afip3__DocTipoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__DocTipoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__DocTipoResponse, sizeof(afip3__DocTipoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__DocTipoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__DocTipoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResultGet1 = 1;
	size_t soap_flag_Errors1 = 1;
	size_t soap_flag_Events1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultGet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfDocTipo(soap, "afip3:ResultGet", &a->afip3__DocTipoResponse::ResultGet, "afip3:ArrayOfDocTipo"))
				{	soap_flag_ResultGet1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", &a->afip3__DocTipoResponse::Errors, "afip3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", &a->afip3__DocTipoResponse::Events, "afip3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__DocTipoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__DocTipoResponse, SOAP_TYPE_afip3__DocTipoResponse, sizeof(afip3__DocTipoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__DocTipoResponse * SOAP_FMAC2 soap_instantiate_afip3__DocTipoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__DocTipoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__DocTipoResponse *p;
	size_t k = sizeof(afip3__DocTipoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__DocTipoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__DocTipoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__DocTipoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__DocTipoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__DocTipoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__DocTipoResponse(soap, tag ? tag : "afip3:DocTipoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__DocTipoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__DocTipoResponse(soap, this, tag, type);
}

SOAP_FMAC3 afip3__DocTipoResponse * SOAP_FMAC4 soap_get_afip3__DocTipoResponse(struct soap *soap, afip3__DocTipoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__DocTipoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__CbteTipo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->afip3__CbteTipo::Id);
	this->afip3__CbteTipo::Desc = NULL;
	this->afip3__CbteTipo::FchDesde = NULL;
	this->afip3__CbteTipo::FchHasta = NULL;
}

void afip3__CbteTipo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->afip3__CbteTipo::Desc);
	soap_serialize_PointerTostd__string(soap, &this->afip3__CbteTipo::FchDesde);
	soap_serialize_PointerTostd__string(soap, &this->afip3__CbteTipo::FchHasta);
#endif
}

int afip3__CbteTipo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__CbteTipo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__CbteTipo(struct soap *soap, const char *tag, int id, const afip3__CbteTipo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__CbteTipo), type))
		return soap->error;
	if (soap_out_int(soap, "afip3:Id", -1, &a->afip3__CbteTipo::Id, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:Desc", -1, &a->afip3__CbteTipo::Desc, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchDesde", -1, &a->afip3__CbteTipo::FchDesde, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchHasta", -1, &a->afip3__CbteTipo::FchHasta, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__CbteTipo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__CbteTipo(soap, tag, this, type);
}

SOAP_FMAC3 afip3__CbteTipo * SOAP_FMAC4 soap_in_afip3__CbteTipo(struct soap *soap, const char *tag, afip3__CbteTipo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__CbteTipo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__CbteTipo, sizeof(afip3__CbteTipo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__CbteTipo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__CbteTipo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_Desc1 = 1;
	size_t soap_flag_FchDesde1 = 1;
	size_t soap_flag_FchHasta1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:Id", &a->afip3__CbteTipo::Id, "xsd:int"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_Desc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:Desc", &a->afip3__CbteTipo::Desc, "xsd:string"))
				{	soap_flag_Desc1--;
					continue;
				}
			}
			if (soap_flag_FchDesde1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchDesde", &a->afip3__CbteTipo::FchDesde, "xsd:string"))
				{	soap_flag_FchDesde1--;
					continue;
				}
			}
			if (soap_flag_FchHasta1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchHasta", &a->afip3__CbteTipo::FchHasta, "xsd:string"))
				{	soap_flag_FchHasta1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__CbteTipo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__CbteTipo, SOAP_TYPE_afip3__CbteTipo, sizeof(afip3__CbteTipo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__CbteTipo * SOAP_FMAC2 soap_instantiate_afip3__CbteTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__CbteTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__CbteTipo *p;
	size_t k = sizeof(afip3__CbteTipo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__CbteTipo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__CbteTipo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__CbteTipo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__CbteTipo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__CbteTipo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__CbteTipo(soap, tag ? tag : "afip3:CbteTipo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__CbteTipo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__CbteTipo(soap, this, tag, type);
}

SOAP_FMAC3 afip3__CbteTipo * SOAP_FMAC4 soap_get_afip3__CbteTipo(struct soap *soap, afip3__CbteTipo *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__CbteTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__ArrayOfCbteTipo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToafip3__CbteTipo(soap, &this->afip3__ArrayOfCbteTipo::CbteTipo);
}

void afip3__ArrayOfCbteTipo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToafip3__CbteTipo(soap, &this->afip3__ArrayOfCbteTipo::CbteTipo);
#endif
}

int afip3__ArrayOfCbteTipo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__ArrayOfCbteTipo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__ArrayOfCbteTipo(struct soap *soap, const char *tag, int id, const afip3__ArrayOfCbteTipo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__ArrayOfCbteTipo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToafip3__CbteTipo(soap, "afip3:CbteTipo", -1, &a->afip3__ArrayOfCbteTipo::CbteTipo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__ArrayOfCbteTipo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__ArrayOfCbteTipo(soap, tag, this, type);
}

SOAP_FMAC3 afip3__ArrayOfCbteTipo * SOAP_FMAC4 soap_in_afip3__ArrayOfCbteTipo(struct soap *soap, const char *tag, afip3__ArrayOfCbteTipo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__ArrayOfCbteTipo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__ArrayOfCbteTipo, sizeof(afip3__ArrayOfCbteTipo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__ArrayOfCbteTipo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__ArrayOfCbteTipo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerToafip3__CbteTipo(soap, "afip3:CbteTipo", &a->afip3__ArrayOfCbteTipo::CbteTipo, "afip3:CbteTipo"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__ArrayOfCbteTipo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__ArrayOfCbteTipo, SOAP_TYPE_afip3__ArrayOfCbteTipo, sizeof(afip3__ArrayOfCbteTipo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__ArrayOfCbteTipo * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfCbteTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__ArrayOfCbteTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__ArrayOfCbteTipo *p;
	size_t k = sizeof(afip3__ArrayOfCbteTipo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__ArrayOfCbteTipo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__ArrayOfCbteTipo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__ArrayOfCbteTipo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__ArrayOfCbteTipo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__ArrayOfCbteTipo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__ArrayOfCbteTipo(soap, tag ? tag : "afip3:ArrayOfCbteTipo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__ArrayOfCbteTipo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__ArrayOfCbteTipo(soap, this, tag, type);
}

SOAP_FMAC3 afip3__ArrayOfCbteTipo * SOAP_FMAC4 soap_get_afip3__ArrayOfCbteTipo(struct soap *soap, afip3__ArrayOfCbteTipo *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__ArrayOfCbteTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__CbteTipoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__CbteTipoResponse::ResultGet = NULL;
	this->afip3__CbteTipoResponse::Errors = NULL;
	this->afip3__CbteTipoResponse::Events = NULL;
}

void afip3__CbteTipoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__ArrayOfCbteTipo(soap, &this->afip3__CbteTipoResponse::ResultGet);
	soap_serialize_PointerToafip3__ArrayOfErr(soap, &this->afip3__CbteTipoResponse::Errors);
	soap_serialize_PointerToafip3__ArrayOfEvt(soap, &this->afip3__CbteTipoResponse::Events);
#endif
}

int afip3__CbteTipoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__CbteTipoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__CbteTipoResponse(struct soap *soap, const char *tag, int id, const afip3__CbteTipoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__CbteTipoResponse), type))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfCbteTipo(soap, "afip3:ResultGet", -1, &a->afip3__CbteTipoResponse::ResultGet, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", -1, &a->afip3__CbteTipoResponse::Errors, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", -1, &a->afip3__CbteTipoResponse::Events, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__CbteTipoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__CbteTipoResponse(soap, tag, this, type);
}

SOAP_FMAC3 afip3__CbteTipoResponse * SOAP_FMAC4 soap_in_afip3__CbteTipoResponse(struct soap *soap, const char *tag, afip3__CbteTipoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__CbteTipoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__CbteTipoResponse, sizeof(afip3__CbteTipoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__CbteTipoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__CbteTipoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResultGet1 = 1;
	size_t soap_flag_Errors1 = 1;
	size_t soap_flag_Events1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultGet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfCbteTipo(soap, "afip3:ResultGet", &a->afip3__CbteTipoResponse::ResultGet, "afip3:ArrayOfCbteTipo"))
				{	soap_flag_ResultGet1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", &a->afip3__CbteTipoResponse::Errors, "afip3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", &a->afip3__CbteTipoResponse::Events, "afip3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__CbteTipoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__CbteTipoResponse, SOAP_TYPE_afip3__CbteTipoResponse, sizeof(afip3__CbteTipoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__CbteTipoResponse * SOAP_FMAC2 soap_instantiate_afip3__CbteTipoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__CbteTipoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__CbteTipoResponse *p;
	size_t k = sizeof(afip3__CbteTipoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__CbteTipoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__CbteTipoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__CbteTipoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__CbteTipoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__CbteTipoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__CbteTipoResponse(soap, tag ? tag : "afip3:CbteTipoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__CbteTipoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__CbteTipoResponse(soap, this, tag, type);
}

SOAP_FMAC3 afip3__CbteTipoResponse * SOAP_FMAC4 soap_get_afip3__CbteTipoResponse(struct soap *soap, afip3__CbteTipoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__CbteTipoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__PtoVenta::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->afip3__PtoVenta::Nro);
	this->afip3__PtoVenta::EmisionTipo = NULL;
	this->afip3__PtoVenta::Bloqueado = NULL;
	this->afip3__PtoVenta::FchBaja = NULL;
}

void afip3__PtoVenta::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->afip3__PtoVenta::EmisionTipo);
	soap_serialize_PointerTostd__string(soap, &this->afip3__PtoVenta::Bloqueado);
	soap_serialize_PointerTostd__string(soap, &this->afip3__PtoVenta::FchBaja);
#endif
}

int afip3__PtoVenta::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__PtoVenta(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__PtoVenta(struct soap *soap, const char *tag, int id, const afip3__PtoVenta *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__PtoVenta), type))
		return soap->error;
	if (soap_out_int(soap, "afip3:Nro", -1, &a->afip3__PtoVenta::Nro, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:EmisionTipo", -1, &a->afip3__PtoVenta::EmisionTipo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:Bloqueado", -1, &a->afip3__PtoVenta::Bloqueado, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchBaja", -1, &a->afip3__PtoVenta::FchBaja, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__PtoVenta::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__PtoVenta(soap, tag, this, type);
}

SOAP_FMAC3 afip3__PtoVenta * SOAP_FMAC4 soap_in_afip3__PtoVenta(struct soap *soap, const char *tag, afip3__PtoVenta *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__PtoVenta*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__PtoVenta, sizeof(afip3__PtoVenta), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__PtoVenta)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__PtoVenta *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Nro1 = 1;
	size_t soap_flag_EmisionTipo1 = 1;
	size_t soap_flag_Bloqueado1 = 1;
	size_t soap_flag_FchBaja1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Nro1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:Nro", &a->afip3__PtoVenta::Nro, "xsd:int"))
				{	soap_flag_Nro1--;
					continue;
				}
			}
			if (soap_flag_EmisionTipo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:EmisionTipo", &a->afip3__PtoVenta::EmisionTipo, "xsd:string"))
				{	soap_flag_EmisionTipo1--;
					continue;
				}
			}
			if (soap_flag_Bloqueado1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:Bloqueado", &a->afip3__PtoVenta::Bloqueado, "xsd:string"))
				{	soap_flag_Bloqueado1--;
					continue;
				}
			}
			if (soap_flag_FchBaja1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchBaja", &a->afip3__PtoVenta::FchBaja, "xsd:string"))
				{	soap_flag_FchBaja1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Nro1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__PtoVenta *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__PtoVenta, SOAP_TYPE_afip3__PtoVenta, sizeof(afip3__PtoVenta), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__PtoVenta * SOAP_FMAC2 soap_instantiate_afip3__PtoVenta(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__PtoVenta(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__PtoVenta *p;
	size_t k = sizeof(afip3__PtoVenta);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__PtoVenta, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__PtoVenta);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__PtoVenta, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__PtoVenta location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__PtoVenta::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__PtoVenta(soap, tag ? tag : "afip3:PtoVenta", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__PtoVenta::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__PtoVenta(soap, this, tag, type);
}

SOAP_FMAC3 afip3__PtoVenta * SOAP_FMAC4 soap_get_afip3__PtoVenta(struct soap *soap, afip3__PtoVenta *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__PtoVenta(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__ArrayOfPtoVenta::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToafip3__PtoVenta(soap, &this->afip3__ArrayOfPtoVenta::PtoVenta);
}

void afip3__ArrayOfPtoVenta::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToafip3__PtoVenta(soap, &this->afip3__ArrayOfPtoVenta::PtoVenta);
#endif
}

int afip3__ArrayOfPtoVenta::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__ArrayOfPtoVenta(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__ArrayOfPtoVenta(struct soap *soap, const char *tag, int id, const afip3__ArrayOfPtoVenta *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__ArrayOfPtoVenta), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToafip3__PtoVenta(soap, "afip3:PtoVenta", -1, &a->afip3__ArrayOfPtoVenta::PtoVenta, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__ArrayOfPtoVenta::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__ArrayOfPtoVenta(soap, tag, this, type);
}

SOAP_FMAC3 afip3__ArrayOfPtoVenta * SOAP_FMAC4 soap_in_afip3__ArrayOfPtoVenta(struct soap *soap, const char *tag, afip3__ArrayOfPtoVenta *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__ArrayOfPtoVenta*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__ArrayOfPtoVenta, sizeof(afip3__ArrayOfPtoVenta), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__ArrayOfPtoVenta)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__ArrayOfPtoVenta *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerToafip3__PtoVenta(soap, "afip3:PtoVenta", &a->afip3__ArrayOfPtoVenta::PtoVenta, "afip3:PtoVenta"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__ArrayOfPtoVenta *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__ArrayOfPtoVenta, SOAP_TYPE_afip3__ArrayOfPtoVenta, sizeof(afip3__ArrayOfPtoVenta), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__ArrayOfPtoVenta * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfPtoVenta(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__ArrayOfPtoVenta(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__ArrayOfPtoVenta *p;
	size_t k = sizeof(afip3__ArrayOfPtoVenta);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__ArrayOfPtoVenta, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__ArrayOfPtoVenta);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__ArrayOfPtoVenta, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__ArrayOfPtoVenta location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__ArrayOfPtoVenta::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__ArrayOfPtoVenta(soap, tag ? tag : "afip3:ArrayOfPtoVenta", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__ArrayOfPtoVenta::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__ArrayOfPtoVenta(soap, this, tag, type);
}

SOAP_FMAC3 afip3__ArrayOfPtoVenta * SOAP_FMAC4 soap_get_afip3__ArrayOfPtoVenta(struct soap *soap, afip3__ArrayOfPtoVenta *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__ArrayOfPtoVenta(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__FEPtoVentaResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__FEPtoVentaResponse::ResultGet = NULL;
	this->afip3__FEPtoVentaResponse::Errors = NULL;
	this->afip3__FEPtoVentaResponse::Events = NULL;
}

void afip3__FEPtoVentaResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__ArrayOfPtoVenta(soap, &this->afip3__FEPtoVentaResponse::ResultGet);
	soap_serialize_PointerToafip3__ArrayOfErr(soap, &this->afip3__FEPtoVentaResponse::Errors);
	soap_serialize_PointerToafip3__ArrayOfEvt(soap, &this->afip3__FEPtoVentaResponse::Events);
#endif
}

int afip3__FEPtoVentaResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__FEPtoVentaResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__FEPtoVentaResponse(struct soap *soap, const char *tag, int id, const afip3__FEPtoVentaResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__FEPtoVentaResponse), type))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfPtoVenta(soap, "afip3:ResultGet", -1, &a->afip3__FEPtoVentaResponse::ResultGet, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", -1, &a->afip3__FEPtoVentaResponse::Errors, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", -1, &a->afip3__FEPtoVentaResponse::Events, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__FEPtoVentaResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__FEPtoVentaResponse(soap, tag, this, type);
}

SOAP_FMAC3 afip3__FEPtoVentaResponse * SOAP_FMAC4 soap_in_afip3__FEPtoVentaResponse(struct soap *soap, const char *tag, afip3__FEPtoVentaResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__FEPtoVentaResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__FEPtoVentaResponse, sizeof(afip3__FEPtoVentaResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__FEPtoVentaResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__FEPtoVentaResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResultGet1 = 1;
	size_t soap_flag_Errors1 = 1;
	size_t soap_flag_Events1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultGet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfPtoVenta(soap, "afip3:ResultGet", &a->afip3__FEPtoVentaResponse::ResultGet, "afip3:ArrayOfPtoVenta"))
				{	soap_flag_ResultGet1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", &a->afip3__FEPtoVentaResponse::Errors, "afip3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", &a->afip3__FEPtoVentaResponse::Events, "afip3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__FEPtoVentaResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__FEPtoVentaResponse, SOAP_TYPE_afip3__FEPtoVentaResponse, sizeof(afip3__FEPtoVentaResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__FEPtoVentaResponse * SOAP_FMAC2 soap_instantiate_afip3__FEPtoVentaResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__FEPtoVentaResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__FEPtoVentaResponse *p;
	size_t k = sizeof(afip3__FEPtoVentaResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__FEPtoVentaResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__FEPtoVentaResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__FEPtoVentaResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__FEPtoVentaResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__FEPtoVentaResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__FEPtoVentaResponse(soap, tag ? tag : "afip3:FEPtoVentaResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__FEPtoVentaResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__FEPtoVentaResponse(soap, this, tag, type);
}

SOAP_FMAC3 afip3__FEPtoVentaResponse * SOAP_FMAC4 soap_get_afip3__FEPtoVentaResponse(struct soap *soap, afip3__FEPtoVentaResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__FEPtoVentaResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__ConceptoTipo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->afip3__ConceptoTipo::Id);
	this->afip3__ConceptoTipo::Desc = NULL;
	this->afip3__ConceptoTipo::FchDesde = NULL;
	this->afip3__ConceptoTipo::FchHasta = NULL;
}

void afip3__ConceptoTipo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->afip3__ConceptoTipo::Desc);
	soap_serialize_PointerTostd__string(soap, &this->afip3__ConceptoTipo::FchDesde);
	soap_serialize_PointerTostd__string(soap, &this->afip3__ConceptoTipo::FchHasta);
#endif
}

int afip3__ConceptoTipo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__ConceptoTipo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__ConceptoTipo(struct soap *soap, const char *tag, int id, const afip3__ConceptoTipo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__ConceptoTipo), type))
		return soap->error;
	if (soap_out_int(soap, "afip3:Id", -1, &a->afip3__ConceptoTipo::Id, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:Desc", -1, &a->afip3__ConceptoTipo::Desc, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchDesde", -1, &a->afip3__ConceptoTipo::FchDesde, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchHasta", -1, &a->afip3__ConceptoTipo::FchHasta, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__ConceptoTipo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__ConceptoTipo(soap, tag, this, type);
}

SOAP_FMAC3 afip3__ConceptoTipo * SOAP_FMAC4 soap_in_afip3__ConceptoTipo(struct soap *soap, const char *tag, afip3__ConceptoTipo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__ConceptoTipo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__ConceptoTipo, sizeof(afip3__ConceptoTipo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__ConceptoTipo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__ConceptoTipo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_Desc1 = 1;
	size_t soap_flag_FchDesde1 = 1;
	size_t soap_flag_FchHasta1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:Id", &a->afip3__ConceptoTipo::Id, "xsd:int"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_Desc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:Desc", &a->afip3__ConceptoTipo::Desc, "xsd:string"))
				{	soap_flag_Desc1--;
					continue;
				}
			}
			if (soap_flag_FchDesde1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchDesde", &a->afip3__ConceptoTipo::FchDesde, "xsd:string"))
				{	soap_flag_FchDesde1--;
					continue;
				}
			}
			if (soap_flag_FchHasta1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchHasta", &a->afip3__ConceptoTipo::FchHasta, "xsd:string"))
				{	soap_flag_FchHasta1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__ConceptoTipo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__ConceptoTipo, SOAP_TYPE_afip3__ConceptoTipo, sizeof(afip3__ConceptoTipo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__ConceptoTipo * SOAP_FMAC2 soap_instantiate_afip3__ConceptoTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__ConceptoTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__ConceptoTipo *p;
	size_t k = sizeof(afip3__ConceptoTipo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__ConceptoTipo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__ConceptoTipo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__ConceptoTipo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__ConceptoTipo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__ConceptoTipo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__ConceptoTipo(soap, tag ? tag : "afip3:ConceptoTipo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__ConceptoTipo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__ConceptoTipo(soap, this, tag, type);
}

SOAP_FMAC3 afip3__ConceptoTipo * SOAP_FMAC4 soap_get_afip3__ConceptoTipo(struct soap *soap, afip3__ConceptoTipo *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__ConceptoTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__ArrayOfConceptoTipo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToafip3__ConceptoTipo(soap, &this->afip3__ArrayOfConceptoTipo::ConceptoTipo);
}

void afip3__ArrayOfConceptoTipo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToafip3__ConceptoTipo(soap, &this->afip3__ArrayOfConceptoTipo::ConceptoTipo);
#endif
}

int afip3__ArrayOfConceptoTipo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__ArrayOfConceptoTipo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__ArrayOfConceptoTipo(struct soap *soap, const char *tag, int id, const afip3__ArrayOfConceptoTipo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__ArrayOfConceptoTipo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToafip3__ConceptoTipo(soap, "afip3:ConceptoTipo", -1, &a->afip3__ArrayOfConceptoTipo::ConceptoTipo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__ArrayOfConceptoTipo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__ArrayOfConceptoTipo(soap, tag, this, type);
}

SOAP_FMAC3 afip3__ArrayOfConceptoTipo * SOAP_FMAC4 soap_in_afip3__ArrayOfConceptoTipo(struct soap *soap, const char *tag, afip3__ArrayOfConceptoTipo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__ArrayOfConceptoTipo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__ArrayOfConceptoTipo, sizeof(afip3__ArrayOfConceptoTipo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__ArrayOfConceptoTipo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__ArrayOfConceptoTipo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerToafip3__ConceptoTipo(soap, "afip3:ConceptoTipo", &a->afip3__ArrayOfConceptoTipo::ConceptoTipo, "afip3:ConceptoTipo"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__ArrayOfConceptoTipo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__ArrayOfConceptoTipo, SOAP_TYPE_afip3__ArrayOfConceptoTipo, sizeof(afip3__ArrayOfConceptoTipo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__ArrayOfConceptoTipo * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfConceptoTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__ArrayOfConceptoTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__ArrayOfConceptoTipo *p;
	size_t k = sizeof(afip3__ArrayOfConceptoTipo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__ArrayOfConceptoTipo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__ArrayOfConceptoTipo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__ArrayOfConceptoTipo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__ArrayOfConceptoTipo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__ArrayOfConceptoTipo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__ArrayOfConceptoTipo(soap, tag ? tag : "afip3:ArrayOfConceptoTipo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__ArrayOfConceptoTipo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__ArrayOfConceptoTipo(soap, this, tag, type);
}

SOAP_FMAC3 afip3__ArrayOfConceptoTipo * SOAP_FMAC4 soap_get_afip3__ArrayOfConceptoTipo(struct soap *soap, afip3__ArrayOfConceptoTipo *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__ArrayOfConceptoTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__ConceptoTipoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__ConceptoTipoResponse::ResultGet = NULL;
	this->afip3__ConceptoTipoResponse::Errors = NULL;
	this->afip3__ConceptoTipoResponse::Events = NULL;
}

void afip3__ConceptoTipoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__ArrayOfConceptoTipo(soap, &this->afip3__ConceptoTipoResponse::ResultGet);
	soap_serialize_PointerToafip3__ArrayOfErr(soap, &this->afip3__ConceptoTipoResponse::Errors);
	soap_serialize_PointerToafip3__ArrayOfEvt(soap, &this->afip3__ConceptoTipoResponse::Events);
#endif
}

int afip3__ConceptoTipoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__ConceptoTipoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__ConceptoTipoResponse(struct soap *soap, const char *tag, int id, const afip3__ConceptoTipoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__ConceptoTipoResponse), type))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfConceptoTipo(soap, "afip3:ResultGet", -1, &a->afip3__ConceptoTipoResponse::ResultGet, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", -1, &a->afip3__ConceptoTipoResponse::Errors, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", -1, &a->afip3__ConceptoTipoResponse::Events, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__ConceptoTipoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__ConceptoTipoResponse(soap, tag, this, type);
}

SOAP_FMAC3 afip3__ConceptoTipoResponse * SOAP_FMAC4 soap_in_afip3__ConceptoTipoResponse(struct soap *soap, const char *tag, afip3__ConceptoTipoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__ConceptoTipoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__ConceptoTipoResponse, sizeof(afip3__ConceptoTipoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__ConceptoTipoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__ConceptoTipoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResultGet1 = 1;
	size_t soap_flag_Errors1 = 1;
	size_t soap_flag_Events1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultGet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfConceptoTipo(soap, "afip3:ResultGet", &a->afip3__ConceptoTipoResponse::ResultGet, "afip3:ArrayOfConceptoTipo"))
				{	soap_flag_ResultGet1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", &a->afip3__ConceptoTipoResponse::Errors, "afip3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", &a->afip3__ConceptoTipoResponse::Events, "afip3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__ConceptoTipoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__ConceptoTipoResponse, SOAP_TYPE_afip3__ConceptoTipoResponse, sizeof(afip3__ConceptoTipoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__ConceptoTipoResponse * SOAP_FMAC2 soap_instantiate_afip3__ConceptoTipoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__ConceptoTipoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__ConceptoTipoResponse *p;
	size_t k = sizeof(afip3__ConceptoTipoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__ConceptoTipoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__ConceptoTipoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__ConceptoTipoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__ConceptoTipoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__ConceptoTipoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__ConceptoTipoResponse(soap, tag ? tag : "afip3:ConceptoTipoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__ConceptoTipoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__ConceptoTipoResponse(soap, this, tag, type);
}

SOAP_FMAC3 afip3__ConceptoTipoResponse * SOAP_FMAC4 soap_get_afip3__ConceptoTipoResponse(struct soap *soap, afip3__ConceptoTipoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__ConceptoTipoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__OpcionalTipo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__OpcionalTipo::Id = NULL;
	this->afip3__OpcionalTipo::Desc = NULL;
	this->afip3__OpcionalTipo::FchDesde = NULL;
	this->afip3__OpcionalTipo::FchHasta = NULL;
}

void afip3__OpcionalTipo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->afip3__OpcionalTipo::Id);
	soap_serialize_PointerTostd__string(soap, &this->afip3__OpcionalTipo::Desc);
	soap_serialize_PointerTostd__string(soap, &this->afip3__OpcionalTipo::FchDesde);
	soap_serialize_PointerTostd__string(soap, &this->afip3__OpcionalTipo::FchHasta);
#endif
}

int afip3__OpcionalTipo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__OpcionalTipo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__OpcionalTipo(struct soap *soap, const char *tag, int id, const afip3__OpcionalTipo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__OpcionalTipo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:Id", -1, &a->afip3__OpcionalTipo::Id, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:Desc", -1, &a->afip3__OpcionalTipo::Desc, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchDesde", -1, &a->afip3__OpcionalTipo::FchDesde, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchHasta", -1, &a->afip3__OpcionalTipo::FchHasta, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__OpcionalTipo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__OpcionalTipo(soap, tag, this, type);
}

SOAP_FMAC3 afip3__OpcionalTipo * SOAP_FMAC4 soap_in_afip3__OpcionalTipo(struct soap *soap, const char *tag, afip3__OpcionalTipo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__OpcionalTipo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__OpcionalTipo, sizeof(afip3__OpcionalTipo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__OpcionalTipo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__OpcionalTipo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_Desc1 = 1;
	size_t soap_flag_FchDesde1 = 1;
	size_t soap_flag_FchHasta1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:Id", &a->afip3__OpcionalTipo::Id, "xsd:string"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_Desc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:Desc", &a->afip3__OpcionalTipo::Desc, "xsd:string"))
				{	soap_flag_Desc1--;
					continue;
				}
			}
			if (soap_flag_FchDesde1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchDesde", &a->afip3__OpcionalTipo::FchDesde, "xsd:string"))
				{	soap_flag_FchDesde1--;
					continue;
				}
			}
			if (soap_flag_FchHasta1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchHasta", &a->afip3__OpcionalTipo::FchHasta, "xsd:string"))
				{	soap_flag_FchHasta1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__OpcionalTipo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__OpcionalTipo, SOAP_TYPE_afip3__OpcionalTipo, sizeof(afip3__OpcionalTipo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__OpcionalTipo * SOAP_FMAC2 soap_instantiate_afip3__OpcionalTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__OpcionalTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__OpcionalTipo *p;
	size_t k = sizeof(afip3__OpcionalTipo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__OpcionalTipo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__OpcionalTipo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__OpcionalTipo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__OpcionalTipo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__OpcionalTipo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__OpcionalTipo(soap, tag ? tag : "afip3:OpcionalTipo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__OpcionalTipo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__OpcionalTipo(soap, this, tag, type);
}

SOAP_FMAC3 afip3__OpcionalTipo * SOAP_FMAC4 soap_get_afip3__OpcionalTipo(struct soap *soap, afip3__OpcionalTipo *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__OpcionalTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__ArrayOfOpcionalTipo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToafip3__OpcionalTipo(soap, &this->afip3__ArrayOfOpcionalTipo::OpcionalTipo);
}

void afip3__ArrayOfOpcionalTipo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToafip3__OpcionalTipo(soap, &this->afip3__ArrayOfOpcionalTipo::OpcionalTipo);
#endif
}

int afip3__ArrayOfOpcionalTipo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__ArrayOfOpcionalTipo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__ArrayOfOpcionalTipo(struct soap *soap, const char *tag, int id, const afip3__ArrayOfOpcionalTipo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__ArrayOfOpcionalTipo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToafip3__OpcionalTipo(soap, "afip3:OpcionalTipo", -1, &a->afip3__ArrayOfOpcionalTipo::OpcionalTipo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__ArrayOfOpcionalTipo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__ArrayOfOpcionalTipo(soap, tag, this, type);
}

SOAP_FMAC3 afip3__ArrayOfOpcionalTipo * SOAP_FMAC4 soap_in_afip3__ArrayOfOpcionalTipo(struct soap *soap, const char *tag, afip3__ArrayOfOpcionalTipo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__ArrayOfOpcionalTipo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__ArrayOfOpcionalTipo, sizeof(afip3__ArrayOfOpcionalTipo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__ArrayOfOpcionalTipo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__ArrayOfOpcionalTipo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerToafip3__OpcionalTipo(soap, "afip3:OpcionalTipo", &a->afip3__ArrayOfOpcionalTipo::OpcionalTipo, "afip3:OpcionalTipo"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__ArrayOfOpcionalTipo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__ArrayOfOpcionalTipo, SOAP_TYPE_afip3__ArrayOfOpcionalTipo, sizeof(afip3__ArrayOfOpcionalTipo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__ArrayOfOpcionalTipo * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfOpcionalTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__ArrayOfOpcionalTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__ArrayOfOpcionalTipo *p;
	size_t k = sizeof(afip3__ArrayOfOpcionalTipo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__ArrayOfOpcionalTipo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__ArrayOfOpcionalTipo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__ArrayOfOpcionalTipo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__ArrayOfOpcionalTipo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__ArrayOfOpcionalTipo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__ArrayOfOpcionalTipo(soap, tag ? tag : "afip3:ArrayOfOpcionalTipo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__ArrayOfOpcionalTipo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__ArrayOfOpcionalTipo(soap, this, tag, type);
}

SOAP_FMAC3 afip3__ArrayOfOpcionalTipo * SOAP_FMAC4 soap_get_afip3__ArrayOfOpcionalTipo(struct soap *soap, afip3__ArrayOfOpcionalTipo *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__ArrayOfOpcionalTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__OpcionalTipoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__OpcionalTipoResponse::ResultGet = NULL;
	this->afip3__OpcionalTipoResponse::Errors = NULL;
	this->afip3__OpcionalTipoResponse::Events = NULL;
}

void afip3__OpcionalTipoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__ArrayOfOpcionalTipo(soap, &this->afip3__OpcionalTipoResponse::ResultGet);
	soap_serialize_PointerToafip3__ArrayOfErr(soap, &this->afip3__OpcionalTipoResponse::Errors);
	soap_serialize_PointerToafip3__ArrayOfEvt(soap, &this->afip3__OpcionalTipoResponse::Events);
#endif
}

int afip3__OpcionalTipoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__OpcionalTipoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__OpcionalTipoResponse(struct soap *soap, const char *tag, int id, const afip3__OpcionalTipoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__OpcionalTipoResponse), type))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfOpcionalTipo(soap, "afip3:ResultGet", -1, &a->afip3__OpcionalTipoResponse::ResultGet, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", -1, &a->afip3__OpcionalTipoResponse::Errors, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", -1, &a->afip3__OpcionalTipoResponse::Events, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__OpcionalTipoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__OpcionalTipoResponse(soap, tag, this, type);
}

SOAP_FMAC3 afip3__OpcionalTipoResponse * SOAP_FMAC4 soap_in_afip3__OpcionalTipoResponse(struct soap *soap, const char *tag, afip3__OpcionalTipoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__OpcionalTipoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__OpcionalTipoResponse, sizeof(afip3__OpcionalTipoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__OpcionalTipoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__OpcionalTipoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResultGet1 = 1;
	size_t soap_flag_Errors1 = 1;
	size_t soap_flag_Events1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultGet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfOpcionalTipo(soap, "afip3:ResultGet", &a->afip3__OpcionalTipoResponse::ResultGet, "afip3:ArrayOfOpcionalTipo"))
				{	soap_flag_ResultGet1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", &a->afip3__OpcionalTipoResponse::Errors, "afip3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", &a->afip3__OpcionalTipoResponse::Events, "afip3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__OpcionalTipoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__OpcionalTipoResponse, SOAP_TYPE_afip3__OpcionalTipoResponse, sizeof(afip3__OpcionalTipoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__OpcionalTipoResponse * SOAP_FMAC2 soap_instantiate_afip3__OpcionalTipoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__OpcionalTipoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__OpcionalTipoResponse *p;
	size_t k = sizeof(afip3__OpcionalTipoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__OpcionalTipoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__OpcionalTipoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__OpcionalTipoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__OpcionalTipoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__OpcionalTipoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__OpcionalTipoResponse(soap, tag ? tag : "afip3:OpcionalTipoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__OpcionalTipoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__OpcionalTipoResponse(soap, this, tag, type);
}

SOAP_FMAC3 afip3__OpcionalTipoResponse * SOAP_FMAC4 soap_get_afip3__OpcionalTipoResponse(struct soap *soap, afip3__OpcionalTipoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__OpcionalTipoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__IvaTipo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__IvaTipo::Id = NULL;
	this->afip3__IvaTipo::Desc = NULL;
	this->afip3__IvaTipo::FchDesde = NULL;
	this->afip3__IvaTipo::FchHasta = NULL;
}

void afip3__IvaTipo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->afip3__IvaTipo::Id);
	soap_serialize_PointerTostd__string(soap, &this->afip3__IvaTipo::Desc);
	soap_serialize_PointerTostd__string(soap, &this->afip3__IvaTipo::FchDesde);
	soap_serialize_PointerTostd__string(soap, &this->afip3__IvaTipo::FchHasta);
#endif
}

int afip3__IvaTipo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__IvaTipo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__IvaTipo(struct soap *soap, const char *tag, int id, const afip3__IvaTipo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__IvaTipo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:Id", -1, &a->afip3__IvaTipo::Id, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:Desc", -1, &a->afip3__IvaTipo::Desc, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchDesde", -1, &a->afip3__IvaTipo::FchDesde, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchHasta", -1, &a->afip3__IvaTipo::FchHasta, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__IvaTipo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__IvaTipo(soap, tag, this, type);
}

SOAP_FMAC3 afip3__IvaTipo * SOAP_FMAC4 soap_in_afip3__IvaTipo(struct soap *soap, const char *tag, afip3__IvaTipo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__IvaTipo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__IvaTipo, sizeof(afip3__IvaTipo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__IvaTipo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__IvaTipo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_Desc1 = 1;
	size_t soap_flag_FchDesde1 = 1;
	size_t soap_flag_FchHasta1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:Id", &a->afip3__IvaTipo::Id, "xsd:string"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_Desc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:Desc", &a->afip3__IvaTipo::Desc, "xsd:string"))
				{	soap_flag_Desc1--;
					continue;
				}
			}
			if (soap_flag_FchDesde1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchDesde", &a->afip3__IvaTipo::FchDesde, "xsd:string"))
				{	soap_flag_FchDesde1--;
					continue;
				}
			}
			if (soap_flag_FchHasta1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchHasta", &a->afip3__IvaTipo::FchHasta, "xsd:string"))
				{	soap_flag_FchHasta1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__IvaTipo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__IvaTipo, SOAP_TYPE_afip3__IvaTipo, sizeof(afip3__IvaTipo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__IvaTipo * SOAP_FMAC2 soap_instantiate_afip3__IvaTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__IvaTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__IvaTipo *p;
	size_t k = sizeof(afip3__IvaTipo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__IvaTipo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__IvaTipo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__IvaTipo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__IvaTipo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__IvaTipo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__IvaTipo(soap, tag ? tag : "afip3:IvaTipo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__IvaTipo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__IvaTipo(soap, this, tag, type);
}

SOAP_FMAC3 afip3__IvaTipo * SOAP_FMAC4 soap_get_afip3__IvaTipo(struct soap *soap, afip3__IvaTipo *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__IvaTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__ArrayOfIvaTipo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToafip3__IvaTipo(soap, &this->afip3__ArrayOfIvaTipo::IvaTipo);
}

void afip3__ArrayOfIvaTipo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToafip3__IvaTipo(soap, &this->afip3__ArrayOfIvaTipo::IvaTipo);
#endif
}

int afip3__ArrayOfIvaTipo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__ArrayOfIvaTipo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__ArrayOfIvaTipo(struct soap *soap, const char *tag, int id, const afip3__ArrayOfIvaTipo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__ArrayOfIvaTipo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToafip3__IvaTipo(soap, "afip3:IvaTipo", -1, &a->afip3__ArrayOfIvaTipo::IvaTipo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__ArrayOfIvaTipo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__ArrayOfIvaTipo(soap, tag, this, type);
}

SOAP_FMAC3 afip3__ArrayOfIvaTipo * SOAP_FMAC4 soap_in_afip3__ArrayOfIvaTipo(struct soap *soap, const char *tag, afip3__ArrayOfIvaTipo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__ArrayOfIvaTipo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__ArrayOfIvaTipo, sizeof(afip3__ArrayOfIvaTipo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__ArrayOfIvaTipo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__ArrayOfIvaTipo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerToafip3__IvaTipo(soap, "afip3:IvaTipo", &a->afip3__ArrayOfIvaTipo::IvaTipo, "afip3:IvaTipo"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__ArrayOfIvaTipo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__ArrayOfIvaTipo, SOAP_TYPE_afip3__ArrayOfIvaTipo, sizeof(afip3__ArrayOfIvaTipo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__ArrayOfIvaTipo * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfIvaTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__ArrayOfIvaTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__ArrayOfIvaTipo *p;
	size_t k = sizeof(afip3__ArrayOfIvaTipo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__ArrayOfIvaTipo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__ArrayOfIvaTipo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__ArrayOfIvaTipo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__ArrayOfIvaTipo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__ArrayOfIvaTipo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__ArrayOfIvaTipo(soap, tag ? tag : "afip3:ArrayOfIvaTipo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__ArrayOfIvaTipo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__ArrayOfIvaTipo(soap, this, tag, type);
}

SOAP_FMAC3 afip3__ArrayOfIvaTipo * SOAP_FMAC4 soap_get_afip3__ArrayOfIvaTipo(struct soap *soap, afip3__ArrayOfIvaTipo *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__ArrayOfIvaTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__IvaTipoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__IvaTipoResponse::ResultGet = NULL;
	this->afip3__IvaTipoResponse::Errors = NULL;
	this->afip3__IvaTipoResponse::Events = NULL;
}

void afip3__IvaTipoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__ArrayOfIvaTipo(soap, &this->afip3__IvaTipoResponse::ResultGet);
	soap_serialize_PointerToafip3__ArrayOfErr(soap, &this->afip3__IvaTipoResponse::Errors);
	soap_serialize_PointerToafip3__ArrayOfEvt(soap, &this->afip3__IvaTipoResponse::Events);
#endif
}

int afip3__IvaTipoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__IvaTipoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__IvaTipoResponse(struct soap *soap, const char *tag, int id, const afip3__IvaTipoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__IvaTipoResponse), type))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfIvaTipo(soap, "afip3:ResultGet", -1, &a->afip3__IvaTipoResponse::ResultGet, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", -1, &a->afip3__IvaTipoResponse::Errors, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", -1, &a->afip3__IvaTipoResponse::Events, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__IvaTipoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__IvaTipoResponse(soap, tag, this, type);
}

SOAP_FMAC3 afip3__IvaTipoResponse * SOAP_FMAC4 soap_in_afip3__IvaTipoResponse(struct soap *soap, const char *tag, afip3__IvaTipoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__IvaTipoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__IvaTipoResponse, sizeof(afip3__IvaTipoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__IvaTipoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__IvaTipoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResultGet1 = 1;
	size_t soap_flag_Errors1 = 1;
	size_t soap_flag_Events1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultGet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfIvaTipo(soap, "afip3:ResultGet", &a->afip3__IvaTipoResponse::ResultGet, "afip3:ArrayOfIvaTipo"))
				{	soap_flag_ResultGet1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", &a->afip3__IvaTipoResponse::Errors, "afip3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", &a->afip3__IvaTipoResponse::Events, "afip3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__IvaTipoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__IvaTipoResponse, SOAP_TYPE_afip3__IvaTipoResponse, sizeof(afip3__IvaTipoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__IvaTipoResponse * SOAP_FMAC2 soap_instantiate_afip3__IvaTipoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__IvaTipoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__IvaTipoResponse *p;
	size_t k = sizeof(afip3__IvaTipoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__IvaTipoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__IvaTipoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__IvaTipoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__IvaTipoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__IvaTipoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__IvaTipoResponse(soap, tag ? tag : "afip3:IvaTipoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__IvaTipoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__IvaTipoResponse(soap, this, tag, type);
}

SOAP_FMAC3 afip3__IvaTipoResponse * SOAP_FMAC4 soap_get_afip3__IvaTipoResponse(struct soap *soap, afip3__IvaTipoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__IvaTipoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__Moneda::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__Moneda::Id = NULL;
	this->afip3__Moneda::Desc = NULL;
	this->afip3__Moneda::FchDesde = NULL;
	this->afip3__Moneda::FchHasta = NULL;
}

void afip3__Moneda::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->afip3__Moneda::Id);
	soap_serialize_PointerTostd__string(soap, &this->afip3__Moneda::Desc);
	soap_serialize_PointerTostd__string(soap, &this->afip3__Moneda::FchDesde);
	soap_serialize_PointerTostd__string(soap, &this->afip3__Moneda::FchHasta);
#endif
}

int afip3__Moneda::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__Moneda(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__Moneda(struct soap *soap, const char *tag, int id, const afip3__Moneda *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__Moneda), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:Id", -1, &a->afip3__Moneda::Id, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:Desc", -1, &a->afip3__Moneda::Desc, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchDesde", -1, &a->afip3__Moneda::FchDesde, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchHasta", -1, &a->afip3__Moneda::FchHasta, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__Moneda::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__Moneda(soap, tag, this, type);
}

SOAP_FMAC3 afip3__Moneda * SOAP_FMAC4 soap_in_afip3__Moneda(struct soap *soap, const char *tag, afip3__Moneda *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__Moneda*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__Moneda, sizeof(afip3__Moneda), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__Moneda)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__Moneda *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_Desc1 = 1;
	size_t soap_flag_FchDesde1 = 1;
	size_t soap_flag_FchHasta1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:Id", &a->afip3__Moneda::Id, "xsd:string"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_Desc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:Desc", &a->afip3__Moneda::Desc, "xsd:string"))
				{	soap_flag_Desc1--;
					continue;
				}
			}
			if (soap_flag_FchDesde1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchDesde", &a->afip3__Moneda::FchDesde, "xsd:string"))
				{	soap_flag_FchDesde1--;
					continue;
				}
			}
			if (soap_flag_FchHasta1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchHasta", &a->afip3__Moneda::FchHasta, "xsd:string"))
				{	soap_flag_FchHasta1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__Moneda *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__Moneda, SOAP_TYPE_afip3__Moneda, sizeof(afip3__Moneda), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__Moneda * SOAP_FMAC2 soap_instantiate_afip3__Moneda(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__Moneda(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__Moneda *p;
	size_t k = sizeof(afip3__Moneda);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__Moneda, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__Moneda);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__Moneda, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__Moneda location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__Moneda::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__Moneda(soap, tag ? tag : "afip3:Moneda", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__Moneda::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__Moneda(soap, this, tag, type);
}

SOAP_FMAC3 afip3__Moneda * SOAP_FMAC4 soap_get_afip3__Moneda(struct soap *soap, afip3__Moneda *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__Moneda(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__ArrayOfMoneda::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToafip3__Moneda(soap, &this->afip3__ArrayOfMoneda::Moneda);
}

void afip3__ArrayOfMoneda::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToafip3__Moneda(soap, &this->afip3__ArrayOfMoneda::Moneda);
#endif
}

int afip3__ArrayOfMoneda::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__ArrayOfMoneda(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__ArrayOfMoneda(struct soap *soap, const char *tag, int id, const afip3__ArrayOfMoneda *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__ArrayOfMoneda), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToafip3__Moneda(soap, "afip3:Moneda", -1, &a->afip3__ArrayOfMoneda::Moneda, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__ArrayOfMoneda::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__ArrayOfMoneda(soap, tag, this, type);
}

SOAP_FMAC3 afip3__ArrayOfMoneda * SOAP_FMAC4 soap_in_afip3__ArrayOfMoneda(struct soap *soap, const char *tag, afip3__ArrayOfMoneda *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__ArrayOfMoneda*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__ArrayOfMoneda, sizeof(afip3__ArrayOfMoneda), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__ArrayOfMoneda)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__ArrayOfMoneda *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerToafip3__Moneda(soap, "afip3:Moneda", &a->afip3__ArrayOfMoneda::Moneda, "afip3:Moneda"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__ArrayOfMoneda *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__ArrayOfMoneda, SOAP_TYPE_afip3__ArrayOfMoneda, sizeof(afip3__ArrayOfMoneda), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__ArrayOfMoneda * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfMoneda(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__ArrayOfMoneda(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__ArrayOfMoneda *p;
	size_t k = sizeof(afip3__ArrayOfMoneda);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__ArrayOfMoneda, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__ArrayOfMoneda);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__ArrayOfMoneda, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__ArrayOfMoneda location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__ArrayOfMoneda::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__ArrayOfMoneda(soap, tag ? tag : "afip3:ArrayOfMoneda", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__ArrayOfMoneda::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__ArrayOfMoneda(soap, this, tag, type);
}

SOAP_FMAC3 afip3__ArrayOfMoneda * SOAP_FMAC4 soap_get_afip3__ArrayOfMoneda(struct soap *soap, afip3__ArrayOfMoneda *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__ArrayOfMoneda(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__MonedaResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__MonedaResponse::ResultGet = NULL;
	this->afip3__MonedaResponse::Errors = NULL;
	this->afip3__MonedaResponse::Events = NULL;
}

void afip3__MonedaResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__ArrayOfMoneda(soap, &this->afip3__MonedaResponse::ResultGet);
	soap_serialize_PointerToafip3__ArrayOfErr(soap, &this->afip3__MonedaResponse::Errors);
	soap_serialize_PointerToafip3__ArrayOfEvt(soap, &this->afip3__MonedaResponse::Events);
#endif
}

int afip3__MonedaResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__MonedaResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__MonedaResponse(struct soap *soap, const char *tag, int id, const afip3__MonedaResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__MonedaResponse), type))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfMoneda(soap, "afip3:ResultGet", -1, &a->afip3__MonedaResponse::ResultGet, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", -1, &a->afip3__MonedaResponse::Errors, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", -1, &a->afip3__MonedaResponse::Events, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__MonedaResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__MonedaResponse(soap, tag, this, type);
}

SOAP_FMAC3 afip3__MonedaResponse * SOAP_FMAC4 soap_in_afip3__MonedaResponse(struct soap *soap, const char *tag, afip3__MonedaResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__MonedaResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__MonedaResponse, sizeof(afip3__MonedaResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__MonedaResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__MonedaResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResultGet1 = 1;
	size_t soap_flag_Errors1 = 1;
	size_t soap_flag_Events1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultGet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfMoneda(soap, "afip3:ResultGet", &a->afip3__MonedaResponse::ResultGet, "afip3:ArrayOfMoneda"))
				{	soap_flag_ResultGet1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", &a->afip3__MonedaResponse::Errors, "afip3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", &a->afip3__MonedaResponse::Events, "afip3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__MonedaResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__MonedaResponse, SOAP_TYPE_afip3__MonedaResponse, sizeof(afip3__MonedaResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__MonedaResponse * SOAP_FMAC2 soap_instantiate_afip3__MonedaResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__MonedaResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__MonedaResponse *p;
	size_t k = sizeof(afip3__MonedaResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__MonedaResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__MonedaResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__MonedaResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__MonedaResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__MonedaResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__MonedaResponse(soap, tag ? tag : "afip3:MonedaResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__MonedaResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__MonedaResponse(soap, this, tag, type);
}

SOAP_FMAC3 afip3__MonedaResponse * SOAP_FMAC4 soap_get_afip3__MonedaResponse(struct soap *soap, afip3__MonedaResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__MonedaResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__TributoTipo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_short(soap, &this->afip3__TributoTipo::Id);
	this->afip3__TributoTipo::Desc = NULL;
	this->afip3__TributoTipo::FchDesde = NULL;
	this->afip3__TributoTipo::FchHasta = NULL;
}

void afip3__TributoTipo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->afip3__TributoTipo::Desc);
	soap_serialize_PointerTostd__string(soap, &this->afip3__TributoTipo::FchDesde);
	soap_serialize_PointerTostd__string(soap, &this->afip3__TributoTipo::FchHasta);
#endif
}

int afip3__TributoTipo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__TributoTipo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__TributoTipo(struct soap *soap, const char *tag, int id, const afip3__TributoTipo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__TributoTipo), type))
		return soap->error;
	if (soap_out_short(soap, "afip3:Id", -1, &a->afip3__TributoTipo::Id, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:Desc", -1, &a->afip3__TributoTipo::Desc, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchDesde", -1, &a->afip3__TributoTipo::FchDesde, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchHasta", -1, &a->afip3__TributoTipo::FchHasta, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__TributoTipo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__TributoTipo(soap, tag, this, type);
}

SOAP_FMAC3 afip3__TributoTipo * SOAP_FMAC4 soap_in_afip3__TributoTipo(struct soap *soap, const char *tag, afip3__TributoTipo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__TributoTipo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__TributoTipo, sizeof(afip3__TributoTipo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__TributoTipo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__TributoTipo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_Desc1 = 1;
	size_t soap_flag_FchDesde1 = 1;
	size_t soap_flag_FchHasta1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_short(soap, "afip3:Id", &a->afip3__TributoTipo::Id, "xsd:short"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_Desc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:Desc", &a->afip3__TributoTipo::Desc, "xsd:string"))
				{	soap_flag_Desc1--;
					continue;
				}
			}
			if (soap_flag_FchDesde1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchDesde", &a->afip3__TributoTipo::FchDesde, "xsd:string"))
				{	soap_flag_FchDesde1--;
					continue;
				}
			}
			if (soap_flag_FchHasta1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchHasta", &a->afip3__TributoTipo::FchHasta, "xsd:string"))
				{	soap_flag_FchHasta1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__TributoTipo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__TributoTipo, SOAP_TYPE_afip3__TributoTipo, sizeof(afip3__TributoTipo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__TributoTipo * SOAP_FMAC2 soap_instantiate_afip3__TributoTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__TributoTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__TributoTipo *p;
	size_t k = sizeof(afip3__TributoTipo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__TributoTipo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__TributoTipo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__TributoTipo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__TributoTipo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__TributoTipo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__TributoTipo(soap, tag ? tag : "afip3:TributoTipo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__TributoTipo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__TributoTipo(soap, this, tag, type);
}

SOAP_FMAC3 afip3__TributoTipo * SOAP_FMAC4 soap_get_afip3__TributoTipo(struct soap *soap, afip3__TributoTipo *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__TributoTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__ArrayOfTributoTipo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToafip3__TributoTipo(soap, &this->afip3__ArrayOfTributoTipo::TributoTipo);
}

void afip3__ArrayOfTributoTipo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToafip3__TributoTipo(soap, &this->afip3__ArrayOfTributoTipo::TributoTipo);
#endif
}

int afip3__ArrayOfTributoTipo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__ArrayOfTributoTipo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__ArrayOfTributoTipo(struct soap *soap, const char *tag, int id, const afip3__ArrayOfTributoTipo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__ArrayOfTributoTipo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToafip3__TributoTipo(soap, "afip3:TributoTipo", -1, &a->afip3__ArrayOfTributoTipo::TributoTipo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__ArrayOfTributoTipo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__ArrayOfTributoTipo(soap, tag, this, type);
}

SOAP_FMAC3 afip3__ArrayOfTributoTipo * SOAP_FMAC4 soap_in_afip3__ArrayOfTributoTipo(struct soap *soap, const char *tag, afip3__ArrayOfTributoTipo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__ArrayOfTributoTipo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__ArrayOfTributoTipo, sizeof(afip3__ArrayOfTributoTipo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__ArrayOfTributoTipo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__ArrayOfTributoTipo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerToafip3__TributoTipo(soap, "afip3:TributoTipo", &a->afip3__ArrayOfTributoTipo::TributoTipo, "afip3:TributoTipo"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__ArrayOfTributoTipo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__ArrayOfTributoTipo, SOAP_TYPE_afip3__ArrayOfTributoTipo, sizeof(afip3__ArrayOfTributoTipo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__ArrayOfTributoTipo * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfTributoTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__ArrayOfTributoTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__ArrayOfTributoTipo *p;
	size_t k = sizeof(afip3__ArrayOfTributoTipo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__ArrayOfTributoTipo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__ArrayOfTributoTipo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__ArrayOfTributoTipo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__ArrayOfTributoTipo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__ArrayOfTributoTipo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__ArrayOfTributoTipo(soap, tag ? tag : "afip3:ArrayOfTributoTipo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__ArrayOfTributoTipo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__ArrayOfTributoTipo(soap, this, tag, type);
}

SOAP_FMAC3 afip3__ArrayOfTributoTipo * SOAP_FMAC4 soap_get_afip3__ArrayOfTributoTipo(struct soap *soap, afip3__ArrayOfTributoTipo *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__ArrayOfTributoTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__FETributoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__FETributoResponse::ResultGet = NULL;
	this->afip3__FETributoResponse::Errors = NULL;
	this->afip3__FETributoResponse::Events = NULL;
}

void afip3__FETributoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__ArrayOfTributoTipo(soap, &this->afip3__FETributoResponse::ResultGet);
	soap_serialize_PointerToafip3__ArrayOfErr(soap, &this->afip3__FETributoResponse::Errors);
	soap_serialize_PointerToafip3__ArrayOfEvt(soap, &this->afip3__FETributoResponse::Events);
#endif
}

int afip3__FETributoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__FETributoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__FETributoResponse(struct soap *soap, const char *tag, int id, const afip3__FETributoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__FETributoResponse), type))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfTributoTipo(soap, "afip3:ResultGet", -1, &a->afip3__FETributoResponse::ResultGet, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", -1, &a->afip3__FETributoResponse::Errors, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", -1, &a->afip3__FETributoResponse::Events, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__FETributoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__FETributoResponse(soap, tag, this, type);
}

SOAP_FMAC3 afip3__FETributoResponse * SOAP_FMAC4 soap_in_afip3__FETributoResponse(struct soap *soap, const char *tag, afip3__FETributoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__FETributoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__FETributoResponse, sizeof(afip3__FETributoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__FETributoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__FETributoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResultGet1 = 1;
	size_t soap_flag_Errors1 = 1;
	size_t soap_flag_Events1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultGet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfTributoTipo(soap, "afip3:ResultGet", &a->afip3__FETributoResponse::ResultGet, "afip3:ArrayOfTributoTipo"))
				{	soap_flag_ResultGet1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", &a->afip3__FETributoResponse::Errors, "afip3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", &a->afip3__FETributoResponse::Events, "afip3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__FETributoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__FETributoResponse, SOAP_TYPE_afip3__FETributoResponse, sizeof(afip3__FETributoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__FETributoResponse * SOAP_FMAC2 soap_instantiate_afip3__FETributoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__FETributoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__FETributoResponse *p;
	size_t k = sizeof(afip3__FETributoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__FETributoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__FETributoResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__FETributoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__FETributoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__FETributoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__FETributoResponse(soap, tag ? tag : "afip3:FETributoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__FETributoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__FETributoResponse(soap, this, tag, type);
}

SOAP_FMAC3 afip3__FETributoResponse * SOAP_FMAC4 soap_get_afip3__FETributoResponse(struct soap *soap, afip3__FETributoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__FETributoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__Cotizacion::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__Cotizacion::MonId = NULL;
	soap_default_double(soap, &this->afip3__Cotizacion::MonCotiz);
	this->afip3__Cotizacion::FchCotiz = NULL;
}

void afip3__Cotizacion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->afip3__Cotizacion::MonId);
	soap_serialize_PointerTostd__string(soap, &this->afip3__Cotizacion::FchCotiz);
#endif
}

int afip3__Cotizacion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__Cotizacion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__Cotizacion(struct soap *soap, const char *tag, int id, const afip3__Cotizacion *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__Cotizacion), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:MonId", -1, &a->afip3__Cotizacion::MonId, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:MonCotiz", -1, &a->afip3__Cotizacion::MonCotiz, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchCotiz", -1, &a->afip3__Cotizacion::FchCotiz, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__Cotizacion::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__Cotizacion(soap, tag, this, type);
}

SOAP_FMAC3 afip3__Cotizacion * SOAP_FMAC4 soap_in_afip3__Cotizacion(struct soap *soap, const char *tag, afip3__Cotizacion *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__Cotizacion*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__Cotizacion, sizeof(afip3__Cotizacion), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__Cotizacion)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__Cotizacion *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MonId1 = 1;
	size_t soap_flag_MonCotiz1 = 1;
	size_t soap_flag_FchCotiz1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MonId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:MonId", &a->afip3__Cotizacion::MonId, "xsd:string"))
				{	soap_flag_MonId1--;
					continue;
				}
			}
			if (soap_flag_MonCotiz1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:MonCotiz", &a->afip3__Cotizacion::MonCotiz, "xsd:double"))
				{	soap_flag_MonCotiz1--;
					continue;
				}
			}
			if (soap_flag_FchCotiz1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchCotiz", &a->afip3__Cotizacion::FchCotiz, "xsd:string"))
				{	soap_flag_FchCotiz1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MonCotiz1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__Cotizacion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__Cotizacion, SOAP_TYPE_afip3__Cotizacion, sizeof(afip3__Cotizacion), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__Cotizacion * SOAP_FMAC2 soap_instantiate_afip3__Cotizacion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__Cotizacion(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__Cotizacion *p;
	size_t k = sizeof(afip3__Cotizacion);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__Cotizacion, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__Cotizacion);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__Cotizacion, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__Cotizacion location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__Cotizacion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__Cotizacion(soap, tag ? tag : "afip3:Cotizacion", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__Cotizacion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__Cotizacion(soap, this, tag, type);
}

SOAP_FMAC3 afip3__Cotizacion * SOAP_FMAC4 soap_get_afip3__Cotizacion(struct soap *soap, afip3__Cotizacion *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__Cotizacion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__FECotizacionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__FECotizacionResponse::ResultGet = NULL;
	this->afip3__FECotizacionResponse::Errors = NULL;
	this->afip3__FECotizacionResponse::Events = NULL;
}

void afip3__FECotizacionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__Cotizacion(soap, &this->afip3__FECotizacionResponse::ResultGet);
	soap_serialize_PointerToafip3__ArrayOfErr(soap, &this->afip3__FECotizacionResponse::Errors);
	soap_serialize_PointerToafip3__ArrayOfEvt(soap, &this->afip3__FECotizacionResponse::Events);
#endif
}

int afip3__FECotizacionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__FECotizacionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__FECotizacionResponse(struct soap *soap, const char *tag, int id, const afip3__FECotizacionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__FECotizacionResponse), type))
		return soap->error;
	if (soap_out_PointerToafip3__Cotizacion(soap, "afip3:ResultGet", -1, &a->afip3__FECotizacionResponse::ResultGet, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", -1, &a->afip3__FECotizacionResponse::Errors, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", -1, &a->afip3__FECotizacionResponse::Events, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__FECotizacionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__FECotizacionResponse(soap, tag, this, type);
}

SOAP_FMAC3 afip3__FECotizacionResponse * SOAP_FMAC4 soap_in_afip3__FECotizacionResponse(struct soap *soap, const char *tag, afip3__FECotizacionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__FECotizacionResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__FECotizacionResponse, sizeof(afip3__FECotizacionResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__FECotizacionResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__FECotizacionResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResultGet1 = 1;
	size_t soap_flag_Errors1 = 1;
	size_t soap_flag_Events1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultGet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__Cotizacion(soap, "afip3:ResultGet", &a->afip3__FECotizacionResponse::ResultGet, "afip3:Cotizacion"))
				{	soap_flag_ResultGet1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", &a->afip3__FECotizacionResponse::Errors, "afip3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", &a->afip3__FECotizacionResponse::Events, "afip3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__FECotizacionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__FECotizacionResponse, SOAP_TYPE_afip3__FECotizacionResponse, sizeof(afip3__FECotizacionResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__FECotizacionResponse * SOAP_FMAC2 soap_instantiate_afip3__FECotizacionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__FECotizacionResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__FECotizacionResponse *p;
	size_t k = sizeof(afip3__FECotizacionResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__FECotizacionResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__FECotizacionResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__FECotizacionResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__FECotizacionResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__FECotizacionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__FECotizacionResponse(soap, tag ? tag : "afip3:FECotizacionResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__FECotizacionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__FECotizacionResponse(soap, this, tag, type);
}

SOAP_FMAC3 afip3__FECotizacionResponse * SOAP_FMAC4 soap_get_afip3__FECotizacionResponse(struct soap *soap, afip3__FECotizacionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__FECotizacionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__FECAEASinMovResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__FECAEASinMov::soap_default(soap);
	this->afip3__FECAEASinMovResponse::Resultado = NULL;
	this->afip3__FECAEASinMovResponse::Errors = NULL;
	this->afip3__FECAEASinMovResponse::Events = NULL;
}

void afip3__FECAEASinMovResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->afip3__FECAEASinMovResponse::Resultado);
	soap_serialize_PointerToafip3__ArrayOfErr(soap, &this->afip3__FECAEASinMovResponse::Errors);
	soap_serialize_PointerToafip3__ArrayOfEvt(soap, &this->afip3__FECAEASinMovResponse::Events);
	this->afip3__FECAEASinMov::soap_serialize(soap);
#endif
}

int afip3__FECAEASinMovResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__FECAEASinMovResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__FECAEASinMovResponse(struct soap *soap, const char *tag, int id, const afip3__FECAEASinMovResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__FECAEASinMovResponse), type ? type : "afip3:FECAEASinMovResponse"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:CAEA", -1, &a->afip3__FECAEASinMov::CAEA, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchProceso", -1, &a->afip3__FECAEASinMov::FchProceso, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:PtoVta", -1, &a->afip3__FECAEASinMov::PtoVta, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:Resultado", -1, &a->afip3__FECAEASinMovResponse::Resultado, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", -1, &a->afip3__FECAEASinMovResponse::Errors, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", -1, &a->afip3__FECAEASinMovResponse::Events, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__FECAEASinMovResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__FECAEASinMovResponse(soap, tag, this, type);
}

SOAP_FMAC3 afip3__FECAEASinMovResponse * SOAP_FMAC4 soap_in_afip3__FECAEASinMovResponse(struct soap *soap, const char *tag, afip3__FECAEASinMovResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__FECAEASinMovResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__FECAEASinMovResponse, sizeof(afip3__FECAEASinMovResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__FECAEASinMovResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__FECAEASinMovResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CAEA2 = 1;
	size_t soap_flag_FchProceso2 = 1;
	size_t soap_flag_PtoVta2 = 1;
	size_t soap_flag_Resultado1 = 1;
	size_t soap_flag_Errors1 = 1;
	size_t soap_flag_Events1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CAEA2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:CAEA", &a->afip3__FECAEASinMov::CAEA, "xsd:string"))
				{	soap_flag_CAEA2--;
					continue;
				}
			}
			if (soap_flag_FchProceso2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchProceso", &a->afip3__FECAEASinMov::FchProceso, "xsd:string"))
				{	soap_flag_FchProceso2--;
					continue;
				}
			}
			if (soap_flag_PtoVta2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:PtoVta", &a->afip3__FECAEASinMov::PtoVta, "xsd:int"))
				{	soap_flag_PtoVta2--;
					continue;
				}
			}
			if (soap_flag_Resultado1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:Resultado", &a->afip3__FECAEASinMovResponse::Resultado, "xsd:string"))
				{	soap_flag_Resultado1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", &a->afip3__FECAEASinMovResponse::Errors, "afip3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", &a->afip3__FECAEASinMovResponse::Events, "afip3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PtoVta2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__FECAEASinMovResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__FECAEASinMovResponse, SOAP_TYPE_afip3__FECAEASinMovResponse, sizeof(afip3__FECAEASinMovResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__FECAEASinMovResponse * SOAP_FMAC2 soap_instantiate_afip3__FECAEASinMovResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__FECAEASinMovResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__FECAEASinMovResponse *p;
	size_t k = sizeof(afip3__FECAEASinMovResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__FECAEASinMovResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__FECAEASinMovResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__FECAEASinMovResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__FECAEASinMovResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__FECAEASinMovResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__FECAEASinMovResponse(soap, tag ? tag : "afip3:FECAEASinMovResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__FECAEASinMovResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__FECAEASinMovResponse(soap, this, tag, type);
}

SOAP_FMAC3 afip3__FECAEASinMovResponse * SOAP_FMAC4 soap_get_afip3__FECAEASinMovResponse(struct soap *soap, afip3__FECAEASinMovResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__FECAEASinMovResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__FECAEASinMov::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__FECAEASinMov::CAEA = NULL;
	this->afip3__FECAEASinMov::FchProceso = NULL;
	soap_default_int(soap, &this->afip3__FECAEASinMov::PtoVta);
}

void afip3__FECAEASinMov::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->afip3__FECAEASinMov::CAEA);
	soap_serialize_PointerTostd__string(soap, &this->afip3__FECAEASinMov::FchProceso);
#endif
}

int afip3__FECAEASinMov::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__FECAEASinMov(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__FECAEASinMov(struct soap *soap, const char *tag, int id, const afip3__FECAEASinMov *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__FECAEASinMov), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:CAEA", -1, &a->afip3__FECAEASinMov::CAEA, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchProceso", -1, &a->afip3__FECAEASinMov::FchProceso, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:PtoVta", -1, &a->afip3__FECAEASinMov::PtoVta, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__FECAEASinMov::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__FECAEASinMov(soap, tag, this, type);
}

SOAP_FMAC3 afip3__FECAEASinMov * SOAP_FMAC4 soap_in_afip3__FECAEASinMov(struct soap *soap, const char *tag, afip3__FECAEASinMov *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__FECAEASinMov*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__FECAEASinMov, sizeof(afip3__FECAEASinMov), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__FECAEASinMov)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__FECAEASinMov *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CAEA1 = 1;
	size_t soap_flag_FchProceso1 = 1;
	size_t soap_flag_PtoVta1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CAEA1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:CAEA", &a->afip3__FECAEASinMov::CAEA, "xsd:string"))
				{	soap_flag_CAEA1--;
					continue;
				}
			}
			if (soap_flag_FchProceso1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchProceso", &a->afip3__FECAEASinMov::FchProceso, "xsd:string"))
				{	soap_flag_FchProceso1--;
					continue;
				}
			}
			if (soap_flag_PtoVta1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:PtoVta", &a->afip3__FECAEASinMov::PtoVta, "xsd:int"))
				{	soap_flag_PtoVta1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PtoVta1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__FECAEASinMov *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__FECAEASinMov, SOAP_TYPE_afip3__FECAEASinMov, sizeof(afip3__FECAEASinMov), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__FECAEASinMov * SOAP_FMAC2 soap_instantiate_afip3__FECAEASinMov(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__FECAEASinMov(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "afip3:FECAEASinMovResponse"))
		return soap_instantiate_afip3__FECAEASinMovResponse(soap, n, NULL, NULL, size);
	afip3__FECAEASinMov *p;
	size_t k = sizeof(afip3__FECAEASinMov);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__FECAEASinMov, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__FECAEASinMov);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__FECAEASinMov, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__FECAEASinMov location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__FECAEASinMov::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__FECAEASinMov(soap, tag ? tag : "afip3:FECAEASinMov", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__FECAEASinMov::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__FECAEASinMov(soap, this, tag, type);
}

SOAP_FMAC3 afip3__FECAEASinMov * SOAP_FMAC4 soap_get_afip3__FECAEASinMov(struct soap *soap, afip3__FECAEASinMov *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__FECAEASinMov(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__ArrayOfFECAEASinMov::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToafip3__FECAEASinMov(soap, &this->afip3__ArrayOfFECAEASinMov::FECAEASinMov);
}

void afip3__ArrayOfFECAEASinMov::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToafip3__FECAEASinMov(soap, &this->afip3__ArrayOfFECAEASinMov::FECAEASinMov);
#endif
}

int afip3__ArrayOfFECAEASinMov::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__ArrayOfFECAEASinMov(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__ArrayOfFECAEASinMov(struct soap *soap, const char *tag, int id, const afip3__ArrayOfFECAEASinMov *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__ArrayOfFECAEASinMov), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToafip3__FECAEASinMov(soap, "afip3:FECAEASinMov", -1, &a->afip3__ArrayOfFECAEASinMov::FECAEASinMov, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__ArrayOfFECAEASinMov::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__ArrayOfFECAEASinMov(soap, tag, this, type);
}

SOAP_FMAC3 afip3__ArrayOfFECAEASinMov * SOAP_FMAC4 soap_in_afip3__ArrayOfFECAEASinMov(struct soap *soap, const char *tag, afip3__ArrayOfFECAEASinMov *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__ArrayOfFECAEASinMov*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__ArrayOfFECAEASinMov, sizeof(afip3__ArrayOfFECAEASinMov), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__ArrayOfFECAEASinMov)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__ArrayOfFECAEASinMov *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerToafip3__FECAEASinMov(soap, "afip3:FECAEASinMov", &a->afip3__ArrayOfFECAEASinMov::FECAEASinMov, "afip3:FECAEASinMov"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__ArrayOfFECAEASinMov *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__ArrayOfFECAEASinMov, SOAP_TYPE_afip3__ArrayOfFECAEASinMov, sizeof(afip3__ArrayOfFECAEASinMov), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__ArrayOfFECAEASinMov * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfFECAEASinMov(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__ArrayOfFECAEASinMov(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__ArrayOfFECAEASinMov *p;
	size_t k = sizeof(afip3__ArrayOfFECAEASinMov);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__ArrayOfFECAEASinMov, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__ArrayOfFECAEASinMov);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__ArrayOfFECAEASinMov, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__ArrayOfFECAEASinMov location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__ArrayOfFECAEASinMov::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__ArrayOfFECAEASinMov(soap, tag ? tag : "afip3:ArrayOfFECAEASinMov", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__ArrayOfFECAEASinMov::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__ArrayOfFECAEASinMov(soap, this, tag, type);
}

SOAP_FMAC3 afip3__ArrayOfFECAEASinMov * SOAP_FMAC4 soap_get_afip3__ArrayOfFECAEASinMov(struct soap *soap, afip3__ArrayOfFECAEASinMov *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__ArrayOfFECAEASinMov(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__FECAEASinMovConsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__FECAEASinMovConsResponse::ResultGet = NULL;
	this->afip3__FECAEASinMovConsResponse::Errors = NULL;
	this->afip3__FECAEASinMovConsResponse::Events = NULL;
}

void afip3__FECAEASinMovConsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__ArrayOfFECAEASinMov(soap, &this->afip3__FECAEASinMovConsResponse::ResultGet);
	soap_serialize_PointerToafip3__ArrayOfErr(soap, &this->afip3__FECAEASinMovConsResponse::Errors);
	soap_serialize_PointerToafip3__ArrayOfEvt(soap, &this->afip3__FECAEASinMovConsResponse::Events);
#endif
}

int afip3__FECAEASinMovConsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__FECAEASinMovConsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__FECAEASinMovConsResponse(struct soap *soap, const char *tag, int id, const afip3__FECAEASinMovConsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__FECAEASinMovConsResponse), type))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfFECAEASinMov(soap, "afip3:ResultGet", -1, &a->afip3__FECAEASinMovConsResponse::ResultGet, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", -1, &a->afip3__FECAEASinMovConsResponse::Errors, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", -1, &a->afip3__FECAEASinMovConsResponse::Events, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__FECAEASinMovConsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__FECAEASinMovConsResponse(soap, tag, this, type);
}

SOAP_FMAC3 afip3__FECAEASinMovConsResponse * SOAP_FMAC4 soap_in_afip3__FECAEASinMovConsResponse(struct soap *soap, const char *tag, afip3__FECAEASinMovConsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__FECAEASinMovConsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__FECAEASinMovConsResponse, sizeof(afip3__FECAEASinMovConsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__FECAEASinMovConsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__FECAEASinMovConsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResultGet1 = 1;
	size_t soap_flag_Errors1 = 1;
	size_t soap_flag_Events1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultGet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfFECAEASinMov(soap, "afip3:ResultGet", &a->afip3__FECAEASinMovConsResponse::ResultGet, "afip3:ArrayOfFECAEASinMov"))
				{	soap_flag_ResultGet1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", &a->afip3__FECAEASinMovConsResponse::Errors, "afip3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", &a->afip3__FECAEASinMovConsResponse::Events, "afip3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__FECAEASinMovConsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__FECAEASinMovConsResponse, SOAP_TYPE_afip3__FECAEASinMovConsResponse, sizeof(afip3__FECAEASinMovConsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__FECAEASinMovConsResponse * SOAP_FMAC2 soap_instantiate_afip3__FECAEASinMovConsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__FECAEASinMovConsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__FECAEASinMovConsResponse *p;
	size_t k = sizeof(afip3__FECAEASinMovConsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__FECAEASinMovConsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__FECAEASinMovConsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__FECAEASinMovConsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__FECAEASinMovConsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__FECAEASinMovConsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__FECAEASinMovConsResponse(soap, tag ? tag : "afip3:FECAEASinMovConsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__FECAEASinMovConsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__FECAEASinMovConsResponse(soap, this, tag, type);
}

SOAP_FMAC3 afip3__FECAEASinMovConsResponse * SOAP_FMAC4 soap_get_afip3__FECAEASinMovConsResponse(struct soap *soap, afip3__FECAEASinMovConsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__FECAEASinMovConsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__FECAEAGet::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__FECAEAGet::CAEA = NULL;
	soap_default_int(soap, &this->afip3__FECAEAGet::Periodo);
	soap_default_short(soap, &this->afip3__FECAEAGet::Orden);
	this->afip3__FECAEAGet::FchVigDesde = NULL;
	this->afip3__FECAEAGet::FchVigHasta = NULL;
	this->afip3__FECAEAGet::FchTopeInf = NULL;
	this->afip3__FECAEAGet::FchProceso = NULL;
	this->afip3__FECAEAGet::Observaciones = NULL;
}

void afip3__FECAEAGet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->afip3__FECAEAGet::CAEA);
	soap_serialize_PointerTostd__string(soap, &this->afip3__FECAEAGet::FchVigDesde);
	soap_serialize_PointerTostd__string(soap, &this->afip3__FECAEAGet::FchVigHasta);
	soap_serialize_PointerTostd__string(soap, &this->afip3__FECAEAGet::FchTopeInf);
	soap_serialize_PointerTostd__string(soap, &this->afip3__FECAEAGet::FchProceso);
	soap_serialize_PointerToafip3__ArrayOfObs(soap, &this->afip3__FECAEAGet::Observaciones);
#endif
}

int afip3__FECAEAGet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__FECAEAGet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__FECAEAGet(struct soap *soap, const char *tag, int id, const afip3__FECAEAGet *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__FECAEAGet), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:CAEA", -1, &a->afip3__FECAEAGet::CAEA, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:Periodo", -1, &a->afip3__FECAEAGet::Periodo, ""))
		return soap->error;
	if (soap_out_short(soap, "afip3:Orden", -1, &a->afip3__FECAEAGet::Orden, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchVigDesde", -1, &a->afip3__FECAEAGet::FchVigDesde, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchVigHasta", -1, &a->afip3__FECAEAGet::FchVigHasta, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchTopeInf", -1, &a->afip3__FECAEAGet::FchTopeInf, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchProceso", -1, &a->afip3__FECAEAGet::FchProceso, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfObs(soap, "afip3:Observaciones", -1, &a->afip3__FECAEAGet::Observaciones, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__FECAEAGet::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__FECAEAGet(soap, tag, this, type);
}

SOAP_FMAC3 afip3__FECAEAGet * SOAP_FMAC4 soap_in_afip3__FECAEAGet(struct soap *soap, const char *tag, afip3__FECAEAGet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__FECAEAGet*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__FECAEAGet, sizeof(afip3__FECAEAGet), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__FECAEAGet)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__FECAEAGet *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CAEA1 = 1;
	size_t soap_flag_Periodo1 = 1;
	size_t soap_flag_Orden1 = 1;
	size_t soap_flag_FchVigDesde1 = 1;
	size_t soap_flag_FchVigHasta1 = 1;
	size_t soap_flag_FchTopeInf1 = 1;
	size_t soap_flag_FchProceso1 = 1;
	size_t soap_flag_Observaciones1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CAEA1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:CAEA", &a->afip3__FECAEAGet::CAEA, "xsd:string"))
				{	soap_flag_CAEA1--;
					continue;
				}
			}
			if (soap_flag_Periodo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:Periodo", &a->afip3__FECAEAGet::Periodo, "xsd:int"))
				{	soap_flag_Periodo1--;
					continue;
				}
			}
			if (soap_flag_Orden1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_short(soap, "afip3:Orden", &a->afip3__FECAEAGet::Orden, "xsd:short"))
				{	soap_flag_Orden1--;
					continue;
				}
			}
			if (soap_flag_FchVigDesde1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchVigDesde", &a->afip3__FECAEAGet::FchVigDesde, "xsd:string"))
				{	soap_flag_FchVigDesde1--;
					continue;
				}
			}
			if (soap_flag_FchVigHasta1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchVigHasta", &a->afip3__FECAEAGet::FchVigHasta, "xsd:string"))
				{	soap_flag_FchVigHasta1--;
					continue;
				}
			}
			if (soap_flag_FchTopeInf1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchTopeInf", &a->afip3__FECAEAGet::FchTopeInf, "xsd:string"))
				{	soap_flag_FchTopeInf1--;
					continue;
				}
			}
			if (soap_flag_FchProceso1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchProceso", &a->afip3__FECAEAGet::FchProceso, "xsd:string"))
				{	soap_flag_FchProceso1--;
					continue;
				}
			}
			if (soap_flag_Observaciones1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfObs(soap, "afip3:Observaciones", &a->afip3__FECAEAGet::Observaciones, "afip3:ArrayOfObs"))
				{	soap_flag_Observaciones1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Periodo1 > 0 || soap_flag_Orden1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__FECAEAGet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__FECAEAGet, SOAP_TYPE_afip3__FECAEAGet, sizeof(afip3__FECAEAGet), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__FECAEAGet * SOAP_FMAC2 soap_instantiate_afip3__FECAEAGet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__FECAEAGet(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__FECAEAGet *p;
	size_t k = sizeof(afip3__FECAEAGet);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__FECAEAGet, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__FECAEAGet);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__FECAEAGet, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__FECAEAGet location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__FECAEAGet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__FECAEAGet(soap, tag ? tag : "afip3:FECAEAGet", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__FECAEAGet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__FECAEAGet(soap, this, tag, type);
}

SOAP_FMAC3 afip3__FECAEAGet * SOAP_FMAC4 soap_get_afip3__FECAEAGet(struct soap *soap, afip3__FECAEAGet *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__FECAEAGet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__FECAEAGetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__FECAEAGetResponse::ResultGet = NULL;
	this->afip3__FECAEAGetResponse::Errors = NULL;
	this->afip3__FECAEAGetResponse::Events = NULL;
}

void afip3__FECAEAGetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FECAEAGet(soap, &this->afip3__FECAEAGetResponse::ResultGet);
	soap_serialize_PointerToafip3__ArrayOfErr(soap, &this->afip3__FECAEAGetResponse::Errors);
	soap_serialize_PointerToafip3__ArrayOfEvt(soap, &this->afip3__FECAEAGetResponse::Events);
#endif
}

int afip3__FECAEAGetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__FECAEAGetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__FECAEAGetResponse(struct soap *soap, const char *tag, int id, const afip3__FECAEAGetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__FECAEAGetResponse), type))
		return soap->error;
	if (soap_out_PointerToafip3__FECAEAGet(soap, "afip3:ResultGet", -1, &a->afip3__FECAEAGetResponse::ResultGet, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", -1, &a->afip3__FECAEAGetResponse::Errors, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", -1, &a->afip3__FECAEAGetResponse::Events, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__FECAEAGetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__FECAEAGetResponse(soap, tag, this, type);
}

SOAP_FMAC3 afip3__FECAEAGetResponse * SOAP_FMAC4 soap_in_afip3__FECAEAGetResponse(struct soap *soap, const char *tag, afip3__FECAEAGetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__FECAEAGetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__FECAEAGetResponse, sizeof(afip3__FECAEAGetResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__FECAEAGetResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__FECAEAGetResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResultGet1 = 1;
	size_t soap_flag_Errors1 = 1;
	size_t soap_flag_Events1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultGet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FECAEAGet(soap, "afip3:ResultGet", &a->afip3__FECAEAGetResponse::ResultGet, "afip3:FECAEAGet"))
				{	soap_flag_ResultGet1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", &a->afip3__FECAEAGetResponse::Errors, "afip3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", &a->afip3__FECAEAGetResponse::Events, "afip3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__FECAEAGetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__FECAEAGetResponse, SOAP_TYPE_afip3__FECAEAGetResponse, sizeof(afip3__FECAEAGetResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__FECAEAGetResponse * SOAP_FMAC2 soap_instantiate_afip3__FECAEAGetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__FECAEAGetResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__FECAEAGetResponse *p;
	size_t k = sizeof(afip3__FECAEAGetResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__FECAEAGetResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__FECAEAGetResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__FECAEAGetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__FECAEAGetResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__FECAEAGetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__FECAEAGetResponse(soap, tag ? tag : "afip3:FECAEAGetResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__FECAEAGetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__FECAEAGetResponse(soap, this, tag, type);
}

SOAP_FMAC3 afip3__FECAEAGetResponse * SOAP_FMAC4 soap_get_afip3__FECAEAGetResponse(struct soap *soap, afip3__FECAEAGetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__FECAEAGetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__FECAEADetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__FEDetResponse::soap_default(soap);
	this->afip3__FECAEADetResponse::CAEA = NULL;
}

void afip3__FECAEADetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->afip3__FECAEADetResponse::CAEA);
	this->afip3__FEDetResponse::soap_serialize(soap);
#endif
}

int afip3__FECAEADetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__FECAEADetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__FECAEADetResponse(struct soap *soap, const char *tag, int id, const afip3__FECAEADetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__FECAEADetResponse), type ? type : "afip3:FECAEADetResponse"))
		return soap->error;
	if (soap_out_int(soap, "afip3:Concepto", -1, &a->afip3__FEDetResponse::Concepto, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:DocTipo", -1, &a->afip3__FEDetResponse::DocTipo, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "afip3:DocNro", -1, &a->afip3__FEDetResponse::DocNro, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "afip3:CbteDesde", -1, &a->afip3__FEDetResponse::CbteDesde, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "afip3:CbteHasta", -1, &a->afip3__FEDetResponse::CbteHasta, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:CbteFch", -1, &a->afip3__FEDetResponse::CbteFch, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:Resultado", -1, &a->afip3__FEDetResponse::Resultado, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfObs(soap, "afip3:Observaciones", -1, &a->afip3__FEDetResponse::Observaciones, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:CAEA", -1, &a->afip3__FECAEADetResponse::CAEA, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__FECAEADetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__FECAEADetResponse(soap, tag, this, type);
}

SOAP_FMAC3 afip3__FECAEADetResponse * SOAP_FMAC4 soap_in_afip3__FECAEADetResponse(struct soap *soap, const char *tag, afip3__FECAEADetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__FECAEADetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__FECAEADetResponse, sizeof(afip3__FECAEADetResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__FECAEADetResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__FECAEADetResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Concepto2 = 1;
	size_t soap_flag_DocTipo2 = 1;
	size_t soap_flag_DocNro2 = 1;
	size_t soap_flag_CbteDesde2 = 1;
	size_t soap_flag_CbteHasta2 = 1;
	size_t soap_flag_CbteFch2 = 1;
	size_t soap_flag_Resultado2 = 1;
	size_t soap_flag_Observaciones2 = 1;
	size_t soap_flag_CAEA1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Concepto2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:Concepto", &a->afip3__FEDetResponse::Concepto, "xsd:int"))
				{	soap_flag_Concepto2--;
					continue;
				}
			}
			if (soap_flag_DocTipo2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:DocTipo", &a->afip3__FEDetResponse::DocTipo, "xsd:int"))
				{	soap_flag_DocTipo2--;
					continue;
				}
			}
			if (soap_flag_DocNro2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "afip3:DocNro", &a->afip3__FEDetResponse::DocNro, "xsd:long"))
				{	soap_flag_DocNro2--;
					continue;
				}
			}
			if (soap_flag_CbteDesde2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "afip3:CbteDesde", &a->afip3__FEDetResponse::CbteDesde, "xsd:long"))
				{	soap_flag_CbteDesde2--;
					continue;
				}
			}
			if (soap_flag_CbteHasta2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "afip3:CbteHasta", &a->afip3__FEDetResponse::CbteHasta, "xsd:long"))
				{	soap_flag_CbteHasta2--;
					continue;
				}
			}
			if (soap_flag_CbteFch2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:CbteFch", &a->afip3__FEDetResponse::CbteFch, "xsd:string"))
				{	soap_flag_CbteFch2--;
					continue;
				}
			}
			if (soap_flag_Resultado2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:Resultado", &a->afip3__FEDetResponse::Resultado, "xsd:string"))
				{	soap_flag_Resultado2--;
					continue;
				}
			}
			if (soap_flag_Observaciones2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfObs(soap, "afip3:Observaciones", &a->afip3__FEDetResponse::Observaciones, "afip3:ArrayOfObs"))
				{	soap_flag_Observaciones2--;
					continue;
				}
			}
			if (soap_flag_CAEA1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:CAEA", &a->afip3__FECAEADetResponse::CAEA, "xsd:string"))
				{	soap_flag_CAEA1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Concepto2 > 0 || soap_flag_DocTipo2 > 0 || soap_flag_DocNro2 > 0 || soap_flag_CbteDesde2 > 0 || soap_flag_CbteHasta2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__FECAEADetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__FECAEADetResponse, SOAP_TYPE_afip3__FECAEADetResponse, sizeof(afip3__FECAEADetResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__FECAEADetResponse * SOAP_FMAC2 soap_instantiate_afip3__FECAEADetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__FECAEADetResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__FECAEADetResponse *p;
	size_t k = sizeof(afip3__FECAEADetResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__FECAEADetResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__FECAEADetResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__FECAEADetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__FECAEADetResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__FECAEADetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__FECAEADetResponse(soap, tag ? tag : "afip3:FECAEADetResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__FECAEADetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__FECAEADetResponse(soap, this, tag, type);
}

SOAP_FMAC3 afip3__FECAEADetResponse * SOAP_FMAC4 soap_get_afip3__FECAEADetResponse(struct soap *soap, afip3__FECAEADetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__FECAEADetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__ArrayOfFECAEADetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToafip3__FECAEADetResponse(soap, &this->afip3__ArrayOfFECAEADetResponse::FECAEADetResponse);
}

void afip3__ArrayOfFECAEADetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToafip3__FECAEADetResponse(soap, &this->afip3__ArrayOfFECAEADetResponse::FECAEADetResponse);
#endif
}

int afip3__ArrayOfFECAEADetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__ArrayOfFECAEADetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__ArrayOfFECAEADetResponse(struct soap *soap, const char *tag, int id, const afip3__ArrayOfFECAEADetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__ArrayOfFECAEADetResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToafip3__FECAEADetResponse(soap, "afip3:FECAEADetResponse", -1, &a->afip3__ArrayOfFECAEADetResponse::FECAEADetResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__ArrayOfFECAEADetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__ArrayOfFECAEADetResponse(soap, tag, this, type);
}

SOAP_FMAC3 afip3__ArrayOfFECAEADetResponse * SOAP_FMAC4 soap_in_afip3__ArrayOfFECAEADetResponse(struct soap *soap, const char *tag, afip3__ArrayOfFECAEADetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__ArrayOfFECAEADetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__ArrayOfFECAEADetResponse, sizeof(afip3__ArrayOfFECAEADetResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__ArrayOfFECAEADetResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__ArrayOfFECAEADetResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerToafip3__FECAEADetResponse(soap, "afip3:FECAEADetResponse", &a->afip3__ArrayOfFECAEADetResponse::FECAEADetResponse, "afip3:FECAEADetResponse"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__ArrayOfFECAEADetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__ArrayOfFECAEADetResponse, SOAP_TYPE_afip3__ArrayOfFECAEADetResponse, sizeof(afip3__ArrayOfFECAEADetResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__ArrayOfFECAEADetResponse * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfFECAEADetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__ArrayOfFECAEADetResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__ArrayOfFECAEADetResponse *p;
	size_t k = sizeof(afip3__ArrayOfFECAEADetResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__ArrayOfFECAEADetResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__ArrayOfFECAEADetResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__ArrayOfFECAEADetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__ArrayOfFECAEADetResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__ArrayOfFECAEADetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__ArrayOfFECAEADetResponse(soap, tag ? tag : "afip3:ArrayOfFECAEADetResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__ArrayOfFECAEADetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__ArrayOfFECAEADetResponse(soap, this, tag, type);
}

SOAP_FMAC3 afip3__ArrayOfFECAEADetResponse * SOAP_FMAC4 soap_get_afip3__ArrayOfFECAEADetResponse(struct soap *soap, afip3__ArrayOfFECAEADetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__ArrayOfFECAEADetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__FECAEACabResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__FECabResponse::soap_default(soap);
}

void afip3__FECAEACabResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->afip3__FECabResponse::soap_serialize(soap);
#endif
}

int afip3__FECAEACabResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__FECAEACabResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__FECAEACabResponse(struct soap *soap, const char *tag, int id, const afip3__FECAEACabResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__FECAEACabResponse), type ? type : "afip3:FECAEACabResponse"))
		return soap->error;
	if (soap_out_LONG64(soap, "afip3:Cuit", -1, &a->afip3__FECabResponse::Cuit, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:PtoVta", -1, &a->afip3__FECabResponse::PtoVta, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:CbteTipo", -1, &a->afip3__FECabResponse::CbteTipo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchProceso", -1, &a->afip3__FECabResponse::FchProceso, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:CantReg", -1, &a->afip3__FECabResponse::CantReg, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:Resultado", -1, &a->afip3__FECabResponse::Resultado, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:Reproceso", -1, &a->afip3__FECabResponse::Reproceso, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__FECAEACabResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__FECAEACabResponse(soap, tag, this, type);
}

SOAP_FMAC3 afip3__FECAEACabResponse * SOAP_FMAC4 soap_in_afip3__FECAEACabResponse(struct soap *soap, const char *tag, afip3__FECAEACabResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__FECAEACabResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__FECAEACabResponse, sizeof(afip3__FECAEACabResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__FECAEACabResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__FECAEACabResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Cuit2 = 1;
	size_t soap_flag_PtoVta2 = 1;
	size_t soap_flag_CbteTipo2 = 1;
	size_t soap_flag_FchProceso2 = 1;
	size_t soap_flag_CantReg2 = 1;
	size_t soap_flag_Resultado2 = 1;
	size_t soap_flag_Reproceso2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Cuit2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "afip3:Cuit", &a->afip3__FECabResponse::Cuit, "xsd:long"))
				{	soap_flag_Cuit2--;
					continue;
				}
			}
			if (soap_flag_PtoVta2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:PtoVta", &a->afip3__FECabResponse::PtoVta, "xsd:int"))
				{	soap_flag_PtoVta2--;
					continue;
				}
			}
			if (soap_flag_CbteTipo2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:CbteTipo", &a->afip3__FECabResponse::CbteTipo, "xsd:int"))
				{	soap_flag_CbteTipo2--;
					continue;
				}
			}
			if (soap_flag_FchProceso2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchProceso", &a->afip3__FECabResponse::FchProceso, "xsd:string"))
				{	soap_flag_FchProceso2--;
					continue;
				}
			}
			if (soap_flag_CantReg2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:CantReg", &a->afip3__FECabResponse::CantReg, "xsd:int"))
				{	soap_flag_CantReg2--;
					continue;
				}
			}
			if (soap_flag_Resultado2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:Resultado", &a->afip3__FECabResponse::Resultado, "xsd:string"))
				{	soap_flag_Resultado2--;
					continue;
				}
			}
			if (soap_flag_Reproceso2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:Reproceso", &a->afip3__FECabResponse::Reproceso, "xsd:string"))
				{	soap_flag_Reproceso2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Cuit2 > 0 || soap_flag_PtoVta2 > 0 || soap_flag_CbteTipo2 > 0 || soap_flag_CantReg2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__FECAEACabResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__FECAEACabResponse, SOAP_TYPE_afip3__FECAEACabResponse, sizeof(afip3__FECAEACabResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__FECAEACabResponse * SOAP_FMAC2 soap_instantiate_afip3__FECAEACabResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__FECAEACabResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__FECAEACabResponse *p;
	size_t k = sizeof(afip3__FECAEACabResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__FECAEACabResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__FECAEACabResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__FECAEACabResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__FECAEACabResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__FECAEACabResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__FECAEACabResponse(soap, tag ? tag : "afip3:FECAEACabResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__FECAEACabResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__FECAEACabResponse(soap, this, tag, type);
}

SOAP_FMAC3 afip3__FECAEACabResponse * SOAP_FMAC4 soap_get_afip3__FECAEACabResponse(struct soap *soap, afip3__FECAEACabResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__FECAEACabResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__FECAEAResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__FECAEAResponse::FeCabResp = NULL;
	this->afip3__FECAEAResponse::FeDetResp = NULL;
	this->afip3__FECAEAResponse::Events = NULL;
	this->afip3__FECAEAResponse::Errors = NULL;
}

void afip3__FECAEAResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FECAEACabResponse(soap, &this->afip3__FECAEAResponse::FeCabResp);
	soap_serialize_PointerToafip3__ArrayOfFECAEADetResponse(soap, &this->afip3__FECAEAResponse::FeDetResp);
	soap_serialize_PointerToafip3__ArrayOfEvt(soap, &this->afip3__FECAEAResponse::Events);
	soap_serialize_PointerToafip3__ArrayOfErr(soap, &this->afip3__FECAEAResponse::Errors);
#endif
}

int afip3__FECAEAResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__FECAEAResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__FECAEAResponse(struct soap *soap, const char *tag, int id, const afip3__FECAEAResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__FECAEAResponse), type))
		return soap->error;
	if (soap_out_PointerToafip3__FECAEACabResponse(soap, "afip3:FeCabResp", -1, &a->afip3__FECAEAResponse::FeCabResp, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfFECAEADetResponse(soap, "afip3:FeDetResp", -1, &a->afip3__FECAEAResponse::FeDetResp, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", -1, &a->afip3__FECAEAResponse::Events, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", -1, &a->afip3__FECAEAResponse::Errors, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__FECAEAResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__FECAEAResponse(soap, tag, this, type);
}

SOAP_FMAC3 afip3__FECAEAResponse * SOAP_FMAC4 soap_in_afip3__FECAEAResponse(struct soap *soap, const char *tag, afip3__FECAEAResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__FECAEAResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__FECAEAResponse, sizeof(afip3__FECAEAResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__FECAEAResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__FECAEAResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FeCabResp1 = 1;
	size_t soap_flag_FeDetResp1 = 1;
	size_t soap_flag_Events1 = 1;
	size_t soap_flag_Errors1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FeCabResp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FECAEACabResponse(soap, "afip3:FeCabResp", &a->afip3__FECAEAResponse::FeCabResp, "afip3:FECAEACabResponse"))
				{	soap_flag_FeCabResp1--;
					continue;
				}
			}
			if (soap_flag_FeDetResp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfFECAEADetResponse(soap, "afip3:FeDetResp", &a->afip3__FECAEAResponse::FeDetResp, "afip3:ArrayOfFECAEADetResponse"))
				{	soap_flag_FeDetResp1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", &a->afip3__FECAEAResponse::Events, "afip3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", &a->afip3__FECAEAResponse::Errors, "afip3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__FECAEAResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__FECAEAResponse, SOAP_TYPE_afip3__FECAEAResponse, sizeof(afip3__FECAEAResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__FECAEAResponse * SOAP_FMAC2 soap_instantiate_afip3__FECAEAResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__FECAEAResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__FECAEAResponse *p;
	size_t k = sizeof(afip3__FECAEAResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__FECAEAResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__FECAEAResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__FECAEAResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__FECAEAResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__FECAEAResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__FECAEAResponse(soap, tag ? tag : "afip3:FECAEAResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__FECAEAResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__FECAEAResponse(soap, this, tag, type);
}

SOAP_FMAC3 afip3__FECAEAResponse * SOAP_FMAC4 soap_get_afip3__FECAEAResponse(struct soap *soap, afip3__FECAEAResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__FECAEAResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__FECAEADetRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__FEDetRequest::soap_default(soap);
	this->afip3__FECAEADetRequest::CAEA = NULL;
	this->afip3__FECAEADetRequest::CbteFchHsGen = NULL;
}

void afip3__FECAEADetRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->afip3__FECAEADetRequest::CAEA);
	soap_serialize_PointerTostd__string(soap, &this->afip3__FECAEADetRequest::CbteFchHsGen);
	this->afip3__FEDetRequest::soap_serialize(soap);
#endif
}

int afip3__FECAEADetRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__FECAEADetRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__FECAEADetRequest(struct soap *soap, const char *tag, int id, const afip3__FECAEADetRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__FECAEADetRequest), type ? type : "afip3:FECAEADetRequest"))
		return soap->error;
	if (soap_out_int(soap, "afip3:Concepto", -1, &a->afip3__FEDetRequest::Concepto, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:DocTipo", -1, &a->afip3__FEDetRequest::DocTipo, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "afip3:DocNro", -1, &a->afip3__FEDetRequest::DocNro, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "afip3:CbteDesde", -1, &a->afip3__FEDetRequest::CbteDesde, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "afip3:CbteHasta", -1, &a->afip3__FEDetRequest::CbteHasta, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:CbteFch", -1, &a->afip3__FEDetRequest::CbteFch, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:ImpTotal", -1, &a->afip3__FEDetRequest::ImpTotal, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:ImpTotConc", -1, &a->afip3__FEDetRequest::ImpTotConc, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:ImpNeto", -1, &a->afip3__FEDetRequest::ImpNeto, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:ImpOpEx", -1, &a->afip3__FEDetRequest::ImpOpEx, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:ImpTrib", -1, &a->afip3__FEDetRequest::ImpTrib, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:ImpIVA", -1, &a->afip3__FEDetRequest::ImpIVA, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchServDesde", -1, &a->afip3__FEDetRequest::FchServDesde, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchServHasta", -1, &a->afip3__FEDetRequest::FchServHasta, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchVtoPago", -1, &a->afip3__FEDetRequest::FchVtoPago, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:MonId", -1, &a->afip3__FEDetRequest::MonId, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:MonCotiz", -1, &a->afip3__FEDetRequest::MonCotiz, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfCbteAsoc(soap, "afip3:CbtesAsoc", -1, &a->afip3__FEDetRequest::CbtesAsoc, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfTributo(soap, "afip3:Tributos", -1, &a->afip3__FEDetRequest::Tributos, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfAlicIva(soap, "afip3:Iva", -1, &a->afip3__FEDetRequest::Iva, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfOpcional(soap, "afip3:Opcionales", -1, &a->afip3__FEDetRequest::Opcionales, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfComprador(soap, "afip3:Compradores", -1, &a->afip3__FEDetRequest::Compradores, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:CAEA", -1, &a->afip3__FECAEADetRequest::CAEA, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:CbteFchHsGen", -1, &a->afip3__FECAEADetRequest::CbteFchHsGen, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__FECAEADetRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__FECAEADetRequest(soap, tag, this, type);
}

SOAP_FMAC3 afip3__FECAEADetRequest * SOAP_FMAC4 soap_in_afip3__FECAEADetRequest(struct soap *soap, const char *tag, afip3__FECAEADetRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__FECAEADetRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__FECAEADetRequest, sizeof(afip3__FECAEADetRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__FECAEADetRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__FECAEADetRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Concepto2 = 1;
	size_t soap_flag_DocTipo2 = 1;
	size_t soap_flag_DocNro2 = 1;
	size_t soap_flag_CbteDesde2 = 1;
	size_t soap_flag_CbteHasta2 = 1;
	size_t soap_flag_CbteFch2 = 1;
	size_t soap_flag_ImpTotal2 = 1;
	size_t soap_flag_ImpTotConc2 = 1;
	size_t soap_flag_ImpNeto2 = 1;
	size_t soap_flag_ImpOpEx2 = 1;
	size_t soap_flag_ImpTrib2 = 1;
	size_t soap_flag_ImpIVA2 = 1;
	size_t soap_flag_FchServDesde2 = 1;
	size_t soap_flag_FchServHasta2 = 1;
	size_t soap_flag_FchVtoPago2 = 1;
	size_t soap_flag_MonId2 = 1;
	size_t soap_flag_MonCotiz2 = 1;
	size_t soap_flag_CbtesAsoc2 = 1;
	size_t soap_flag_Tributos2 = 1;
	size_t soap_flag_Iva2 = 1;
	size_t soap_flag_Opcionales2 = 1;
	size_t soap_flag_Compradores2 = 1;
	size_t soap_flag_CAEA1 = 1;
	size_t soap_flag_CbteFchHsGen1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Concepto2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:Concepto", &a->afip3__FEDetRequest::Concepto, "xsd:int"))
				{	soap_flag_Concepto2--;
					continue;
				}
			}
			if (soap_flag_DocTipo2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:DocTipo", &a->afip3__FEDetRequest::DocTipo, "xsd:int"))
				{	soap_flag_DocTipo2--;
					continue;
				}
			}
			if (soap_flag_DocNro2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "afip3:DocNro", &a->afip3__FEDetRequest::DocNro, "xsd:long"))
				{	soap_flag_DocNro2--;
					continue;
				}
			}
			if (soap_flag_CbteDesde2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "afip3:CbteDesde", &a->afip3__FEDetRequest::CbteDesde, "xsd:long"))
				{	soap_flag_CbteDesde2--;
					continue;
				}
			}
			if (soap_flag_CbteHasta2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "afip3:CbteHasta", &a->afip3__FEDetRequest::CbteHasta, "xsd:long"))
				{	soap_flag_CbteHasta2--;
					continue;
				}
			}
			if (soap_flag_CbteFch2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:CbteFch", &a->afip3__FEDetRequest::CbteFch, "xsd:string"))
				{	soap_flag_CbteFch2--;
					continue;
				}
			}
			if (soap_flag_ImpTotal2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:ImpTotal", &a->afip3__FEDetRequest::ImpTotal, "xsd:double"))
				{	soap_flag_ImpTotal2--;
					continue;
				}
			}
			if (soap_flag_ImpTotConc2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:ImpTotConc", &a->afip3__FEDetRequest::ImpTotConc, "xsd:double"))
				{	soap_flag_ImpTotConc2--;
					continue;
				}
			}
			if (soap_flag_ImpNeto2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:ImpNeto", &a->afip3__FEDetRequest::ImpNeto, "xsd:double"))
				{	soap_flag_ImpNeto2--;
					continue;
				}
			}
			if (soap_flag_ImpOpEx2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:ImpOpEx", &a->afip3__FEDetRequest::ImpOpEx, "xsd:double"))
				{	soap_flag_ImpOpEx2--;
					continue;
				}
			}
			if (soap_flag_ImpTrib2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:ImpTrib", &a->afip3__FEDetRequest::ImpTrib, "xsd:double"))
				{	soap_flag_ImpTrib2--;
					continue;
				}
			}
			if (soap_flag_ImpIVA2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:ImpIVA", &a->afip3__FEDetRequest::ImpIVA, "xsd:double"))
				{	soap_flag_ImpIVA2--;
					continue;
				}
			}
			if (soap_flag_FchServDesde2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchServDesde", &a->afip3__FEDetRequest::FchServDesde, "xsd:string"))
				{	soap_flag_FchServDesde2--;
					continue;
				}
			}
			if (soap_flag_FchServHasta2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchServHasta", &a->afip3__FEDetRequest::FchServHasta, "xsd:string"))
				{	soap_flag_FchServHasta2--;
					continue;
				}
			}
			if (soap_flag_FchVtoPago2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchVtoPago", &a->afip3__FEDetRequest::FchVtoPago, "xsd:string"))
				{	soap_flag_FchVtoPago2--;
					continue;
				}
			}
			if (soap_flag_MonId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:MonId", &a->afip3__FEDetRequest::MonId, "xsd:string"))
				{	soap_flag_MonId2--;
					continue;
				}
			}
			if (soap_flag_MonCotiz2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:MonCotiz", &a->afip3__FEDetRequest::MonCotiz, "xsd:double"))
				{	soap_flag_MonCotiz2--;
					continue;
				}
			}
			if (soap_flag_CbtesAsoc2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfCbteAsoc(soap, "afip3:CbtesAsoc", &a->afip3__FEDetRequest::CbtesAsoc, "afip3:ArrayOfCbteAsoc"))
				{	soap_flag_CbtesAsoc2--;
					continue;
				}
			}
			if (soap_flag_Tributos2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfTributo(soap, "afip3:Tributos", &a->afip3__FEDetRequest::Tributos, "afip3:ArrayOfTributo"))
				{	soap_flag_Tributos2--;
					continue;
				}
			}
			if (soap_flag_Iva2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfAlicIva(soap, "afip3:Iva", &a->afip3__FEDetRequest::Iva, "afip3:ArrayOfAlicIva"))
				{	soap_flag_Iva2--;
					continue;
				}
			}
			if (soap_flag_Opcionales2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfOpcional(soap, "afip3:Opcionales", &a->afip3__FEDetRequest::Opcionales, "afip3:ArrayOfOpcional"))
				{	soap_flag_Opcionales2--;
					continue;
				}
			}
			if (soap_flag_Compradores2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfComprador(soap, "afip3:Compradores", &a->afip3__FEDetRequest::Compradores, "afip3:ArrayOfComprador"))
				{	soap_flag_Compradores2--;
					continue;
				}
			}
			if (soap_flag_CAEA1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:CAEA", &a->afip3__FECAEADetRequest::CAEA, "xsd:string"))
				{	soap_flag_CAEA1--;
					continue;
				}
			}
			if (soap_flag_CbteFchHsGen1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:CbteFchHsGen", &a->afip3__FECAEADetRequest::CbteFchHsGen, "xsd:string"))
				{	soap_flag_CbteFchHsGen1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Concepto2 > 0 || soap_flag_DocTipo2 > 0 || soap_flag_DocNro2 > 0 || soap_flag_CbteDesde2 > 0 || soap_flag_CbteHasta2 > 0 || soap_flag_ImpTotal2 > 0 || soap_flag_ImpTotConc2 > 0 || soap_flag_ImpNeto2 > 0 || soap_flag_ImpOpEx2 > 0 || soap_flag_ImpTrib2 > 0 || soap_flag_ImpIVA2 > 0 || soap_flag_MonCotiz2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__FECAEADetRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__FECAEADetRequest, SOAP_TYPE_afip3__FECAEADetRequest, sizeof(afip3__FECAEADetRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__FECAEADetRequest * SOAP_FMAC2 soap_instantiate_afip3__FECAEADetRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__FECAEADetRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__FECAEADetRequest *p;
	size_t k = sizeof(afip3__FECAEADetRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__FECAEADetRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__FECAEADetRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__FECAEADetRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__FECAEADetRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__FECAEADetRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__FECAEADetRequest(soap, tag ? tag : "afip3:FECAEADetRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__FECAEADetRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__FECAEADetRequest(soap, this, tag, type);
}

SOAP_FMAC3 afip3__FECAEADetRequest * SOAP_FMAC4 soap_get_afip3__FECAEADetRequest(struct soap *soap, afip3__FECAEADetRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__FECAEADetRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__ArrayOfFECAEADetRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToafip3__FECAEADetRequest(soap, &this->afip3__ArrayOfFECAEADetRequest::FECAEADetRequest);
}

void afip3__ArrayOfFECAEADetRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToafip3__FECAEADetRequest(soap, &this->afip3__ArrayOfFECAEADetRequest::FECAEADetRequest);
#endif
}

int afip3__ArrayOfFECAEADetRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__ArrayOfFECAEADetRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__ArrayOfFECAEADetRequest(struct soap *soap, const char *tag, int id, const afip3__ArrayOfFECAEADetRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__ArrayOfFECAEADetRequest), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToafip3__FECAEADetRequest(soap, "afip3:FECAEADetRequest", -1, &a->afip3__ArrayOfFECAEADetRequest::FECAEADetRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__ArrayOfFECAEADetRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__ArrayOfFECAEADetRequest(soap, tag, this, type);
}

SOAP_FMAC3 afip3__ArrayOfFECAEADetRequest * SOAP_FMAC4 soap_in_afip3__ArrayOfFECAEADetRequest(struct soap *soap, const char *tag, afip3__ArrayOfFECAEADetRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__ArrayOfFECAEADetRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__ArrayOfFECAEADetRequest, sizeof(afip3__ArrayOfFECAEADetRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__ArrayOfFECAEADetRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__ArrayOfFECAEADetRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerToafip3__FECAEADetRequest(soap, "afip3:FECAEADetRequest", &a->afip3__ArrayOfFECAEADetRequest::FECAEADetRequest, "afip3:FECAEADetRequest"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__ArrayOfFECAEADetRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__ArrayOfFECAEADetRequest, SOAP_TYPE_afip3__ArrayOfFECAEADetRequest, sizeof(afip3__ArrayOfFECAEADetRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__ArrayOfFECAEADetRequest * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfFECAEADetRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__ArrayOfFECAEADetRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__ArrayOfFECAEADetRequest *p;
	size_t k = sizeof(afip3__ArrayOfFECAEADetRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__ArrayOfFECAEADetRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__ArrayOfFECAEADetRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__ArrayOfFECAEADetRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__ArrayOfFECAEADetRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__ArrayOfFECAEADetRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__ArrayOfFECAEADetRequest(soap, tag ? tag : "afip3:ArrayOfFECAEADetRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__ArrayOfFECAEADetRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__ArrayOfFECAEADetRequest(soap, this, tag, type);
}

SOAP_FMAC3 afip3__ArrayOfFECAEADetRequest * SOAP_FMAC4 soap_get_afip3__ArrayOfFECAEADetRequest(struct soap *soap, afip3__ArrayOfFECAEADetRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__ArrayOfFECAEADetRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__FECAEACabRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__FECabRequest::soap_default(soap);
}

void afip3__FECAEACabRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->afip3__FECabRequest::soap_serialize(soap);
#endif
}

int afip3__FECAEACabRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__FECAEACabRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__FECAEACabRequest(struct soap *soap, const char *tag, int id, const afip3__FECAEACabRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__FECAEACabRequest), type ? type : "afip3:FECAEACabRequest"))
		return soap->error;
	if (soap_out_int(soap, "afip3:CantReg", -1, &a->afip3__FECabRequest::CantReg, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:PtoVta", -1, &a->afip3__FECabRequest::PtoVta, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:CbteTipo", -1, &a->afip3__FECabRequest::CbteTipo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__FECAEACabRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__FECAEACabRequest(soap, tag, this, type);
}

SOAP_FMAC3 afip3__FECAEACabRequest * SOAP_FMAC4 soap_in_afip3__FECAEACabRequest(struct soap *soap, const char *tag, afip3__FECAEACabRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__FECAEACabRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__FECAEACabRequest, sizeof(afip3__FECAEACabRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__FECAEACabRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__FECAEACabRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CantReg2 = 1;
	size_t soap_flag_PtoVta2 = 1;
	size_t soap_flag_CbteTipo2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CantReg2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:CantReg", &a->afip3__FECabRequest::CantReg, "xsd:int"))
				{	soap_flag_CantReg2--;
					continue;
				}
			}
			if (soap_flag_PtoVta2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:PtoVta", &a->afip3__FECabRequest::PtoVta, "xsd:int"))
				{	soap_flag_PtoVta2--;
					continue;
				}
			}
			if (soap_flag_CbteTipo2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:CbteTipo", &a->afip3__FECabRequest::CbteTipo, "xsd:int"))
				{	soap_flag_CbteTipo2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CantReg2 > 0 || soap_flag_PtoVta2 > 0 || soap_flag_CbteTipo2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__FECAEACabRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__FECAEACabRequest, SOAP_TYPE_afip3__FECAEACabRequest, sizeof(afip3__FECAEACabRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__FECAEACabRequest * SOAP_FMAC2 soap_instantiate_afip3__FECAEACabRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__FECAEACabRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__FECAEACabRequest *p;
	size_t k = sizeof(afip3__FECAEACabRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__FECAEACabRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__FECAEACabRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__FECAEACabRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__FECAEACabRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__FECAEACabRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__FECAEACabRequest(soap, tag ? tag : "afip3:FECAEACabRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__FECAEACabRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__FECAEACabRequest(soap, this, tag, type);
}

SOAP_FMAC3 afip3__FECAEACabRequest * SOAP_FMAC4 soap_get_afip3__FECAEACabRequest(struct soap *soap, afip3__FECAEACabRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__FECAEACabRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__FECAEARequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__FECAEARequest::FeCabReq = NULL;
	this->afip3__FECAEARequest::FeDetReq = NULL;
}

void afip3__FECAEARequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FECAEACabRequest(soap, &this->afip3__FECAEARequest::FeCabReq);
	soap_serialize_PointerToafip3__ArrayOfFECAEADetRequest(soap, &this->afip3__FECAEARequest::FeDetReq);
#endif
}

int afip3__FECAEARequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__FECAEARequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__FECAEARequest(struct soap *soap, const char *tag, int id, const afip3__FECAEARequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__FECAEARequest), type))
		return soap->error;
	if (soap_out_PointerToafip3__FECAEACabRequest(soap, "afip3:FeCabReq", -1, &a->afip3__FECAEARequest::FeCabReq, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfFECAEADetRequest(soap, "afip3:FeDetReq", -1, &a->afip3__FECAEARequest::FeDetReq, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__FECAEARequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__FECAEARequest(soap, tag, this, type);
}

SOAP_FMAC3 afip3__FECAEARequest * SOAP_FMAC4 soap_in_afip3__FECAEARequest(struct soap *soap, const char *tag, afip3__FECAEARequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__FECAEARequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__FECAEARequest, sizeof(afip3__FECAEARequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__FECAEARequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__FECAEARequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FeCabReq1 = 1;
	size_t soap_flag_FeDetReq1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FeCabReq1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FECAEACabRequest(soap, "afip3:FeCabReq", &a->afip3__FECAEARequest::FeCabReq, "afip3:FECAEACabRequest"))
				{	soap_flag_FeCabReq1--;
					continue;
				}
			}
			if (soap_flag_FeDetReq1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfFECAEADetRequest(soap, "afip3:FeDetReq", &a->afip3__FECAEARequest::FeDetReq, "afip3:ArrayOfFECAEADetRequest"))
				{	soap_flag_FeDetReq1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__FECAEARequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__FECAEARequest, SOAP_TYPE_afip3__FECAEARequest, sizeof(afip3__FECAEARequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__FECAEARequest * SOAP_FMAC2 soap_instantiate_afip3__FECAEARequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__FECAEARequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__FECAEARequest *p;
	size_t k = sizeof(afip3__FECAEARequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__FECAEARequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__FECAEARequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__FECAEARequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__FECAEARequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__FECAEARequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__FECAEARequest(soap, tag ? tag : "afip3:FECAEARequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__FECAEARequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__FECAEARequest(soap, this, tag, type);
}

SOAP_FMAC3 afip3__FECAEARequest * SOAP_FMAC4 soap_get_afip3__FECAEARequest(struct soap *soap, afip3__FECAEARequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__FECAEARequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__FECompConsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__FECAEDetRequest::soap_default(soap);
	this->afip3__FECompConsResponse::Resultado = NULL;
	this->afip3__FECompConsResponse::CodAutorizacion = NULL;
	this->afip3__FECompConsResponse::EmisionTipo = NULL;
	this->afip3__FECompConsResponse::FchVto = NULL;
	this->afip3__FECompConsResponse::FchProceso = NULL;
	this->afip3__FECompConsResponse::Observaciones = NULL;
	soap_default_int(soap, &this->afip3__FECompConsResponse::PtoVta);
	soap_default_int(soap, &this->afip3__FECompConsResponse::CbteTipo);
}

void afip3__FECompConsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->afip3__FECompConsResponse::Resultado);
	soap_serialize_PointerTostd__string(soap, &this->afip3__FECompConsResponse::CodAutorizacion);
	soap_serialize_PointerTostd__string(soap, &this->afip3__FECompConsResponse::EmisionTipo);
	soap_serialize_PointerTostd__string(soap, &this->afip3__FECompConsResponse::FchVto);
	soap_serialize_PointerTostd__string(soap, &this->afip3__FECompConsResponse::FchProceso);
	soap_serialize_PointerToafip3__ArrayOfObs(soap, &this->afip3__FECompConsResponse::Observaciones);
	this->afip3__FECAEDetRequest::soap_serialize(soap);
#endif
}

int afip3__FECompConsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__FECompConsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__FECompConsResponse(struct soap *soap, const char *tag, int id, const afip3__FECompConsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__FECompConsResponse), type ? type : "afip3:FECompConsResponse"))
		return soap->error;
	if (soap_out_int(soap, "afip3:Concepto", -1, &a->afip3__FEDetRequest::Concepto, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:DocTipo", -1, &a->afip3__FEDetRequest::DocTipo, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "afip3:DocNro", -1, &a->afip3__FEDetRequest::DocNro, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "afip3:CbteDesde", -1, &a->afip3__FEDetRequest::CbteDesde, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "afip3:CbteHasta", -1, &a->afip3__FEDetRequest::CbteHasta, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:CbteFch", -1, &a->afip3__FEDetRequest::CbteFch, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:ImpTotal", -1, &a->afip3__FEDetRequest::ImpTotal, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:ImpTotConc", -1, &a->afip3__FEDetRequest::ImpTotConc, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:ImpNeto", -1, &a->afip3__FEDetRequest::ImpNeto, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:ImpOpEx", -1, &a->afip3__FEDetRequest::ImpOpEx, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:ImpTrib", -1, &a->afip3__FEDetRequest::ImpTrib, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:ImpIVA", -1, &a->afip3__FEDetRequest::ImpIVA, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchServDesde", -1, &a->afip3__FEDetRequest::FchServDesde, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchServHasta", -1, &a->afip3__FEDetRequest::FchServHasta, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchVtoPago", -1, &a->afip3__FEDetRequest::FchVtoPago, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:MonId", -1, &a->afip3__FEDetRequest::MonId, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:MonCotiz", -1, &a->afip3__FEDetRequest::MonCotiz, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfCbteAsoc(soap, "afip3:CbtesAsoc", -1, &a->afip3__FEDetRequest::CbtesAsoc, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfTributo(soap, "afip3:Tributos", -1, &a->afip3__FEDetRequest::Tributos, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfAlicIva(soap, "afip3:Iva", -1, &a->afip3__FEDetRequest::Iva, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfOpcional(soap, "afip3:Opcionales", -1, &a->afip3__FEDetRequest::Opcionales, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfComprador(soap, "afip3:Compradores", -1, &a->afip3__FEDetRequest::Compradores, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:Resultado", -1, &a->afip3__FECompConsResponse::Resultado, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:CodAutorizacion", -1, &a->afip3__FECompConsResponse::CodAutorizacion, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:EmisionTipo", -1, &a->afip3__FECompConsResponse::EmisionTipo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchVto", -1, &a->afip3__FECompConsResponse::FchVto, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchProceso", -1, &a->afip3__FECompConsResponse::FchProceso, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfObs(soap, "afip3:Observaciones", -1, &a->afip3__FECompConsResponse::Observaciones, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:PtoVta", -1, &a->afip3__FECompConsResponse::PtoVta, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:CbteTipo", -1, &a->afip3__FECompConsResponse::CbteTipo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__FECompConsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__FECompConsResponse(soap, tag, this, type);
}

SOAP_FMAC3 afip3__FECompConsResponse * SOAP_FMAC4 soap_in_afip3__FECompConsResponse(struct soap *soap, const char *tag, afip3__FECompConsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__FECompConsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__FECompConsResponse, sizeof(afip3__FECompConsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__FECompConsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__FECompConsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Concepto3 = 1;
	size_t soap_flag_DocTipo3 = 1;
	size_t soap_flag_DocNro3 = 1;
	size_t soap_flag_CbteDesde3 = 1;
	size_t soap_flag_CbteHasta3 = 1;
	size_t soap_flag_CbteFch3 = 1;
	size_t soap_flag_ImpTotal3 = 1;
	size_t soap_flag_ImpTotConc3 = 1;
	size_t soap_flag_ImpNeto3 = 1;
	size_t soap_flag_ImpOpEx3 = 1;
	size_t soap_flag_ImpTrib3 = 1;
	size_t soap_flag_ImpIVA3 = 1;
	size_t soap_flag_FchServDesde3 = 1;
	size_t soap_flag_FchServHasta3 = 1;
	size_t soap_flag_FchVtoPago3 = 1;
	size_t soap_flag_MonId3 = 1;
	size_t soap_flag_MonCotiz3 = 1;
	size_t soap_flag_CbtesAsoc3 = 1;
	size_t soap_flag_Tributos3 = 1;
	size_t soap_flag_Iva3 = 1;
	size_t soap_flag_Opcionales3 = 1;
	size_t soap_flag_Compradores3 = 1;
	size_t soap_flag_Resultado1 = 1;
	size_t soap_flag_CodAutorizacion1 = 1;
	size_t soap_flag_EmisionTipo1 = 1;
	size_t soap_flag_FchVto1 = 1;
	size_t soap_flag_FchProceso1 = 1;
	size_t soap_flag_Observaciones1 = 1;
	size_t soap_flag_PtoVta1 = 1;
	size_t soap_flag_CbteTipo1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Concepto3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:Concepto", &a->afip3__FEDetRequest::Concepto, "xsd:int"))
				{	soap_flag_Concepto3--;
					continue;
				}
			}
			if (soap_flag_DocTipo3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:DocTipo", &a->afip3__FEDetRequest::DocTipo, "xsd:int"))
				{	soap_flag_DocTipo3--;
					continue;
				}
			}
			if (soap_flag_DocNro3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "afip3:DocNro", &a->afip3__FEDetRequest::DocNro, "xsd:long"))
				{	soap_flag_DocNro3--;
					continue;
				}
			}
			if (soap_flag_CbteDesde3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "afip3:CbteDesde", &a->afip3__FEDetRequest::CbteDesde, "xsd:long"))
				{	soap_flag_CbteDesde3--;
					continue;
				}
			}
			if (soap_flag_CbteHasta3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "afip3:CbteHasta", &a->afip3__FEDetRequest::CbteHasta, "xsd:long"))
				{	soap_flag_CbteHasta3--;
					continue;
				}
			}
			if (soap_flag_CbteFch3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:CbteFch", &a->afip3__FEDetRequest::CbteFch, "xsd:string"))
				{	soap_flag_CbteFch3--;
					continue;
				}
			}
			if (soap_flag_ImpTotal3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:ImpTotal", &a->afip3__FEDetRequest::ImpTotal, "xsd:double"))
				{	soap_flag_ImpTotal3--;
					continue;
				}
			}
			if (soap_flag_ImpTotConc3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:ImpTotConc", &a->afip3__FEDetRequest::ImpTotConc, "xsd:double"))
				{	soap_flag_ImpTotConc3--;
					continue;
				}
			}
			if (soap_flag_ImpNeto3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:ImpNeto", &a->afip3__FEDetRequest::ImpNeto, "xsd:double"))
				{	soap_flag_ImpNeto3--;
					continue;
				}
			}
			if (soap_flag_ImpOpEx3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:ImpOpEx", &a->afip3__FEDetRequest::ImpOpEx, "xsd:double"))
				{	soap_flag_ImpOpEx3--;
					continue;
				}
			}
			if (soap_flag_ImpTrib3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:ImpTrib", &a->afip3__FEDetRequest::ImpTrib, "xsd:double"))
				{	soap_flag_ImpTrib3--;
					continue;
				}
			}
			if (soap_flag_ImpIVA3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:ImpIVA", &a->afip3__FEDetRequest::ImpIVA, "xsd:double"))
				{	soap_flag_ImpIVA3--;
					continue;
				}
			}
			if (soap_flag_FchServDesde3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchServDesde", &a->afip3__FEDetRequest::FchServDesde, "xsd:string"))
				{	soap_flag_FchServDesde3--;
					continue;
				}
			}
			if (soap_flag_FchServHasta3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchServHasta", &a->afip3__FEDetRequest::FchServHasta, "xsd:string"))
				{	soap_flag_FchServHasta3--;
					continue;
				}
			}
			if (soap_flag_FchVtoPago3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchVtoPago", &a->afip3__FEDetRequest::FchVtoPago, "xsd:string"))
				{	soap_flag_FchVtoPago3--;
					continue;
				}
			}
			if (soap_flag_MonId3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:MonId", &a->afip3__FEDetRequest::MonId, "xsd:string"))
				{	soap_flag_MonId3--;
					continue;
				}
			}
			if (soap_flag_MonCotiz3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:MonCotiz", &a->afip3__FEDetRequest::MonCotiz, "xsd:double"))
				{	soap_flag_MonCotiz3--;
					continue;
				}
			}
			if (soap_flag_CbtesAsoc3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfCbteAsoc(soap, "afip3:CbtesAsoc", &a->afip3__FEDetRequest::CbtesAsoc, "afip3:ArrayOfCbteAsoc"))
				{	soap_flag_CbtesAsoc3--;
					continue;
				}
			}
			if (soap_flag_Tributos3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfTributo(soap, "afip3:Tributos", &a->afip3__FEDetRequest::Tributos, "afip3:ArrayOfTributo"))
				{	soap_flag_Tributos3--;
					continue;
				}
			}
			if (soap_flag_Iva3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfAlicIva(soap, "afip3:Iva", &a->afip3__FEDetRequest::Iva, "afip3:ArrayOfAlicIva"))
				{	soap_flag_Iva3--;
					continue;
				}
			}
			if (soap_flag_Opcionales3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfOpcional(soap, "afip3:Opcionales", &a->afip3__FEDetRequest::Opcionales, "afip3:ArrayOfOpcional"))
				{	soap_flag_Opcionales3--;
					continue;
				}
			}
			if (soap_flag_Compradores3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfComprador(soap, "afip3:Compradores", &a->afip3__FEDetRequest::Compradores, "afip3:ArrayOfComprador"))
				{	soap_flag_Compradores3--;
					continue;
				}
			}
			if (soap_flag_Resultado1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:Resultado", &a->afip3__FECompConsResponse::Resultado, "xsd:string"))
				{	soap_flag_Resultado1--;
					continue;
				}
			}
			if (soap_flag_CodAutorizacion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:CodAutorizacion", &a->afip3__FECompConsResponse::CodAutorizacion, "xsd:string"))
				{	soap_flag_CodAutorizacion1--;
					continue;
				}
			}
			if (soap_flag_EmisionTipo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:EmisionTipo", &a->afip3__FECompConsResponse::EmisionTipo, "xsd:string"))
				{	soap_flag_EmisionTipo1--;
					continue;
				}
			}
			if (soap_flag_FchVto1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchVto", &a->afip3__FECompConsResponse::FchVto, "xsd:string"))
				{	soap_flag_FchVto1--;
					continue;
				}
			}
			if (soap_flag_FchProceso1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchProceso", &a->afip3__FECompConsResponse::FchProceso, "xsd:string"))
				{	soap_flag_FchProceso1--;
					continue;
				}
			}
			if (soap_flag_Observaciones1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfObs(soap, "afip3:Observaciones", &a->afip3__FECompConsResponse::Observaciones, "afip3:ArrayOfObs"))
				{	soap_flag_Observaciones1--;
					continue;
				}
			}
			if (soap_flag_PtoVta1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:PtoVta", &a->afip3__FECompConsResponse::PtoVta, "xsd:int"))
				{	soap_flag_PtoVta1--;
					continue;
				}
			}
			if (soap_flag_CbteTipo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:CbteTipo", &a->afip3__FECompConsResponse::CbteTipo, "xsd:int"))
				{	soap_flag_CbteTipo1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Concepto3 > 0 || soap_flag_DocTipo3 > 0 || soap_flag_DocNro3 > 0 || soap_flag_CbteDesde3 > 0 || soap_flag_CbteHasta3 > 0 || soap_flag_ImpTotal3 > 0 || soap_flag_ImpTotConc3 > 0 || soap_flag_ImpNeto3 > 0 || soap_flag_ImpOpEx3 > 0 || soap_flag_ImpTrib3 > 0 || soap_flag_ImpIVA3 > 0 || soap_flag_MonCotiz3 > 0 || soap_flag_PtoVta1 > 0 || soap_flag_CbteTipo1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__FECompConsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__FECompConsResponse, SOAP_TYPE_afip3__FECompConsResponse, sizeof(afip3__FECompConsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__FECompConsResponse * SOAP_FMAC2 soap_instantiate_afip3__FECompConsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__FECompConsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__FECompConsResponse *p;
	size_t k = sizeof(afip3__FECompConsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__FECompConsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__FECompConsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__FECompConsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__FECompConsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__FECompConsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__FECompConsResponse(soap, tag ? tag : "afip3:FECompConsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__FECompConsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__FECompConsResponse(soap, this, tag, type);
}

SOAP_FMAC3 afip3__FECompConsResponse * SOAP_FMAC4 soap_get_afip3__FECompConsResponse(struct soap *soap, afip3__FECompConsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__FECompConsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__FECompConsultaResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__FECompConsultaResponse::ResultGet = NULL;
	this->afip3__FECompConsultaResponse::Errors = NULL;
	this->afip3__FECompConsultaResponse::Events = NULL;
}

void afip3__FECompConsultaResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FECompConsResponse(soap, &this->afip3__FECompConsultaResponse::ResultGet);
	soap_serialize_PointerToafip3__ArrayOfErr(soap, &this->afip3__FECompConsultaResponse::Errors);
	soap_serialize_PointerToafip3__ArrayOfEvt(soap, &this->afip3__FECompConsultaResponse::Events);
#endif
}

int afip3__FECompConsultaResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__FECompConsultaResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__FECompConsultaResponse(struct soap *soap, const char *tag, int id, const afip3__FECompConsultaResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__FECompConsultaResponse), type))
		return soap->error;
	if (soap_out_PointerToafip3__FECompConsResponse(soap, "afip3:ResultGet", -1, &a->afip3__FECompConsultaResponse::ResultGet, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", -1, &a->afip3__FECompConsultaResponse::Errors, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", -1, &a->afip3__FECompConsultaResponse::Events, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__FECompConsultaResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__FECompConsultaResponse(soap, tag, this, type);
}

SOAP_FMAC3 afip3__FECompConsultaResponse * SOAP_FMAC4 soap_in_afip3__FECompConsultaResponse(struct soap *soap, const char *tag, afip3__FECompConsultaResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__FECompConsultaResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__FECompConsultaResponse, sizeof(afip3__FECompConsultaResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__FECompConsultaResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__FECompConsultaResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResultGet1 = 1;
	size_t soap_flag_Errors1 = 1;
	size_t soap_flag_Events1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultGet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FECompConsResponse(soap, "afip3:ResultGet", &a->afip3__FECompConsultaResponse::ResultGet, "afip3:FECompConsResponse"))
				{	soap_flag_ResultGet1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", &a->afip3__FECompConsultaResponse::Errors, "afip3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", &a->afip3__FECompConsultaResponse::Events, "afip3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__FECompConsultaResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__FECompConsultaResponse, SOAP_TYPE_afip3__FECompConsultaResponse, sizeof(afip3__FECompConsultaResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__FECompConsultaResponse * SOAP_FMAC2 soap_instantiate_afip3__FECompConsultaResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__FECompConsultaResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__FECompConsultaResponse *p;
	size_t k = sizeof(afip3__FECompConsultaResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__FECompConsultaResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__FECompConsultaResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__FECompConsultaResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__FECompConsultaResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__FECompConsultaResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__FECompConsultaResponse(soap, tag ? tag : "afip3:FECompConsultaResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__FECompConsultaResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__FECompConsultaResponse(soap, this, tag, type);
}

SOAP_FMAC3 afip3__FECompConsultaResponse * SOAP_FMAC4 soap_get_afip3__FECompConsultaResponse(struct soap *soap, afip3__FECompConsultaResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__FECompConsultaResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__FECompConsultaReq::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->afip3__FECompConsultaReq::CbteTipo);
	soap_default_LONG64(soap, &this->afip3__FECompConsultaReq::CbteNro);
	soap_default_int(soap, &this->afip3__FECompConsultaReq::PtoVta);
}

void afip3__FECompConsultaReq::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int afip3__FECompConsultaReq::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__FECompConsultaReq(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__FECompConsultaReq(struct soap *soap, const char *tag, int id, const afip3__FECompConsultaReq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__FECompConsultaReq), type))
		return soap->error;
	if (soap_out_int(soap, "afip3:CbteTipo", -1, &a->afip3__FECompConsultaReq::CbteTipo, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "afip3:CbteNro", -1, &a->afip3__FECompConsultaReq::CbteNro, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:PtoVta", -1, &a->afip3__FECompConsultaReq::PtoVta, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__FECompConsultaReq::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__FECompConsultaReq(soap, tag, this, type);
}

SOAP_FMAC3 afip3__FECompConsultaReq * SOAP_FMAC4 soap_in_afip3__FECompConsultaReq(struct soap *soap, const char *tag, afip3__FECompConsultaReq *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__FECompConsultaReq*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__FECompConsultaReq, sizeof(afip3__FECompConsultaReq), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__FECompConsultaReq)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__FECompConsultaReq *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CbteTipo1 = 1;
	size_t soap_flag_CbteNro1 = 1;
	size_t soap_flag_PtoVta1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CbteTipo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:CbteTipo", &a->afip3__FECompConsultaReq::CbteTipo, "xsd:int"))
				{	soap_flag_CbteTipo1--;
					continue;
				}
			}
			if (soap_flag_CbteNro1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "afip3:CbteNro", &a->afip3__FECompConsultaReq::CbteNro, "xsd:long"))
				{	soap_flag_CbteNro1--;
					continue;
				}
			}
			if (soap_flag_PtoVta1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:PtoVta", &a->afip3__FECompConsultaReq::PtoVta, "xsd:int"))
				{	soap_flag_PtoVta1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CbteTipo1 > 0 || soap_flag_CbteNro1 > 0 || soap_flag_PtoVta1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__FECompConsultaReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__FECompConsultaReq, SOAP_TYPE_afip3__FECompConsultaReq, sizeof(afip3__FECompConsultaReq), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__FECompConsultaReq * SOAP_FMAC2 soap_instantiate_afip3__FECompConsultaReq(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__FECompConsultaReq(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__FECompConsultaReq *p;
	size_t k = sizeof(afip3__FECompConsultaReq);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__FECompConsultaReq, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__FECompConsultaReq);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__FECompConsultaReq, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__FECompConsultaReq location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__FECompConsultaReq::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__FECompConsultaReq(soap, tag ? tag : "afip3:FECompConsultaReq", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__FECompConsultaReq::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__FECompConsultaReq(soap, this, tag, type);
}

SOAP_FMAC3 afip3__FECompConsultaReq * SOAP_FMAC4 soap_get_afip3__FECompConsultaReq(struct soap *soap, afip3__FECompConsultaReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__FECompConsultaReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__FERecuperaLastCbteResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->afip3__FERecuperaLastCbteResponse::PtoVta);
	soap_default_int(soap, &this->afip3__FERecuperaLastCbteResponse::CbteTipo);
	soap_default_int(soap, &this->afip3__FERecuperaLastCbteResponse::CbteNro);
	this->afip3__FERecuperaLastCbteResponse::Errors = NULL;
	this->afip3__FERecuperaLastCbteResponse::Events = NULL;
}

void afip3__FERecuperaLastCbteResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__ArrayOfErr(soap, &this->afip3__FERecuperaLastCbteResponse::Errors);
	soap_serialize_PointerToafip3__ArrayOfEvt(soap, &this->afip3__FERecuperaLastCbteResponse::Events);
#endif
}

int afip3__FERecuperaLastCbteResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__FERecuperaLastCbteResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__FERecuperaLastCbteResponse(struct soap *soap, const char *tag, int id, const afip3__FERecuperaLastCbteResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__FERecuperaLastCbteResponse), type))
		return soap->error;
	if (soap_out_int(soap, "afip3:PtoVta", -1, &a->afip3__FERecuperaLastCbteResponse::PtoVta, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:CbteTipo", -1, &a->afip3__FERecuperaLastCbteResponse::CbteTipo, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:CbteNro", -1, &a->afip3__FERecuperaLastCbteResponse::CbteNro, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", -1, &a->afip3__FERecuperaLastCbteResponse::Errors, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", -1, &a->afip3__FERecuperaLastCbteResponse::Events, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__FERecuperaLastCbteResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__FERecuperaLastCbteResponse(soap, tag, this, type);
}

SOAP_FMAC3 afip3__FERecuperaLastCbteResponse * SOAP_FMAC4 soap_in_afip3__FERecuperaLastCbteResponse(struct soap *soap, const char *tag, afip3__FERecuperaLastCbteResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__FERecuperaLastCbteResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__FERecuperaLastCbteResponse, sizeof(afip3__FERecuperaLastCbteResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__FERecuperaLastCbteResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__FERecuperaLastCbteResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PtoVta1 = 1;
	size_t soap_flag_CbteTipo1 = 1;
	size_t soap_flag_CbteNro1 = 1;
	size_t soap_flag_Errors1 = 1;
	size_t soap_flag_Events1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PtoVta1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:PtoVta", &a->afip3__FERecuperaLastCbteResponse::PtoVta, "xsd:int"))
				{	soap_flag_PtoVta1--;
					continue;
				}
			}
			if (soap_flag_CbteTipo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:CbteTipo", &a->afip3__FERecuperaLastCbteResponse::CbteTipo, "xsd:int"))
				{	soap_flag_CbteTipo1--;
					continue;
				}
			}
			if (soap_flag_CbteNro1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:CbteNro", &a->afip3__FERecuperaLastCbteResponse::CbteNro, "xsd:int"))
				{	soap_flag_CbteNro1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", &a->afip3__FERecuperaLastCbteResponse::Errors, "afip3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", &a->afip3__FERecuperaLastCbteResponse::Events, "afip3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PtoVta1 > 0 || soap_flag_CbteTipo1 > 0 || soap_flag_CbteNro1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__FERecuperaLastCbteResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__FERecuperaLastCbteResponse, SOAP_TYPE_afip3__FERecuperaLastCbteResponse, sizeof(afip3__FERecuperaLastCbteResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__FERecuperaLastCbteResponse * SOAP_FMAC2 soap_instantiate_afip3__FERecuperaLastCbteResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__FERecuperaLastCbteResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__FERecuperaLastCbteResponse *p;
	size_t k = sizeof(afip3__FERecuperaLastCbteResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__FERecuperaLastCbteResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__FERecuperaLastCbteResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__FERecuperaLastCbteResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__FERecuperaLastCbteResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__FERecuperaLastCbteResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__FERecuperaLastCbteResponse(soap, tag ? tag : "afip3:FERecuperaLastCbteResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__FERecuperaLastCbteResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__FERecuperaLastCbteResponse(soap, this, tag, type);
}

SOAP_FMAC3 afip3__FERecuperaLastCbteResponse * SOAP_FMAC4 soap_get_afip3__FERecuperaLastCbteResponse(struct soap *soap, afip3__FERecuperaLastCbteResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__FERecuperaLastCbteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__DummyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__DummyResponse::AppServer = NULL;
	this->afip3__DummyResponse::DbServer = NULL;
	this->afip3__DummyResponse::AuthServer = NULL;
}

void afip3__DummyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->afip3__DummyResponse::AppServer);
	soap_serialize_PointerTostd__string(soap, &this->afip3__DummyResponse::DbServer);
	soap_serialize_PointerTostd__string(soap, &this->afip3__DummyResponse::AuthServer);
#endif
}

int afip3__DummyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__DummyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__DummyResponse(struct soap *soap, const char *tag, int id, const afip3__DummyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__DummyResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:AppServer", -1, &a->afip3__DummyResponse::AppServer, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:DbServer", -1, &a->afip3__DummyResponse::DbServer, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:AuthServer", -1, &a->afip3__DummyResponse::AuthServer, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__DummyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__DummyResponse(soap, tag, this, type);
}

SOAP_FMAC3 afip3__DummyResponse * SOAP_FMAC4 soap_in_afip3__DummyResponse(struct soap *soap, const char *tag, afip3__DummyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__DummyResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__DummyResponse, sizeof(afip3__DummyResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__DummyResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__DummyResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AppServer1 = 1;
	size_t soap_flag_DbServer1 = 1;
	size_t soap_flag_AuthServer1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AppServer1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:AppServer", &a->afip3__DummyResponse::AppServer, "xsd:string"))
				{	soap_flag_AppServer1--;
					continue;
				}
			}
			if (soap_flag_DbServer1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:DbServer", &a->afip3__DummyResponse::DbServer, "xsd:string"))
				{	soap_flag_DbServer1--;
					continue;
				}
			}
			if (soap_flag_AuthServer1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:AuthServer", &a->afip3__DummyResponse::AuthServer, "xsd:string"))
				{	soap_flag_AuthServer1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__DummyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__DummyResponse, SOAP_TYPE_afip3__DummyResponse, sizeof(afip3__DummyResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__DummyResponse * SOAP_FMAC2 soap_instantiate_afip3__DummyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__DummyResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__DummyResponse *p;
	size_t k = sizeof(afip3__DummyResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__DummyResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__DummyResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__DummyResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__DummyResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__DummyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__DummyResponse(soap, tag ? tag : "afip3:DummyResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__DummyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__DummyResponse(soap, this, tag, type);
}

SOAP_FMAC3 afip3__DummyResponse * SOAP_FMAC4 soap_get_afip3__DummyResponse(struct soap *soap, afip3__DummyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__DummyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__FERegXReqResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->afip3__FERegXReqResponse::RegXReq);
	this->afip3__FERegXReqResponse::Errors = NULL;
	this->afip3__FERegXReqResponse::Events = NULL;
}

void afip3__FERegXReqResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__ArrayOfErr(soap, &this->afip3__FERegXReqResponse::Errors);
	soap_serialize_PointerToafip3__ArrayOfEvt(soap, &this->afip3__FERegXReqResponse::Events);
#endif
}

int afip3__FERegXReqResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__FERegXReqResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__FERegXReqResponse(struct soap *soap, const char *tag, int id, const afip3__FERegXReqResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__FERegXReqResponse), type))
		return soap->error;
	if (soap_out_int(soap, "afip3:RegXReq", -1, &a->afip3__FERegXReqResponse::RegXReq, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", -1, &a->afip3__FERegXReqResponse::Errors, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", -1, &a->afip3__FERegXReqResponse::Events, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__FERegXReqResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__FERegXReqResponse(soap, tag, this, type);
}

SOAP_FMAC3 afip3__FERegXReqResponse * SOAP_FMAC4 soap_in_afip3__FERegXReqResponse(struct soap *soap, const char *tag, afip3__FERegXReqResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__FERegXReqResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__FERegXReqResponse, sizeof(afip3__FERegXReqResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__FERegXReqResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__FERegXReqResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RegXReq1 = 1;
	size_t soap_flag_Errors1 = 1;
	size_t soap_flag_Events1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RegXReq1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:RegXReq", &a->afip3__FERegXReqResponse::RegXReq, "xsd:int"))
				{	soap_flag_RegXReq1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", &a->afip3__FERegXReqResponse::Errors, "afip3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", &a->afip3__FERegXReqResponse::Events, "afip3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RegXReq1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__FERegXReqResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__FERegXReqResponse, SOAP_TYPE_afip3__FERegXReqResponse, sizeof(afip3__FERegXReqResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__FERegXReqResponse * SOAP_FMAC2 soap_instantiate_afip3__FERegXReqResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__FERegXReqResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__FERegXReqResponse *p;
	size_t k = sizeof(afip3__FERegXReqResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__FERegXReqResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__FERegXReqResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__FERegXReqResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__FERegXReqResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__FERegXReqResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__FERegXReqResponse(soap, tag ? tag : "afip3:FERegXReqResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__FERegXReqResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__FERegXReqResponse(soap, this, tag, type);
}

SOAP_FMAC3 afip3__FERegXReqResponse * SOAP_FMAC4 soap_get_afip3__FERegXReqResponse(struct soap *soap, afip3__FERegXReqResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__FERegXReqResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__Err::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->afip3__Err::Code);
	this->afip3__Err::Msg = NULL;
}

void afip3__Err::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->afip3__Err::Msg);
#endif
}

int afip3__Err::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__Err(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__Err(struct soap *soap, const char *tag, int id, const afip3__Err *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__Err), type))
		return soap->error;
	if (soap_out_int(soap, "afip3:Code", -1, &a->afip3__Err::Code, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:Msg", -1, &a->afip3__Err::Msg, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__Err::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__Err(soap, tag, this, type);
}

SOAP_FMAC3 afip3__Err * SOAP_FMAC4 soap_in_afip3__Err(struct soap *soap, const char *tag, afip3__Err *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__Err*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__Err, sizeof(afip3__Err), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__Err)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__Err *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Code1 = 1;
	size_t soap_flag_Msg1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Code1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:Code", &a->afip3__Err::Code, "xsd:int"))
				{	soap_flag_Code1--;
					continue;
				}
			}
			if (soap_flag_Msg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:Msg", &a->afip3__Err::Msg, "xsd:string"))
				{	soap_flag_Msg1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Code1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__Err *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__Err, SOAP_TYPE_afip3__Err, sizeof(afip3__Err), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__Err * SOAP_FMAC2 soap_instantiate_afip3__Err(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__Err(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__Err *p;
	size_t k = sizeof(afip3__Err);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__Err, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__Err);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__Err, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__Err location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__Err::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__Err(soap, tag ? tag : "afip3:Err", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__Err::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__Err(soap, this, tag, type);
}

SOAP_FMAC3 afip3__Err * SOAP_FMAC4 soap_get_afip3__Err(struct soap *soap, afip3__Err *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__Err(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__ArrayOfErr::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToafip3__Err(soap, &this->afip3__ArrayOfErr::Err);
}

void afip3__ArrayOfErr::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToafip3__Err(soap, &this->afip3__ArrayOfErr::Err);
#endif
}

int afip3__ArrayOfErr::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__ArrayOfErr(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__ArrayOfErr(struct soap *soap, const char *tag, int id, const afip3__ArrayOfErr *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__ArrayOfErr), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToafip3__Err(soap, "afip3:Err", -1, &a->afip3__ArrayOfErr::Err, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__ArrayOfErr::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__ArrayOfErr(soap, tag, this, type);
}

SOAP_FMAC3 afip3__ArrayOfErr * SOAP_FMAC4 soap_in_afip3__ArrayOfErr(struct soap *soap, const char *tag, afip3__ArrayOfErr *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__ArrayOfErr*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__ArrayOfErr, sizeof(afip3__ArrayOfErr), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__ArrayOfErr)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__ArrayOfErr *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerToafip3__Err(soap, "afip3:Err", &a->afip3__ArrayOfErr::Err, "afip3:Err"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__ArrayOfErr *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__ArrayOfErr, SOAP_TYPE_afip3__ArrayOfErr, sizeof(afip3__ArrayOfErr), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__ArrayOfErr * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfErr(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__ArrayOfErr(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__ArrayOfErr *p;
	size_t k = sizeof(afip3__ArrayOfErr);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__ArrayOfErr, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__ArrayOfErr);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__ArrayOfErr, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__ArrayOfErr location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__ArrayOfErr::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__ArrayOfErr(soap, tag ? tag : "afip3:ArrayOfErr", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__ArrayOfErr::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__ArrayOfErr(soap, this, tag, type);
}

SOAP_FMAC3 afip3__ArrayOfErr * SOAP_FMAC4 soap_get_afip3__ArrayOfErr(struct soap *soap, afip3__ArrayOfErr *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__ArrayOfErr(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__Evt::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->afip3__Evt::Code);
	this->afip3__Evt::Msg = NULL;
}

void afip3__Evt::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->afip3__Evt::Msg);
#endif
}

int afip3__Evt::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__Evt(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__Evt(struct soap *soap, const char *tag, int id, const afip3__Evt *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__Evt), type))
		return soap->error;
	if (soap_out_int(soap, "afip3:Code", -1, &a->afip3__Evt::Code, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:Msg", -1, &a->afip3__Evt::Msg, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__Evt::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__Evt(soap, tag, this, type);
}

SOAP_FMAC3 afip3__Evt * SOAP_FMAC4 soap_in_afip3__Evt(struct soap *soap, const char *tag, afip3__Evt *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__Evt*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__Evt, sizeof(afip3__Evt), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__Evt)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__Evt *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Code1 = 1;
	size_t soap_flag_Msg1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Code1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:Code", &a->afip3__Evt::Code, "xsd:int"))
				{	soap_flag_Code1--;
					continue;
				}
			}
			if (soap_flag_Msg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:Msg", &a->afip3__Evt::Msg, "xsd:string"))
				{	soap_flag_Msg1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Code1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__Evt *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__Evt, SOAP_TYPE_afip3__Evt, sizeof(afip3__Evt), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__Evt * SOAP_FMAC2 soap_instantiate_afip3__Evt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__Evt(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__Evt *p;
	size_t k = sizeof(afip3__Evt);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__Evt, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__Evt);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__Evt, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__Evt location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__Evt::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__Evt(soap, tag ? tag : "afip3:Evt", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__Evt::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__Evt(soap, this, tag, type);
}

SOAP_FMAC3 afip3__Evt * SOAP_FMAC4 soap_get_afip3__Evt(struct soap *soap, afip3__Evt *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__Evt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__ArrayOfEvt::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToafip3__Evt(soap, &this->afip3__ArrayOfEvt::Evt);
}

void afip3__ArrayOfEvt::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToafip3__Evt(soap, &this->afip3__ArrayOfEvt::Evt);
#endif
}

int afip3__ArrayOfEvt::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__ArrayOfEvt(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__ArrayOfEvt(struct soap *soap, const char *tag, int id, const afip3__ArrayOfEvt *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__ArrayOfEvt), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToafip3__Evt(soap, "afip3:Evt", -1, &a->afip3__ArrayOfEvt::Evt, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__ArrayOfEvt::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__ArrayOfEvt(soap, tag, this, type);
}

SOAP_FMAC3 afip3__ArrayOfEvt * SOAP_FMAC4 soap_in_afip3__ArrayOfEvt(struct soap *soap, const char *tag, afip3__ArrayOfEvt *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__ArrayOfEvt*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__ArrayOfEvt, sizeof(afip3__ArrayOfEvt), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__ArrayOfEvt)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__ArrayOfEvt *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerToafip3__Evt(soap, "afip3:Evt", &a->afip3__ArrayOfEvt::Evt, "afip3:Evt"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__ArrayOfEvt *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__ArrayOfEvt, SOAP_TYPE_afip3__ArrayOfEvt, sizeof(afip3__ArrayOfEvt), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__ArrayOfEvt * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfEvt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__ArrayOfEvt(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__ArrayOfEvt *p;
	size_t k = sizeof(afip3__ArrayOfEvt);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__ArrayOfEvt, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__ArrayOfEvt);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__ArrayOfEvt, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__ArrayOfEvt location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__ArrayOfEvt::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__ArrayOfEvt(soap, tag ? tag : "afip3:ArrayOfEvt", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__ArrayOfEvt::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__ArrayOfEvt(soap, this, tag, type);
}

SOAP_FMAC3 afip3__ArrayOfEvt * SOAP_FMAC4 soap_get_afip3__ArrayOfEvt(struct soap *soap, afip3__ArrayOfEvt *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__ArrayOfEvt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__Obs::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->afip3__Obs::Code);
	this->afip3__Obs::Msg = NULL;
}

void afip3__Obs::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->afip3__Obs::Msg);
#endif
}

int afip3__Obs::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__Obs(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__Obs(struct soap *soap, const char *tag, int id, const afip3__Obs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__Obs), type))
		return soap->error;
	if (soap_out_int(soap, "afip3:Code", -1, &a->afip3__Obs::Code, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:Msg", -1, &a->afip3__Obs::Msg, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__Obs::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__Obs(soap, tag, this, type);
}

SOAP_FMAC3 afip3__Obs * SOAP_FMAC4 soap_in_afip3__Obs(struct soap *soap, const char *tag, afip3__Obs *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__Obs*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__Obs, sizeof(afip3__Obs), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__Obs)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__Obs *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Code1 = 1;
	size_t soap_flag_Msg1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Code1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:Code", &a->afip3__Obs::Code, "xsd:int"))
				{	soap_flag_Code1--;
					continue;
				}
			}
			if (soap_flag_Msg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:Msg", &a->afip3__Obs::Msg, "xsd:string"))
				{	soap_flag_Msg1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Code1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__Obs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__Obs, SOAP_TYPE_afip3__Obs, sizeof(afip3__Obs), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__Obs * SOAP_FMAC2 soap_instantiate_afip3__Obs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__Obs(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__Obs *p;
	size_t k = sizeof(afip3__Obs);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__Obs, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__Obs);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__Obs, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__Obs location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__Obs::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__Obs(soap, tag ? tag : "afip3:Obs", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__Obs::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__Obs(soap, this, tag, type);
}

SOAP_FMAC3 afip3__Obs * SOAP_FMAC4 soap_get_afip3__Obs(struct soap *soap, afip3__Obs *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__Obs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__ArrayOfObs::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToafip3__Obs(soap, &this->afip3__ArrayOfObs::Obs);
}

void afip3__ArrayOfObs::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToafip3__Obs(soap, &this->afip3__ArrayOfObs::Obs);
#endif
}

int afip3__ArrayOfObs::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__ArrayOfObs(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__ArrayOfObs(struct soap *soap, const char *tag, int id, const afip3__ArrayOfObs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__ArrayOfObs), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToafip3__Obs(soap, "afip3:Obs", -1, &a->afip3__ArrayOfObs::Obs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__ArrayOfObs::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__ArrayOfObs(soap, tag, this, type);
}

SOAP_FMAC3 afip3__ArrayOfObs * SOAP_FMAC4 soap_in_afip3__ArrayOfObs(struct soap *soap, const char *tag, afip3__ArrayOfObs *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__ArrayOfObs*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__ArrayOfObs, sizeof(afip3__ArrayOfObs), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__ArrayOfObs)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__ArrayOfObs *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerToafip3__Obs(soap, "afip3:Obs", &a->afip3__ArrayOfObs::Obs, "afip3:Obs"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__ArrayOfObs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__ArrayOfObs, SOAP_TYPE_afip3__ArrayOfObs, sizeof(afip3__ArrayOfObs), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__ArrayOfObs * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfObs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__ArrayOfObs(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__ArrayOfObs *p;
	size_t k = sizeof(afip3__ArrayOfObs);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__ArrayOfObs, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__ArrayOfObs);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__ArrayOfObs, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__ArrayOfObs location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__ArrayOfObs::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__ArrayOfObs(soap, tag ? tag : "afip3:ArrayOfObs", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__ArrayOfObs::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__ArrayOfObs(soap, this, tag, type);
}

SOAP_FMAC3 afip3__ArrayOfObs * SOAP_FMAC4 soap_get_afip3__ArrayOfObs(struct soap *soap, afip3__ArrayOfObs *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__ArrayOfObs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__FEDetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->afip3__FEDetResponse::Concepto);
	soap_default_int(soap, &this->afip3__FEDetResponse::DocTipo);
	soap_default_LONG64(soap, &this->afip3__FEDetResponse::DocNro);
	soap_default_LONG64(soap, &this->afip3__FEDetResponse::CbteDesde);
	soap_default_LONG64(soap, &this->afip3__FEDetResponse::CbteHasta);
	this->afip3__FEDetResponse::CbteFch = NULL;
	this->afip3__FEDetResponse::Resultado = NULL;
	this->afip3__FEDetResponse::Observaciones = NULL;
}

void afip3__FEDetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->afip3__FEDetResponse::CbteFch);
	soap_serialize_PointerTostd__string(soap, &this->afip3__FEDetResponse::Resultado);
	soap_serialize_PointerToafip3__ArrayOfObs(soap, &this->afip3__FEDetResponse::Observaciones);
#endif
}

int afip3__FEDetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__FEDetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__FEDetResponse(struct soap *soap, const char *tag, int id, const afip3__FEDetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__FEDetResponse), type))
		return soap->error;
	if (soap_out_int(soap, "afip3:Concepto", -1, &a->afip3__FEDetResponse::Concepto, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:DocTipo", -1, &a->afip3__FEDetResponse::DocTipo, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "afip3:DocNro", -1, &a->afip3__FEDetResponse::DocNro, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "afip3:CbteDesde", -1, &a->afip3__FEDetResponse::CbteDesde, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "afip3:CbteHasta", -1, &a->afip3__FEDetResponse::CbteHasta, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:CbteFch", -1, &a->afip3__FEDetResponse::CbteFch, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:Resultado", -1, &a->afip3__FEDetResponse::Resultado, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfObs(soap, "afip3:Observaciones", -1, &a->afip3__FEDetResponse::Observaciones, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__FEDetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__FEDetResponse(soap, tag, this, type);
}

SOAP_FMAC3 afip3__FEDetResponse * SOAP_FMAC4 soap_in_afip3__FEDetResponse(struct soap *soap, const char *tag, afip3__FEDetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__FEDetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__FEDetResponse, sizeof(afip3__FEDetResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__FEDetResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__FEDetResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Concepto1 = 1;
	size_t soap_flag_DocTipo1 = 1;
	size_t soap_flag_DocNro1 = 1;
	size_t soap_flag_CbteDesde1 = 1;
	size_t soap_flag_CbteHasta1 = 1;
	size_t soap_flag_CbteFch1 = 1;
	size_t soap_flag_Resultado1 = 1;
	size_t soap_flag_Observaciones1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Concepto1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:Concepto", &a->afip3__FEDetResponse::Concepto, "xsd:int"))
				{	soap_flag_Concepto1--;
					continue;
				}
			}
			if (soap_flag_DocTipo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:DocTipo", &a->afip3__FEDetResponse::DocTipo, "xsd:int"))
				{	soap_flag_DocTipo1--;
					continue;
				}
			}
			if (soap_flag_DocNro1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "afip3:DocNro", &a->afip3__FEDetResponse::DocNro, "xsd:long"))
				{	soap_flag_DocNro1--;
					continue;
				}
			}
			if (soap_flag_CbteDesde1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "afip3:CbteDesde", &a->afip3__FEDetResponse::CbteDesde, "xsd:long"))
				{	soap_flag_CbteDesde1--;
					continue;
				}
			}
			if (soap_flag_CbteHasta1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "afip3:CbteHasta", &a->afip3__FEDetResponse::CbteHasta, "xsd:long"))
				{	soap_flag_CbteHasta1--;
					continue;
				}
			}
			if (soap_flag_CbteFch1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:CbteFch", &a->afip3__FEDetResponse::CbteFch, "xsd:string"))
				{	soap_flag_CbteFch1--;
					continue;
				}
			}
			if (soap_flag_Resultado1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:Resultado", &a->afip3__FEDetResponse::Resultado, "xsd:string"))
				{	soap_flag_Resultado1--;
					continue;
				}
			}
			if (soap_flag_Observaciones1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfObs(soap, "afip3:Observaciones", &a->afip3__FEDetResponse::Observaciones, "afip3:ArrayOfObs"))
				{	soap_flag_Observaciones1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Concepto1 > 0 || soap_flag_DocTipo1 > 0 || soap_flag_DocNro1 > 0 || soap_flag_CbteDesde1 > 0 || soap_flag_CbteHasta1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__FEDetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__FEDetResponse, SOAP_TYPE_afip3__FEDetResponse, sizeof(afip3__FEDetResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__FEDetResponse * SOAP_FMAC2 soap_instantiate_afip3__FEDetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__FEDetResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "afip3:FECAEDetResponse"))
		return soap_instantiate_afip3__FECAEDetResponse(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "afip3:FECAEADetResponse"))
		return soap_instantiate_afip3__FECAEADetResponse(soap, n, NULL, NULL, size);
	afip3__FEDetResponse *p;
	size_t k = sizeof(afip3__FEDetResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__FEDetResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__FEDetResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__FEDetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__FEDetResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__FEDetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__FEDetResponse(soap, tag ? tag : "afip3:FEDetResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__FEDetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__FEDetResponse(soap, this, tag, type);
}

SOAP_FMAC3 afip3__FEDetResponse * SOAP_FMAC4 soap_get_afip3__FEDetResponse(struct soap *soap, afip3__FEDetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__FEDetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__FECAEDetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__FEDetResponse::soap_default(soap);
	this->afip3__FECAEDetResponse::CAE = NULL;
	this->afip3__FECAEDetResponse::CAEFchVto = NULL;
}

void afip3__FECAEDetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->afip3__FECAEDetResponse::CAE);
	soap_serialize_PointerTostd__string(soap, &this->afip3__FECAEDetResponse::CAEFchVto);
	this->afip3__FEDetResponse::soap_serialize(soap);
#endif
}

int afip3__FECAEDetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__FECAEDetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__FECAEDetResponse(struct soap *soap, const char *tag, int id, const afip3__FECAEDetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__FECAEDetResponse), type ? type : "afip3:FECAEDetResponse"))
		return soap->error;
	if (soap_out_int(soap, "afip3:Concepto", -1, &a->afip3__FEDetResponse::Concepto, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:DocTipo", -1, &a->afip3__FEDetResponse::DocTipo, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "afip3:DocNro", -1, &a->afip3__FEDetResponse::DocNro, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "afip3:CbteDesde", -1, &a->afip3__FEDetResponse::CbteDesde, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "afip3:CbteHasta", -1, &a->afip3__FEDetResponse::CbteHasta, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:CbteFch", -1, &a->afip3__FEDetResponse::CbteFch, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:Resultado", -1, &a->afip3__FEDetResponse::Resultado, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfObs(soap, "afip3:Observaciones", -1, &a->afip3__FEDetResponse::Observaciones, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:CAE", -1, &a->afip3__FECAEDetResponse::CAE, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:CAEFchVto", -1, &a->afip3__FECAEDetResponse::CAEFchVto, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__FECAEDetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__FECAEDetResponse(soap, tag, this, type);
}

SOAP_FMAC3 afip3__FECAEDetResponse * SOAP_FMAC4 soap_in_afip3__FECAEDetResponse(struct soap *soap, const char *tag, afip3__FECAEDetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__FECAEDetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__FECAEDetResponse, sizeof(afip3__FECAEDetResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__FECAEDetResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__FECAEDetResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Concepto2 = 1;
	size_t soap_flag_DocTipo2 = 1;
	size_t soap_flag_DocNro2 = 1;
	size_t soap_flag_CbteDesde2 = 1;
	size_t soap_flag_CbteHasta2 = 1;
	size_t soap_flag_CbteFch2 = 1;
	size_t soap_flag_Resultado2 = 1;
	size_t soap_flag_Observaciones2 = 1;
	size_t soap_flag_CAE1 = 1;
	size_t soap_flag_CAEFchVto1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Concepto2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:Concepto", &a->afip3__FEDetResponse::Concepto, "xsd:int"))
				{	soap_flag_Concepto2--;
					continue;
				}
			}
			if (soap_flag_DocTipo2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:DocTipo", &a->afip3__FEDetResponse::DocTipo, "xsd:int"))
				{	soap_flag_DocTipo2--;
					continue;
				}
			}
			if (soap_flag_DocNro2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "afip3:DocNro", &a->afip3__FEDetResponse::DocNro, "xsd:long"))
				{	soap_flag_DocNro2--;
					continue;
				}
			}
			if (soap_flag_CbteDesde2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "afip3:CbteDesde", &a->afip3__FEDetResponse::CbteDesde, "xsd:long"))
				{	soap_flag_CbteDesde2--;
					continue;
				}
			}
			if (soap_flag_CbteHasta2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "afip3:CbteHasta", &a->afip3__FEDetResponse::CbteHasta, "xsd:long"))
				{	soap_flag_CbteHasta2--;
					continue;
				}
			}
			if (soap_flag_CbteFch2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:CbteFch", &a->afip3__FEDetResponse::CbteFch, "xsd:string"))
				{	soap_flag_CbteFch2--;
					continue;
				}
			}
			if (soap_flag_Resultado2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:Resultado", &a->afip3__FEDetResponse::Resultado, "xsd:string"))
				{	soap_flag_Resultado2--;
					continue;
				}
			}
			if (soap_flag_Observaciones2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfObs(soap, "afip3:Observaciones", &a->afip3__FEDetResponse::Observaciones, "afip3:ArrayOfObs"))
				{	soap_flag_Observaciones2--;
					continue;
				}
			}
			if (soap_flag_CAE1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:CAE", &a->afip3__FECAEDetResponse::CAE, "xsd:string"))
				{	soap_flag_CAE1--;
					continue;
				}
			}
			if (soap_flag_CAEFchVto1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:CAEFchVto", &a->afip3__FECAEDetResponse::CAEFchVto, "xsd:string"))
				{	soap_flag_CAEFchVto1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Concepto2 > 0 || soap_flag_DocTipo2 > 0 || soap_flag_DocNro2 > 0 || soap_flag_CbteDesde2 > 0 || soap_flag_CbteHasta2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__FECAEDetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__FECAEDetResponse, SOAP_TYPE_afip3__FECAEDetResponse, sizeof(afip3__FECAEDetResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__FECAEDetResponse * SOAP_FMAC2 soap_instantiate_afip3__FECAEDetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__FECAEDetResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__FECAEDetResponse *p;
	size_t k = sizeof(afip3__FECAEDetResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__FECAEDetResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__FECAEDetResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__FECAEDetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__FECAEDetResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__FECAEDetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__FECAEDetResponse(soap, tag ? tag : "afip3:FECAEDetResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__FECAEDetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__FECAEDetResponse(soap, this, tag, type);
}

SOAP_FMAC3 afip3__FECAEDetResponse * SOAP_FMAC4 soap_get_afip3__FECAEDetResponse(struct soap *soap, afip3__FECAEDetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__FECAEDetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__ArrayOfFECAEDetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToafip3__FECAEDetResponse(soap, &this->afip3__ArrayOfFECAEDetResponse::FECAEDetResponse);
}

void afip3__ArrayOfFECAEDetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToafip3__FECAEDetResponse(soap, &this->afip3__ArrayOfFECAEDetResponse::FECAEDetResponse);
#endif
}

int afip3__ArrayOfFECAEDetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__ArrayOfFECAEDetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__ArrayOfFECAEDetResponse(struct soap *soap, const char *tag, int id, const afip3__ArrayOfFECAEDetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__ArrayOfFECAEDetResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToafip3__FECAEDetResponse(soap, "afip3:FECAEDetResponse", -1, &a->afip3__ArrayOfFECAEDetResponse::FECAEDetResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__ArrayOfFECAEDetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__ArrayOfFECAEDetResponse(soap, tag, this, type);
}

SOAP_FMAC3 afip3__ArrayOfFECAEDetResponse * SOAP_FMAC4 soap_in_afip3__ArrayOfFECAEDetResponse(struct soap *soap, const char *tag, afip3__ArrayOfFECAEDetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__ArrayOfFECAEDetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__ArrayOfFECAEDetResponse, sizeof(afip3__ArrayOfFECAEDetResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__ArrayOfFECAEDetResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__ArrayOfFECAEDetResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerToafip3__FECAEDetResponse(soap, "afip3:FECAEDetResponse", &a->afip3__ArrayOfFECAEDetResponse::FECAEDetResponse, "afip3:FECAEDetResponse"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__ArrayOfFECAEDetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__ArrayOfFECAEDetResponse, SOAP_TYPE_afip3__ArrayOfFECAEDetResponse, sizeof(afip3__ArrayOfFECAEDetResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__ArrayOfFECAEDetResponse * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfFECAEDetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__ArrayOfFECAEDetResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__ArrayOfFECAEDetResponse *p;
	size_t k = sizeof(afip3__ArrayOfFECAEDetResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__ArrayOfFECAEDetResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__ArrayOfFECAEDetResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__ArrayOfFECAEDetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__ArrayOfFECAEDetResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__ArrayOfFECAEDetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__ArrayOfFECAEDetResponse(soap, tag ? tag : "afip3:ArrayOfFECAEDetResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__ArrayOfFECAEDetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__ArrayOfFECAEDetResponse(soap, this, tag, type);
}

SOAP_FMAC3 afip3__ArrayOfFECAEDetResponse * SOAP_FMAC4 soap_get_afip3__ArrayOfFECAEDetResponse(struct soap *soap, afip3__ArrayOfFECAEDetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__ArrayOfFECAEDetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__FECabResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->afip3__FECabResponse::Cuit);
	soap_default_int(soap, &this->afip3__FECabResponse::PtoVta);
	soap_default_int(soap, &this->afip3__FECabResponse::CbteTipo);
	this->afip3__FECabResponse::FchProceso = NULL;
	soap_default_int(soap, &this->afip3__FECabResponse::CantReg);
	this->afip3__FECabResponse::Resultado = NULL;
	this->afip3__FECabResponse::Reproceso = NULL;
}

void afip3__FECabResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->afip3__FECabResponse::FchProceso);
	soap_serialize_PointerTostd__string(soap, &this->afip3__FECabResponse::Resultado);
	soap_serialize_PointerTostd__string(soap, &this->afip3__FECabResponse::Reproceso);
#endif
}

int afip3__FECabResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__FECabResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__FECabResponse(struct soap *soap, const char *tag, int id, const afip3__FECabResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__FECabResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "afip3:Cuit", -1, &a->afip3__FECabResponse::Cuit, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:PtoVta", -1, &a->afip3__FECabResponse::PtoVta, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:CbteTipo", -1, &a->afip3__FECabResponse::CbteTipo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchProceso", -1, &a->afip3__FECabResponse::FchProceso, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:CantReg", -1, &a->afip3__FECabResponse::CantReg, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:Resultado", -1, &a->afip3__FECabResponse::Resultado, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:Reproceso", -1, &a->afip3__FECabResponse::Reproceso, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__FECabResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__FECabResponse(soap, tag, this, type);
}

SOAP_FMAC3 afip3__FECabResponse * SOAP_FMAC4 soap_in_afip3__FECabResponse(struct soap *soap, const char *tag, afip3__FECabResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__FECabResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__FECabResponse, sizeof(afip3__FECabResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__FECabResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__FECabResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Cuit1 = 1;
	size_t soap_flag_PtoVta1 = 1;
	size_t soap_flag_CbteTipo1 = 1;
	size_t soap_flag_FchProceso1 = 1;
	size_t soap_flag_CantReg1 = 1;
	size_t soap_flag_Resultado1 = 1;
	size_t soap_flag_Reproceso1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Cuit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "afip3:Cuit", &a->afip3__FECabResponse::Cuit, "xsd:long"))
				{	soap_flag_Cuit1--;
					continue;
				}
			}
			if (soap_flag_PtoVta1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:PtoVta", &a->afip3__FECabResponse::PtoVta, "xsd:int"))
				{	soap_flag_PtoVta1--;
					continue;
				}
			}
			if (soap_flag_CbteTipo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:CbteTipo", &a->afip3__FECabResponse::CbteTipo, "xsd:int"))
				{	soap_flag_CbteTipo1--;
					continue;
				}
			}
			if (soap_flag_FchProceso1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchProceso", &a->afip3__FECabResponse::FchProceso, "xsd:string"))
				{	soap_flag_FchProceso1--;
					continue;
				}
			}
			if (soap_flag_CantReg1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:CantReg", &a->afip3__FECabResponse::CantReg, "xsd:int"))
				{	soap_flag_CantReg1--;
					continue;
				}
			}
			if (soap_flag_Resultado1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:Resultado", &a->afip3__FECabResponse::Resultado, "xsd:string"))
				{	soap_flag_Resultado1--;
					continue;
				}
			}
			if (soap_flag_Reproceso1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:Reproceso", &a->afip3__FECabResponse::Reproceso, "xsd:string"))
				{	soap_flag_Reproceso1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Cuit1 > 0 || soap_flag_PtoVta1 > 0 || soap_flag_CbteTipo1 > 0 || soap_flag_CantReg1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__FECabResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__FECabResponse, SOAP_TYPE_afip3__FECabResponse, sizeof(afip3__FECabResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__FECabResponse * SOAP_FMAC2 soap_instantiate_afip3__FECabResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__FECabResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "afip3:FECAECabResponse"))
		return soap_instantiate_afip3__FECAECabResponse(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "afip3:FECAEACabResponse"))
		return soap_instantiate_afip3__FECAEACabResponse(soap, n, NULL, NULL, size);
	afip3__FECabResponse *p;
	size_t k = sizeof(afip3__FECabResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__FECabResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__FECabResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__FECabResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__FECabResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__FECabResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__FECabResponse(soap, tag ? tag : "afip3:FECabResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__FECabResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__FECabResponse(soap, this, tag, type);
}

SOAP_FMAC3 afip3__FECabResponse * SOAP_FMAC4 soap_get_afip3__FECabResponse(struct soap *soap, afip3__FECabResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__FECabResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__FECAECabResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__FECabResponse::soap_default(soap);
}

void afip3__FECAECabResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->afip3__FECabResponse::soap_serialize(soap);
#endif
}

int afip3__FECAECabResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__FECAECabResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__FECAECabResponse(struct soap *soap, const char *tag, int id, const afip3__FECAECabResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__FECAECabResponse), type ? type : "afip3:FECAECabResponse"))
		return soap->error;
	if (soap_out_LONG64(soap, "afip3:Cuit", -1, &a->afip3__FECabResponse::Cuit, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:PtoVta", -1, &a->afip3__FECabResponse::PtoVta, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:CbteTipo", -1, &a->afip3__FECabResponse::CbteTipo, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchProceso", -1, &a->afip3__FECabResponse::FchProceso, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:CantReg", -1, &a->afip3__FECabResponse::CantReg, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:Resultado", -1, &a->afip3__FECabResponse::Resultado, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:Reproceso", -1, &a->afip3__FECabResponse::Reproceso, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__FECAECabResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__FECAECabResponse(soap, tag, this, type);
}

SOAP_FMAC3 afip3__FECAECabResponse * SOAP_FMAC4 soap_in_afip3__FECAECabResponse(struct soap *soap, const char *tag, afip3__FECAECabResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__FECAECabResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__FECAECabResponse, sizeof(afip3__FECAECabResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__FECAECabResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__FECAECabResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Cuit2 = 1;
	size_t soap_flag_PtoVta2 = 1;
	size_t soap_flag_CbteTipo2 = 1;
	size_t soap_flag_FchProceso2 = 1;
	size_t soap_flag_CantReg2 = 1;
	size_t soap_flag_Resultado2 = 1;
	size_t soap_flag_Reproceso2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Cuit2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "afip3:Cuit", &a->afip3__FECabResponse::Cuit, "xsd:long"))
				{	soap_flag_Cuit2--;
					continue;
				}
			}
			if (soap_flag_PtoVta2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:PtoVta", &a->afip3__FECabResponse::PtoVta, "xsd:int"))
				{	soap_flag_PtoVta2--;
					continue;
				}
			}
			if (soap_flag_CbteTipo2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:CbteTipo", &a->afip3__FECabResponse::CbteTipo, "xsd:int"))
				{	soap_flag_CbteTipo2--;
					continue;
				}
			}
			if (soap_flag_FchProceso2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchProceso", &a->afip3__FECabResponse::FchProceso, "xsd:string"))
				{	soap_flag_FchProceso2--;
					continue;
				}
			}
			if (soap_flag_CantReg2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:CantReg", &a->afip3__FECabResponse::CantReg, "xsd:int"))
				{	soap_flag_CantReg2--;
					continue;
				}
			}
			if (soap_flag_Resultado2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:Resultado", &a->afip3__FECabResponse::Resultado, "xsd:string"))
				{	soap_flag_Resultado2--;
					continue;
				}
			}
			if (soap_flag_Reproceso2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:Reproceso", &a->afip3__FECabResponse::Reproceso, "xsd:string"))
				{	soap_flag_Reproceso2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Cuit2 > 0 || soap_flag_PtoVta2 > 0 || soap_flag_CbteTipo2 > 0 || soap_flag_CantReg2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__FECAECabResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__FECAECabResponse, SOAP_TYPE_afip3__FECAECabResponse, sizeof(afip3__FECAECabResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__FECAECabResponse * SOAP_FMAC2 soap_instantiate_afip3__FECAECabResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__FECAECabResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__FECAECabResponse *p;
	size_t k = sizeof(afip3__FECAECabResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__FECAECabResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__FECAECabResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__FECAECabResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__FECAECabResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__FECAECabResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__FECAECabResponse(soap, tag ? tag : "afip3:FECAECabResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__FECAECabResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__FECAECabResponse(soap, this, tag, type);
}

SOAP_FMAC3 afip3__FECAECabResponse * SOAP_FMAC4 soap_get_afip3__FECAECabResponse(struct soap *soap, afip3__FECAECabResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__FECAECabResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__FECAEResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__FECAEResponse::FeCabResp = NULL;
	this->afip3__FECAEResponse::FeDetResp = NULL;
	this->afip3__FECAEResponse::Events = NULL;
	this->afip3__FECAEResponse::Errors = NULL;
}

void afip3__FECAEResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FECAECabResponse(soap, &this->afip3__FECAEResponse::FeCabResp);
	soap_serialize_PointerToafip3__ArrayOfFECAEDetResponse(soap, &this->afip3__FECAEResponse::FeDetResp);
	soap_serialize_PointerToafip3__ArrayOfEvt(soap, &this->afip3__FECAEResponse::Events);
	soap_serialize_PointerToafip3__ArrayOfErr(soap, &this->afip3__FECAEResponse::Errors);
#endif
}

int afip3__FECAEResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__FECAEResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__FECAEResponse(struct soap *soap, const char *tag, int id, const afip3__FECAEResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__FECAEResponse), type))
		return soap->error;
	if (soap_out_PointerToafip3__FECAECabResponse(soap, "afip3:FeCabResp", -1, &a->afip3__FECAEResponse::FeCabResp, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfFECAEDetResponse(soap, "afip3:FeDetResp", -1, &a->afip3__FECAEResponse::FeDetResp, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", -1, &a->afip3__FECAEResponse::Events, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", -1, &a->afip3__FECAEResponse::Errors, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__FECAEResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__FECAEResponse(soap, tag, this, type);
}

SOAP_FMAC3 afip3__FECAEResponse * SOAP_FMAC4 soap_in_afip3__FECAEResponse(struct soap *soap, const char *tag, afip3__FECAEResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__FECAEResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__FECAEResponse, sizeof(afip3__FECAEResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__FECAEResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__FECAEResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FeCabResp1 = 1;
	size_t soap_flag_FeDetResp1 = 1;
	size_t soap_flag_Events1 = 1;
	size_t soap_flag_Errors1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FeCabResp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FECAECabResponse(soap, "afip3:FeCabResp", &a->afip3__FECAEResponse::FeCabResp, "afip3:FECAECabResponse"))
				{	soap_flag_FeCabResp1--;
					continue;
				}
			}
			if (soap_flag_FeDetResp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfFECAEDetResponse(soap, "afip3:FeDetResp", &a->afip3__FECAEResponse::FeDetResp, "afip3:ArrayOfFECAEDetResponse"))
				{	soap_flag_FeDetResp1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfEvt(soap, "afip3:Events", &a->afip3__FECAEResponse::Events, "afip3:ArrayOfEvt"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap_flag_Errors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfErr(soap, "afip3:Errors", &a->afip3__FECAEResponse::Errors, "afip3:ArrayOfErr"))
				{	soap_flag_Errors1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__FECAEResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__FECAEResponse, SOAP_TYPE_afip3__FECAEResponse, sizeof(afip3__FECAEResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__FECAEResponse * SOAP_FMAC2 soap_instantiate_afip3__FECAEResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__FECAEResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__FECAEResponse *p;
	size_t k = sizeof(afip3__FECAEResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__FECAEResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__FECAEResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__FECAEResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__FECAEResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__FECAEResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__FECAEResponse(soap, tag ? tag : "afip3:FECAEResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__FECAEResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__FECAEResponse(soap, this, tag, type);
}

SOAP_FMAC3 afip3__FECAEResponse * SOAP_FMAC4 soap_get_afip3__FECAEResponse(struct soap *soap, afip3__FECAEResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__FECAEResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__Comprador::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->afip3__Comprador::DocTipo);
	soap_default_LONG64(soap, &this->afip3__Comprador::DocNro);
	soap_default_double(soap, &this->afip3__Comprador::Porcentaje);
}

void afip3__Comprador::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int afip3__Comprador::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__Comprador(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__Comprador(struct soap *soap, const char *tag, int id, const afip3__Comprador *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__Comprador), type))
		return soap->error;
	if (soap_out_int(soap, "afip3:DocTipo", -1, &a->afip3__Comprador::DocTipo, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "afip3:DocNro", -1, &a->afip3__Comprador::DocNro, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:Porcentaje", -1, &a->afip3__Comprador::Porcentaje, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__Comprador::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__Comprador(soap, tag, this, type);
}

SOAP_FMAC3 afip3__Comprador * SOAP_FMAC4 soap_in_afip3__Comprador(struct soap *soap, const char *tag, afip3__Comprador *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__Comprador*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__Comprador, sizeof(afip3__Comprador), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__Comprador)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__Comprador *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DocTipo1 = 1;
	size_t soap_flag_DocNro1 = 1;
	size_t soap_flag_Porcentaje1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DocTipo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:DocTipo", &a->afip3__Comprador::DocTipo, "xsd:int"))
				{	soap_flag_DocTipo1--;
					continue;
				}
			}
			if (soap_flag_DocNro1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "afip3:DocNro", &a->afip3__Comprador::DocNro, "xsd:long"))
				{	soap_flag_DocNro1--;
					continue;
				}
			}
			if (soap_flag_Porcentaje1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:Porcentaje", &a->afip3__Comprador::Porcentaje, "xsd:double"))
				{	soap_flag_Porcentaje1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DocTipo1 > 0 || soap_flag_DocNro1 > 0 || soap_flag_Porcentaje1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__Comprador *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__Comprador, SOAP_TYPE_afip3__Comprador, sizeof(afip3__Comprador), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__Comprador * SOAP_FMAC2 soap_instantiate_afip3__Comprador(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__Comprador(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__Comprador *p;
	size_t k = sizeof(afip3__Comprador);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__Comprador, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__Comprador);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__Comprador, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__Comprador location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__Comprador::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__Comprador(soap, tag ? tag : "afip3:Comprador", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__Comprador::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__Comprador(soap, this, tag, type);
}

SOAP_FMAC3 afip3__Comprador * SOAP_FMAC4 soap_get_afip3__Comprador(struct soap *soap, afip3__Comprador *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__Comprador(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__ArrayOfComprador::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToafip3__Comprador(soap, &this->afip3__ArrayOfComprador::Comprador);
}

void afip3__ArrayOfComprador::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToafip3__Comprador(soap, &this->afip3__ArrayOfComprador::Comprador);
#endif
}

int afip3__ArrayOfComprador::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__ArrayOfComprador(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__ArrayOfComprador(struct soap *soap, const char *tag, int id, const afip3__ArrayOfComprador *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__ArrayOfComprador), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToafip3__Comprador(soap, "afip3:Comprador", -1, &a->afip3__ArrayOfComprador::Comprador, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__ArrayOfComprador::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__ArrayOfComprador(soap, tag, this, type);
}

SOAP_FMAC3 afip3__ArrayOfComprador * SOAP_FMAC4 soap_in_afip3__ArrayOfComprador(struct soap *soap, const char *tag, afip3__ArrayOfComprador *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__ArrayOfComprador*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__ArrayOfComprador, sizeof(afip3__ArrayOfComprador), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__ArrayOfComprador)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__ArrayOfComprador *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerToafip3__Comprador(soap, "afip3:Comprador", &a->afip3__ArrayOfComprador::Comprador, "afip3:Comprador"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__ArrayOfComprador *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__ArrayOfComprador, SOAP_TYPE_afip3__ArrayOfComprador, sizeof(afip3__ArrayOfComprador), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__ArrayOfComprador * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfComprador(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__ArrayOfComprador(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__ArrayOfComprador *p;
	size_t k = sizeof(afip3__ArrayOfComprador);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__ArrayOfComprador, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__ArrayOfComprador);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__ArrayOfComprador, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__ArrayOfComprador location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__ArrayOfComprador::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__ArrayOfComprador(soap, tag ? tag : "afip3:ArrayOfComprador", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__ArrayOfComprador::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__ArrayOfComprador(soap, this, tag, type);
}

SOAP_FMAC3 afip3__ArrayOfComprador * SOAP_FMAC4 soap_get_afip3__ArrayOfComprador(struct soap *soap, afip3__ArrayOfComprador *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__ArrayOfComprador(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__Opcional::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__Opcional::Id = NULL;
	this->afip3__Opcional::Valor = NULL;
}

void afip3__Opcional::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->afip3__Opcional::Id);
	soap_serialize_PointerTostd__string(soap, &this->afip3__Opcional::Valor);
#endif
}

int afip3__Opcional::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__Opcional(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__Opcional(struct soap *soap, const char *tag, int id, const afip3__Opcional *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__Opcional), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:Id", -1, &a->afip3__Opcional::Id, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:Valor", -1, &a->afip3__Opcional::Valor, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__Opcional::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__Opcional(soap, tag, this, type);
}

SOAP_FMAC3 afip3__Opcional * SOAP_FMAC4 soap_in_afip3__Opcional(struct soap *soap, const char *tag, afip3__Opcional *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__Opcional*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__Opcional, sizeof(afip3__Opcional), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__Opcional)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__Opcional *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_Valor1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:Id", &a->afip3__Opcional::Id, "xsd:string"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_Valor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:Valor", &a->afip3__Opcional::Valor, "xsd:string"))
				{	soap_flag_Valor1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__Opcional *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__Opcional, SOAP_TYPE_afip3__Opcional, sizeof(afip3__Opcional), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__Opcional * SOAP_FMAC2 soap_instantiate_afip3__Opcional(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__Opcional(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__Opcional *p;
	size_t k = sizeof(afip3__Opcional);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__Opcional, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__Opcional);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__Opcional, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__Opcional location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__Opcional::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__Opcional(soap, tag ? tag : "afip3:Opcional", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__Opcional::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__Opcional(soap, this, tag, type);
}

SOAP_FMAC3 afip3__Opcional * SOAP_FMAC4 soap_get_afip3__Opcional(struct soap *soap, afip3__Opcional *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__Opcional(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__ArrayOfOpcional::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToafip3__Opcional(soap, &this->afip3__ArrayOfOpcional::Opcional);
}

void afip3__ArrayOfOpcional::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToafip3__Opcional(soap, &this->afip3__ArrayOfOpcional::Opcional);
#endif
}

int afip3__ArrayOfOpcional::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__ArrayOfOpcional(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__ArrayOfOpcional(struct soap *soap, const char *tag, int id, const afip3__ArrayOfOpcional *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__ArrayOfOpcional), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToafip3__Opcional(soap, "afip3:Opcional", -1, &a->afip3__ArrayOfOpcional::Opcional, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__ArrayOfOpcional::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__ArrayOfOpcional(soap, tag, this, type);
}

SOAP_FMAC3 afip3__ArrayOfOpcional * SOAP_FMAC4 soap_in_afip3__ArrayOfOpcional(struct soap *soap, const char *tag, afip3__ArrayOfOpcional *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__ArrayOfOpcional*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__ArrayOfOpcional, sizeof(afip3__ArrayOfOpcional), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__ArrayOfOpcional)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__ArrayOfOpcional *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerToafip3__Opcional(soap, "afip3:Opcional", &a->afip3__ArrayOfOpcional::Opcional, "afip3:Opcional"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__ArrayOfOpcional *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__ArrayOfOpcional, SOAP_TYPE_afip3__ArrayOfOpcional, sizeof(afip3__ArrayOfOpcional), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__ArrayOfOpcional * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfOpcional(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__ArrayOfOpcional(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__ArrayOfOpcional *p;
	size_t k = sizeof(afip3__ArrayOfOpcional);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__ArrayOfOpcional, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__ArrayOfOpcional);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__ArrayOfOpcional, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__ArrayOfOpcional location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__ArrayOfOpcional::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__ArrayOfOpcional(soap, tag ? tag : "afip3:ArrayOfOpcional", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__ArrayOfOpcional::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__ArrayOfOpcional(soap, this, tag, type);
}

SOAP_FMAC3 afip3__ArrayOfOpcional * SOAP_FMAC4 soap_get_afip3__ArrayOfOpcional(struct soap *soap, afip3__ArrayOfOpcional *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__ArrayOfOpcional(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__AlicIva::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->afip3__AlicIva::Id);
	soap_default_double(soap, &this->afip3__AlicIva::BaseImp);
	soap_default_double(soap, &this->afip3__AlicIva::Importe);
}

void afip3__AlicIva::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int afip3__AlicIva::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__AlicIva(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__AlicIva(struct soap *soap, const char *tag, int id, const afip3__AlicIva *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__AlicIva), type))
		return soap->error;
	if (soap_out_int(soap, "afip3:Id", -1, &a->afip3__AlicIva::Id, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:BaseImp", -1, &a->afip3__AlicIva::BaseImp, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:Importe", -1, &a->afip3__AlicIva::Importe, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__AlicIva::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__AlicIva(soap, tag, this, type);
}

SOAP_FMAC3 afip3__AlicIva * SOAP_FMAC4 soap_in_afip3__AlicIva(struct soap *soap, const char *tag, afip3__AlicIva *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__AlicIva*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__AlicIva, sizeof(afip3__AlicIva), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__AlicIva)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__AlicIva *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_BaseImp1 = 1;
	size_t soap_flag_Importe1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:Id", &a->afip3__AlicIva::Id, "xsd:int"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_BaseImp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:BaseImp", &a->afip3__AlicIva::BaseImp, "xsd:double"))
				{	soap_flag_BaseImp1--;
					continue;
				}
			}
			if (soap_flag_Importe1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:Importe", &a->afip3__AlicIva::Importe, "xsd:double"))
				{	soap_flag_Importe1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0 || soap_flag_BaseImp1 > 0 || soap_flag_Importe1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__AlicIva *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__AlicIva, SOAP_TYPE_afip3__AlicIva, sizeof(afip3__AlicIva), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__AlicIva * SOAP_FMAC2 soap_instantiate_afip3__AlicIva(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__AlicIva(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__AlicIva *p;
	size_t k = sizeof(afip3__AlicIva);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__AlicIva, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__AlicIva);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__AlicIva, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__AlicIva location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__AlicIva::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__AlicIva(soap, tag ? tag : "afip3:AlicIva", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__AlicIva::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__AlicIva(soap, this, tag, type);
}

SOAP_FMAC3 afip3__AlicIva * SOAP_FMAC4 soap_get_afip3__AlicIva(struct soap *soap, afip3__AlicIva *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__AlicIva(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__ArrayOfAlicIva::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToafip3__AlicIva(soap, &this->afip3__ArrayOfAlicIva::AlicIva);
}

void afip3__ArrayOfAlicIva::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToafip3__AlicIva(soap, &this->afip3__ArrayOfAlicIva::AlicIva);
#endif
}

int afip3__ArrayOfAlicIva::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__ArrayOfAlicIva(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__ArrayOfAlicIva(struct soap *soap, const char *tag, int id, const afip3__ArrayOfAlicIva *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__ArrayOfAlicIva), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToafip3__AlicIva(soap, "afip3:AlicIva", -1, &a->afip3__ArrayOfAlicIva::AlicIva, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__ArrayOfAlicIva::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__ArrayOfAlicIva(soap, tag, this, type);
}

SOAP_FMAC3 afip3__ArrayOfAlicIva * SOAP_FMAC4 soap_in_afip3__ArrayOfAlicIva(struct soap *soap, const char *tag, afip3__ArrayOfAlicIva *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__ArrayOfAlicIva*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__ArrayOfAlicIva, sizeof(afip3__ArrayOfAlicIva), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__ArrayOfAlicIva)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__ArrayOfAlicIva *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerToafip3__AlicIva(soap, "afip3:AlicIva", &a->afip3__ArrayOfAlicIva::AlicIva, "afip3:AlicIva"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__ArrayOfAlicIva *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__ArrayOfAlicIva, SOAP_TYPE_afip3__ArrayOfAlicIva, sizeof(afip3__ArrayOfAlicIva), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__ArrayOfAlicIva * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfAlicIva(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__ArrayOfAlicIva(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__ArrayOfAlicIva *p;
	size_t k = sizeof(afip3__ArrayOfAlicIva);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__ArrayOfAlicIva, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__ArrayOfAlicIva);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__ArrayOfAlicIva, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__ArrayOfAlicIva location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__ArrayOfAlicIva::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__ArrayOfAlicIva(soap, tag ? tag : "afip3:ArrayOfAlicIva", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__ArrayOfAlicIva::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__ArrayOfAlicIva(soap, this, tag, type);
}

SOAP_FMAC3 afip3__ArrayOfAlicIva * SOAP_FMAC4 soap_get_afip3__ArrayOfAlicIva(struct soap *soap, afip3__ArrayOfAlicIva *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__ArrayOfAlicIva(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__Tributo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_short(soap, &this->afip3__Tributo::Id);
	this->afip3__Tributo::Desc = NULL;
	soap_default_double(soap, &this->afip3__Tributo::BaseImp);
	soap_default_double(soap, &this->afip3__Tributo::Alic);
	soap_default_double(soap, &this->afip3__Tributo::Importe);
}

void afip3__Tributo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->afip3__Tributo::Desc);
#endif
}

int afip3__Tributo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__Tributo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__Tributo(struct soap *soap, const char *tag, int id, const afip3__Tributo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__Tributo), type))
		return soap->error;
	if (soap_out_short(soap, "afip3:Id", -1, &a->afip3__Tributo::Id, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:Desc", -1, &a->afip3__Tributo::Desc, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:BaseImp", -1, &a->afip3__Tributo::BaseImp, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:Alic", -1, &a->afip3__Tributo::Alic, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:Importe", -1, &a->afip3__Tributo::Importe, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__Tributo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__Tributo(soap, tag, this, type);
}

SOAP_FMAC3 afip3__Tributo * SOAP_FMAC4 soap_in_afip3__Tributo(struct soap *soap, const char *tag, afip3__Tributo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__Tributo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__Tributo, sizeof(afip3__Tributo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__Tributo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__Tributo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Id1 = 1;
	size_t soap_flag_Desc1 = 1;
	size_t soap_flag_BaseImp1 = 1;
	size_t soap_flag_Alic1 = 1;
	size_t soap_flag_Importe1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Id1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_short(soap, "afip3:Id", &a->afip3__Tributo::Id, "xsd:short"))
				{	soap_flag_Id1--;
					continue;
				}
			}
			if (soap_flag_Desc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:Desc", &a->afip3__Tributo::Desc, "xsd:string"))
				{	soap_flag_Desc1--;
					continue;
				}
			}
			if (soap_flag_BaseImp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:BaseImp", &a->afip3__Tributo::BaseImp, "xsd:double"))
				{	soap_flag_BaseImp1--;
					continue;
				}
			}
			if (soap_flag_Alic1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:Alic", &a->afip3__Tributo::Alic, "xsd:double"))
				{	soap_flag_Alic1--;
					continue;
				}
			}
			if (soap_flag_Importe1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:Importe", &a->afip3__Tributo::Importe, "xsd:double"))
				{	soap_flag_Importe1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Id1 > 0 || soap_flag_BaseImp1 > 0 || soap_flag_Alic1 > 0 || soap_flag_Importe1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__Tributo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__Tributo, SOAP_TYPE_afip3__Tributo, sizeof(afip3__Tributo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__Tributo * SOAP_FMAC2 soap_instantiate_afip3__Tributo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__Tributo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__Tributo *p;
	size_t k = sizeof(afip3__Tributo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__Tributo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__Tributo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__Tributo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__Tributo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__Tributo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__Tributo(soap, tag ? tag : "afip3:Tributo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__Tributo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__Tributo(soap, this, tag, type);
}

SOAP_FMAC3 afip3__Tributo * SOAP_FMAC4 soap_get_afip3__Tributo(struct soap *soap, afip3__Tributo *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__Tributo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__ArrayOfTributo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToafip3__Tributo(soap, &this->afip3__ArrayOfTributo::Tributo);
}

void afip3__ArrayOfTributo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToafip3__Tributo(soap, &this->afip3__ArrayOfTributo::Tributo);
#endif
}

int afip3__ArrayOfTributo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__ArrayOfTributo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__ArrayOfTributo(struct soap *soap, const char *tag, int id, const afip3__ArrayOfTributo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__ArrayOfTributo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToafip3__Tributo(soap, "afip3:Tributo", -1, &a->afip3__ArrayOfTributo::Tributo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__ArrayOfTributo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__ArrayOfTributo(soap, tag, this, type);
}

SOAP_FMAC3 afip3__ArrayOfTributo * SOAP_FMAC4 soap_in_afip3__ArrayOfTributo(struct soap *soap, const char *tag, afip3__ArrayOfTributo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__ArrayOfTributo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__ArrayOfTributo, sizeof(afip3__ArrayOfTributo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__ArrayOfTributo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__ArrayOfTributo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerToafip3__Tributo(soap, "afip3:Tributo", &a->afip3__ArrayOfTributo::Tributo, "afip3:Tributo"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__ArrayOfTributo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__ArrayOfTributo, SOAP_TYPE_afip3__ArrayOfTributo, sizeof(afip3__ArrayOfTributo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__ArrayOfTributo * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfTributo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__ArrayOfTributo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__ArrayOfTributo *p;
	size_t k = sizeof(afip3__ArrayOfTributo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__ArrayOfTributo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__ArrayOfTributo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__ArrayOfTributo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__ArrayOfTributo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__ArrayOfTributo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__ArrayOfTributo(soap, tag ? tag : "afip3:ArrayOfTributo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__ArrayOfTributo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__ArrayOfTributo(soap, this, tag, type);
}

SOAP_FMAC3 afip3__ArrayOfTributo * SOAP_FMAC4 soap_get_afip3__ArrayOfTributo(struct soap *soap, afip3__ArrayOfTributo *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__ArrayOfTributo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__CbteAsoc::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->afip3__CbteAsoc::Tipo);
	soap_default_int(soap, &this->afip3__CbteAsoc::PtoVta);
	soap_default_LONG64(soap, &this->afip3__CbteAsoc::Nro);
	this->afip3__CbteAsoc::Cuit = NULL;
	this->afip3__CbteAsoc::CbteFch = NULL;
}

void afip3__CbteAsoc::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->afip3__CbteAsoc::Cuit);
	soap_serialize_PointerTostd__string(soap, &this->afip3__CbteAsoc::CbteFch);
#endif
}

int afip3__CbteAsoc::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__CbteAsoc(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__CbteAsoc(struct soap *soap, const char *tag, int id, const afip3__CbteAsoc *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__CbteAsoc), type))
		return soap->error;
	if (soap_out_int(soap, "afip3:Tipo", -1, &a->afip3__CbteAsoc::Tipo, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:PtoVta", -1, &a->afip3__CbteAsoc::PtoVta, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "afip3:Nro", -1, &a->afip3__CbteAsoc::Nro, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:Cuit", -1, &a->afip3__CbteAsoc::Cuit, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:CbteFch", -1, &a->afip3__CbteAsoc::CbteFch, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__CbteAsoc::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__CbteAsoc(soap, tag, this, type);
}

SOAP_FMAC3 afip3__CbteAsoc * SOAP_FMAC4 soap_in_afip3__CbteAsoc(struct soap *soap, const char *tag, afip3__CbteAsoc *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__CbteAsoc*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__CbteAsoc, sizeof(afip3__CbteAsoc), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__CbteAsoc)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__CbteAsoc *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Tipo1 = 1;
	size_t soap_flag_PtoVta1 = 1;
	size_t soap_flag_Nro1 = 1;
	size_t soap_flag_Cuit1 = 1;
	size_t soap_flag_CbteFch1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Tipo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:Tipo", &a->afip3__CbteAsoc::Tipo, "xsd:int"))
				{	soap_flag_Tipo1--;
					continue;
				}
			}
			if (soap_flag_PtoVta1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:PtoVta", &a->afip3__CbteAsoc::PtoVta, "xsd:int"))
				{	soap_flag_PtoVta1--;
					continue;
				}
			}
			if (soap_flag_Nro1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "afip3:Nro", &a->afip3__CbteAsoc::Nro, "xsd:long"))
				{	soap_flag_Nro1--;
					continue;
				}
			}
			if (soap_flag_Cuit1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:Cuit", &a->afip3__CbteAsoc::Cuit, "xsd:string"))
				{	soap_flag_Cuit1--;
					continue;
				}
			}
			if (soap_flag_CbteFch1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:CbteFch", &a->afip3__CbteAsoc::CbteFch, "xsd:string"))
				{	soap_flag_CbteFch1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Tipo1 > 0 || soap_flag_PtoVta1 > 0 || soap_flag_Nro1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__CbteAsoc *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__CbteAsoc, SOAP_TYPE_afip3__CbteAsoc, sizeof(afip3__CbteAsoc), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__CbteAsoc * SOAP_FMAC2 soap_instantiate_afip3__CbteAsoc(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__CbteAsoc(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__CbteAsoc *p;
	size_t k = sizeof(afip3__CbteAsoc);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__CbteAsoc, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__CbteAsoc);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__CbteAsoc, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__CbteAsoc location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__CbteAsoc::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__CbteAsoc(soap, tag ? tag : "afip3:CbteAsoc", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__CbteAsoc::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__CbteAsoc(soap, this, tag, type);
}

SOAP_FMAC3 afip3__CbteAsoc * SOAP_FMAC4 soap_get_afip3__CbteAsoc(struct soap *soap, afip3__CbteAsoc *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__CbteAsoc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__ArrayOfCbteAsoc::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToafip3__CbteAsoc(soap, &this->afip3__ArrayOfCbteAsoc::CbteAsoc);
}

void afip3__ArrayOfCbteAsoc::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToafip3__CbteAsoc(soap, &this->afip3__ArrayOfCbteAsoc::CbteAsoc);
#endif
}

int afip3__ArrayOfCbteAsoc::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__ArrayOfCbteAsoc(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__ArrayOfCbteAsoc(struct soap *soap, const char *tag, int id, const afip3__ArrayOfCbteAsoc *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__ArrayOfCbteAsoc), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToafip3__CbteAsoc(soap, "afip3:CbteAsoc", -1, &a->afip3__ArrayOfCbteAsoc::CbteAsoc, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__ArrayOfCbteAsoc::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__ArrayOfCbteAsoc(soap, tag, this, type);
}

SOAP_FMAC3 afip3__ArrayOfCbteAsoc * SOAP_FMAC4 soap_in_afip3__ArrayOfCbteAsoc(struct soap *soap, const char *tag, afip3__ArrayOfCbteAsoc *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__ArrayOfCbteAsoc*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__ArrayOfCbteAsoc, sizeof(afip3__ArrayOfCbteAsoc), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__ArrayOfCbteAsoc)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__ArrayOfCbteAsoc *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerToafip3__CbteAsoc(soap, "afip3:CbteAsoc", &a->afip3__ArrayOfCbteAsoc::CbteAsoc, "afip3:CbteAsoc"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__ArrayOfCbteAsoc *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__ArrayOfCbteAsoc, SOAP_TYPE_afip3__ArrayOfCbteAsoc, sizeof(afip3__ArrayOfCbteAsoc), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__ArrayOfCbteAsoc * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfCbteAsoc(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__ArrayOfCbteAsoc(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__ArrayOfCbteAsoc *p;
	size_t k = sizeof(afip3__ArrayOfCbteAsoc);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__ArrayOfCbteAsoc, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__ArrayOfCbteAsoc);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__ArrayOfCbteAsoc, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__ArrayOfCbteAsoc location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__ArrayOfCbteAsoc::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__ArrayOfCbteAsoc(soap, tag ? tag : "afip3:ArrayOfCbteAsoc", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__ArrayOfCbteAsoc::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__ArrayOfCbteAsoc(soap, this, tag, type);
}

SOAP_FMAC3 afip3__ArrayOfCbteAsoc * SOAP_FMAC4 soap_get_afip3__ArrayOfCbteAsoc(struct soap *soap, afip3__ArrayOfCbteAsoc *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__ArrayOfCbteAsoc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__FEDetRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->afip3__FEDetRequest::Concepto);
	soap_default_int(soap, &this->afip3__FEDetRequest::DocTipo);
	soap_default_LONG64(soap, &this->afip3__FEDetRequest::DocNro);
	soap_default_LONG64(soap, &this->afip3__FEDetRequest::CbteDesde);
	soap_default_LONG64(soap, &this->afip3__FEDetRequest::CbteHasta);
	this->afip3__FEDetRequest::CbteFch = NULL;
	soap_default_double(soap, &this->afip3__FEDetRequest::ImpTotal);
	soap_default_double(soap, &this->afip3__FEDetRequest::ImpTotConc);
	soap_default_double(soap, &this->afip3__FEDetRequest::ImpNeto);
	soap_default_double(soap, &this->afip3__FEDetRequest::ImpOpEx);
	soap_default_double(soap, &this->afip3__FEDetRequest::ImpTrib);
	soap_default_double(soap, &this->afip3__FEDetRequest::ImpIVA);
	this->afip3__FEDetRequest::FchServDesde = NULL;
	this->afip3__FEDetRequest::FchServHasta = NULL;
	this->afip3__FEDetRequest::FchVtoPago = NULL;
	this->afip3__FEDetRequest::MonId = NULL;
	soap_default_double(soap, &this->afip3__FEDetRequest::MonCotiz);
	this->afip3__FEDetRequest::CbtesAsoc = NULL;
	this->afip3__FEDetRequest::Tributos = NULL;
	this->afip3__FEDetRequest::Iva = NULL;
	this->afip3__FEDetRequest::Opcionales = NULL;
	this->afip3__FEDetRequest::Compradores = NULL;
}

void afip3__FEDetRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->afip3__FEDetRequest::CbteFch);
	soap_serialize_PointerTostd__string(soap, &this->afip3__FEDetRequest::FchServDesde);
	soap_serialize_PointerTostd__string(soap, &this->afip3__FEDetRequest::FchServHasta);
	soap_serialize_PointerTostd__string(soap, &this->afip3__FEDetRequest::FchVtoPago);
	soap_serialize_PointerTostd__string(soap, &this->afip3__FEDetRequest::MonId);
	soap_serialize_PointerToafip3__ArrayOfCbteAsoc(soap, &this->afip3__FEDetRequest::CbtesAsoc);
	soap_serialize_PointerToafip3__ArrayOfTributo(soap, &this->afip3__FEDetRequest::Tributos);
	soap_serialize_PointerToafip3__ArrayOfAlicIva(soap, &this->afip3__FEDetRequest::Iva);
	soap_serialize_PointerToafip3__ArrayOfOpcional(soap, &this->afip3__FEDetRequest::Opcionales);
	soap_serialize_PointerToafip3__ArrayOfComprador(soap, &this->afip3__FEDetRequest::Compradores);
#endif
}

int afip3__FEDetRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__FEDetRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__FEDetRequest(struct soap *soap, const char *tag, int id, const afip3__FEDetRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__FEDetRequest), type))
		return soap->error;
	if (soap_out_int(soap, "afip3:Concepto", -1, &a->afip3__FEDetRequest::Concepto, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:DocTipo", -1, &a->afip3__FEDetRequest::DocTipo, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "afip3:DocNro", -1, &a->afip3__FEDetRequest::DocNro, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "afip3:CbteDesde", -1, &a->afip3__FEDetRequest::CbteDesde, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "afip3:CbteHasta", -1, &a->afip3__FEDetRequest::CbteHasta, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:CbteFch", -1, &a->afip3__FEDetRequest::CbteFch, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:ImpTotal", -1, &a->afip3__FEDetRequest::ImpTotal, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:ImpTotConc", -1, &a->afip3__FEDetRequest::ImpTotConc, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:ImpNeto", -1, &a->afip3__FEDetRequest::ImpNeto, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:ImpOpEx", -1, &a->afip3__FEDetRequest::ImpOpEx, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:ImpTrib", -1, &a->afip3__FEDetRequest::ImpTrib, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:ImpIVA", -1, &a->afip3__FEDetRequest::ImpIVA, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchServDesde", -1, &a->afip3__FEDetRequest::FchServDesde, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchServHasta", -1, &a->afip3__FEDetRequest::FchServHasta, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchVtoPago", -1, &a->afip3__FEDetRequest::FchVtoPago, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:MonId", -1, &a->afip3__FEDetRequest::MonId, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:MonCotiz", -1, &a->afip3__FEDetRequest::MonCotiz, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfCbteAsoc(soap, "afip3:CbtesAsoc", -1, &a->afip3__FEDetRequest::CbtesAsoc, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfTributo(soap, "afip3:Tributos", -1, &a->afip3__FEDetRequest::Tributos, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfAlicIva(soap, "afip3:Iva", -1, &a->afip3__FEDetRequest::Iva, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfOpcional(soap, "afip3:Opcionales", -1, &a->afip3__FEDetRequest::Opcionales, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfComprador(soap, "afip3:Compradores", -1, &a->afip3__FEDetRequest::Compradores, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__FEDetRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__FEDetRequest(soap, tag, this, type);
}

SOAP_FMAC3 afip3__FEDetRequest * SOAP_FMAC4 soap_in_afip3__FEDetRequest(struct soap *soap, const char *tag, afip3__FEDetRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__FEDetRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__FEDetRequest, sizeof(afip3__FEDetRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__FEDetRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__FEDetRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Concepto1 = 1;
	size_t soap_flag_DocTipo1 = 1;
	size_t soap_flag_DocNro1 = 1;
	size_t soap_flag_CbteDesde1 = 1;
	size_t soap_flag_CbteHasta1 = 1;
	size_t soap_flag_CbteFch1 = 1;
	size_t soap_flag_ImpTotal1 = 1;
	size_t soap_flag_ImpTotConc1 = 1;
	size_t soap_flag_ImpNeto1 = 1;
	size_t soap_flag_ImpOpEx1 = 1;
	size_t soap_flag_ImpTrib1 = 1;
	size_t soap_flag_ImpIVA1 = 1;
	size_t soap_flag_FchServDesde1 = 1;
	size_t soap_flag_FchServHasta1 = 1;
	size_t soap_flag_FchVtoPago1 = 1;
	size_t soap_flag_MonId1 = 1;
	size_t soap_flag_MonCotiz1 = 1;
	size_t soap_flag_CbtesAsoc1 = 1;
	size_t soap_flag_Tributos1 = 1;
	size_t soap_flag_Iva1 = 1;
	size_t soap_flag_Opcionales1 = 1;
	size_t soap_flag_Compradores1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Concepto1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:Concepto", &a->afip3__FEDetRequest::Concepto, "xsd:int"))
				{	soap_flag_Concepto1--;
					continue;
				}
			}
			if (soap_flag_DocTipo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:DocTipo", &a->afip3__FEDetRequest::DocTipo, "xsd:int"))
				{	soap_flag_DocTipo1--;
					continue;
				}
			}
			if (soap_flag_DocNro1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "afip3:DocNro", &a->afip3__FEDetRequest::DocNro, "xsd:long"))
				{	soap_flag_DocNro1--;
					continue;
				}
			}
			if (soap_flag_CbteDesde1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "afip3:CbteDesde", &a->afip3__FEDetRequest::CbteDesde, "xsd:long"))
				{	soap_flag_CbteDesde1--;
					continue;
				}
			}
			if (soap_flag_CbteHasta1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "afip3:CbteHasta", &a->afip3__FEDetRequest::CbteHasta, "xsd:long"))
				{	soap_flag_CbteHasta1--;
					continue;
				}
			}
			if (soap_flag_CbteFch1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:CbteFch", &a->afip3__FEDetRequest::CbteFch, "xsd:string"))
				{	soap_flag_CbteFch1--;
					continue;
				}
			}
			if (soap_flag_ImpTotal1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:ImpTotal", &a->afip3__FEDetRequest::ImpTotal, "xsd:double"))
				{	soap_flag_ImpTotal1--;
					continue;
				}
			}
			if (soap_flag_ImpTotConc1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:ImpTotConc", &a->afip3__FEDetRequest::ImpTotConc, "xsd:double"))
				{	soap_flag_ImpTotConc1--;
					continue;
				}
			}
			if (soap_flag_ImpNeto1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:ImpNeto", &a->afip3__FEDetRequest::ImpNeto, "xsd:double"))
				{	soap_flag_ImpNeto1--;
					continue;
				}
			}
			if (soap_flag_ImpOpEx1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:ImpOpEx", &a->afip3__FEDetRequest::ImpOpEx, "xsd:double"))
				{	soap_flag_ImpOpEx1--;
					continue;
				}
			}
			if (soap_flag_ImpTrib1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:ImpTrib", &a->afip3__FEDetRequest::ImpTrib, "xsd:double"))
				{	soap_flag_ImpTrib1--;
					continue;
				}
			}
			if (soap_flag_ImpIVA1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:ImpIVA", &a->afip3__FEDetRequest::ImpIVA, "xsd:double"))
				{	soap_flag_ImpIVA1--;
					continue;
				}
			}
			if (soap_flag_FchServDesde1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchServDesde", &a->afip3__FEDetRequest::FchServDesde, "xsd:string"))
				{	soap_flag_FchServDesde1--;
					continue;
				}
			}
			if (soap_flag_FchServHasta1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchServHasta", &a->afip3__FEDetRequest::FchServHasta, "xsd:string"))
				{	soap_flag_FchServHasta1--;
					continue;
				}
			}
			if (soap_flag_FchVtoPago1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchVtoPago", &a->afip3__FEDetRequest::FchVtoPago, "xsd:string"))
				{	soap_flag_FchVtoPago1--;
					continue;
				}
			}
			if (soap_flag_MonId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:MonId", &a->afip3__FEDetRequest::MonId, "xsd:string"))
				{	soap_flag_MonId1--;
					continue;
				}
			}
			if (soap_flag_MonCotiz1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:MonCotiz", &a->afip3__FEDetRequest::MonCotiz, "xsd:double"))
				{	soap_flag_MonCotiz1--;
					continue;
				}
			}
			if (soap_flag_CbtesAsoc1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfCbteAsoc(soap, "afip3:CbtesAsoc", &a->afip3__FEDetRequest::CbtesAsoc, "afip3:ArrayOfCbteAsoc"))
				{	soap_flag_CbtesAsoc1--;
					continue;
				}
			}
			if (soap_flag_Tributos1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfTributo(soap, "afip3:Tributos", &a->afip3__FEDetRequest::Tributos, "afip3:ArrayOfTributo"))
				{	soap_flag_Tributos1--;
					continue;
				}
			}
			if (soap_flag_Iva1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfAlicIva(soap, "afip3:Iva", &a->afip3__FEDetRequest::Iva, "afip3:ArrayOfAlicIva"))
				{	soap_flag_Iva1--;
					continue;
				}
			}
			if (soap_flag_Opcionales1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfOpcional(soap, "afip3:Opcionales", &a->afip3__FEDetRequest::Opcionales, "afip3:ArrayOfOpcional"))
				{	soap_flag_Opcionales1--;
					continue;
				}
			}
			if (soap_flag_Compradores1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfComprador(soap, "afip3:Compradores", &a->afip3__FEDetRequest::Compradores, "afip3:ArrayOfComprador"))
				{	soap_flag_Compradores1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Concepto1 > 0 || soap_flag_DocTipo1 > 0 || soap_flag_DocNro1 > 0 || soap_flag_CbteDesde1 > 0 || soap_flag_CbteHasta1 > 0 || soap_flag_ImpTotal1 > 0 || soap_flag_ImpTotConc1 > 0 || soap_flag_ImpNeto1 > 0 || soap_flag_ImpOpEx1 > 0 || soap_flag_ImpTrib1 > 0 || soap_flag_ImpIVA1 > 0 || soap_flag_MonCotiz1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__FEDetRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__FEDetRequest, SOAP_TYPE_afip3__FEDetRequest, sizeof(afip3__FEDetRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__FEDetRequest * SOAP_FMAC2 soap_instantiate_afip3__FEDetRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__FEDetRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "afip3:FECAEDetRequest"))
		return soap_instantiate_afip3__FECAEDetRequest(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "afip3:FECAEADetRequest"))
		return soap_instantiate_afip3__FECAEADetRequest(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "afip3:FECompConsResponse"))
		return soap_instantiate_afip3__FECompConsResponse(soap, n, NULL, NULL, size);
	afip3__FEDetRequest *p;
	size_t k = sizeof(afip3__FEDetRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__FEDetRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__FEDetRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__FEDetRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__FEDetRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__FEDetRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__FEDetRequest(soap, tag ? tag : "afip3:FEDetRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__FEDetRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__FEDetRequest(soap, this, tag, type);
}

SOAP_FMAC3 afip3__FEDetRequest * SOAP_FMAC4 soap_get_afip3__FEDetRequest(struct soap *soap, afip3__FEDetRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__FEDetRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__FECAEDetRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__FEDetRequest::soap_default(soap);
}

void afip3__FECAEDetRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->afip3__FEDetRequest::soap_serialize(soap);
#endif
}

int afip3__FECAEDetRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__FECAEDetRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__FECAEDetRequest(struct soap *soap, const char *tag, int id, const afip3__FECAEDetRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__FECAEDetRequest), type ? type : "afip3:FECAEDetRequest"))
		return soap->error;
	if (soap_out_int(soap, "afip3:Concepto", -1, &a->afip3__FEDetRequest::Concepto, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:DocTipo", -1, &a->afip3__FEDetRequest::DocTipo, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "afip3:DocNro", -1, &a->afip3__FEDetRequest::DocNro, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "afip3:CbteDesde", -1, &a->afip3__FEDetRequest::CbteDesde, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "afip3:CbteHasta", -1, &a->afip3__FEDetRequest::CbteHasta, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:CbteFch", -1, &a->afip3__FEDetRequest::CbteFch, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:ImpTotal", -1, &a->afip3__FEDetRequest::ImpTotal, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:ImpTotConc", -1, &a->afip3__FEDetRequest::ImpTotConc, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:ImpNeto", -1, &a->afip3__FEDetRequest::ImpNeto, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:ImpOpEx", -1, &a->afip3__FEDetRequest::ImpOpEx, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:ImpTrib", -1, &a->afip3__FEDetRequest::ImpTrib, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:ImpIVA", -1, &a->afip3__FEDetRequest::ImpIVA, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchServDesde", -1, &a->afip3__FEDetRequest::FchServDesde, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchServHasta", -1, &a->afip3__FEDetRequest::FchServHasta, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:FchVtoPago", -1, &a->afip3__FEDetRequest::FchVtoPago, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:MonId", -1, &a->afip3__FEDetRequest::MonId, ""))
		return soap->error;
	if (soap_out_double(soap, "afip3:MonCotiz", -1, &a->afip3__FEDetRequest::MonCotiz, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfCbteAsoc(soap, "afip3:CbtesAsoc", -1, &a->afip3__FEDetRequest::CbtesAsoc, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfTributo(soap, "afip3:Tributos", -1, &a->afip3__FEDetRequest::Tributos, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfAlicIva(soap, "afip3:Iva", -1, &a->afip3__FEDetRequest::Iva, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfOpcional(soap, "afip3:Opcionales", -1, &a->afip3__FEDetRequest::Opcionales, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfComprador(soap, "afip3:Compradores", -1, &a->afip3__FEDetRequest::Compradores, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__FECAEDetRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__FECAEDetRequest(soap, tag, this, type);
}

SOAP_FMAC3 afip3__FECAEDetRequest * SOAP_FMAC4 soap_in_afip3__FECAEDetRequest(struct soap *soap, const char *tag, afip3__FECAEDetRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__FECAEDetRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__FECAEDetRequest, sizeof(afip3__FECAEDetRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__FECAEDetRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__FECAEDetRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Concepto2 = 1;
	size_t soap_flag_DocTipo2 = 1;
	size_t soap_flag_DocNro2 = 1;
	size_t soap_flag_CbteDesde2 = 1;
	size_t soap_flag_CbteHasta2 = 1;
	size_t soap_flag_CbteFch2 = 1;
	size_t soap_flag_ImpTotal2 = 1;
	size_t soap_flag_ImpTotConc2 = 1;
	size_t soap_flag_ImpNeto2 = 1;
	size_t soap_flag_ImpOpEx2 = 1;
	size_t soap_flag_ImpTrib2 = 1;
	size_t soap_flag_ImpIVA2 = 1;
	size_t soap_flag_FchServDesde2 = 1;
	size_t soap_flag_FchServHasta2 = 1;
	size_t soap_flag_FchVtoPago2 = 1;
	size_t soap_flag_MonId2 = 1;
	size_t soap_flag_MonCotiz2 = 1;
	size_t soap_flag_CbtesAsoc2 = 1;
	size_t soap_flag_Tributos2 = 1;
	size_t soap_flag_Iva2 = 1;
	size_t soap_flag_Opcionales2 = 1;
	size_t soap_flag_Compradores2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Concepto2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:Concepto", &a->afip3__FEDetRequest::Concepto, "xsd:int"))
				{	soap_flag_Concepto2--;
					continue;
				}
			}
			if (soap_flag_DocTipo2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:DocTipo", &a->afip3__FEDetRequest::DocTipo, "xsd:int"))
				{	soap_flag_DocTipo2--;
					continue;
				}
			}
			if (soap_flag_DocNro2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "afip3:DocNro", &a->afip3__FEDetRequest::DocNro, "xsd:long"))
				{	soap_flag_DocNro2--;
					continue;
				}
			}
			if (soap_flag_CbteDesde2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "afip3:CbteDesde", &a->afip3__FEDetRequest::CbteDesde, "xsd:long"))
				{	soap_flag_CbteDesde2--;
					continue;
				}
			}
			if (soap_flag_CbteHasta2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "afip3:CbteHasta", &a->afip3__FEDetRequest::CbteHasta, "xsd:long"))
				{	soap_flag_CbteHasta2--;
					continue;
				}
			}
			if (soap_flag_CbteFch2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:CbteFch", &a->afip3__FEDetRequest::CbteFch, "xsd:string"))
				{	soap_flag_CbteFch2--;
					continue;
				}
			}
			if (soap_flag_ImpTotal2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:ImpTotal", &a->afip3__FEDetRequest::ImpTotal, "xsd:double"))
				{	soap_flag_ImpTotal2--;
					continue;
				}
			}
			if (soap_flag_ImpTotConc2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:ImpTotConc", &a->afip3__FEDetRequest::ImpTotConc, "xsd:double"))
				{	soap_flag_ImpTotConc2--;
					continue;
				}
			}
			if (soap_flag_ImpNeto2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:ImpNeto", &a->afip3__FEDetRequest::ImpNeto, "xsd:double"))
				{	soap_flag_ImpNeto2--;
					continue;
				}
			}
			if (soap_flag_ImpOpEx2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:ImpOpEx", &a->afip3__FEDetRequest::ImpOpEx, "xsd:double"))
				{	soap_flag_ImpOpEx2--;
					continue;
				}
			}
			if (soap_flag_ImpTrib2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:ImpTrib", &a->afip3__FEDetRequest::ImpTrib, "xsd:double"))
				{	soap_flag_ImpTrib2--;
					continue;
				}
			}
			if (soap_flag_ImpIVA2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:ImpIVA", &a->afip3__FEDetRequest::ImpIVA, "xsd:double"))
				{	soap_flag_ImpIVA2--;
					continue;
				}
			}
			if (soap_flag_FchServDesde2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchServDesde", &a->afip3__FEDetRequest::FchServDesde, "xsd:string"))
				{	soap_flag_FchServDesde2--;
					continue;
				}
			}
			if (soap_flag_FchServHasta2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchServHasta", &a->afip3__FEDetRequest::FchServHasta, "xsd:string"))
				{	soap_flag_FchServHasta2--;
					continue;
				}
			}
			if (soap_flag_FchVtoPago2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:FchVtoPago", &a->afip3__FEDetRequest::FchVtoPago, "xsd:string"))
				{	soap_flag_FchVtoPago2--;
					continue;
				}
			}
			if (soap_flag_MonId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:MonId", &a->afip3__FEDetRequest::MonId, "xsd:string"))
				{	soap_flag_MonId2--;
					continue;
				}
			}
			if (soap_flag_MonCotiz2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "afip3:MonCotiz", &a->afip3__FEDetRequest::MonCotiz, "xsd:double"))
				{	soap_flag_MonCotiz2--;
					continue;
				}
			}
			if (soap_flag_CbtesAsoc2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfCbteAsoc(soap, "afip3:CbtesAsoc", &a->afip3__FEDetRequest::CbtesAsoc, "afip3:ArrayOfCbteAsoc"))
				{	soap_flag_CbtesAsoc2--;
					continue;
				}
			}
			if (soap_flag_Tributos2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfTributo(soap, "afip3:Tributos", &a->afip3__FEDetRequest::Tributos, "afip3:ArrayOfTributo"))
				{	soap_flag_Tributos2--;
					continue;
				}
			}
			if (soap_flag_Iva2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfAlicIva(soap, "afip3:Iva", &a->afip3__FEDetRequest::Iva, "afip3:ArrayOfAlicIva"))
				{	soap_flag_Iva2--;
					continue;
				}
			}
			if (soap_flag_Opcionales2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfOpcional(soap, "afip3:Opcionales", &a->afip3__FEDetRequest::Opcionales, "afip3:ArrayOfOpcional"))
				{	soap_flag_Opcionales2--;
					continue;
				}
			}
			if (soap_flag_Compradores2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfComprador(soap, "afip3:Compradores", &a->afip3__FEDetRequest::Compradores, "afip3:ArrayOfComprador"))
				{	soap_flag_Compradores2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Concepto2 > 0 || soap_flag_DocTipo2 > 0 || soap_flag_DocNro2 > 0 || soap_flag_CbteDesde2 > 0 || soap_flag_CbteHasta2 > 0 || soap_flag_ImpTotal2 > 0 || soap_flag_ImpTotConc2 > 0 || soap_flag_ImpNeto2 > 0 || soap_flag_ImpOpEx2 > 0 || soap_flag_ImpTrib2 > 0 || soap_flag_ImpIVA2 > 0 || soap_flag_MonCotiz2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__FECAEDetRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__FECAEDetRequest, SOAP_TYPE_afip3__FECAEDetRequest, sizeof(afip3__FECAEDetRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__FECAEDetRequest * SOAP_FMAC2 soap_instantiate_afip3__FECAEDetRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__FECAEDetRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "afip3:FECompConsResponse"))
		return soap_instantiate_afip3__FECompConsResponse(soap, n, NULL, NULL, size);
	afip3__FECAEDetRequest *p;
	size_t k = sizeof(afip3__FECAEDetRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__FECAEDetRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__FECAEDetRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__FECAEDetRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__FECAEDetRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__FECAEDetRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__FECAEDetRequest(soap, tag ? tag : "afip3:FECAEDetRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__FECAEDetRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__FECAEDetRequest(soap, this, tag, type);
}

SOAP_FMAC3 afip3__FECAEDetRequest * SOAP_FMAC4 soap_get_afip3__FECAEDetRequest(struct soap *soap, afip3__FECAEDetRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__FECAEDetRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__ArrayOfFECAEDetRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToafip3__FECAEDetRequest(soap, &this->afip3__ArrayOfFECAEDetRequest::FECAEDetRequest);
}

void afip3__ArrayOfFECAEDetRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerToafip3__FECAEDetRequest(soap, &this->afip3__ArrayOfFECAEDetRequest::FECAEDetRequest);
#endif
}

int afip3__ArrayOfFECAEDetRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__ArrayOfFECAEDetRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__ArrayOfFECAEDetRequest(struct soap *soap, const char *tag, int id, const afip3__ArrayOfFECAEDetRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__ArrayOfFECAEDetRequest), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToafip3__FECAEDetRequest(soap, "afip3:FECAEDetRequest", -1, &a->afip3__ArrayOfFECAEDetRequest::FECAEDetRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__ArrayOfFECAEDetRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__ArrayOfFECAEDetRequest(soap, tag, this, type);
}

SOAP_FMAC3 afip3__ArrayOfFECAEDetRequest * SOAP_FMAC4 soap_in_afip3__ArrayOfFECAEDetRequest(struct soap *soap, const char *tag, afip3__ArrayOfFECAEDetRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__ArrayOfFECAEDetRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__ArrayOfFECAEDetRequest, sizeof(afip3__ArrayOfFECAEDetRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__ArrayOfFECAEDetRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__ArrayOfFECAEDetRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerToafip3__FECAEDetRequest(soap, "afip3:FECAEDetRequest", &a->afip3__ArrayOfFECAEDetRequest::FECAEDetRequest, "afip3:FECAEDetRequest"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__ArrayOfFECAEDetRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__ArrayOfFECAEDetRequest, SOAP_TYPE_afip3__ArrayOfFECAEDetRequest, sizeof(afip3__ArrayOfFECAEDetRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__ArrayOfFECAEDetRequest * SOAP_FMAC2 soap_instantiate_afip3__ArrayOfFECAEDetRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__ArrayOfFECAEDetRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__ArrayOfFECAEDetRequest *p;
	size_t k = sizeof(afip3__ArrayOfFECAEDetRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__ArrayOfFECAEDetRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__ArrayOfFECAEDetRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__ArrayOfFECAEDetRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__ArrayOfFECAEDetRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__ArrayOfFECAEDetRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__ArrayOfFECAEDetRequest(soap, tag ? tag : "afip3:ArrayOfFECAEDetRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__ArrayOfFECAEDetRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__ArrayOfFECAEDetRequest(soap, this, tag, type);
}

SOAP_FMAC3 afip3__ArrayOfFECAEDetRequest * SOAP_FMAC4 soap_get_afip3__ArrayOfFECAEDetRequest(struct soap *soap, afip3__ArrayOfFECAEDetRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__ArrayOfFECAEDetRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__FECabRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->afip3__FECabRequest::CantReg);
	soap_default_int(soap, &this->afip3__FECabRequest::PtoVta);
	soap_default_int(soap, &this->afip3__FECabRequest::CbteTipo);
}

void afip3__FECabRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int afip3__FECabRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__FECabRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__FECabRequest(struct soap *soap, const char *tag, int id, const afip3__FECabRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__FECabRequest), type))
		return soap->error;
	if (soap_out_int(soap, "afip3:CantReg", -1, &a->afip3__FECabRequest::CantReg, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:PtoVta", -1, &a->afip3__FECabRequest::PtoVta, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:CbteTipo", -1, &a->afip3__FECabRequest::CbteTipo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__FECabRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__FECabRequest(soap, tag, this, type);
}

SOAP_FMAC3 afip3__FECabRequest * SOAP_FMAC4 soap_in_afip3__FECabRequest(struct soap *soap, const char *tag, afip3__FECabRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__FECabRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__FECabRequest, sizeof(afip3__FECabRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__FECabRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__FECabRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CantReg1 = 1;
	size_t soap_flag_PtoVta1 = 1;
	size_t soap_flag_CbteTipo1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CantReg1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:CantReg", &a->afip3__FECabRequest::CantReg, "xsd:int"))
				{	soap_flag_CantReg1--;
					continue;
				}
			}
			if (soap_flag_PtoVta1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:PtoVta", &a->afip3__FECabRequest::PtoVta, "xsd:int"))
				{	soap_flag_PtoVta1--;
					continue;
				}
			}
			if (soap_flag_CbteTipo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:CbteTipo", &a->afip3__FECabRequest::CbteTipo, "xsd:int"))
				{	soap_flag_CbteTipo1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CantReg1 > 0 || soap_flag_PtoVta1 > 0 || soap_flag_CbteTipo1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__FECabRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__FECabRequest, SOAP_TYPE_afip3__FECabRequest, sizeof(afip3__FECabRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__FECabRequest * SOAP_FMAC2 soap_instantiate_afip3__FECabRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__FECabRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "afip3:FECAECabRequest"))
		return soap_instantiate_afip3__FECAECabRequest(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "afip3:FECAEACabRequest"))
		return soap_instantiate_afip3__FECAEACabRequest(soap, n, NULL, NULL, size);
	afip3__FECabRequest *p;
	size_t k = sizeof(afip3__FECabRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__FECabRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__FECabRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__FECabRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__FECabRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__FECabRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__FECabRequest(soap, tag ? tag : "afip3:FECabRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__FECabRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__FECabRequest(soap, this, tag, type);
}

SOAP_FMAC3 afip3__FECabRequest * SOAP_FMAC4 soap_get_afip3__FECabRequest(struct soap *soap, afip3__FECabRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__FECabRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__FECAECabRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__FECabRequest::soap_default(soap);
}

void afip3__FECAECabRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->afip3__FECabRequest::soap_serialize(soap);
#endif
}

int afip3__FECAECabRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__FECAECabRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__FECAECabRequest(struct soap *soap, const char *tag, int id, const afip3__FECAECabRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__FECAECabRequest), type ? type : "afip3:FECAECabRequest"))
		return soap->error;
	if (soap_out_int(soap, "afip3:CantReg", -1, &a->afip3__FECabRequest::CantReg, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:PtoVta", -1, &a->afip3__FECabRequest::PtoVta, ""))
		return soap->error;
	if (soap_out_int(soap, "afip3:CbteTipo", -1, &a->afip3__FECabRequest::CbteTipo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__FECAECabRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__FECAECabRequest(soap, tag, this, type);
}

SOAP_FMAC3 afip3__FECAECabRequest * SOAP_FMAC4 soap_in_afip3__FECAECabRequest(struct soap *soap, const char *tag, afip3__FECAECabRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__FECAECabRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__FECAECabRequest, sizeof(afip3__FECAECabRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__FECAECabRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__FECAECabRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CantReg2 = 1;
	size_t soap_flag_PtoVta2 = 1;
	size_t soap_flag_CbteTipo2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CantReg2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:CantReg", &a->afip3__FECabRequest::CantReg, "xsd:int"))
				{	soap_flag_CantReg2--;
					continue;
				}
			}
			if (soap_flag_PtoVta2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:PtoVta", &a->afip3__FECabRequest::PtoVta, "xsd:int"))
				{	soap_flag_PtoVta2--;
					continue;
				}
			}
			if (soap_flag_CbteTipo2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "afip3:CbteTipo", &a->afip3__FECabRequest::CbteTipo, "xsd:int"))
				{	soap_flag_CbteTipo2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CantReg2 > 0 || soap_flag_PtoVta2 > 0 || soap_flag_CbteTipo2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__FECAECabRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__FECAECabRequest, SOAP_TYPE_afip3__FECAECabRequest, sizeof(afip3__FECAECabRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__FECAECabRequest * SOAP_FMAC2 soap_instantiate_afip3__FECAECabRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__FECAECabRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__FECAECabRequest *p;
	size_t k = sizeof(afip3__FECAECabRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__FECAECabRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__FECAECabRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__FECAECabRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__FECAECabRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__FECAECabRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__FECAECabRequest(soap, tag ? tag : "afip3:FECAECabRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__FECAECabRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__FECAECabRequest(soap, this, tag, type);
}

SOAP_FMAC3 afip3__FECAECabRequest * SOAP_FMAC4 soap_get_afip3__FECAECabRequest(struct soap *soap, afip3__FECAECabRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__FECAECabRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__FECAERequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__FECAERequest::FeCabReq = NULL;
	this->afip3__FECAERequest::FeDetReq = NULL;
}

void afip3__FECAERequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip3__FECAECabRequest(soap, &this->afip3__FECAERequest::FeCabReq);
	soap_serialize_PointerToafip3__ArrayOfFECAEDetRequest(soap, &this->afip3__FECAERequest::FeDetReq);
#endif
}

int afip3__FECAERequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__FECAERequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__FECAERequest(struct soap *soap, const char *tag, int id, const afip3__FECAERequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__FECAERequest), type))
		return soap->error;
	if (soap_out_PointerToafip3__FECAECabRequest(soap, "afip3:FeCabReq", -1, &a->afip3__FECAERequest::FeCabReq, ""))
		return soap->error;
	if (soap_out_PointerToafip3__ArrayOfFECAEDetRequest(soap, "afip3:FeDetReq", -1, &a->afip3__FECAERequest::FeDetReq, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__FECAERequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__FECAERequest(soap, tag, this, type);
}

SOAP_FMAC3 afip3__FECAERequest * SOAP_FMAC4 soap_in_afip3__FECAERequest(struct soap *soap, const char *tag, afip3__FECAERequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__FECAERequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__FECAERequest, sizeof(afip3__FECAERequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__FECAERequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__FECAERequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FeCabReq1 = 1;
	size_t soap_flag_FeDetReq1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FeCabReq1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__FECAECabRequest(soap, "afip3:FeCabReq", &a->afip3__FECAERequest::FeCabReq, "afip3:FECAECabRequest"))
				{	soap_flag_FeCabReq1--;
					continue;
				}
			}
			if (soap_flag_FeDetReq1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip3__ArrayOfFECAEDetRequest(soap, "afip3:FeDetReq", &a->afip3__FECAERequest::FeDetReq, "afip3:ArrayOfFECAEDetRequest"))
				{	soap_flag_FeDetReq1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip3__FECAERequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__FECAERequest, SOAP_TYPE_afip3__FECAERequest, sizeof(afip3__FECAERequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__FECAERequest * SOAP_FMAC2 soap_instantiate_afip3__FECAERequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__FECAERequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__FECAERequest *p;
	size_t k = sizeof(afip3__FECAERequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__FECAERequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__FECAERequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__FECAERequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__FECAERequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__FECAERequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__FECAERequest(soap, tag ? tag : "afip3:FECAERequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__FECAERequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__FECAERequest(soap, this, tag, type);
}

SOAP_FMAC3 afip3__FECAERequest * SOAP_FMAC4 soap_get_afip3__FECAERequest(struct soap *soap, afip3__FECAERequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__FECAERequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip3__FEAuthRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->afip3__FEAuthRequest::Token = NULL;
	this->afip3__FEAuthRequest::Sign = NULL;
	soap_default_LONG64(soap, &this->afip3__FEAuthRequest::Cuit);
}

void afip3__FEAuthRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->afip3__FEAuthRequest::Token);
	soap_serialize_PointerTostd__string(soap, &this->afip3__FEAuthRequest::Sign);
#endif
}

int afip3__FEAuthRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip3__FEAuthRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip3__FEAuthRequest(struct soap *soap, const char *tag, int id, const afip3__FEAuthRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip3__FEAuthRequest), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:Token", -1, &a->afip3__FEAuthRequest::Token, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "afip3:Sign", -1, &a->afip3__FEAuthRequest::Sign, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "afip3:Cuit", -1, &a->afip3__FEAuthRequest::Cuit, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip3__FEAuthRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip3__FEAuthRequest(soap, tag, this, type);
}

SOAP_FMAC3 afip3__FEAuthRequest * SOAP_FMAC4 soap_in_afip3__FEAuthRequest(struct soap *soap, const char *tag, afip3__FEAuthRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip3__FEAuthRequest*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip3__FEAuthRequest, sizeof(afip3__FEAuthRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip3__FEAuthRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip3__FEAuthRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	size_t soap_flag_Sign1 = 1;
	size_t soap_flag_Cuit1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:Token", &a->afip3__FEAuthRequest::Token, "xsd:string"))
				{	soap_flag_Token1--;
					continue;
				}
			}
			if (soap_flag_Sign1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "afip3:Sign", &a->afip3__FEAuthRequest::Sign, "xsd:string"))
				{	soap_flag_Sign1--;
					continue;
				}
			}
			if (soap_flag_Cuit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_LONG64(soap, "afip3:Cuit", &a->afip3__FEAuthRequest::Cuit, "xsd:long"))
				{	soap_flag_Cuit1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Cuit1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (afip3__FEAuthRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip3__FEAuthRequest, SOAP_TYPE_afip3__FEAuthRequest, sizeof(afip3__FEAuthRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip3__FEAuthRequest * SOAP_FMAC2 soap_instantiate_afip3__FEAuthRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip3__FEAuthRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip3__FEAuthRequest *p;
	size_t k = sizeof(afip3__FEAuthRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip3__FEAuthRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip3__FEAuthRequest);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip3__FEAuthRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip3__FEAuthRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip3__FEAuthRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip3__FEAuthRequest(soap, tag ? tag : "afip3:FEAuthRequest", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip3__FEAuthRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip3__FEAuthRequest(soap, this, tag, type);
}

SOAP_FMAC3 afip3__FEAuthRequest * SOAP_FMAC4 soap_get_afip3__FEAuthRequest(struct soap *soap, afip3__FEAuthRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip3__FEAuthRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void afip2__LoginFault::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void afip2__LoginFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int afip2__LoginFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_afip2__LoginFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_afip2__LoginFault(struct soap *soap, const char *tag, int id, const afip2__LoginFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_afip2__LoginFault), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *afip2__LoginFault::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_afip2__LoginFault(soap, tag, this, type);
}

SOAP_FMAC3 afip2__LoginFault * SOAP_FMAC4 soap_in_afip2__LoginFault(struct soap *soap, const char *tag, afip2__LoginFault *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (afip2__LoginFault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_afip2__LoginFault, sizeof(afip2__LoginFault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_afip2__LoginFault)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (afip2__LoginFault *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (afip2__LoginFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_afip2__LoginFault, SOAP_TYPE_afip2__LoginFault, sizeof(afip2__LoginFault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 afip2__LoginFault * SOAP_FMAC2 soap_instantiate_afip2__LoginFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_afip2__LoginFault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	afip2__LoginFault *p;
	size_t k = sizeof(afip2__LoginFault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_afip2__LoginFault, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, afip2__LoginFault);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, afip2__LoginFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated afip2__LoginFault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int afip2__LoginFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_afip2__LoginFault(soap, tag ? tag : "afip2:LoginFault", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *afip2__LoginFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_afip2__LoginFault(soap, this, tag, type);
}

SOAP_FMAC3 afip2__LoginFault * SOAP_FMAC4 soap_get_afip2__LoginFault(struct soap *soap, afip2__LoginFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_afip2__LoginFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip1__loginCmsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_afip1__loginCmsResponse::loginCmsReturn);
}

void _afip1__loginCmsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_afip1__loginCmsResponse::loginCmsReturn, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_afip1__loginCmsResponse::loginCmsReturn);
#endif
}

int _afip1__loginCmsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip1__loginCmsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip1__loginCmsResponse(struct soap *soap, const char *tag, int id, const _afip1__loginCmsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip1__loginCmsResponse), type))
		return soap->error;
	soap_element_result(soap, "afip1:loginCmsReturn");
	if (soap_out_std__string(soap, "afip1:loginCmsReturn", -1, &a->_afip1__loginCmsResponse::loginCmsReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip1__loginCmsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip1__loginCmsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _afip1__loginCmsResponse * SOAP_FMAC4 soap_in__afip1__loginCmsResponse(struct soap *soap, const char *tag, _afip1__loginCmsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip1__loginCmsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip1__loginCmsResponse, sizeof(_afip1__loginCmsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip1__loginCmsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip1__loginCmsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_loginCmsReturn1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_loginCmsReturn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "afip1:loginCmsReturn", &a->_afip1__loginCmsResponse::loginCmsReturn, "xsd:string"))
				{	soap_flag_loginCmsReturn1--;
					continue;
				}
			}
			soap_check_result(soap, "afip1:loginCmsReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_loginCmsReturn1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_afip1__loginCmsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip1__loginCmsResponse, SOAP_TYPE__afip1__loginCmsResponse, sizeof(_afip1__loginCmsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip1__loginCmsResponse * SOAP_FMAC2 soap_instantiate__afip1__loginCmsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip1__loginCmsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip1__loginCmsResponse *p;
	size_t k = sizeof(_afip1__loginCmsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip1__loginCmsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip1__loginCmsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip1__loginCmsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip1__loginCmsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip1__loginCmsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip1__loginCmsResponse(soap, tag ? tag : "afip1:loginCmsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip1__loginCmsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip1__loginCmsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _afip1__loginCmsResponse * SOAP_FMAC4 soap_get__afip1__loginCmsResponse(struct soap *soap, _afip1__loginCmsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip1__loginCmsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _afip1__loginCms::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_afip1__loginCms::in0);
}

void _afip1__loginCms::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_afip1__loginCms::in0, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_afip1__loginCms::in0);
#endif
}

int _afip1__loginCms::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__afip1__loginCms(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__afip1__loginCms(struct soap *soap, const char *tag, int id, const _afip1__loginCms *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__afip1__loginCms), type))
		return soap->error;
	if (soap_out_std__string(soap, "afip1:in0", -1, &a->_afip1__loginCms::in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_afip1__loginCms::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__afip1__loginCms(soap, tag, this, type);
}

SOAP_FMAC3 _afip1__loginCms * SOAP_FMAC4 soap_in__afip1__loginCms(struct soap *soap, const char *tag, _afip1__loginCms *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_afip1__loginCms*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__afip1__loginCms, sizeof(_afip1__loginCms), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__afip1__loginCms)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_afip1__loginCms *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_in01 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "afip1:in0", &a->_afip1__loginCms::in0, "xsd:string"))
				{	soap_flag_in01--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_afip1__loginCms *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__afip1__loginCms, SOAP_TYPE__afip1__loginCms, sizeof(_afip1__loginCms), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _afip1__loginCms * SOAP_FMAC2 soap_instantiate__afip1__loginCms(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__afip1__loginCms(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_afip1__loginCms *p;
	size_t k = sizeof(_afip1__loginCms);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__afip1__loginCms, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _afip1__loginCms);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _afip1__loginCms, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _afip1__loginCms location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _afip1__loginCms::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__afip1__loginCms(soap, tag ? tag : "afip1:loginCms", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_afip1__loginCms::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__afip1__loginCms(soap, this, tag, type);
}

SOAP_FMAC3 _afip1__loginCms * SOAP_FMAC4 soap_get__afip1__loginCms(struct soap *soap, _afip1__loginCms *p, const char *tag, const char *type)
{
	if ((p = soap_in__afip1__loginCms(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode;
	soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Fault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Reason*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value;
	soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Header*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip5__FEParamGetTiposPaises(struct soap *soap, struct __afip5__FEParamGetTiposPaises *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FEParamGetTiposPaises = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip5__FEParamGetTiposPaises(struct soap *soap, const struct __afip5__FEParamGetTiposPaises *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FEParamGetTiposPaises(soap, &a->afip3__FEParamGetTiposPaises);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip5__FEParamGetTiposPaises(struct soap *soap, const char *tag, int id, const struct __afip5__FEParamGetTiposPaises *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FEParamGetTiposPaises(soap, "afip3:FEParamGetTiposPaises", -1, &a->afip3__FEParamGetTiposPaises, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FEParamGetTiposPaises * SOAP_FMAC4 soap_in___afip5__FEParamGetTiposPaises(struct soap *soap, const char *tag, struct __afip5__FEParamGetTiposPaises *a, const char *type)
{
	size_t soap_flag_afip3__FEParamGetTiposPaises = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip5__FEParamGetTiposPaises*)soap_id_enter(soap, "", a, SOAP_TYPE___afip5__FEParamGetTiposPaises, sizeof(struct __afip5__FEParamGetTiposPaises), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip5__FEParamGetTiposPaises(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FEParamGetTiposPaises && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FEParamGetTiposPaises(soap, "afip3:FEParamGetTiposPaises", &a->afip3__FEParamGetTiposPaises, ""))
				{	soap_flag_afip3__FEParamGetTiposPaises--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip5__FEParamGetTiposPaises * SOAP_FMAC2 soap_instantiate___afip5__FEParamGetTiposPaises(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip5__FEParamGetTiposPaises(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip5__FEParamGetTiposPaises *p;
	size_t k = sizeof(struct __afip5__FEParamGetTiposPaises);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip5__FEParamGetTiposPaises, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip5__FEParamGetTiposPaises);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip5__FEParamGetTiposPaises, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip5__FEParamGetTiposPaises location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip5__FEParamGetTiposPaises(struct soap *soap, const struct __afip5__FEParamGetTiposPaises *a, const char *tag, const char *type)
{
	if (soap_out___afip5__FEParamGetTiposPaises(soap, tag ? tag : "-afip5:FEParamGetTiposPaises", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FEParamGetTiposPaises * SOAP_FMAC4 soap_get___afip5__FEParamGetTiposPaises(struct soap *soap, struct __afip5__FEParamGetTiposPaises *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip5__FEParamGetTiposPaises(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip5__FEParamGetTiposDoc(struct soap *soap, struct __afip5__FEParamGetTiposDoc *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FEParamGetTiposDoc = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip5__FEParamGetTiposDoc(struct soap *soap, const struct __afip5__FEParamGetTiposDoc *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FEParamGetTiposDoc(soap, &a->afip3__FEParamGetTiposDoc);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip5__FEParamGetTiposDoc(struct soap *soap, const char *tag, int id, const struct __afip5__FEParamGetTiposDoc *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FEParamGetTiposDoc(soap, "afip3:FEParamGetTiposDoc", -1, &a->afip3__FEParamGetTiposDoc, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FEParamGetTiposDoc * SOAP_FMAC4 soap_in___afip5__FEParamGetTiposDoc(struct soap *soap, const char *tag, struct __afip5__FEParamGetTiposDoc *a, const char *type)
{
	size_t soap_flag_afip3__FEParamGetTiposDoc = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip5__FEParamGetTiposDoc*)soap_id_enter(soap, "", a, SOAP_TYPE___afip5__FEParamGetTiposDoc, sizeof(struct __afip5__FEParamGetTiposDoc), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip5__FEParamGetTiposDoc(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FEParamGetTiposDoc && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FEParamGetTiposDoc(soap, "afip3:FEParamGetTiposDoc", &a->afip3__FEParamGetTiposDoc, ""))
				{	soap_flag_afip3__FEParamGetTiposDoc--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip5__FEParamGetTiposDoc * SOAP_FMAC2 soap_instantiate___afip5__FEParamGetTiposDoc(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip5__FEParamGetTiposDoc(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip5__FEParamGetTiposDoc *p;
	size_t k = sizeof(struct __afip5__FEParamGetTiposDoc);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip5__FEParamGetTiposDoc, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip5__FEParamGetTiposDoc);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip5__FEParamGetTiposDoc, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip5__FEParamGetTiposDoc location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip5__FEParamGetTiposDoc(struct soap *soap, const struct __afip5__FEParamGetTiposDoc *a, const char *tag, const char *type)
{
	if (soap_out___afip5__FEParamGetTiposDoc(soap, tag ? tag : "-afip5:FEParamGetTiposDoc", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FEParamGetTiposDoc * SOAP_FMAC4 soap_get___afip5__FEParamGetTiposDoc(struct soap *soap, struct __afip5__FEParamGetTiposDoc *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip5__FEParamGetTiposDoc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip5__FEParamGetTiposCbte(struct soap *soap, struct __afip5__FEParamGetTiposCbte *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FEParamGetTiposCbte = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip5__FEParamGetTiposCbte(struct soap *soap, const struct __afip5__FEParamGetTiposCbte *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FEParamGetTiposCbte(soap, &a->afip3__FEParamGetTiposCbte);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip5__FEParamGetTiposCbte(struct soap *soap, const char *tag, int id, const struct __afip5__FEParamGetTiposCbte *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FEParamGetTiposCbte(soap, "afip3:FEParamGetTiposCbte", -1, &a->afip3__FEParamGetTiposCbte, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FEParamGetTiposCbte * SOAP_FMAC4 soap_in___afip5__FEParamGetTiposCbte(struct soap *soap, const char *tag, struct __afip5__FEParamGetTiposCbte *a, const char *type)
{
	size_t soap_flag_afip3__FEParamGetTiposCbte = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip5__FEParamGetTiposCbte*)soap_id_enter(soap, "", a, SOAP_TYPE___afip5__FEParamGetTiposCbte, sizeof(struct __afip5__FEParamGetTiposCbte), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip5__FEParamGetTiposCbte(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FEParamGetTiposCbte && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FEParamGetTiposCbte(soap, "afip3:FEParamGetTiposCbte", &a->afip3__FEParamGetTiposCbte, ""))
				{	soap_flag_afip3__FEParamGetTiposCbte--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip5__FEParamGetTiposCbte * SOAP_FMAC2 soap_instantiate___afip5__FEParamGetTiposCbte(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip5__FEParamGetTiposCbte(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip5__FEParamGetTiposCbte *p;
	size_t k = sizeof(struct __afip5__FEParamGetTiposCbte);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip5__FEParamGetTiposCbte, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip5__FEParamGetTiposCbte);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip5__FEParamGetTiposCbte, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip5__FEParamGetTiposCbte location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip5__FEParamGetTiposCbte(struct soap *soap, const struct __afip5__FEParamGetTiposCbte *a, const char *tag, const char *type)
{
	if (soap_out___afip5__FEParamGetTiposCbte(soap, tag ? tag : "-afip5:FEParamGetTiposCbte", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FEParamGetTiposCbte * SOAP_FMAC4 soap_get___afip5__FEParamGetTiposCbte(struct soap *soap, struct __afip5__FEParamGetTiposCbte *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip5__FEParamGetTiposCbte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip5__FEParamGetPtosVenta(struct soap *soap, struct __afip5__FEParamGetPtosVenta *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FEParamGetPtosVenta = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip5__FEParamGetPtosVenta(struct soap *soap, const struct __afip5__FEParamGetPtosVenta *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FEParamGetPtosVenta(soap, &a->afip3__FEParamGetPtosVenta);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip5__FEParamGetPtosVenta(struct soap *soap, const char *tag, int id, const struct __afip5__FEParamGetPtosVenta *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FEParamGetPtosVenta(soap, "afip3:FEParamGetPtosVenta", -1, &a->afip3__FEParamGetPtosVenta, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FEParamGetPtosVenta * SOAP_FMAC4 soap_in___afip5__FEParamGetPtosVenta(struct soap *soap, const char *tag, struct __afip5__FEParamGetPtosVenta *a, const char *type)
{
	size_t soap_flag_afip3__FEParamGetPtosVenta = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip5__FEParamGetPtosVenta*)soap_id_enter(soap, "", a, SOAP_TYPE___afip5__FEParamGetPtosVenta, sizeof(struct __afip5__FEParamGetPtosVenta), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip5__FEParamGetPtosVenta(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FEParamGetPtosVenta && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FEParamGetPtosVenta(soap, "afip3:FEParamGetPtosVenta", &a->afip3__FEParamGetPtosVenta, ""))
				{	soap_flag_afip3__FEParamGetPtosVenta--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip5__FEParamGetPtosVenta * SOAP_FMAC2 soap_instantiate___afip5__FEParamGetPtosVenta(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip5__FEParamGetPtosVenta(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip5__FEParamGetPtosVenta *p;
	size_t k = sizeof(struct __afip5__FEParamGetPtosVenta);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip5__FEParamGetPtosVenta, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip5__FEParamGetPtosVenta);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip5__FEParamGetPtosVenta, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip5__FEParamGetPtosVenta location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip5__FEParamGetPtosVenta(struct soap *soap, const struct __afip5__FEParamGetPtosVenta *a, const char *tag, const char *type)
{
	if (soap_out___afip5__FEParamGetPtosVenta(soap, tag ? tag : "-afip5:FEParamGetPtosVenta", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FEParamGetPtosVenta * SOAP_FMAC4 soap_get___afip5__FEParamGetPtosVenta(struct soap *soap, struct __afip5__FEParamGetPtosVenta *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip5__FEParamGetPtosVenta(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip5__FEParamGetTiposConcepto(struct soap *soap, struct __afip5__FEParamGetTiposConcepto *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FEParamGetTiposConcepto = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip5__FEParamGetTiposConcepto(struct soap *soap, const struct __afip5__FEParamGetTiposConcepto *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FEParamGetTiposConcepto(soap, &a->afip3__FEParamGetTiposConcepto);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip5__FEParamGetTiposConcepto(struct soap *soap, const char *tag, int id, const struct __afip5__FEParamGetTiposConcepto *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FEParamGetTiposConcepto(soap, "afip3:FEParamGetTiposConcepto", -1, &a->afip3__FEParamGetTiposConcepto, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FEParamGetTiposConcepto * SOAP_FMAC4 soap_in___afip5__FEParamGetTiposConcepto(struct soap *soap, const char *tag, struct __afip5__FEParamGetTiposConcepto *a, const char *type)
{
	size_t soap_flag_afip3__FEParamGetTiposConcepto = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip5__FEParamGetTiposConcepto*)soap_id_enter(soap, "", a, SOAP_TYPE___afip5__FEParamGetTiposConcepto, sizeof(struct __afip5__FEParamGetTiposConcepto), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip5__FEParamGetTiposConcepto(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FEParamGetTiposConcepto && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FEParamGetTiposConcepto(soap, "afip3:FEParamGetTiposConcepto", &a->afip3__FEParamGetTiposConcepto, ""))
				{	soap_flag_afip3__FEParamGetTiposConcepto--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip5__FEParamGetTiposConcepto * SOAP_FMAC2 soap_instantiate___afip5__FEParamGetTiposConcepto(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip5__FEParamGetTiposConcepto(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip5__FEParamGetTiposConcepto *p;
	size_t k = sizeof(struct __afip5__FEParamGetTiposConcepto);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip5__FEParamGetTiposConcepto, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip5__FEParamGetTiposConcepto);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip5__FEParamGetTiposConcepto, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip5__FEParamGetTiposConcepto location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip5__FEParamGetTiposConcepto(struct soap *soap, const struct __afip5__FEParamGetTiposConcepto *a, const char *tag, const char *type)
{
	if (soap_out___afip5__FEParamGetTiposConcepto(soap, tag ? tag : "-afip5:FEParamGetTiposConcepto", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FEParamGetTiposConcepto * SOAP_FMAC4 soap_get___afip5__FEParamGetTiposConcepto(struct soap *soap, struct __afip5__FEParamGetTiposConcepto *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip5__FEParamGetTiposConcepto(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip5__FEParamGetTiposOpcional(struct soap *soap, struct __afip5__FEParamGetTiposOpcional *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FEParamGetTiposOpcional = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip5__FEParamGetTiposOpcional(struct soap *soap, const struct __afip5__FEParamGetTiposOpcional *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FEParamGetTiposOpcional(soap, &a->afip3__FEParamGetTiposOpcional);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip5__FEParamGetTiposOpcional(struct soap *soap, const char *tag, int id, const struct __afip5__FEParamGetTiposOpcional *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FEParamGetTiposOpcional(soap, "afip3:FEParamGetTiposOpcional", -1, &a->afip3__FEParamGetTiposOpcional, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FEParamGetTiposOpcional * SOAP_FMAC4 soap_in___afip5__FEParamGetTiposOpcional(struct soap *soap, const char *tag, struct __afip5__FEParamGetTiposOpcional *a, const char *type)
{
	size_t soap_flag_afip3__FEParamGetTiposOpcional = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip5__FEParamGetTiposOpcional*)soap_id_enter(soap, "", a, SOAP_TYPE___afip5__FEParamGetTiposOpcional, sizeof(struct __afip5__FEParamGetTiposOpcional), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip5__FEParamGetTiposOpcional(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FEParamGetTiposOpcional && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FEParamGetTiposOpcional(soap, "afip3:FEParamGetTiposOpcional", &a->afip3__FEParamGetTiposOpcional, ""))
				{	soap_flag_afip3__FEParamGetTiposOpcional--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip5__FEParamGetTiposOpcional * SOAP_FMAC2 soap_instantiate___afip5__FEParamGetTiposOpcional(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip5__FEParamGetTiposOpcional(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip5__FEParamGetTiposOpcional *p;
	size_t k = sizeof(struct __afip5__FEParamGetTiposOpcional);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip5__FEParamGetTiposOpcional, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip5__FEParamGetTiposOpcional);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip5__FEParamGetTiposOpcional, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip5__FEParamGetTiposOpcional location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip5__FEParamGetTiposOpcional(struct soap *soap, const struct __afip5__FEParamGetTiposOpcional *a, const char *tag, const char *type)
{
	if (soap_out___afip5__FEParamGetTiposOpcional(soap, tag ? tag : "-afip5:FEParamGetTiposOpcional", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FEParamGetTiposOpcional * SOAP_FMAC4 soap_get___afip5__FEParamGetTiposOpcional(struct soap *soap, struct __afip5__FEParamGetTiposOpcional *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip5__FEParamGetTiposOpcional(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip5__FEParamGetTiposIva(struct soap *soap, struct __afip5__FEParamGetTiposIva *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FEParamGetTiposIva = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip5__FEParamGetTiposIva(struct soap *soap, const struct __afip5__FEParamGetTiposIva *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FEParamGetTiposIva(soap, &a->afip3__FEParamGetTiposIva);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip5__FEParamGetTiposIva(struct soap *soap, const char *tag, int id, const struct __afip5__FEParamGetTiposIva *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FEParamGetTiposIva(soap, "afip3:FEParamGetTiposIva", -1, &a->afip3__FEParamGetTiposIva, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FEParamGetTiposIva * SOAP_FMAC4 soap_in___afip5__FEParamGetTiposIva(struct soap *soap, const char *tag, struct __afip5__FEParamGetTiposIva *a, const char *type)
{
	size_t soap_flag_afip3__FEParamGetTiposIva = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip5__FEParamGetTiposIva*)soap_id_enter(soap, "", a, SOAP_TYPE___afip5__FEParamGetTiposIva, sizeof(struct __afip5__FEParamGetTiposIva), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip5__FEParamGetTiposIva(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FEParamGetTiposIva && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FEParamGetTiposIva(soap, "afip3:FEParamGetTiposIva", &a->afip3__FEParamGetTiposIva, ""))
				{	soap_flag_afip3__FEParamGetTiposIva--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip5__FEParamGetTiposIva * SOAP_FMAC2 soap_instantiate___afip5__FEParamGetTiposIva(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip5__FEParamGetTiposIva(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip5__FEParamGetTiposIva *p;
	size_t k = sizeof(struct __afip5__FEParamGetTiposIva);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip5__FEParamGetTiposIva, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip5__FEParamGetTiposIva);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip5__FEParamGetTiposIva, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip5__FEParamGetTiposIva location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip5__FEParamGetTiposIva(struct soap *soap, const struct __afip5__FEParamGetTiposIva *a, const char *tag, const char *type)
{
	if (soap_out___afip5__FEParamGetTiposIva(soap, tag ? tag : "-afip5:FEParamGetTiposIva", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FEParamGetTiposIva * SOAP_FMAC4 soap_get___afip5__FEParamGetTiposIva(struct soap *soap, struct __afip5__FEParamGetTiposIva *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip5__FEParamGetTiposIva(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip5__FEParamGetTiposMonedas(struct soap *soap, struct __afip5__FEParamGetTiposMonedas *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FEParamGetTiposMonedas = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip5__FEParamGetTiposMonedas(struct soap *soap, const struct __afip5__FEParamGetTiposMonedas *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FEParamGetTiposMonedas(soap, &a->afip3__FEParamGetTiposMonedas);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip5__FEParamGetTiposMonedas(struct soap *soap, const char *tag, int id, const struct __afip5__FEParamGetTiposMonedas *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FEParamGetTiposMonedas(soap, "afip3:FEParamGetTiposMonedas", -1, &a->afip3__FEParamGetTiposMonedas, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FEParamGetTiposMonedas * SOAP_FMAC4 soap_in___afip5__FEParamGetTiposMonedas(struct soap *soap, const char *tag, struct __afip5__FEParamGetTiposMonedas *a, const char *type)
{
	size_t soap_flag_afip3__FEParamGetTiposMonedas = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip5__FEParamGetTiposMonedas*)soap_id_enter(soap, "", a, SOAP_TYPE___afip5__FEParamGetTiposMonedas, sizeof(struct __afip5__FEParamGetTiposMonedas), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip5__FEParamGetTiposMonedas(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FEParamGetTiposMonedas && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FEParamGetTiposMonedas(soap, "afip3:FEParamGetTiposMonedas", &a->afip3__FEParamGetTiposMonedas, ""))
				{	soap_flag_afip3__FEParamGetTiposMonedas--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip5__FEParamGetTiposMonedas * SOAP_FMAC2 soap_instantiate___afip5__FEParamGetTiposMonedas(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip5__FEParamGetTiposMonedas(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip5__FEParamGetTiposMonedas *p;
	size_t k = sizeof(struct __afip5__FEParamGetTiposMonedas);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip5__FEParamGetTiposMonedas, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip5__FEParamGetTiposMonedas);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip5__FEParamGetTiposMonedas, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip5__FEParamGetTiposMonedas location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip5__FEParamGetTiposMonedas(struct soap *soap, const struct __afip5__FEParamGetTiposMonedas *a, const char *tag, const char *type)
{
	if (soap_out___afip5__FEParamGetTiposMonedas(soap, tag ? tag : "-afip5:FEParamGetTiposMonedas", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FEParamGetTiposMonedas * SOAP_FMAC4 soap_get___afip5__FEParamGetTiposMonedas(struct soap *soap, struct __afip5__FEParamGetTiposMonedas *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip5__FEParamGetTiposMonedas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip5__FEParamGetTiposTributos(struct soap *soap, struct __afip5__FEParamGetTiposTributos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FEParamGetTiposTributos = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip5__FEParamGetTiposTributos(struct soap *soap, const struct __afip5__FEParamGetTiposTributos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FEParamGetTiposTributos(soap, &a->afip3__FEParamGetTiposTributos);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip5__FEParamGetTiposTributos(struct soap *soap, const char *tag, int id, const struct __afip5__FEParamGetTiposTributos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FEParamGetTiposTributos(soap, "afip3:FEParamGetTiposTributos", -1, &a->afip3__FEParamGetTiposTributos, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FEParamGetTiposTributos * SOAP_FMAC4 soap_in___afip5__FEParamGetTiposTributos(struct soap *soap, const char *tag, struct __afip5__FEParamGetTiposTributos *a, const char *type)
{
	size_t soap_flag_afip3__FEParamGetTiposTributos = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip5__FEParamGetTiposTributos*)soap_id_enter(soap, "", a, SOAP_TYPE___afip5__FEParamGetTiposTributos, sizeof(struct __afip5__FEParamGetTiposTributos), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip5__FEParamGetTiposTributos(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FEParamGetTiposTributos && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FEParamGetTiposTributos(soap, "afip3:FEParamGetTiposTributos", &a->afip3__FEParamGetTiposTributos, ""))
				{	soap_flag_afip3__FEParamGetTiposTributos--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip5__FEParamGetTiposTributos * SOAP_FMAC2 soap_instantiate___afip5__FEParamGetTiposTributos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip5__FEParamGetTiposTributos(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip5__FEParamGetTiposTributos *p;
	size_t k = sizeof(struct __afip5__FEParamGetTiposTributos);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip5__FEParamGetTiposTributos, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip5__FEParamGetTiposTributos);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip5__FEParamGetTiposTributos, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip5__FEParamGetTiposTributos location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip5__FEParamGetTiposTributos(struct soap *soap, const struct __afip5__FEParamGetTiposTributos *a, const char *tag, const char *type)
{
	if (soap_out___afip5__FEParamGetTiposTributos(soap, tag ? tag : "-afip5:FEParamGetTiposTributos", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FEParamGetTiposTributos * SOAP_FMAC4 soap_get___afip5__FEParamGetTiposTributos(struct soap *soap, struct __afip5__FEParamGetTiposTributos *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip5__FEParamGetTiposTributos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip5__FEParamGetCotizacion(struct soap *soap, struct __afip5__FEParamGetCotizacion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FEParamGetCotizacion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip5__FEParamGetCotizacion(struct soap *soap, const struct __afip5__FEParamGetCotizacion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FEParamGetCotizacion(soap, &a->afip3__FEParamGetCotizacion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip5__FEParamGetCotizacion(struct soap *soap, const char *tag, int id, const struct __afip5__FEParamGetCotizacion *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FEParamGetCotizacion(soap, "afip3:FEParamGetCotizacion", -1, &a->afip3__FEParamGetCotizacion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FEParamGetCotizacion * SOAP_FMAC4 soap_in___afip5__FEParamGetCotizacion(struct soap *soap, const char *tag, struct __afip5__FEParamGetCotizacion *a, const char *type)
{
	size_t soap_flag_afip3__FEParamGetCotizacion = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip5__FEParamGetCotizacion*)soap_id_enter(soap, "", a, SOAP_TYPE___afip5__FEParamGetCotizacion, sizeof(struct __afip5__FEParamGetCotizacion), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip5__FEParamGetCotizacion(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FEParamGetCotizacion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FEParamGetCotizacion(soap, "afip3:FEParamGetCotizacion", &a->afip3__FEParamGetCotizacion, ""))
				{	soap_flag_afip3__FEParamGetCotizacion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip5__FEParamGetCotizacion * SOAP_FMAC2 soap_instantiate___afip5__FEParamGetCotizacion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip5__FEParamGetCotizacion(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip5__FEParamGetCotizacion *p;
	size_t k = sizeof(struct __afip5__FEParamGetCotizacion);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip5__FEParamGetCotizacion, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip5__FEParamGetCotizacion);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip5__FEParamGetCotizacion, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip5__FEParamGetCotizacion location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip5__FEParamGetCotizacion(struct soap *soap, const struct __afip5__FEParamGetCotizacion *a, const char *tag, const char *type)
{
	if (soap_out___afip5__FEParamGetCotizacion(soap, tag ? tag : "-afip5:FEParamGetCotizacion", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FEParamGetCotizacion * SOAP_FMAC4 soap_get___afip5__FEParamGetCotizacion(struct soap *soap, struct __afip5__FEParamGetCotizacion *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip5__FEParamGetCotizacion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip5__FECAEAConsultar(struct soap *soap, struct __afip5__FECAEAConsultar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FECAEAConsultar = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip5__FECAEAConsultar(struct soap *soap, const struct __afip5__FECAEAConsultar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FECAEAConsultar(soap, &a->afip3__FECAEAConsultar);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip5__FECAEAConsultar(struct soap *soap, const char *tag, int id, const struct __afip5__FECAEAConsultar *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FECAEAConsultar(soap, "afip3:FECAEAConsultar", -1, &a->afip3__FECAEAConsultar, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FECAEAConsultar * SOAP_FMAC4 soap_in___afip5__FECAEAConsultar(struct soap *soap, const char *tag, struct __afip5__FECAEAConsultar *a, const char *type)
{
	size_t soap_flag_afip3__FECAEAConsultar = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip5__FECAEAConsultar*)soap_id_enter(soap, "", a, SOAP_TYPE___afip5__FECAEAConsultar, sizeof(struct __afip5__FECAEAConsultar), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip5__FECAEAConsultar(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FECAEAConsultar && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FECAEAConsultar(soap, "afip3:FECAEAConsultar", &a->afip3__FECAEAConsultar, ""))
				{	soap_flag_afip3__FECAEAConsultar--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip5__FECAEAConsultar * SOAP_FMAC2 soap_instantiate___afip5__FECAEAConsultar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip5__FECAEAConsultar(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip5__FECAEAConsultar *p;
	size_t k = sizeof(struct __afip5__FECAEAConsultar);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip5__FECAEAConsultar, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip5__FECAEAConsultar);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip5__FECAEAConsultar, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip5__FECAEAConsultar location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip5__FECAEAConsultar(struct soap *soap, const struct __afip5__FECAEAConsultar *a, const char *tag, const char *type)
{
	if (soap_out___afip5__FECAEAConsultar(soap, tag ? tag : "-afip5:FECAEAConsultar", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FECAEAConsultar * SOAP_FMAC4 soap_get___afip5__FECAEAConsultar(struct soap *soap, struct __afip5__FECAEAConsultar *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip5__FECAEAConsultar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip5__FECAEASinMovimientoInformar(struct soap *soap, struct __afip5__FECAEASinMovimientoInformar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FECAEASinMovimientoInformar = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip5__FECAEASinMovimientoInformar(struct soap *soap, const struct __afip5__FECAEASinMovimientoInformar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FECAEASinMovimientoInformar(soap, &a->afip3__FECAEASinMovimientoInformar);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip5__FECAEASinMovimientoInformar(struct soap *soap, const char *tag, int id, const struct __afip5__FECAEASinMovimientoInformar *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FECAEASinMovimientoInformar(soap, "afip3:FECAEASinMovimientoInformar", -1, &a->afip3__FECAEASinMovimientoInformar, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FECAEASinMovimientoInformar * SOAP_FMAC4 soap_in___afip5__FECAEASinMovimientoInformar(struct soap *soap, const char *tag, struct __afip5__FECAEASinMovimientoInformar *a, const char *type)
{
	size_t soap_flag_afip3__FECAEASinMovimientoInformar = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip5__FECAEASinMovimientoInformar*)soap_id_enter(soap, "", a, SOAP_TYPE___afip5__FECAEASinMovimientoInformar, sizeof(struct __afip5__FECAEASinMovimientoInformar), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip5__FECAEASinMovimientoInformar(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FECAEASinMovimientoInformar && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FECAEASinMovimientoInformar(soap, "afip3:FECAEASinMovimientoInformar", &a->afip3__FECAEASinMovimientoInformar, ""))
				{	soap_flag_afip3__FECAEASinMovimientoInformar--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip5__FECAEASinMovimientoInformar * SOAP_FMAC2 soap_instantiate___afip5__FECAEASinMovimientoInformar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip5__FECAEASinMovimientoInformar(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip5__FECAEASinMovimientoInformar *p;
	size_t k = sizeof(struct __afip5__FECAEASinMovimientoInformar);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip5__FECAEASinMovimientoInformar, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip5__FECAEASinMovimientoInformar);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip5__FECAEASinMovimientoInformar, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip5__FECAEASinMovimientoInformar location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip5__FECAEASinMovimientoInformar(struct soap *soap, const struct __afip5__FECAEASinMovimientoInformar *a, const char *tag, const char *type)
{
	if (soap_out___afip5__FECAEASinMovimientoInformar(soap, tag ? tag : "-afip5:FECAEASinMovimientoInformar", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FECAEASinMovimientoInformar * SOAP_FMAC4 soap_get___afip5__FECAEASinMovimientoInformar(struct soap *soap, struct __afip5__FECAEASinMovimientoInformar *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip5__FECAEASinMovimientoInformar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip5__FECAEASinMovimientoConsultar(struct soap *soap, struct __afip5__FECAEASinMovimientoConsultar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FECAEASinMovimientoConsultar = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip5__FECAEASinMovimientoConsultar(struct soap *soap, const struct __afip5__FECAEASinMovimientoConsultar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FECAEASinMovimientoConsultar(soap, &a->afip3__FECAEASinMovimientoConsultar);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip5__FECAEASinMovimientoConsultar(struct soap *soap, const char *tag, int id, const struct __afip5__FECAEASinMovimientoConsultar *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FECAEASinMovimientoConsultar(soap, "afip3:FECAEASinMovimientoConsultar", -1, &a->afip3__FECAEASinMovimientoConsultar, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FECAEASinMovimientoConsultar * SOAP_FMAC4 soap_in___afip5__FECAEASinMovimientoConsultar(struct soap *soap, const char *tag, struct __afip5__FECAEASinMovimientoConsultar *a, const char *type)
{
	size_t soap_flag_afip3__FECAEASinMovimientoConsultar = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip5__FECAEASinMovimientoConsultar*)soap_id_enter(soap, "", a, SOAP_TYPE___afip5__FECAEASinMovimientoConsultar, sizeof(struct __afip5__FECAEASinMovimientoConsultar), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip5__FECAEASinMovimientoConsultar(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FECAEASinMovimientoConsultar && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FECAEASinMovimientoConsultar(soap, "afip3:FECAEASinMovimientoConsultar", &a->afip3__FECAEASinMovimientoConsultar, ""))
				{	soap_flag_afip3__FECAEASinMovimientoConsultar--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip5__FECAEASinMovimientoConsultar * SOAP_FMAC2 soap_instantiate___afip5__FECAEASinMovimientoConsultar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip5__FECAEASinMovimientoConsultar(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip5__FECAEASinMovimientoConsultar *p;
	size_t k = sizeof(struct __afip5__FECAEASinMovimientoConsultar);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip5__FECAEASinMovimientoConsultar, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip5__FECAEASinMovimientoConsultar);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip5__FECAEASinMovimientoConsultar, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip5__FECAEASinMovimientoConsultar location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip5__FECAEASinMovimientoConsultar(struct soap *soap, const struct __afip5__FECAEASinMovimientoConsultar *a, const char *tag, const char *type)
{
	if (soap_out___afip5__FECAEASinMovimientoConsultar(soap, tag ? tag : "-afip5:FECAEASinMovimientoConsultar", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FECAEASinMovimientoConsultar * SOAP_FMAC4 soap_get___afip5__FECAEASinMovimientoConsultar(struct soap *soap, struct __afip5__FECAEASinMovimientoConsultar *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip5__FECAEASinMovimientoConsultar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip5__FECAEASolicitar(struct soap *soap, struct __afip5__FECAEASolicitar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FECAEASolicitar = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip5__FECAEASolicitar(struct soap *soap, const struct __afip5__FECAEASolicitar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FECAEASolicitar(soap, &a->afip3__FECAEASolicitar);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip5__FECAEASolicitar(struct soap *soap, const char *tag, int id, const struct __afip5__FECAEASolicitar *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FECAEASolicitar(soap, "afip3:FECAEASolicitar", -1, &a->afip3__FECAEASolicitar, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FECAEASolicitar * SOAP_FMAC4 soap_in___afip5__FECAEASolicitar(struct soap *soap, const char *tag, struct __afip5__FECAEASolicitar *a, const char *type)
{
	size_t soap_flag_afip3__FECAEASolicitar = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip5__FECAEASolicitar*)soap_id_enter(soap, "", a, SOAP_TYPE___afip5__FECAEASolicitar, sizeof(struct __afip5__FECAEASolicitar), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip5__FECAEASolicitar(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FECAEASolicitar && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FECAEASolicitar(soap, "afip3:FECAEASolicitar", &a->afip3__FECAEASolicitar, ""))
				{	soap_flag_afip3__FECAEASolicitar--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip5__FECAEASolicitar * SOAP_FMAC2 soap_instantiate___afip5__FECAEASolicitar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip5__FECAEASolicitar(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip5__FECAEASolicitar *p;
	size_t k = sizeof(struct __afip5__FECAEASolicitar);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip5__FECAEASolicitar, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip5__FECAEASolicitar);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip5__FECAEASolicitar, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip5__FECAEASolicitar location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip5__FECAEASolicitar(struct soap *soap, const struct __afip5__FECAEASolicitar *a, const char *tag, const char *type)
{
	if (soap_out___afip5__FECAEASolicitar(soap, tag ? tag : "-afip5:FECAEASolicitar", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FECAEASolicitar * SOAP_FMAC4 soap_get___afip5__FECAEASolicitar(struct soap *soap, struct __afip5__FECAEASolicitar *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip5__FECAEASolicitar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip5__FECAEARegInformativo(struct soap *soap, struct __afip5__FECAEARegInformativo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FECAEARegInformativo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip5__FECAEARegInformativo(struct soap *soap, const struct __afip5__FECAEARegInformativo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FECAEARegInformativo(soap, &a->afip3__FECAEARegInformativo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip5__FECAEARegInformativo(struct soap *soap, const char *tag, int id, const struct __afip5__FECAEARegInformativo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FECAEARegInformativo(soap, "afip3:FECAEARegInformativo", -1, &a->afip3__FECAEARegInformativo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FECAEARegInformativo * SOAP_FMAC4 soap_in___afip5__FECAEARegInformativo(struct soap *soap, const char *tag, struct __afip5__FECAEARegInformativo *a, const char *type)
{
	size_t soap_flag_afip3__FECAEARegInformativo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip5__FECAEARegInformativo*)soap_id_enter(soap, "", a, SOAP_TYPE___afip5__FECAEARegInformativo, sizeof(struct __afip5__FECAEARegInformativo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip5__FECAEARegInformativo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FECAEARegInformativo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FECAEARegInformativo(soap, "afip3:FECAEARegInformativo", &a->afip3__FECAEARegInformativo, ""))
				{	soap_flag_afip3__FECAEARegInformativo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip5__FECAEARegInformativo * SOAP_FMAC2 soap_instantiate___afip5__FECAEARegInformativo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip5__FECAEARegInformativo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip5__FECAEARegInformativo *p;
	size_t k = sizeof(struct __afip5__FECAEARegInformativo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip5__FECAEARegInformativo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip5__FECAEARegInformativo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip5__FECAEARegInformativo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip5__FECAEARegInformativo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip5__FECAEARegInformativo(struct soap *soap, const struct __afip5__FECAEARegInformativo *a, const char *tag, const char *type)
{
	if (soap_out___afip5__FECAEARegInformativo(soap, tag ? tag : "-afip5:FECAEARegInformativo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FECAEARegInformativo * SOAP_FMAC4 soap_get___afip5__FECAEARegInformativo(struct soap *soap, struct __afip5__FECAEARegInformativo *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip5__FECAEARegInformativo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip5__FECompConsultar(struct soap *soap, struct __afip5__FECompConsultar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FECompConsultar = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip5__FECompConsultar(struct soap *soap, const struct __afip5__FECompConsultar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FECompConsultar(soap, &a->afip3__FECompConsultar);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip5__FECompConsultar(struct soap *soap, const char *tag, int id, const struct __afip5__FECompConsultar *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FECompConsultar(soap, "afip3:FECompConsultar", -1, &a->afip3__FECompConsultar, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FECompConsultar * SOAP_FMAC4 soap_in___afip5__FECompConsultar(struct soap *soap, const char *tag, struct __afip5__FECompConsultar *a, const char *type)
{
	size_t soap_flag_afip3__FECompConsultar = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip5__FECompConsultar*)soap_id_enter(soap, "", a, SOAP_TYPE___afip5__FECompConsultar, sizeof(struct __afip5__FECompConsultar), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip5__FECompConsultar(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FECompConsultar && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FECompConsultar(soap, "afip3:FECompConsultar", &a->afip3__FECompConsultar, ""))
				{	soap_flag_afip3__FECompConsultar--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip5__FECompConsultar * SOAP_FMAC2 soap_instantiate___afip5__FECompConsultar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip5__FECompConsultar(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip5__FECompConsultar *p;
	size_t k = sizeof(struct __afip5__FECompConsultar);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip5__FECompConsultar, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip5__FECompConsultar);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip5__FECompConsultar, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip5__FECompConsultar location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip5__FECompConsultar(struct soap *soap, const struct __afip5__FECompConsultar *a, const char *tag, const char *type)
{
	if (soap_out___afip5__FECompConsultar(soap, tag ? tag : "-afip5:FECompConsultar", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FECompConsultar * SOAP_FMAC4 soap_get___afip5__FECompConsultar(struct soap *soap, struct __afip5__FECompConsultar *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip5__FECompConsultar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip5__FECompUltimoAutorizado(struct soap *soap, struct __afip5__FECompUltimoAutorizado *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FECompUltimoAutorizado = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip5__FECompUltimoAutorizado(struct soap *soap, const struct __afip5__FECompUltimoAutorizado *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FECompUltimoAutorizado(soap, &a->afip3__FECompUltimoAutorizado);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip5__FECompUltimoAutorizado(struct soap *soap, const char *tag, int id, const struct __afip5__FECompUltimoAutorizado *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FECompUltimoAutorizado(soap, "afip3:FECompUltimoAutorizado", -1, &a->afip3__FECompUltimoAutorizado, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FECompUltimoAutorizado * SOAP_FMAC4 soap_in___afip5__FECompUltimoAutorizado(struct soap *soap, const char *tag, struct __afip5__FECompUltimoAutorizado *a, const char *type)
{
	size_t soap_flag_afip3__FECompUltimoAutorizado = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip5__FECompUltimoAutorizado*)soap_id_enter(soap, "", a, SOAP_TYPE___afip5__FECompUltimoAutorizado, sizeof(struct __afip5__FECompUltimoAutorizado), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip5__FECompUltimoAutorizado(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FECompUltimoAutorizado && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FECompUltimoAutorizado(soap, "afip3:FECompUltimoAutorizado", &a->afip3__FECompUltimoAutorizado, ""))
				{	soap_flag_afip3__FECompUltimoAutorizado--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip5__FECompUltimoAutorizado * SOAP_FMAC2 soap_instantiate___afip5__FECompUltimoAutorizado(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip5__FECompUltimoAutorizado(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip5__FECompUltimoAutorizado *p;
	size_t k = sizeof(struct __afip5__FECompUltimoAutorizado);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip5__FECompUltimoAutorizado, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip5__FECompUltimoAutorizado);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip5__FECompUltimoAutorizado, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip5__FECompUltimoAutorizado location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip5__FECompUltimoAutorizado(struct soap *soap, const struct __afip5__FECompUltimoAutorizado *a, const char *tag, const char *type)
{
	if (soap_out___afip5__FECompUltimoAutorizado(soap, tag ? tag : "-afip5:FECompUltimoAutorizado", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FECompUltimoAutorizado * SOAP_FMAC4 soap_get___afip5__FECompUltimoAutorizado(struct soap *soap, struct __afip5__FECompUltimoAutorizado *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip5__FECompUltimoAutorizado(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip5__FEDummy(struct soap *soap, struct __afip5__FEDummy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FEDummy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip5__FEDummy(struct soap *soap, const struct __afip5__FEDummy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FEDummy(soap, &a->afip3__FEDummy);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip5__FEDummy(struct soap *soap, const char *tag, int id, const struct __afip5__FEDummy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FEDummy(soap, "afip3:FEDummy", -1, &a->afip3__FEDummy, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FEDummy * SOAP_FMAC4 soap_in___afip5__FEDummy(struct soap *soap, const char *tag, struct __afip5__FEDummy *a, const char *type)
{
	size_t soap_flag_afip3__FEDummy = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip5__FEDummy*)soap_id_enter(soap, "", a, SOAP_TYPE___afip5__FEDummy, sizeof(struct __afip5__FEDummy), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip5__FEDummy(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FEDummy && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FEDummy(soap, "afip3:FEDummy", &a->afip3__FEDummy, ""))
				{	soap_flag_afip3__FEDummy--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip5__FEDummy * SOAP_FMAC2 soap_instantiate___afip5__FEDummy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip5__FEDummy(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip5__FEDummy *p;
	size_t k = sizeof(struct __afip5__FEDummy);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip5__FEDummy, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip5__FEDummy);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip5__FEDummy, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip5__FEDummy location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip5__FEDummy(struct soap *soap, const struct __afip5__FEDummy *a, const char *tag, const char *type)
{
	if (soap_out___afip5__FEDummy(soap, tag ? tag : "-afip5:FEDummy", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FEDummy * SOAP_FMAC4 soap_get___afip5__FEDummy(struct soap *soap, struct __afip5__FEDummy *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip5__FEDummy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip5__FECompTotXRequest(struct soap *soap, struct __afip5__FECompTotXRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FECompTotXRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip5__FECompTotXRequest(struct soap *soap, const struct __afip5__FECompTotXRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FECompTotXRequest(soap, &a->afip3__FECompTotXRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip5__FECompTotXRequest(struct soap *soap, const char *tag, int id, const struct __afip5__FECompTotXRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FECompTotXRequest(soap, "afip3:FECompTotXRequest", -1, &a->afip3__FECompTotXRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FECompTotXRequest * SOAP_FMAC4 soap_in___afip5__FECompTotXRequest(struct soap *soap, const char *tag, struct __afip5__FECompTotXRequest *a, const char *type)
{
	size_t soap_flag_afip3__FECompTotXRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip5__FECompTotXRequest*)soap_id_enter(soap, "", a, SOAP_TYPE___afip5__FECompTotXRequest, sizeof(struct __afip5__FECompTotXRequest), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip5__FECompTotXRequest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FECompTotXRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FECompTotXRequest(soap, "afip3:FECompTotXRequest", &a->afip3__FECompTotXRequest, ""))
				{	soap_flag_afip3__FECompTotXRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip5__FECompTotXRequest * SOAP_FMAC2 soap_instantiate___afip5__FECompTotXRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip5__FECompTotXRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip5__FECompTotXRequest *p;
	size_t k = sizeof(struct __afip5__FECompTotXRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip5__FECompTotXRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip5__FECompTotXRequest);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip5__FECompTotXRequest, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip5__FECompTotXRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip5__FECompTotXRequest(struct soap *soap, const struct __afip5__FECompTotXRequest *a, const char *tag, const char *type)
{
	if (soap_out___afip5__FECompTotXRequest(soap, tag ? tag : "-afip5:FECompTotXRequest", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FECompTotXRequest * SOAP_FMAC4 soap_get___afip5__FECompTotXRequest(struct soap *soap, struct __afip5__FECompTotXRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip5__FECompTotXRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip5__FECAESolicitar(struct soap *soap, struct __afip5__FECAESolicitar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FECAESolicitar = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip5__FECAESolicitar(struct soap *soap, const struct __afip5__FECAESolicitar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FECAESolicitar(soap, &a->afip3__FECAESolicitar);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip5__FECAESolicitar(struct soap *soap, const char *tag, int id, const struct __afip5__FECAESolicitar *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FECAESolicitar(soap, "afip3:FECAESolicitar", -1, &a->afip3__FECAESolicitar, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FECAESolicitar * SOAP_FMAC4 soap_in___afip5__FECAESolicitar(struct soap *soap, const char *tag, struct __afip5__FECAESolicitar *a, const char *type)
{
	size_t soap_flag_afip3__FECAESolicitar = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip5__FECAESolicitar*)soap_id_enter(soap, "", a, SOAP_TYPE___afip5__FECAESolicitar, sizeof(struct __afip5__FECAESolicitar), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip5__FECAESolicitar(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FECAESolicitar && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FECAESolicitar(soap, "afip3:FECAESolicitar", &a->afip3__FECAESolicitar, ""))
				{	soap_flag_afip3__FECAESolicitar--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip5__FECAESolicitar * SOAP_FMAC2 soap_instantiate___afip5__FECAESolicitar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip5__FECAESolicitar(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip5__FECAESolicitar *p;
	size_t k = sizeof(struct __afip5__FECAESolicitar);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip5__FECAESolicitar, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip5__FECAESolicitar);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip5__FECAESolicitar, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip5__FECAESolicitar location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip5__FECAESolicitar(struct soap *soap, const struct __afip5__FECAESolicitar *a, const char *tag, const char *type)
{
	if (soap_out___afip5__FECAESolicitar(soap, tag ? tag : "-afip5:FECAESolicitar", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip5__FECAESolicitar * SOAP_FMAC4 soap_get___afip5__FECAESolicitar(struct soap *soap, struct __afip5__FECAESolicitar *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip5__FECAESolicitar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip4__FEParamGetTiposPaises(struct soap *soap, struct __afip4__FEParamGetTiposPaises *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FEParamGetTiposPaises = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip4__FEParamGetTiposPaises(struct soap *soap, const struct __afip4__FEParamGetTiposPaises *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FEParamGetTiposPaises(soap, &a->afip3__FEParamGetTiposPaises);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip4__FEParamGetTiposPaises(struct soap *soap, const char *tag, int id, const struct __afip4__FEParamGetTiposPaises *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FEParamGetTiposPaises(soap, "afip3:FEParamGetTiposPaises", -1, &a->afip3__FEParamGetTiposPaises, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FEParamGetTiposPaises * SOAP_FMAC4 soap_in___afip4__FEParamGetTiposPaises(struct soap *soap, const char *tag, struct __afip4__FEParamGetTiposPaises *a, const char *type)
{
	size_t soap_flag_afip3__FEParamGetTiposPaises = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip4__FEParamGetTiposPaises*)soap_id_enter(soap, "", a, SOAP_TYPE___afip4__FEParamGetTiposPaises, sizeof(struct __afip4__FEParamGetTiposPaises), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip4__FEParamGetTiposPaises(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FEParamGetTiposPaises && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FEParamGetTiposPaises(soap, "afip3:FEParamGetTiposPaises", &a->afip3__FEParamGetTiposPaises, ""))
				{	soap_flag_afip3__FEParamGetTiposPaises--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip4__FEParamGetTiposPaises * SOAP_FMAC2 soap_instantiate___afip4__FEParamGetTiposPaises(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip4__FEParamGetTiposPaises(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip4__FEParamGetTiposPaises *p;
	size_t k = sizeof(struct __afip4__FEParamGetTiposPaises);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip4__FEParamGetTiposPaises, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip4__FEParamGetTiposPaises);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip4__FEParamGetTiposPaises, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip4__FEParamGetTiposPaises location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip4__FEParamGetTiposPaises(struct soap *soap, const struct __afip4__FEParamGetTiposPaises *a, const char *tag, const char *type)
{
	if (soap_out___afip4__FEParamGetTiposPaises(soap, tag ? tag : "-afip4:FEParamGetTiposPaises", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FEParamGetTiposPaises * SOAP_FMAC4 soap_get___afip4__FEParamGetTiposPaises(struct soap *soap, struct __afip4__FEParamGetTiposPaises *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip4__FEParamGetTiposPaises(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip4__FEParamGetTiposDoc(struct soap *soap, struct __afip4__FEParamGetTiposDoc *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FEParamGetTiposDoc = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip4__FEParamGetTiposDoc(struct soap *soap, const struct __afip4__FEParamGetTiposDoc *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FEParamGetTiposDoc(soap, &a->afip3__FEParamGetTiposDoc);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip4__FEParamGetTiposDoc(struct soap *soap, const char *tag, int id, const struct __afip4__FEParamGetTiposDoc *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FEParamGetTiposDoc(soap, "afip3:FEParamGetTiposDoc", -1, &a->afip3__FEParamGetTiposDoc, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FEParamGetTiposDoc * SOAP_FMAC4 soap_in___afip4__FEParamGetTiposDoc(struct soap *soap, const char *tag, struct __afip4__FEParamGetTiposDoc *a, const char *type)
{
	size_t soap_flag_afip3__FEParamGetTiposDoc = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip4__FEParamGetTiposDoc*)soap_id_enter(soap, "", a, SOAP_TYPE___afip4__FEParamGetTiposDoc, sizeof(struct __afip4__FEParamGetTiposDoc), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip4__FEParamGetTiposDoc(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FEParamGetTiposDoc && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FEParamGetTiposDoc(soap, "afip3:FEParamGetTiposDoc", &a->afip3__FEParamGetTiposDoc, ""))
				{	soap_flag_afip3__FEParamGetTiposDoc--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip4__FEParamGetTiposDoc * SOAP_FMAC2 soap_instantiate___afip4__FEParamGetTiposDoc(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip4__FEParamGetTiposDoc(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip4__FEParamGetTiposDoc *p;
	size_t k = sizeof(struct __afip4__FEParamGetTiposDoc);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip4__FEParamGetTiposDoc, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip4__FEParamGetTiposDoc);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip4__FEParamGetTiposDoc, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip4__FEParamGetTiposDoc location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip4__FEParamGetTiposDoc(struct soap *soap, const struct __afip4__FEParamGetTiposDoc *a, const char *tag, const char *type)
{
	if (soap_out___afip4__FEParamGetTiposDoc(soap, tag ? tag : "-afip4:FEParamGetTiposDoc", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FEParamGetTiposDoc * SOAP_FMAC4 soap_get___afip4__FEParamGetTiposDoc(struct soap *soap, struct __afip4__FEParamGetTiposDoc *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip4__FEParamGetTiposDoc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip4__FEParamGetTiposCbte(struct soap *soap, struct __afip4__FEParamGetTiposCbte *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FEParamGetTiposCbte = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip4__FEParamGetTiposCbte(struct soap *soap, const struct __afip4__FEParamGetTiposCbte *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FEParamGetTiposCbte(soap, &a->afip3__FEParamGetTiposCbte);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip4__FEParamGetTiposCbte(struct soap *soap, const char *tag, int id, const struct __afip4__FEParamGetTiposCbte *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FEParamGetTiposCbte(soap, "afip3:FEParamGetTiposCbte", -1, &a->afip3__FEParamGetTiposCbte, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FEParamGetTiposCbte * SOAP_FMAC4 soap_in___afip4__FEParamGetTiposCbte(struct soap *soap, const char *tag, struct __afip4__FEParamGetTiposCbte *a, const char *type)
{
	size_t soap_flag_afip3__FEParamGetTiposCbte = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip4__FEParamGetTiposCbte*)soap_id_enter(soap, "", a, SOAP_TYPE___afip4__FEParamGetTiposCbte, sizeof(struct __afip4__FEParamGetTiposCbte), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip4__FEParamGetTiposCbte(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FEParamGetTiposCbte && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FEParamGetTiposCbte(soap, "afip3:FEParamGetTiposCbte", &a->afip3__FEParamGetTiposCbte, ""))
				{	soap_flag_afip3__FEParamGetTiposCbte--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip4__FEParamGetTiposCbte * SOAP_FMAC2 soap_instantiate___afip4__FEParamGetTiposCbte(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip4__FEParamGetTiposCbte(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip4__FEParamGetTiposCbte *p;
	size_t k = sizeof(struct __afip4__FEParamGetTiposCbte);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip4__FEParamGetTiposCbte, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip4__FEParamGetTiposCbte);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip4__FEParamGetTiposCbte, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip4__FEParamGetTiposCbte location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip4__FEParamGetTiposCbte(struct soap *soap, const struct __afip4__FEParamGetTiposCbte *a, const char *tag, const char *type)
{
	if (soap_out___afip4__FEParamGetTiposCbte(soap, tag ? tag : "-afip4:FEParamGetTiposCbte", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FEParamGetTiposCbte * SOAP_FMAC4 soap_get___afip4__FEParamGetTiposCbte(struct soap *soap, struct __afip4__FEParamGetTiposCbte *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip4__FEParamGetTiposCbte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip4__FEParamGetPtosVenta(struct soap *soap, struct __afip4__FEParamGetPtosVenta *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FEParamGetPtosVenta = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip4__FEParamGetPtosVenta(struct soap *soap, const struct __afip4__FEParamGetPtosVenta *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FEParamGetPtosVenta(soap, &a->afip3__FEParamGetPtosVenta);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip4__FEParamGetPtosVenta(struct soap *soap, const char *tag, int id, const struct __afip4__FEParamGetPtosVenta *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FEParamGetPtosVenta(soap, "afip3:FEParamGetPtosVenta", -1, &a->afip3__FEParamGetPtosVenta, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FEParamGetPtosVenta * SOAP_FMAC4 soap_in___afip4__FEParamGetPtosVenta(struct soap *soap, const char *tag, struct __afip4__FEParamGetPtosVenta *a, const char *type)
{
	size_t soap_flag_afip3__FEParamGetPtosVenta = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip4__FEParamGetPtosVenta*)soap_id_enter(soap, "", a, SOAP_TYPE___afip4__FEParamGetPtosVenta, sizeof(struct __afip4__FEParamGetPtosVenta), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip4__FEParamGetPtosVenta(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FEParamGetPtosVenta && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FEParamGetPtosVenta(soap, "afip3:FEParamGetPtosVenta", &a->afip3__FEParamGetPtosVenta, ""))
				{	soap_flag_afip3__FEParamGetPtosVenta--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip4__FEParamGetPtosVenta * SOAP_FMAC2 soap_instantiate___afip4__FEParamGetPtosVenta(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip4__FEParamGetPtosVenta(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip4__FEParamGetPtosVenta *p;
	size_t k = sizeof(struct __afip4__FEParamGetPtosVenta);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip4__FEParamGetPtosVenta, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip4__FEParamGetPtosVenta);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip4__FEParamGetPtosVenta, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip4__FEParamGetPtosVenta location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip4__FEParamGetPtosVenta(struct soap *soap, const struct __afip4__FEParamGetPtosVenta *a, const char *tag, const char *type)
{
	if (soap_out___afip4__FEParamGetPtosVenta(soap, tag ? tag : "-afip4:FEParamGetPtosVenta", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FEParamGetPtosVenta * SOAP_FMAC4 soap_get___afip4__FEParamGetPtosVenta(struct soap *soap, struct __afip4__FEParamGetPtosVenta *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip4__FEParamGetPtosVenta(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip4__FEParamGetTiposConcepto(struct soap *soap, struct __afip4__FEParamGetTiposConcepto *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FEParamGetTiposConcepto = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip4__FEParamGetTiposConcepto(struct soap *soap, const struct __afip4__FEParamGetTiposConcepto *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FEParamGetTiposConcepto(soap, &a->afip3__FEParamGetTiposConcepto);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip4__FEParamGetTiposConcepto(struct soap *soap, const char *tag, int id, const struct __afip4__FEParamGetTiposConcepto *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FEParamGetTiposConcepto(soap, "afip3:FEParamGetTiposConcepto", -1, &a->afip3__FEParamGetTiposConcepto, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FEParamGetTiposConcepto * SOAP_FMAC4 soap_in___afip4__FEParamGetTiposConcepto(struct soap *soap, const char *tag, struct __afip4__FEParamGetTiposConcepto *a, const char *type)
{
	size_t soap_flag_afip3__FEParamGetTiposConcepto = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip4__FEParamGetTiposConcepto*)soap_id_enter(soap, "", a, SOAP_TYPE___afip4__FEParamGetTiposConcepto, sizeof(struct __afip4__FEParamGetTiposConcepto), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip4__FEParamGetTiposConcepto(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FEParamGetTiposConcepto && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FEParamGetTiposConcepto(soap, "afip3:FEParamGetTiposConcepto", &a->afip3__FEParamGetTiposConcepto, ""))
				{	soap_flag_afip3__FEParamGetTiposConcepto--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip4__FEParamGetTiposConcepto * SOAP_FMAC2 soap_instantiate___afip4__FEParamGetTiposConcepto(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip4__FEParamGetTiposConcepto(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip4__FEParamGetTiposConcepto *p;
	size_t k = sizeof(struct __afip4__FEParamGetTiposConcepto);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip4__FEParamGetTiposConcepto, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip4__FEParamGetTiposConcepto);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip4__FEParamGetTiposConcepto, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip4__FEParamGetTiposConcepto location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip4__FEParamGetTiposConcepto(struct soap *soap, const struct __afip4__FEParamGetTiposConcepto *a, const char *tag, const char *type)
{
	if (soap_out___afip4__FEParamGetTiposConcepto(soap, tag ? tag : "-afip4:FEParamGetTiposConcepto", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FEParamGetTiposConcepto * SOAP_FMAC4 soap_get___afip4__FEParamGetTiposConcepto(struct soap *soap, struct __afip4__FEParamGetTiposConcepto *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip4__FEParamGetTiposConcepto(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip4__FEParamGetTiposOpcional(struct soap *soap, struct __afip4__FEParamGetTiposOpcional *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FEParamGetTiposOpcional = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip4__FEParamGetTiposOpcional(struct soap *soap, const struct __afip4__FEParamGetTiposOpcional *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FEParamGetTiposOpcional(soap, &a->afip3__FEParamGetTiposOpcional);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip4__FEParamGetTiposOpcional(struct soap *soap, const char *tag, int id, const struct __afip4__FEParamGetTiposOpcional *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FEParamGetTiposOpcional(soap, "afip3:FEParamGetTiposOpcional", -1, &a->afip3__FEParamGetTiposOpcional, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FEParamGetTiposOpcional * SOAP_FMAC4 soap_in___afip4__FEParamGetTiposOpcional(struct soap *soap, const char *tag, struct __afip4__FEParamGetTiposOpcional *a, const char *type)
{
	size_t soap_flag_afip3__FEParamGetTiposOpcional = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip4__FEParamGetTiposOpcional*)soap_id_enter(soap, "", a, SOAP_TYPE___afip4__FEParamGetTiposOpcional, sizeof(struct __afip4__FEParamGetTiposOpcional), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip4__FEParamGetTiposOpcional(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FEParamGetTiposOpcional && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FEParamGetTiposOpcional(soap, "afip3:FEParamGetTiposOpcional", &a->afip3__FEParamGetTiposOpcional, ""))
				{	soap_flag_afip3__FEParamGetTiposOpcional--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip4__FEParamGetTiposOpcional * SOAP_FMAC2 soap_instantiate___afip4__FEParamGetTiposOpcional(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip4__FEParamGetTiposOpcional(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip4__FEParamGetTiposOpcional *p;
	size_t k = sizeof(struct __afip4__FEParamGetTiposOpcional);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip4__FEParamGetTiposOpcional, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip4__FEParamGetTiposOpcional);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip4__FEParamGetTiposOpcional, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip4__FEParamGetTiposOpcional location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip4__FEParamGetTiposOpcional(struct soap *soap, const struct __afip4__FEParamGetTiposOpcional *a, const char *tag, const char *type)
{
	if (soap_out___afip4__FEParamGetTiposOpcional(soap, tag ? tag : "-afip4:FEParamGetTiposOpcional", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FEParamGetTiposOpcional * SOAP_FMAC4 soap_get___afip4__FEParamGetTiposOpcional(struct soap *soap, struct __afip4__FEParamGetTiposOpcional *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip4__FEParamGetTiposOpcional(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip4__FEParamGetTiposIva(struct soap *soap, struct __afip4__FEParamGetTiposIva *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FEParamGetTiposIva = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip4__FEParamGetTiposIva(struct soap *soap, const struct __afip4__FEParamGetTiposIva *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FEParamGetTiposIva(soap, &a->afip3__FEParamGetTiposIva);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip4__FEParamGetTiposIva(struct soap *soap, const char *tag, int id, const struct __afip4__FEParamGetTiposIva *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FEParamGetTiposIva(soap, "afip3:FEParamGetTiposIva", -1, &a->afip3__FEParamGetTiposIva, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FEParamGetTiposIva * SOAP_FMAC4 soap_in___afip4__FEParamGetTiposIva(struct soap *soap, const char *tag, struct __afip4__FEParamGetTiposIva *a, const char *type)
{
	size_t soap_flag_afip3__FEParamGetTiposIva = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip4__FEParamGetTiposIva*)soap_id_enter(soap, "", a, SOAP_TYPE___afip4__FEParamGetTiposIva, sizeof(struct __afip4__FEParamGetTiposIva), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip4__FEParamGetTiposIva(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FEParamGetTiposIva && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FEParamGetTiposIva(soap, "afip3:FEParamGetTiposIva", &a->afip3__FEParamGetTiposIva, ""))
				{	soap_flag_afip3__FEParamGetTiposIva--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip4__FEParamGetTiposIva * SOAP_FMAC2 soap_instantiate___afip4__FEParamGetTiposIva(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip4__FEParamGetTiposIva(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip4__FEParamGetTiposIva *p;
	size_t k = sizeof(struct __afip4__FEParamGetTiposIva);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip4__FEParamGetTiposIva, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip4__FEParamGetTiposIva);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip4__FEParamGetTiposIva, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip4__FEParamGetTiposIva location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip4__FEParamGetTiposIva(struct soap *soap, const struct __afip4__FEParamGetTiposIva *a, const char *tag, const char *type)
{
	if (soap_out___afip4__FEParamGetTiposIva(soap, tag ? tag : "-afip4:FEParamGetTiposIva", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FEParamGetTiposIva * SOAP_FMAC4 soap_get___afip4__FEParamGetTiposIva(struct soap *soap, struct __afip4__FEParamGetTiposIva *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip4__FEParamGetTiposIva(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip4__FEParamGetTiposMonedas(struct soap *soap, struct __afip4__FEParamGetTiposMonedas *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FEParamGetTiposMonedas = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip4__FEParamGetTiposMonedas(struct soap *soap, const struct __afip4__FEParamGetTiposMonedas *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FEParamGetTiposMonedas(soap, &a->afip3__FEParamGetTiposMonedas);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip4__FEParamGetTiposMonedas(struct soap *soap, const char *tag, int id, const struct __afip4__FEParamGetTiposMonedas *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FEParamGetTiposMonedas(soap, "afip3:FEParamGetTiposMonedas", -1, &a->afip3__FEParamGetTiposMonedas, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FEParamGetTiposMonedas * SOAP_FMAC4 soap_in___afip4__FEParamGetTiposMonedas(struct soap *soap, const char *tag, struct __afip4__FEParamGetTiposMonedas *a, const char *type)
{
	size_t soap_flag_afip3__FEParamGetTiposMonedas = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip4__FEParamGetTiposMonedas*)soap_id_enter(soap, "", a, SOAP_TYPE___afip4__FEParamGetTiposMonedas, sizeof(struct __afip4__FEParamGetTiposMonedas), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip4__FEParamGetTiposMonedas(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FEParamGetTiposMonedas && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FEParamGetTiposMonedas(soap, "afip3:FEParamGetTiposMonedas", &a->afip3__FEParamGetTiposMonedas, ""))
				{	soap_flag_afip3__FEParamGetTiposMonedas--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip4__FEParamGetTiposMonedas * SOAP_FMAC2 soap_instantiate___afip4__FEParamGetTiposMonedas(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip4__FEParamGetTiposMonedas(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip4__FEParamGetTiposMonedas *p;
	size_t k = sizeof(struct __afip4__FEParamGetTiposMonedas);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip4__FEParamGetTiposMonedas, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip4__FEParamGetTiposMonedas);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip4__FEParamGetTiposMonedas, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip4__FEParamGetTiposMonedas location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip4__FEParamGetTiposMonedas(struct soap *soap, const struct __afip4__FEParamGetTiposMonedas *a, const char *tag, const char *type)
{
	if (soap_out___afip4__FEParamGetTiposMonedas(soap, tag ? tag : "-afip4:FEParamGetTiposMonedas", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FEParamGetTiposMonedas * SOAP_FMAC4 soap_get___afip4__FEParamGetTiposMonedas(struct soap *soap, struct __afip4__FEParamGetTiposMonedas *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip4__FEParamGetTiposMonedas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip4__FEParamGetTiposTributos(struct soap *soap, struct __afip4__FEParamGetTiposTributos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FEParamGetTiposTributos = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip4__FEParamGetTiposTributos(struct soap *soap, const struct __afip4__FEParamGetTiposTributos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FEParamGetTiposTributos(soap, &a->afip3__FEParamGetTiposTributos);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip4__FEParamGetTiposTributos(struct soap *soap, const char *tag, int id, const struct __afip4__FEParamGetTiposTributos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FEParamGetTiposTributos(soap, "afip3:FEParamGetTiposTributos", -1, &a->afip3__FEParamGetTiposTributos, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FEParamGetTiposTributos * SOAP_FMAC4 soap_in___afip4__FEParamGetTiposTributos(struct soap *soap, const char *tag, struct __afip4__FEParamGetTiposTributos *a, const char *type)
{
	size_t soap_flag_afip3__FEParamGetTiposTributos = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip4__FEParamGetTiposTributos*)soap_id_enter(soap, "", a, SOAP_TYPE___afip4__FEParamGetTiposTributos, sizeof(struct __afip4__FEParamGetTiposTributos), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip4__FEParamGetTiposTributos(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FEParamGetTiposTributos && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FEParamGetTiposTributos(soap, "afip3:FEParamGetTiposTributos", &a->afip3__FEParamGetTiposTributos, ""))
				{	soap_flag_afip3__FEParamGetTiposTributos--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip4__FEParamGetTiposTributos * SOAP_FMAC2 soap_instantiate___afip4__FEParamGetTiposTributos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip4__FEParamGetTiposTributos(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip4__FEParamGetTiposTributos *p;
	size_t k = sizeof(struct __afip4__FEParamGetTiposTributos);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip4__FEParamGetTiposTributos, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip4__FEParamGetTiposTributos);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip4__FEParamGetTiposTributos, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip4__FEParamGetTiposTributos location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip4__FEParamGetTiposTributos(struct soap *soap, const struct __afip4__FEParamGetTiposTributos *a, const char *tag, const char *type)
{
	if (soap_out___afip4__FEParamGetTiposTributos(soap, tag ? tag : "-afip4:FEParamGetTiposTributos", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FEParamGetTiposTributos * SOAP_FMAC4 soap_get___afip4__FEParamGetTiposTributos(struct soap *soap, struct __afip4__FEParamGetTiposTributos *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip4__FEParamGetTiposTributos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip4__FEParamGetCotizacion(struct soap *soap, struct __afip4__FEParamGetCotizacion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FEParamGetCotizacion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip4__FEParamGetCotizacion(struct soap *soap, const struct __afip4__FEParamGetCotizacion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FEParamGetCotizacion(soap, &a->afip3__FEParamGetCotizacion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip4__FEParamGetCotizacion(struct soap *soap, const char *tag, int id, const struct __afip4__FEParamGetCotizacion *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FEParamGetCotizacion(soap, "afip3:FEParamGetCotizacion", -1, &a->afip3__FEParamGetCotizacion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FEParamGetCotizacion * SOAP_FMAC4 soap_in___afip4__FEParamGetCotizacion(struct soap *soap, const char *tag, struct __afip4__FEParamGetCotizacion *a, const char *type)
{
	size_t soap_flag_afip3__FEParamGetCotizacion = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip4__FEParamGetCotizacion*)soap_id_enter(soap, "", a, SOAP_TYPE___afip4__FEParamGetCotizacion, sizeof(struct __afip4__FEParamGetCotizacion), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip4__FEParamGetCotizacion(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FEParamGetCotizacion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FEParamGetCotizacion(soap, "afip3:FEParamGetCotizacion", &a->afip3__FEParamGetCotizacion, ""))
				{	soap_flag_afip3__FEParamGetCotizacion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip4__FEParamGetCotizacion * SOAP_FMAC2 soap_instantiate___afip4__FEParamGetCotizacion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip4__FEParamGetCotizacion(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip4__FEParamGetCotizacion *p;
	size_t k = sizeof(struct __afip4__FEParamGetCotizacion);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip4__FEParamGetCotizacion, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip4__FEParamGetCotizacion);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip4__FEParamGetCotizacion, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip4__FEParamGetCotizacion location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip4__FEParamGetCotizacion(struct soap *soap, const struct __afip4__FEParamGetCotizacion *a, const char *tag, const char *type)
{
	if (soap_out___afip4__FEParamGetCotizacion(soap, tag ? tag : "-afip4:FEParamGetCotizacion", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FEParamGetCotizacion * SOAP_FMAC4 soap_get___afip4__FEParamGetCotizacion(struct soap *soap, struct __afip4__FEParamGetCotizacion *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip4__FEParamGetCotizacion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip4__FECAEAConsultar(struct soap *soap, struct __afip4__FECAEAConsultar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FECAEAConsultar = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip4__FECAEAConsultar(struct soap *soap, const struct __afip4__FECAEAConsultar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FECAEAConsultar(soap, &a->afip3__FECAEAConsultar);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip4__FECAEAConsultar(struct soap *soap, const char *tag, int id, const struct __afip4__FECAEAConsultar *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FECAEAConsultar(soap, "afip3:FECAEAConsultar", -1, &a->afip3__FECAEAConsultar, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FECAEAConsultar * SOAP_FMAC4 soap_in___afip4__FECAEAConsultar(struct soap *soap, const char *tag, struct __afip4__FECAEAConsultar *a, const char *type)
{
	size_t soap_flag_afip3__FECAEAConsultar = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip4__FECAEAConsultar*)soap_id_enter(soap, "", a, SOAP_TYPE___afip4__FECAEAConsultar, sizeof(struct __afip4__FECAEAConsultar), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip4__FECAEAConsultar(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FECAEAConsultar && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FECAEAConsultar(soap, "afip3:FECAEAConsultar", &a->afip3__FECAEAConsultar, ""))
				{	soap_flag_afip3__FECAEAConsultar--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip4__FECAEAConsultar * SOAP_FMAC2 soap_instantiate___afip4__FECAEAConsultar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip4__FECAEAConsultar(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip4__FECAEAConsultar *p;
	size_t k = sizeof(struct __afip4__FECAEAConsultar);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip4__FECAEAConsultar, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip4__FECAEAConsultar);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip4__FECAEAConsultar, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip4__FECAEAConsultar location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip4__FECAEAConsultar(struct soap *soap, const struct __afip4__FECAEAConsultar *a, const char *tag, const char *type)
{
	if (soap_out___afip4__FECAEAConsultar(soap, tag ? tag : "-afip4:FECAEAConsultar", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FECAEAConsultar * SOAP_FMAC4 soap_get___afip4__FECAEAConsultar(struct soap *soap, struct __afip4__FECAEAConsultar *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip4__FECAEAConsultar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip4__FECAEASinMovimientoInformar(struct soap *soap, struct __afip4__FECAEASinMovimientoInformar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FECAEASinMovimientoInformar = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip4__FECAEASinMovimientoInformar(struct soap *soap, const struct __afip4__FECAEASinMovimientoInformar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FECAEASinMovimientoInformar(soap, &a->afip3__FECAEASinMovimientoInformar);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip4__FECAEASinMovimientoInformar(struct soap *soap, const char *tag, int id, const struct __afip4__FECAEASinMovimientoInformar *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FECAEASinMovimientoInformar(soap, "afip3:FECAEASinMovimientoInformar", -1, &a->afip3__FECAEASinMovimientoInformar, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FECAEASinMovimientoInformar * SOAP_FMAC4 soap_in___afip4__FECAEASinMovimientoInformar(struct soap *soap, const char *tag, struct __afip4__FECAEASinMovimientoInformar *a, const char *type)
{
	size_t soap_flag_afip3__FECAEASinMovimientoInformar = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip4__FECAEASinMovimientoInformar*)soap_id_enter(soap, "", a, SOAP_TYPE___afip4__FECAEASinMovimientoInformar, sizeof(struct __afip4__FECAEASinMovimientoInformar), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip4__FECAEASinMovimientoInformar(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FECAEASinMovimientoInformar && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FECAEASinMovimientoInformar(soap, "afip3:FECAEASinMovimientoInformar", &a->afip3__FECAEASinMovimientoInformar, ""))
				{	soap_flag_afip3__FECAEASinMovimientoInformar--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip4__FECAEASinMovimientoInformar * SOAP_FMAC2 soap_instantiate___afip4__FECAEASinMovimientoInformar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip4__FECAEASinMovimientoInformar(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip4__FECAEASinMovimientoInformar *p;
	size_t k = sizeof(struct __afip4__FECAEASinMovimientoInformar);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip4__FECAEASinMovimientoInformar, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip4__FECAEASinMovimientoInformar);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip4__FECAEASinMovimientoInformar, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip4__FECAEASinMovimientoInformar location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip4__FECAEASinMovimientoInformar(struct soap *soap, const struct __afip4__FECAEASinMovimientoInformar *a, const char *tag, const char *type)
{
	if (soap_out___afip4__FECAEASinMovimientoInformar(soap, tag ? tag : "-afip4:FECAEASinMovimientoInformar", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FECAEASinMovimientoInformar * SOAP_FMAC4 soap_get___afip4__FECAEASinMovimientoInformar(struct soap *soap, struct __afip4__FECAEASinMovimientoInformar *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip4__FECAEASinMovimientoInformar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip4__FECAEASinMovimientoConsultar(struct soap *soap, struct __afip4__FECAEASinMovimientoConsultar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FECAEASinMovimientoConsultar = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip4__FECAEASinMovimientoConsultar(struct soap *soap, const struct __afip4__FECAEASinMovimientoConsultar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FECAEASinMovimientoConsultar(soap, &a->afip3__FECAEASinMovimientoConsultar);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip4__FECAEASinMovimientoConsultar(struct soap *soap, const char *tag, int id, const struct __afip4__FECAEASinMovimientoConsultar *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FECAEASinMovimientoConsultar(soap, "afip3:FECAEASinMovimientoConsultar", -1, &a->afip3__FECAEASinMovimientoConsultar, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FECAEASinMovimientoConsultar * SOAP_FMAC4 soap_in___afip4__FECAEASinMovimientoConsultar(struct soap *soap, const char *tag, struct __afip4__FECAEASinMovimientoConsultar *a, const char *type)
{
	size_t soap_flag_afip3__FECAEASinMovimientoConsultar = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip4__FECAEASinMovimientoConsultar*)soap_id_enter(soap, "", a, SOAP_TYPE___afip4__FECAEASinMovimientoConsultar, sizeof(struct __afip4__FECAEASinMovimientoConsultar), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip4__FECAEASinMovimientoConsultar(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FECAEASinMovimientoConsultar && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FECAEASinMovimientoConsultar(soap, "afip3:FECAEASinMovimientoConsultar", &a->afip3__FECAEASinMovimientoConsultar, ""))
				{	soap_flag_afip3__FECAEASinMovimientoConsultar--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip4__FECAEASinMovimientoConsultar * SOAP_FMAC2 soap_instantiate___afip4__FECAEASinMovimientoConsultar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip4__FECAEASinMovimientoConsultar(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip4__FECAEASinMovimientoConsultar *p;
	size_t k = sizeof(struct __afip4__FECAEASinMovimientoConsultar);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip4__FECAEASinMovimientoConsultar, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip4__FECAEASinMovimientoConsultar);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip4__FECAEASinMovimientoConsultar, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip4__FECAEASinMovimientoConsultar location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip4__FECAEASinMovimientoConsultar(struct soap *soap, const struct __afip4__FECAEASinMovimientoConsultar *a, const char *tag, const char *type)
{
	if (soap_out___afip4__FECAEASinMovimientoConsultar(soap, tag ? tag : "-afip4:FECAEASinMovimientoConsultar", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FECAEASinMovimientoConsultar * SOAP_FMAC4 soap_get___afip4__FECAEASinMovimientoConsultar(struct soap *soap, struct __afip4__FECAEASinMovimientoConsultar *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip4__FECAEASinMovimientoConsultar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip4__FECAEASolicitar(struct soap *soap, struct __afip4__FECAEASolicitar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FECAEASolicitar = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip4__FECAEASolicitar(struct soap *soap, const struct __afip4__FECAEASolicitar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FECAEASolicitar(soap, &a->afip3__FECAEASolicitar);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip4__FECAEASolicitar(struct soap *soap, const char *tag, int id, const struct __afip4__FECAEASolicitar *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FECAEASolicitar(soap, "afip3:FECAEASolicitar", -1, &a->afip3__FECAEASolicitar, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FECAEASolicitar * SOAP_FMAC4 soap_in___afip4__FECAEASolicitar(struct soap *soap, const char *tag, struct __afip4__FECAEASolicitar *a, const char *type)
{
	size_t soap_flag_afip3__FECAEASolicitar = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip4__FECAEASolicitar*)soap_id_enter(soap, "", a, SOAP_TYPE___afip4__FECAEASolicitar, sizeof(struct __afip4__FECAEASolicitar), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip4__FECAEASolicitar(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FECAEASolicitar && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FECAEASolicitar(soap, "afip3:FECAEASolicitar", &a->afip3__FECAEASolicitar, ""))
				{	soap_flag_afip3__FECAEASolicitar--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip4__FECAEASolicitar * SOAP_FMAC2 soap_instantiate___afip4__FECAEASolicitar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip4__FECAEASolicitar(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip4__FECAEASolicitar *p;
	size_t k = sizeof(struct __afip4__FECAEASolicitar);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip4__FECAEASolicitar, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip4__FECAEASolicitar);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip4__FECAEASolicitar, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip4__FECAEASolicitar location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip4__FECAEASolicitar(struct soap *soap, const struct __afip4__FECAEASolicitar *a, const char *tag, const char *type)
{
	if (soap_out___afip4__FECAEASolicitar(soap, tag ? tag : "-afip4:FECAEASolicitar", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FECAEASolicitar * SOAP_FMAC4 soap_get___afip4__FECAEASolicitar(struct soap *soap, struct __afip4__FECAEASolicitar *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip4__FECAEASolicitar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip4__FECAEARegInformativo(struct soap *soap, struct __afip4__FECAEARegInformativo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FECAEARegInformativo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip4__FECAEARegInformativo(struct soap *soap, const struct __afip4__FECAEARegInformativo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FECAEARegInformativo(soap, &a->afip3__FECAEARegInformativo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip4__FECAEARegInformativo(struct soap *soap, const char *tag, int id, const struct __afip4__FECAEARegInformativo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FECAEARegInformativo(soap, "afip3:FECAEARegInformativo", -1, &a->afip3__FECAEARegInformativo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FECAEARegInformativo * SOAP_FMAC4 soap_in___afip4__FECAEARegInformativo(struct soap *soap, const char *tag, struct __afip4__FECAEARegInformativo *a, const char *type)
{
	size_t soap_flag_afip3__FECAEARegInformativo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip4__FECAEARegInformativo*)soap_id_enter(soap, "", a, SOAP_TYPE___afip4__FECAEARegInformativo, sizeof(struct __afip4__FECAEARegInformativo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip4__FECAEARegInformativo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FECAEARegInformativo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FECAEARegInformativo(soap, "afip3:FECAEARegInformativo", &a->afip3__FECAEARegInformativo, ""))
				{	soap_flag_afip3__FECAEARegInformativo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip4__FECAEARegInformativo * SOAP_FMAC2 soap_instantiate___afip4__FECAEARegInformativo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip4__FECAEARegInformativo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip4__FECAEARegInformativo *p;
	size_t k = sizeof(struct __afip4__FECAEARegInformativo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip4__FECAEARegInformativo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip4__FECAEARegInformativo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip4__FECAEARegInformativo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip4__FECAEARegInformativo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip4__FECAEARegInformativo(struct soap *soap, const struct __afip4__FECAEARegInformativo *a, const char *tag, const char *type)
{
	if (soap_out___afip4__FECAEARegInformativo(soap, tag ? tag : "-afip4:FECAEARegInformativo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FECAEARegInformativo * SOAP_FMAC4 soap_get___afip4__FECAEARegInformativo(struct soap *soap, struct __afip4__FECAEARegInformativo *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip4__FECAEARegInformativo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip4__FECompConsultar(struct soap *soap, struct __afip4__FECompConsultar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FECompConsultar = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip4__FECompConsultar(struct soap *soap, const struct __afip4__FECompConsultar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FECompConsultar(soap, &a->afip3__FECompConsultar);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip4__FECompConsultar(struct soap *soap, const char *tag, int id, const struct __afip4__FECompConsultar *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FECompConsultar(soap, "afip3:FECompConsultar", -1, &a->afip3__FECompConsultar, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FECompConsultar * SOAP_FMAC4 soap_in___afip4__FECompConsultar(struct soap *soap, const char *tag, struct __afip4__FECompConsultar *a, const char *type)
{
	size_t soap_flag_afip3__FECompConsultar = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip4__FECompConsultar*)soap_id_enter(soap, "", a, SOAP_TYPE___afip4__FECompConsultar, sizeof(struct __afip4__FECompConsultar), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip4__FECompConsultar(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FECompConsultar && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FECompConsultar(soap, "afip3:FECompConsultar", &a->afip3__FECompConsultar, ""))
				{	soap_flag_afip3__FECompConsultar--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip4__FECompConsultar * SOAP_FMAC2 soap_instantiate___afip4__FECompConsultar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip4__FECompConsultar(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip4__FECompConsultar *p;
	size_t k = sizeof(struct __afip4__FECompConsultar);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip4__FECompConsultar, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip4__FECompConsultar);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip4__FECompConsultar, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip4__FECompConsultar location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip4__FECompConsultar(struct soap *soap, const struct __afip4__FECompConsultar *a, const char *tag, const char *type)
{
	if (soap_out___afip4__FECompConsultar(soap, tag ? tag : "-afip4:FECompConsultar", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FECompConsultar * SOAP_FMAC4 soap_get___afip4__FECompConsultar(struct soap *soap, struct __afip4__FECompConsultar *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip4__FECompConsultar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip4__FECompUltimoAutorizado(struct soap *soap, struct __afip4__FECompUltimoAutorizado *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FECompUltimoAutorizado = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip4__FECompUltimoAutorizado(struct soap *soap, const struct __afip4__FECompUltimoAutorizado *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FECompUltimoAutorizado(soap, &a->afip3__FECompUltimoAutorizado);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip4__FECompUltimoAutorizado(struct soap *soap, const char *tag, int id, const struct __afip4__FECompUltimoAutorizado *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FECompUltimoAutorizado(soap, "afip3:FECompUltimoAutorizado", -1, &a->afip3__FECompUltimoAutorizado, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FECompUltimoAutorizado * SOAP_FMAC4 soap_in___afip4__FECompUltimoAutorizado(struct soap *soap, const char *tag, struct __afip4__FECompUltimoAutorizado *a, const char *type)
{
	size_t soap_flag_afip3__FECompUltimoAutorizado = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip4__FECompUltimoAutorizado*)soap_id_enter(soap, "", a, SOAP_TYPE___afip4__FECompUltimoAutorizado, sizeof(struct __afip4__FECompUltimoAutorizado), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip4__FECompUltimoAutorizado(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FECompUltimoAutorizado && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FECompUltimoAutorizado(soap, "afip3:FECompUltimoAutorizado", &a->afip3__FECompUltimoAutorizado, ""))
				{	soap_flag_afip3__FECompUltimoAutorizado--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip4__FECompUltimoAutorizado * SOAP_FMAC2 soap_instantiate___afip4__FECompUltimoAutorizado(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip4__FECompUltimoAutorizado(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip4__FECompUltimoAutorizado *p;
	size_t k = sizeof(struct __afip4__FECompUltimoAutorizado);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip4__FECompUltimoAutorizado, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip4__FECompUltimoAutorizado);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip4__FECompUltimoAutorizado, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip4__FECompUltimoAutorizado location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip4__FECompUltimoAutorizado(struct soap *soap, const struct __afip4__FECompUltimoAutorizado *a, const char *tag, const char *type)
{
	if (soap_out___afip4__FECompUltimoAutorizado(soap, tag ? tag : "-afip4:FECompUltimoAutorizado", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FECompUltimoAutorizado * SOAP_FMAC4 soap_get___afip4__FECompUltimoAutorizado(struct soap *soap, struct __afip4__FECompUltimoAutorizado *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip4__FECompUltimoAutorizado(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip4__FEDummy(struct soap *soap, struct __afip4__FEDummy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FEDummy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip4__FEDummy(struct soap *soap, const struct __afip4__FEDummy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FEDummy(soap, &a->afip3__FEDummy);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip4__FEDummy(struct soap *soap, const char *tag, int id, const struct __afip4__FEDummy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FEDummy(soap, "afip3:FEDummy", -1, &a->afip3__FEDummy, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FEDummy * SOAP_FMAC4 soap_in___afip4__FEDummy(struct soap *soap, const char *tag, struct __afip4__FEDummy *a, const char *type)
{
	size_t soap_flag_afip3__FEDummy = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip4__FEDummy*)soap_id_enter(soap, "", a, SOAP_TYPE___afip4__FEDummy, sizeof(struct __afip4__FEDummy), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip4__FEDummy(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FEDummy && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FEDummy(soap, "afip3:FEDummy", &a->afip3__FEDummy, ""))
				{	soap_flag_afip3__FEDummy--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip4__FEDummy * SOAP_FMAC2 soap_instantiate___afip4__FEDummy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip4__FEDummy(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip4__FEDummy *p;
	size_t k = sizeof(struct __afip4__FEDummy);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip4__FEDummy, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip4__FEDummy);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip4__FEDummy, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip4__FEDummy location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip4__FEDummy(struct soap *soap, const struct __afip4__FEDummy *a, const char *tag, const char *type)
{
	if (soap_out___afip4__FEDummy(soap, tag ? tag : "-afip4:FEDummy", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FEDummy * SOAP_FMAC4 soap_get___afip4__FEDummy(struct soap *soap, struct __afip4__FEDummy *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip4__FEDummy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip4__FECompTotXRequest(struct soap *soap, struct __afip4__FECompTotXRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FECompTotXRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip4__FECompTotXRequest(struct soap *soap, const struct __afip4__FECompTotXRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FECompTotXRequest(soap, &a->afip3__FECompTotXRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip4__FECompTotXRequest(struct soap *soap, const char *tag, int id, const struct __afip4__FECompTotXRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FECompTotXRequest(soap, "afip3:FECompTotXRequest", -1, &a->afip3__FECompTotXRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FECompTotXRequest * SOAP_FMAC4 soap_in___afip4__FECompTotXRequest(struct soap *soap, const char *tag, struct __afip4__FECompTotXRequest *a, const char *type)
{
	size_t soap_flag_afip3__FECompTotXRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip4__FECompTotXRequest*)soap_id_enter(soap, "", a, SOAP_TYPE___afip4__FECompTotXRequest, sizeof(struct __afip4__FECompTotXRequest), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip4__FECompTotXRequest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FECompTotXRequest && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FECompTotXRequest(soap, "afip3:FECompTotXRequest", &a->afip3__FECompTotXRequest, ""))
				{	soap_flag_afip3__FECompTotXRequest--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip4__FECompTotXRequest * SOAP_FMAC2 soap_instantiate___afip4__FECompTotXRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip4__FECompTotXRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip4__FECompTotXRequest *p;
	size_t k = sizeof(struct __afip4__FECompTotXRequest);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip4__FECompTotXRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip4__FECompTotXRequest);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip4__FECompTotXRequest, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip4__FECompTotXRequest location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip4__FECompTotXRequest(struct soap *soap, const struct __afip4__FECompTotXRequest *a, const char *tag, const char *type)
{
	if (soap_out___afip4__FECompTotXRequest(soap, tag ? tag : "-afip4:FECompTotXRequest", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FECompTotXRequest * SOAP_FMAC4 soap_get___afip4__FECompTotXRequest(struct soap *soap, struct __afip4__FECompTotXRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip4__FECompTotXRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip4__FECAESolicitar(struct soap *soap, struct __afip4__FECAESolicitar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip3__FECAESolicitar = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip4__FECAESolicitar(struct soap *soap, const struct __afip4__FECAESolicitar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip3__FECAESolicitar(soap, &a->afip3__FECAESolicitar);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip4__FECAESolicitar(struct soap *soap, const char *tag, int id, const struct __afip4__FECAESolicitar *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip3__FECAESolicitar(soap, "afip3:FECAESolicitar", -1, &a->afip3__FECAESolicitar, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FECAESolicitar * SOAP_FMAC4 soap_in___afip4__FECAESolicitar(struct soap *soap, const char *tag, struct __afip4__FECAESolicitar *a, const char *type)
{
	size_t soap_flag_afip3__FECAESolicitar = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip4__FECAESolicitar*)soap_id_enter(soap, "", a, SOAP_TYPE___afip4__FECAESolicitar, sizeof(struct __afip4__FECAESolicitar), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip4__FECAESolicitar(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip3__FECAESolicitar && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip3__FECAESolicitar(soap, "afip3:FECAESolicitar", &a->afip3__FECAESolicitar, ""))
				{	soap_flag_afip3__FECAESolicitar--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip4__FECAESolicitar * SOAP_FMAC2 soap_instantiate___afip4__FECAESolicitar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip4__FECAESolicitar(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip4__FECAESolicitar *p;
	size_t k = sizeof(struct __afip4__FECAESolicitar);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip4__FECAESolicitar, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip4__FECAESolicitar);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip4__FECAESolicitar, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip4__FECAESolicitar location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip4__FECAESolicitar(struct soap *soap, const struct __afip4__FECAESolicitar *a, const char *tag, const char *type)
{
	if (soap_out___afip4__FECAESolicitar(soap, tag ? tag : "-afip4:FECAESolicitar", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip4__FECAESolicitar * SOAP_FMAC4 soap_get___afip4__FECAESolicitar(struct soap *soap, struct __afip4__FECAESolicitar *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip4__FECAESolicitar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___afip2__loginCms(struct soap *soap, struct __afip2__loginCms *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip1__loginCms = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___afip2__loginCms(struct soap *soap, const struct __afip2__loginCms *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_afip1__loginCms(soap, &a->afip1__loginCms);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___afip2__loginCms(struct soap *soap, const char *tag, int id, const struct __afip2__loginCms *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_afip1__loginCms(soap, "afip1:loginCms", -1, &a->afip1__loginCms, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip2__loginCms * SOAP_FMAC4 soap_in___afip2__loginCms(struct soap *soap, const char *tag, struct __afip2__loginCms *a, const char *type)
{
	size_t soap_flag_afip1__loginCms = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __afip2__loginCms*)soap_id_enter(soap, "", a, SOAP_TYPE___afip2__loginCms, sizeof(struct __afip2__loginCms), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___afip2__loginCms(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip1__loginCms && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_afip1__loginCms(soap, "afip1:loginCms", &a->afip1__loginCms, ""))
				{	soap_flag_afip1__loginCms--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __afip2__loginCms * SOAP_FMAC2 soap_instantiate___afip2__loginCms(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___afip2__loginCms(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __afip2__loginCms *p;
	size_t k = sizeof(struct __afip2__loginCms);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___afip2__loginCms, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __afip2__loginCms);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __afip2__loginCms, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __afip2__loginCms location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___afip2__loginCms(struct soap *soap, const struct __afip2__loginCms *a, const char *tag, const char *type)
{
	if (soap_out___afip2__loginCms(soap, tag ? tag : "-afip2:loginCms", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __afip2__loginCms * SOAP_FMAC4 soap_get___afip2__loginCms(struct soap *soap, struct __afip2__loginCms *p, const char *tag, const char *type)
{
	if ((p = soap_in___afip2__loginCms(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->afip2__fault = NULL;
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToafip2__LoginFault(soap, &a->afip2__fault);
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_out_PointerToafip2__LoginFault(soap, "afip2:fault", -1, &a->afip2__fault, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_afip2__fault = 1;
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Detail*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_afip2__fault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToafip2__LoginFault(soap, "afip2:fault", &a->afip2__fault, "afip2:LoginFault"))
				{	soap_flag_afip2__fault--;
					continue;
				}
			}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, "fault", &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_afip3__FEParamGetTiposPaises(struct soap *soap, _afip3__FEParamGetTiposPaises *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__afip3__FEParamGetTiposPaises))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_afip3__FEParamGetTiposPaises(struct soap *soap, const char *tag, int id, _afip3__FEParamGetTiposPaises *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__afip3__FEParamGetTiposPaises, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__afip3__FEParamGetTiposPaises ? type : NULL);
}

SOAP_FMAC3 _afip3__FEParamGetTiposPaises ** SOAP_FMAC4 soap_in_PointerTo_afip3__FEParamGetTiposPaises(struct soap *soap, const char *tag, _afip3__FEParamGetTiposPaises **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_afip3__FEParamGetTiposPaises **)soap_malloc(soap, sizeof(_afip3__FEParamGetTiposPaises *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_afip3__FEParamGetTiposPaises *)soap_instantiate__afip3__FEParamGetTiposPaises(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_afip3__FEParamGetTiposPaises **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__afip3__FEParamGetTiposPaises, sizeof(_afip3__FEParamGetTiposPaises), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_afip3__FEParamGetTiposPaises(struct soap *soap, _afip3__FEParamGetTiposPaises *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_afip3__FEParamGetTiposPaises(soap, tag ? tag : "afip3:FEParamGetTiposPaises", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _afip3__FEParamGetTiposPaises ** SOAP_FMAC4 soap_get_PointerTo_afip3__FEParamGetTiposPaises(struct soap *soap, _afip3__FEParamGetTiposPaises **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_afip3__FEParamGetTiposPaises(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_afip3__FEParamGetTiposDoc(struct soap *soap, _afip3__FEParamGetTiposDoc *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__afip3__FEParamGetTiposDoc))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_afip3__FEParamGetTiposDoc(struct soap *soap, const char *tag, int id, _afip3__FEParamGetTiposDoc *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__afip3__FEParamGetTiposDoc, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__afip3__FEParamGetTiposDoc ? type : NULL);
}

SOAP_FMAC3 _afip3__FEParamGetTiposDoc ** SOAP_FMAC4 soap_in_PointerTo_afip3__FEParamGetTiposDoc(struct soap *soap, const char *tag, _afip3__FEParamGetTiposDoc **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_afip3__FEParamGetTiposDoc **)soap_malloc(soap, sizeof(_afip3__FEParamGetTiposDoc *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_afip3__FEParamGetTiposDoc *)soap_instantiate__afip3__FEParamGetTiposDoc(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_afip3__FEParamGetTiposDoc **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__afip3__FEParamGetTiposDoc, sizeof(_afip3__FEParamGetTiposDoc), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_afip3__FEParamGetTiposDoc(struct soap *soap, _afip3__FEParamGetTiposDoc *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_afip3__FEParamGetTiposDoc(soap, tag ? tag : "afip3:FEParamGetTiposDoc", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _afip3__FEParamGetTiposDoc ** SOAP_FMAC4 soap_get_PointerTo_afip3__FEParamGetTiposDoc(struct soap *soap, _afip3__FEParamGetTiposDoc **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_afip3__FEParamGetTiposDoc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_afip3__FEParamGetTiposCbte(struct soap *soap, _afip3__FEParamGetTiposCbte *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__afip3__FEParamGetTiposCbte))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_afip3__FEParamGetTiposCbte(struct soap *soap, const char *tag, int id, _afip3__FEParamGetTiposCbte *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__afip3__FEParamGetTiposCbte, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__afip3__FEParamGetTiposCbte ? type : NULL);
}

SOAP_FMAC3 _afip3__FEParamGetTiposCbte ** SOAP_FMAC4 soap_in_PointerTo_afip3__FEParamGetTiposCbte(struct soap *soap, const char *tag, _afip3__FEParamGetTiposCbte **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_afip3__FEParamGetTiposCbte **)soap_malloc(soap, sizeof(_afip3__FEParamGetTiposCbte *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_afip3__FEParamGetTiposCbte *)soap_instantiate__afip3__FEParamGetTiposCbte(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_afip3__FEParamGetTiposCbte **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__afip3__FEParamGetTiposCbte, sizeof(_afip3__FEParamGetTiposCbte), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_afip3__FEParamGetTiposCbte(struct soap *soap, _afip3__FEParamGetTiposCbte *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_afip3__FEParamGetTiposCbte(soap, tag ? tag : "afip3:FEParamGetTiposCbte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _afip3__FEParamGetTiposCbte ** SOAP_FMAC4 soap_get_PointerTo_afip3__FEParamGetTiposCbte(struct soap *soap, _afip3__FEParamGetTiposCbte **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_afip3__FEParamGetTiposCbte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_afip3__FEParamGetPtosVenta(struct soap *soap, _afip3__FEParamGetPtosVenta *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__afip3__FEParamGetPtosVenta))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_afip3__FEParamGetPtosVenta(struct soap *soap, const char *tag, int id, _afip3__FEParamGetPtosVenta *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__afip3__FEParamGetPtosVenta, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__afip3__FEParamGetPtosVenta ? type : NULL);
}

SOAP_FMAC3 _afip3__FEParamGetPtosVenta ** SOAP_FMAC4 soap_in_PointerTo_afip3__FEParamGetPtosVenta(struct soap *soap, const char *tag, _afip3__FEParamGetPtosVenta **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_afip3__FEParamGetPtosVenta **)soap_malloc(soap, sizeof(_afip3__FEParamGetPtosVenta *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_afip3__FEParamGetPtosVenta *)soap_instantiate__afip3__FEParamGetPtosVenta(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_afip3__FEParamGetPtosVenta **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__afip3__FEParamGetPtosVenta, sizeof(_afip3__FEParamGetPtosVenta), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_afip3__FEParamGetPtosVenta(struct soap *soap, _afip3__FEParamGetPtosVenta *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_afip3__FEParamGetPtosVenta(soap, tag ? tag : "afip3:FEParamGetPtosVenta", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _afip3__FEParamGetPtosVenta ** SOAP_FMAC4 soap_get_PointerTo_afip3__FEParamGetPtosVenta(struct soap *soap, _afip3__FEParamGetPtosVenta **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_afip3__FEParamGetPtosVenta(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_afip3__FEParamGetTiposConcepto(struct soap *soap, _afip3__FEParamGetTiposConcepto *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__afip3__FEParamGetTiposConcepto))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_afip3__FEParamGetTiposConcepto(struct soap *soap, const char *tag, int id, _afip3__FEParamGetTiposConcepto *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__afip3__FEParamGetTiposConcepto, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__afip3__FEParamGetTiposConcepto ? type : NULL);
}

SOAP_FMAC3 _afip3__FEParamGetTiposConcepto ** SOAP_FMAC4 soap_in_PointerTo_afip3__FEParamGetTiposConcepto(struct soap *soap, const char *tag, _afip3__FEParamGetTiposConcepto **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_afip3__FEParamGetTiposConcepto **)soap_malloc(soap, sizeof(_afip3__FEParamGetTiposConcepto *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_afip3__FEParamGetTiposConcepto *)soap_instantiate__afip3__FEParamGetTiposConcepto(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_afip3__FEParamGetTiposConcepto **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__afip3__FEParamGetTiposConcepto, sizeof(_afip3__FEParamGetTiposConcepto), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_afip3__FEParamGetTiposConcepto(struct soap *soap, _afip3__FEParamGetTiposConcepto *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_afip3__FEParamGetTiposConcepto(soap, tag ? tag : "afip3:FEParamGetTiposConcepto", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _afip3__FEParamGetTiposConcepto ** SOAP_FMAC4 soap_get_PointerTo_afip3__FEParamGetTiposConcepto(struct soap *soap, _afip3__FEParamGetTiposConcepto **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_afip3__FEParamGetTiposConcepto(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_afip3__FEParamGetTiposOpcional(struct soap *soap, _afip3__FEParamGetTiposOpcional *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__afip3__FEParamGetTiposOpcional))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_afip3__FEParamGetTiposOpcional(struct soap *soap, const char *tag, int id, _afip3__FEParamGetTiposOpcional *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__afip3__FEParamGetTiposOpcional, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__afip3__FEParamGetTiposOpcional ? type : NULL);
}

SOAP_FMAC3 _afip3__FEParamGetTiposOpcional ** SOAP_FMAC4 soap_in_PointerTo_afip3__FEParamGetTiposOpcional(struct soap *soap, const char *tag, _afip3__FEParamGetTiposOpcional **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_afip3__FEParamGetTiposOpcional **)soap_malloc(soap, sizeof(_afip3__FEParamGetTiposOpcional *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_afip3__FEParamGetTiposOpcional *)soap_instantiate__afip3__FEParamGetTiposOpcional(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_afip3__FEParamGetTiposOpcional **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__afip3__FEParamGetTiposOpcional, sizeof(_afip3__FEParamGetTiposOpcional), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_afip3__FEParamGetTiposOpcional(struct soap *soap, _afip3__FEParamGetTiposOpcional *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_afip3__FEParamGetTiposOpcional(soap, tag ? tag : "afip3:FEParamGetTiposOpcional", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _afip3__FEParamGetTiposOpcional ** SOAP_FMAC4 soap_get_PointerTo_afip3__FEParamGetTiposOpcional(struct soap *soap, _afip3__FEParamGetTiposOpcional **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_afip3__FEParamGetTiposOpcional(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_afip3__FEParamGetTiposIva(struct soap *soap, _afip3__FEParamGetTiposIva *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__afip3__FEParamGetTiposIva))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_afip3__FEParamGetTiposIva(struct soap *soap, const char *tag, int id, _afip3__FEParamGetTiposIva *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__afip3__FEParamGetTiposIva, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__afip3__FEParamGetTiposIva ? type : NULL);
}

SOAP_FMAC3 _afip3__FEParamGetTiposIva ** SOAP_FMAC4 soap_in_PointerTo_afip3__FEParamGetTiposIva(struct soap *soap, const char *tag, _afip3__FEParamGetTiposIva **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_afip3__FEParamGetTiposIva **)soap_malloc(soap, sizeof(_afip3__FEParamGetTiposIva *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_afip3__FEParamGetTiposIva *)soap_instantiate__afip3__FEParamGetTiposIva(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_afip3__FEParamGetTiposIva **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__afip3__FEParamGetTiposIva, sizeof(_afip3__FEParamGetTiposIva), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_afip3__FEParamGetTiposIva(struct soap *soap, _afip3__FEParamGetTiposIva *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_afip3__FEParamGetTiposIva(soap, tag ? tag : "afip3:FEParamGetTiposIva", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _afip3__FEParamGetTiposIva ** SOAP_FMAC4 soap_get_PointerTo_afip3__FEParamGetTiposIva(struct soap *soap, _afip3__FEParamGetTiposIva **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_afip3__FEParamGetTiposIva(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_afip3__FEParamGetTiposMonedas(struct soap *soap, _afip3__FEParamGetTiposMonedas *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__afip3__FEParamGetTiposMonedas))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_afip3__FEParamGetTiposMonedas(struct soap *soap, const char *tag, int id, _afip3__FEParamGetTiposMonedas *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__afip3__FEParamGetTiposMonedas, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__afip3__FEParamGetTiposMonedas ? type : NULL);
}

SOAP_FMAC3 _afip3__FEParamGetTiposMonedas ** SOAP_FMAC4 soap_in_PointerTo_afip3__FEParamGetTiposMonedas(struct soap *soap, const char *tag, _afip3__FEParamGetTiposMonedas **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_afip3__FEParamGetTiposMonedas **)soap_malloc(soap, sizeof(_afip3__FEParamGetTiposMonedas *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_afip3__FEParamGetTiposMonedas *)soap_instantiate__afip3__FEParamGetTiposMonedas(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_afip3__FEParamGetTiposMonedas **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__afip3__FEParamGetTiposMonedas, sizeof(_afip3__FEParamGetTiposMonedas), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_afip3__FEParamGetTiposMonedas(struct soap *soap, _afip3__FEParamGetTiposMonedas *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_afip3__FEParamGetTiposMonedas(soap, tag ? tag : "afip3:FEParamGetTiposMonedas", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _afip3__FEParamGetTiposMonedas ** SOAP_FMAC4 soap_get_PointerTo_afip3__FEParamGetTiposMonedas(struct soap *soap, _afip3__FEParamGetTiposMonedas **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_afip3__FEParamGetTiposMonedas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_afip3__FEParamGetTiposTributos(struct soap *soap, _afip3__FEParamGetTiposTributos *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__afip3__FEParamGetTiposTributos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_afip3__FEParamGetTiposTributos(struct soap *soap, const char *tag, int id, _afip3__FEParamGetTiposTributos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__afip3__FEParamGetTiposTributos, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__afip3__FEParamGetTiposTributos ? type : NULL);
}

SOAP_FMAC3 _afip3__FEParamGetTiposTributos ** SOAP_FMAC4 soap_in_PointerTo_afip3__FEParamGetTiposTributos(struct soap *soap, const char *tag, _afip3__FEParamGetTiposTributos **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_afip3__FEParamGetTiposTributos **)soap_malloc(soap, sizeof(_afip3__FEParamGetTiposTributos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_afip3__FEParamGetTiposTributos *)soap_instantiate__afip3__FEParamGetTiposTributos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_afip3__FEParamGetTiposTributos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__afip3__FEParamGetTiposTributos, sizeof(_afip3__FEParamGetTiposTributos), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_afip3__FEParamGetTiposTributos(struct soap *soap, _afip3__FEParamGetTiposTributos *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_afip3__FEParamGetTiposTributos(soap, tag ? tag : "afip3:FEParamGetTiposTributos", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _afip3__FEParamGetTiposTributos ** SOAP_FMAC4 soap_get_PointerTo_afip3__FEParamGetTiposTributos(struct soap *soap, _afip3__FEParamGetTiposTributos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_afip3__FEParamGetTiposTributos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_afip3__FEParamGetCotizacion(struct soap *soap, _afip3__FEParamGetCotizacion *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__afip3__FEParamGetCotizacion))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_afip3__FEParamGetCotizacion(struct soap *soap, const char *tag, int id, _afip3__FEParamGetCotizacion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__afip3__FEParamGetCotizacion, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__afip3__FEParamGetCotizacion ? type : NULL);
}

SOAP_FMAC3 _afip3__FEParamGetCotizacion ** SOAP_FMAC4 soap_in_PointerTo_afip3__FEParamGetCotizacion(struct soap *soap, const char *tag, _afip3__FEParamGetCotizacion **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_afip3__FEParamGetCotizacion **)soap_malloc(soap, sizeof(_afip3__FEParamGetCotizacion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_afip3__FEParamGetCotizacion *)soap_instantiate__afip3__FEParamGetCotizacion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_afip3__FEParamGetCotizacion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__afip3__FEParamGetCotizacion, sizeof(_afip3__FEParamGetCotizacion), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_afip3__FEParamGetCotizacion(struct soap *soap, _afip3__FEParamGetCotizacion *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_afip3__FEParamGetCotizacion(soap, tag ? tag : "afip3:FEParamGetCotizacion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _afip3__FEParamGetCotizacion ** SOAP_FMAC4 soap_get_PointerTo_afip3__FEParamGetCotizacion(struct soap *soap, _afip3__FEParamGetCotizacion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_afip3__FEParamGetCotizacion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_afip3__FECAEAConsultar(struct soap *soap, _afip3__FECAEAConsultar *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__afip3__FECAEAConsultar))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_afip3__FECAEAConsultar(struct soap *soap, const char *tag, int id, _afip3__FECAEAConsultar *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__afip3__FECAEAConsultar, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__afip3__FECAEAConsultar ? type : NULL);
}

SOAP_FMAC3 _afip3__FECAEAConsultar ** SOAP_FMAC4 soap_in_PointerTo_afip3__FECAEAConsultar(struct soap *soap, const char *tag, _afip3__FECAEAConsultar **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_afip3__FECAEAConsultar **)soap_malloc(soap, sizeof(_afip3__FECAEAConsultar *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_afip3__FECAEAConsultar *)soap_instantiate__afip3__FECAEAConsultar(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_afip3__FECAEAConsultar **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__afip3__FECAEAConsultar, sizeof(_afip3__FECAEAConsultar), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_afip3__FECAEAConsultar(struct soap *soap, _afip3__FECAEAConsultar *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_afip3__FECAEAConsultar(soap, tag ? tag : "afip3:FECAEAConsultar", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _afip3__FECAEAConsultar ** SOAP_FMAC4 soap_get_PointerTo_afip3__FECAEAConsultar(struct soap *soap, _afip3__FECAEAConsultar **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_afip3__FECAEAConsultar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_afip3__FECAEASinMovimientoInformar(struct soap *soap, _afip3__FECAEASinMovimientoInformar *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__afip3__FECAEASinMovimientoInformar))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_afip3__FECAEASinMovimientoInformar(struct soap *soap, const char *tag, int id, _afip3__FECAEASinMovimientoInformar *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__afip3__FECAEASinMovimientoInformar, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__afip3__FECAEASinMovimientoInformar ? type : NULL);
}

SOAP_FMAC3 _afip3__FECAEASinMovimientoInformar ** SOAP_FMAC4 soap_in_PointerTo_afip3__FECAEASinMovimientoInformar(struct soap *soap, const char *tag, _afip3__FECAEASinMovimientoInformar **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_afip3__FECAEASinMovimientoInformar **)soap_malloc(soap, sizeof(_afip3__FECAEASinMovimientoInformar *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_afip3__FECAEASinMovimientoInformar *)soap_instantiate__afip3__FECAEASinMovimientoInformar(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_afip3__FECAEASinMovimientoInformar **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__afip3__FECAEASinMovimientoInformar, sizeof(_afip3__FECAEASinMovimientoInformar), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_afip3__FECAEASinMovimientoInformar(struct soap *soap, _afip3__FECAEASinMovimientoInformar *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_afip3__FECAEASinMovimientoInformar(soap, tag ? tag : "afip3:FECAEASinMovimientoInformar", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _afip3__FECAEASinMovimientoInformar ** SOAP_FMAC4 soap_get_PointerTo_afip3__FECAEASinMovimientoInformar(struct soap *soap, _afip3__FECAEASinMovimientoInformar **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_afip3__FECAEASinMovimientoInformar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_afip3__FECAEASinMovimientoConsultar(struct soap *soap, _afip3__FECAEASinMovimientoConsultar *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__afip3__FECAEASinMovimientoConsultar))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_afip3__FECAEASinMovimientoConsultar(struct soap *soap, const char *tag, int id, _afip3__FECAEASinMovimientoConsultar *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__afip3__FECAEASinMovimientoConsultar, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__afip3__FECAEASinMovimientoConsultar ? type : NULL);
}

SOAP_FMAC3 _afip3__FECAEASinMovimientoConsultar ** SOAP_FMAC4 soap_in_PointerTo_afip3__FECAEASinMovimientoConsultar(struct soap *soap, const char *tag, _afip3__FECAEASinMovimientoConsultar **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_afip3__FECAEASinMovimientoConsultar **)soap_malloc(soap, sizeof(_afip3__FECAEASinMovimientoConsultar *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_afip3__FECAEASinMovimientoConsultar *)soap_instantiate__afip3__FECAEASinMovimientoConsultar(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_afip3__FECAEASinMovimientoConsultar **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__afip3__FECAEASinMovimientoConsultar, sizeof(_afip3__FECAEASinMovimientoConsultar), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_afip3__FECAEASinMovimientoConsultar(struct soap *soap, _afip3__FECAEASinMovimientoConsultar *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_afip3__FECAEASinMovimientoConsultar(soap, tag ? tag : "afip3:FECAEASinMovimientoConsultar", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _afip3__FECAEASinMovimientoConsultar ** SOAP_FMAC4 soap_get_PointerTo_afip3__FECAEASinMovimientoConsultar(struct soap *soap, _afip3__FECAEASinMovimientoConsultar **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_afip3__FECAEASinMovimientoConsultar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_afip3__FECAEASolicitar(struct soap *soap, _afip3__FECAEASolicitar *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__afip3__FECAEASolicitar))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_afip3__FECAEASolicitar(struct soap *soap, const char *tag, int id, _afip3__FECAEASolicitar *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__afip3__FECAEASolicitar, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__afip3__FECAEASolicitar ? type : NULL);
}

SOAP_FMAC3 _afip3__FECAEASolicitar ** SOAP_FMAC4 soap_in_PointerTo_afip3__FECAEASolicitar(struct soap *soap, const char *tag, _afip3__FECAEASolicitar **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_afip3__FECAEASolicitar **)soap_malloc(soap, sizeof(_afip3__FECAEASolicitar *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_afip3__FECAEASolicitar *)soap_instantiate__afip3__FECAEASolicitar(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_afip3__FECAEASolicitar **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__afip3__FECAEASolicitar, sizeof(_afip3__FECAEASolicitar), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_afip3__FECAEASolicitar(struct soap *soap, _afip3__FECAEASolicitar *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_afip3__FECAEASolicitar(soap, tag ? tag : "afip3:FECAEASolicitar", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _afip3__FECAEASolicitar ** SOAP_FMAC4 soap_get_PointerTo_afip3__FECAEASolicitar(struct soap *soap, _afip3__FECAEASolicitar **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_afip3__FECAEASolicitar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_afip3__FECAEARegInformativo(struct soap *soap, _afip3__FECAEARegInformativo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__afip3__FECAEARegInformativo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_afip3__FECAEARegInformativo(struct soap *soap, const char *tag, int id, _afip3__FECAEARegInformativo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__afip3__FECAEARegInformativo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__afip3__FECAEARegInformativo ? type : NULL);
}

SOAP_FMAC3 _afip3__FECAEARegInformativo ** SOAP_FMAC4 soap_in_PointerTo_afip3__FECAEARegInformativo(struct soap *soap, const char *tag, _afip3__FECAEARegInformativo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_afip3__FECAEARegInformativo **)soap_malloc(soap, sizeof(_afip3__FECAEARegInformativo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_afip3__FECAEARegInformativo *)soap_instantiate__afip3__FECAEARegInformativo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_afip3__FECAEARegInformativo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__afip3__FECAEARegInformativo, sizeof(_afip3__FECAEARegInformativo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_afip3__FECAEARegInformativo(struct soap *soap, _afip3__FECAEARegInformativo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_afip3__FECAEARegInformativo(soap, tag ? tag : "afip3:FECAEARegInformativo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _afip3__FECAEARegInformativo ** SOAP_FMAC4 soap_get_PointerTo_afip3__FECAEARegInformativo(struct soap *soap, _afip3__FECAEARegInformativo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_afip3__FECAEARegInformativo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_afip3__FECompConsultar(struct soap *soap, _afip3__FECompConsultar *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__afip3__FECompConsultar))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_afip3__FECompConsultar(struct soap *soap, const char *tag, int id, _afip3__FECompConsultar *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__afip3__FECompConsultar, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__afip3__FECompConsultar ? type : NULL);
}

SOAP_FMAC3 _afip3__FECompConsultar ** SOAP_FMAC4 soap_in_PointerTo_afip3__FECompConsultar(struct soap *soap, const char *tag, _afip3__FECompConsultar **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_afip3__FECompConsultar **)soap_malloc(soap, sizeof(_afip3__FECompConsultar *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_afip3__FECompConsultar *)soap_instantiate__afip3__FECompConsultar(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_afip3__FECompConsultar **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__afip3__FECompConsultar, sizeof(_afip3__FECompConsultar), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_afip3__FECompConsultar(struct soap *soap, _afip3__FECompConsultar *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_afip3__FECompConsultar(soap, tag ? tag : "afip3:FECompConsultar", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _afip3__FECompConsultar ** SOAP_FMAC4 soap_get_PointerTo_afip3__FECompConsultar(struct soap *soap, _afip3__FECompConsultar **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_afip3__FECompConsultar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_afip3__FECompUltimoAutorizado(struct soap *soap, _afip3__FECompUltimoAutorizado *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__afip3__FECompUltimoAutorizado))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_afip3__FECompUltimoAutorizado(struct soap *soap, const char *tag, int id, _afip3__FECompUltimoAutorizado *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__afip3__FECompUltimoAutorizado, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__afip3__FECompUltimoAutorizado ? type : NULL);
}

SOAP_FMAC3 _afip3__FECompUltimoAutorizado ** SOAP_FMAC4 soap_in_PointerTo_afip3__FECompUltimoAutorizado(struct soap *soap, const char *tag, _afip3__FECompUltimoAutorizado **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_afip3__FECompUltimoAutorizado **)soap_malloc(soap, sizeof(_afip3__FECompUltimoAutorizado *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_afip3__FECompUltimoAutorizado *)soap_instantiate__afip3__FECompUltimoAutorizado(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_afip3__FECompUltimoAutorizado **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__afip3__FECompUltimoAutorizado, sizeof(_afip3__FECompUltimoAutorizado), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_afip3__FECompUltimoAutorizado(struct soap *soap, _afip3__FECompUltimoAutorizado *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_afip3__FECompUltimoAutorizado(soap, tag ? tag : "afip3:FECompUltimoAutorizado", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _afip3__FECompUltimoAutorizado ** SOAP_FMAC4 soap_get_PointerTo_afip3__FECompUltimoAutorizado(struct soap *soap, _afip3__FECompUltimoAutorizado **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_afip3__FECompUltimoAutorizado(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_afip3__FEDummy(struct soap *soap, _afip3__FEDummy *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__afip3__FEDummy))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_afip3__FEDummy(struct soap *soap, const char *tag, int id, _afip3__FEDummy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__afip3__FEDummy, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__afip3__FEDummy ? type : NULL);
}

SOAP_FMAC3 _afip3__FEDummy ** SOAP_FMAC4 soap_in_PointerTo_afip3__FEDummy(struct soap *soap, const char *tag, _afip3__FEDummy **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_afip3__FEDummy **)soap_malloc(soap, sizeof(_afip3__FEDummy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_afip3__FEDummy *)soap_instantiate__afip3__FEDummy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_afip3__FEDummy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__afip3__FEDummy, sizeof(_afip3__FEDummy), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_afip3__FEDummy(struct soap *soap, _afip3__FEDummy *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_afip3__FEDummy(soap, tag ? tag : "afip3:FEDummy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _afip3__FEDummy ** SOAP_FMAC4 soap_get_PointerTo_afip3__FEDummy(struct soap *soap, _afip3__FEDummy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_afip3__FEDummy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_afip3__FECompTotXRequest(struct soap *soap, _afip3__FECompTotXRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__afip3__FECompTotXRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_afip3__FECompTotXRequest(struct soap *soap, const char *tag, int id, _afip3__FECompTotXRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__afip3__FECompTotXRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__afip3__FECompTotXRequest ? type : NULL);
}

SOAP_FMAC3 _afip3__FECompTotXRequest ** SOAP_FMAC4 soap_in_PointerTo_afip3__FECompTotXRequest(struct soap *soap, const char *tag, _afip3__FECompTotXRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_afip3__FECompTotXRequest **)soap_malloc(soap, sizeof(_afip3__FECompTotXRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_afip3__FECompTotXRequest *)soap_instantiate__afip3__FECompTotXRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_afip3__FECompTotXRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__afip3__FECompTotXRequest, sizeof(_afip3__FECompTotXRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_afip3__FECompTotXRequest(struct soap *soap, _afip3__FECompTotXRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_afip3__FECompTotXRequest(soap, tag ? tag : "afip3:FECompTotXRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _afip3__FECompTotXRequest ** SOAP_FMAC4 soap_get_PointerTo_afip3__FECompTotXRequest(struct soap *soap, _afip3__FECompTotXRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_afip3__FECompTotXRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_afip3__FECAESolicitar(struct soap *soap, _afip3__FECAESolicitar *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__afip3__FECAESolicitar))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_afip3__FECAESolicitar(struct soap *soap, const char *tag, int id, _afip3__FECAESolicitar *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__afip3__FECAESolicitar, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__afip3__FECAESolicitar ? type : NULL);
}

SOAP_FMAC3 _afip3__FECAESolicitar ** SOAP_FMAC4 soap_in_PointerTo_afip3__FECAESolicitar(struct soap *soap, const char *tag, _afip3__FECAESolicitar **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_afip3__FECAESolicitar **)soap_malloc(soap, sizeof(_afip3__FECAESolicitar *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_afip3__FECAESolicitar *)soap_instantiate__afip3__FECAESolicitar(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_afip3__FECAESolicitar **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__afip3__FECAESolicitar, sizeof(_afip3__FECAESolicitar), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_afip3__FECAESolicitar(struct soap *soap, _afip3__FECAESolicitar *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_afip3__FECAESolicitar(soap, tag ? tag : "afip3:FECAESolicitar", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _afip3__FECAESolicitar ** SOAP_FMAC4 soap_get_PointerTo_afip3__FECAESolicitar(struct soap *soap, _afip3__FECAESolicitar **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_afip3__FECAESolicitar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_afip1__loginCms(struct soap *soap, _afip1__loginCms *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__afip1__loginCms))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_afip1__loginCms(struct soap *soap, const char *tag, int id, _afip1__loginCms *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__afip1__loginCms, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__afip1__loginCms ? type : NULL);
}

SOAP_FMAC3 _afip1__loginCms ** SOAP_FMAC4 soap_in_PointerTo_afip1__loginCms(struct soap *soap, const char *tag, _afip1__loginCms **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_afip1__loginCms **)soap_malloc(soap, sizeof(_afip1__loginCms *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_afip1__loginCms *)soap_instantiate__afip1__loginCms(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_afip1__loginCms **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__afip1__loginCms, sizeof(_afip1__loginCms), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_afip1__loginCms(struct soap *soap, _afip1__loginCms *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_afip1__loginCms(soap, tag ? tag : "afip1:loginCms", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _afip1__loginCms ** SOAP_FMAC4 soap_get_PointerTo_afip1__loginCms(struct soap *soap, _afip1__loginCms **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_afip1__loginCms(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip2__LoginFault(struct soap *soap, afip2__LoginFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip2__LoginFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip2__LoginFault(struct soap *soap, const char *tag, int id, afip2__LoginFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip2__LoginFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip2__LoginFault ? type : NULL);
}

SOAP_FMAC3 afip2__LoginFault ** SOAP_FMAC4 soap_in_PointerToafip2__LoginFault(struct soap *soap, const char *tag, afip2__LoginFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip2__LoginFault **)soap_malloc(soap, sizeof(afip2__LoginFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip2__LoginFault *)soap_instantiate_afip2__LoginFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip2__LoginFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip2__LoginFault, sizeof(afip2__LoginFault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip2__LoginFault(struct soap *soap, afip2__LoginFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip2__LoginFault(soap, tag ? tag : "afip2:LoginFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip2__LoginFault ** SOAP_FMAC4 soap_get_PointerToafip2__LoginFault(struct soap *soap, afip2__LoginFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip2__LoginFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__FEPaisResponse(struct soap *soap, afip3__FEPaisResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__FEPaisResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__FEPaisResponse(struct soap *soap, const char *tag, int id, afip3__FEPaisResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__FEPaisResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__FEPaisResponse ? type : NULL);
}

SOAP_FMAC3 afip3__FEPaisResponse ** SOAP_FMAC4 soap_in_PointerToafip3__FEPaisResponse(struct soap *soap, const char *tag, afip3__FEPaisResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__FEPaisResponse **)soap_malloc(soap, sizeof(afip3__FEPaisResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__FEPaisResponse *)soap_instantiate_afip3__FEPaisResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__FEPaisResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__FEPaisResponse, sizeof(afip3__FEPaisResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__FEPaisResponse(struct soap *soap, afip3__FEPaisResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__FEPaisResponse(soap, tag ? tag : "afip3:FEPaisResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__FEPaisResponse ** SOAP_FMAC4 soap_get_PointerToafip3__FEPaisResponse(struct soap *soap, afip3__FEPaisResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__FEPaisResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__DocTipoResponse(struct soap *soap, afip3__DocTipoResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__DocTipoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__DocTipoResponse(struct soap *soap, const char *tag, int id, afip3__DocTipoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__DocTipoResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__DocTipoResponse ? type : NULL);
}

SOAP_FMAC3 afip3__DocTipoResponse ** SOAP_FMAC4 soap_in_PointerToafip3__DocTipoResponse(struct soap *soap, const char *tag, afip3__DocTipoResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__DocTipoResponse **)soap_malloc(soap, sizeof(afip3__DocTipoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__DocTipoResponse *)soap_instantiate_afip3__DocTipoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__DocTipoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__DocTipoResponse, sizeof(afip3__DocTipoResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__DocTipoResponse(struct soap *soap, afip3__DocTipoResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__DocTipoResponse(soap, tag ? tag : "afip3:DocTipoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__DocTipoResponse ** SOAP_FMAC4 soap_get_PointerToafip3__DocTipoResponse(struct soap *soap, afip3__DocTipoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__DocTipoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__CbteTipoResponse(struct soap *soap, afip3__CbteTipoResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__CbteTipoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__CbteTipoResponse(struct soap *soap, const char *tag, int id, afip3__CbteTipoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__CbteTipoResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__CbteTipoResponse ? type : NULL);
}

SOAP_FMAC3 afip3__CbteTipoResponse ** SOAP_FMAC4 soap_in_PointerToafip3__CbteTipoResponse(struct soap *soap, const char *tag, afip3__CbteTipoResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__CbteTipoResponse **)soap_malloc(soap, sizeof(afip3__CbteTipoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__CbteTipoResponse *)soap_instantiate_afip3__CbteTipoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__CbteTipoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__CbteTipoResponse, sizeof(afip3__CbteTipoResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__CbteTipoResponse(struct soap *soap, afip3__CbteTipoResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__CbteTipoResponse(soap, tag ? tag : "afip3:CbteTipoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__CbteTipoResponse ** SOAP_FMAC4 soap_get_PointerToafip3__CbteTipoResponse(struct soap *soap, afip3__CbteTipoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__CbteTipoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__FEPtoVentaResponse(struct soap *soap, afip3__FEPtoVentaResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__FEPtoVentaResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__FEPtoVentaResponse(struct soap *soap, const char *tag, int id, afip3__FEPtoVentaResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__FEPtoVentaResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__FEPtoVentaResponse ? type : NULL);
}

SOAP_FMAC3 afip3__FEPtoVentaResponse ** SOAP_FMAC4 soap_in_PointerToafip3__FEPtoVentaResponse(struct soap *soap, const char *tag, afip3__FEPtoVentaResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__FEPtoVentaResponse **)soap_malloc(soap, sizeof(afip3__FEPtoVentaResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__FEPtoVentaResponse *)soap_instantiate_afip3__FEPtoVentaResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__FEPtoVentaResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__FEPtoVentaResponse, sizeof(afip3__FEPtoVentaResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__FEPtoVentaResponse(struct soap *soap, afip3__FEPtoVentaResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__FEPtoVentaResponse(soap, tag ? tag : "afip3:FEPtoVentaResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__FEPtoVentaResponse ** SOAP_FMAC4 soap_get_PointerToafip3__FEPtoVentaResponse(struct soap *soap, afip3__FEPtoVentaResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__FEPtoVentaResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__ConceptoTipoResponse(struct soap *soap, afip3__ConceptoTipoResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__ConceptoTipoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__ConceptoTipoResponse(struct soap *soap, const char *tag, int id, afip3__ConceptoTipoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__ConceptoTipoResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__ConceptoTipoResponse ? type : NULL);
}

SOAP_FMAC3 afip3__ConceptoTipoResponse ** SOAP_FMAC4 soap_in_PointerToafip3__ConceptoTipoResponse(struct soap *soap, const char *tag, afip3__ConceptoTipoResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__ConceptoTipoResponse **)soap_malloc(soap, sizeof(afip3__ConceptoTipoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__ConceptoTipoResponse *)soap_instantiate_afip3__ConceptoTipoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__ConceptoTipoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__ConceptoTipoResponse, sizeof(afip3__ConceptoTipoResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__ConceptoTipoResponse(struct soap *soap, afip3__ConceptoTipoResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__ConceptoTipoResponse(soap, tag ? tag : "afip3:ConceptoTipoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__ConceptoTipoResponse ** SOAP_FMAC4 soap_get_PointerToafip3__ConceptoTipoResponse(struct soap *soap, afip3__ConceptoTipoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__ConceptoTipoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__OpcionalTipoResponse(struct soap *soap, afip3__OpcionalTipoResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__OpcionalTipoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__OpcionalTipoResponse(struct soap *soap, const char *tag, int id, afip3__OpcionalTipoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__OpcionalTipoResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__OpcionalTipoResponse ? type : NULL);
}

SOAP_FMAC3 afip3__OpcionalTipoResponse ** SOAP_FMAC4 soap_in_PointerToafip3__OpcionalTipoResponse(struct soap *soap, const char *tag, afip3__OpcionalTipoResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__OpcionalTipoResponse **)soap_malloc(soap, sizeof(afip3__OpcionalTipoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__OpcionalTipoResponse *)soap_instantiate_afip3__OpcionalTipoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__OpcionalTipoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__OpcionalTipoResponse, sizeof(afip3__OpcionalTipoResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__OpcionalTipoResponse(struct soap *soap, afip3__OpcionalTipoResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__OpcionalTipoResponse(soap, tag ? tag : "afip3:OpcionalTipoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__OpcionalTipoResponse ** SOAP_FMAC4 soap_get_PointerToafip3__OpcionalTipoResponse(struct soap *soap, afip3__OpcionalTipoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__OpcionalTipoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__IvaTipoResponse(struct soap *soap, afip3__IvaTipoResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__IvaTipoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__IvaTipoResponse(struct soap *soap, const char *tag, int id, afip3__IvaTipoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__IvaTipoResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__IvaTipoResponse ? type : NULL);
}

SOAP_FMAC3 afip3__IvaTipoResponse ** SOAP_FMAC4 soap_in_PointerToafip3__IvaTipoResponse(struct soap *soap, const char *tag, afip3__IvaTipoResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__IvaTipoResponse **)soap_malloc(soap, sizeof(afip3__IvaTipoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__IvaTipoResponse *)soap_instantiate_afip3__IvaTipoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__IvaTipoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__IvaTipoResponse, sizeof(afip3__IvaTipoResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__IvaTipoResponse(struct soap *soap, afip3__IvaTipoResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__IvaTipoResponse(soap, tag ? tag : "afip3:IvaTipoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__IvaTipoResponse ** SOAP_FMAC4 soap_get_PointerToafip3__IvaTipoResponse(struct soap *soap, afip3__IvaTipoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__IvaTipoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__MonedaResponse(struct soap *soap, afip3__MonedaResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__MonedaResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__MonedaResponse(struct soap *soap, const char *tag, int id, afip3__MonedaResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__MonedaResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__MonedaResponse ? type : NULL);
}

SOAP_FMAC3 afip3__MonedaResponse ** SOAP_FMAC4 soap_in_PointerToafip3__MonedaResponse(struct soap *soap, const char *tag, afip3__MonedaResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__MonedaResponse **)soap_malloc(soap, sizeof(afip3__MonedaResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__MonedaResponse *)soap_instantiate_afip3__MonedaResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__MonedaResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__MonedaResponse, sizeof(afip3__MonedaResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__MonedaResponse(struct soap *soap, afip3__MonedaResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__MonedaResponse(soap, tag ? tag : "afip3:MonedaResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__MonedaResponse ** SOAP_FMAC4 soap_get_PointerToafip3__MonedaResponse(struct soap *soap, afip3__MonedaResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__MonedaResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__FETributoResponse(struct soap *soap, afip3__FETributoResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__FETributoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__FETributoResponse(struct soap *soap, const char *tag, int id, afip3__FETributoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__FETributoResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__FETributoResponse ? type : NULL);
}

SOAP_FMAC3 afip3__FETributoResponse ** SOAP_FMAC4 soap_in_PointerToafip3__FETributoResponse(struct soap *soap, const char *tag, afip3__FETributoResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__FETributoResponse **)soap_malloc(soap, sizeof(afip3__FETributoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__FETributoResponse *)soap_instantiate_afip3__FETributoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__FETributoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__FETributoResponse, sizeof(afip3__FETributoResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__FETributoResponse(struct soap *soap, afip3__FETributoResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__FETributoResponse(soap, tag ? tag : "afip3:FETributoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__FETributoResponse ** SOAP_FMAC4 soap_get_PointerToafip3__FETributoResponse(struct soap *soap, afip3__FETributoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__FETributoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__FECotizacionResponse(struct soap *soap, afip3__FECotizacionResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__FECotizacionResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__FECotizacionResponse(struct soap *soap, const char *tag, int id, afip3__FECotizacionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__FECotizacionResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__FECotizacionResponse ? type : NULL);
}

SOAP_FMAC3 afip3__FECotizacionResponse ** SOAP_FMAC4 soap_in_PointerToafip3__FECotizacionResponse(struct soap *soap, const char *tag, afip3__FECotizacionResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__FECotizacionResponse **)soap_malloc(soap, sizeof(afip3__FECotizacionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__FECotizacionResponse *)soap_instantiate_afip3__FECotizacionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__FECotizacionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__FECotizacionResponse, sizeof(afip3__FECotizacionResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__FECotizacionResponse(struct soap *soap, afip3__FECotizacionResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__FECotizacionResponse(soap, tag ? tag : "afip3:FECotizacionResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__FECotizacionResponse ** SOAP_FMAC4 soap_get_PointerToafip3__FECotizacionResponse(struct soap *soap, afip3__FECotizacionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__FECotizacionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__FECAEASinMovResponse(struct soap *soap, afip3__FECAEASinMovResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__FECAEASinMovResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__FECAEASinMovResponse(struct soap *soap, const char *tag, int id, afip3__FECAEASinMovResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__FECAEASinMovResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__FECAEASinMovResponse ? type : NULL);
}

SOAP_FMAC3 afip3__FECAEASinMovResponse ** SOAP_FMAC4 soap_in_PointerToafip3__FECAEASinMovResponse(struct soap *soap, const char *tag, afip3__FECAEASinMovResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__FECAEASinMovResponse **)soap_malloc(soap, sizeof(afip3__FECAEASinMovResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__FECAEASinMovResponse *)soap_instantiate_afip3__FECAEASinMovResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__FECAEASinMovResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__FECAEASinMovResponse, sizeof(afip3__FECAEASinMovResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__FECAEASinMovResponse(struct soap *soap, afip3__FECAEASinMovResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__FECAEASinMovResponse(soap, tag ? tag : "afip3:FECAEASinMovResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__FECAEASinMovResponse ** SOAP_FMAC4 soap_get_PointerToafip3__FECAEASinMovResponse(struct soap *soap, afip3__FECAEASinMovResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__FECAEASinMovResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__FECAEASinMovConsResponse(struct soap *soap, afip3__FECAEASinMovConsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__FECAEASinMovConsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__FECAEASinMovConsResponse(struct soap *soap, const char *tag, int id, afip3__FECAEASinMovConsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__FECAEASinMovConsResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__FECAEASinMovConsResponse ? type : NULL);
}

SOAP_FMAC3 afip3__FECAEASinMovConsResponse ** SOAP_FMAC4 soap_in_PointerToafip3__FECAEASinMovConsResponse(struct soap *soap, const char *tag, afip3__FECAEASinMovConsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__FECAEASinMovConsResponse **)soap_malloc(soap, sizeof(afip3__FECAEASinMovConsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__FECAEASinMovConsResponse *)soap_instantiate_afip3__FECAEASinMovConsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__FECAEASinMovConsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__FECAEASinMovConsResponse, sizeof(afip3__FECAEASinMovConsResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__FECAEASinMovConsResponse(struct soap *soap, afip3__FECAEASinMovConsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__FECAEASinMovConsResponse(soap, tag ? tag : "afip3:FECAEASinMovConsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__FECAEASinMovConsResponse ** SOAP_FMAC4 soap_get_PointerToafip3__FECAEASinMovConsResponse(struct soap *soap, afip3__FECAEASinMovConsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__FECAEASinMovConsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__FECAEAGetResponse(struct soap *soap, afip3__FECAEAGetResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__FECAEAGetResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__FECAEAGetResponse(struct soap *soap, const char *tag, int id, afip3__FECAEAGetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__FECAEAGetResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__FECAEAGetResponse ? type : NULL);
}

SOAP_FMAC3 afip3__FECAEAGetResponse ** SOAP_FMAC4 soap_in_PointerToafip3__FECAEAGetResponse(struct soap *soap, const char *tag, afip3__FECAEAGetResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__FECAEAGetResponse **)soap_malloc(soap, sizeof(afip3__FECAEAGetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__FECAEAGetResponse *)soap_instantiate_afip3__FECAEAGetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__FECAEAGetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__FECAEAGetResponse, sizeof(afip3__FECAEAGetResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__FECAEAGetResponse(struct soap *soap, afip3__FECAEAGetResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__FECAEAGetResponse(soap, tag ? tag : "afip3:FECAEAGetResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__FECAEAGetResponse ** SOAP_FMAC4 soap_get_PointerToafip3__FECAEAGetResponse(struct soap *soap, afip3__FECAEAGetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__FECAEAGetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__FECAEAResponse(struct soap *soap, afip3__FECAEAResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__FECAEAResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__FECAEAResponse(struct soap *soap, const char *tag, int id, afip3__FECAEAResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__FECAEAResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__FECAEAResponse ? type : NULL);
}

SOAP_FMAC3 afip3__FECAEAResponse ** SOAP_FMAC4 soap_in_PointerToafip3__FECAEAResponse(struct soap *soap, const char *tag, afip3__FECAEAResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__FECAEAResponse **)soap_malloc(soap, sizeof(afip3__FECAEAResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__FECAEAResponse *)soap_instantiate_afip3__FECAEAResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__FECAEAResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__FECAEAResponse, sizeof(afip3__FECAEAResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__FECAEAResponse(struct soap *soap, afip3__FECAEAResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__FECAEAResponse(soap, tag ? tag : "afip3:FECAEAResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__FECAEAResponse ** SOAP_FMAC4 soap_get_PointerToafip3__FECAEAResponse(struct soap *soap, afip3__FECAEAResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__FECAEAResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__FECAEARequest(struct soap *soap, afip3__FECAEARequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__FECAEARequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__FECAEARequest(struct soap *soap, const char *tag, int id, afip3__FECAEARequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__FECAEARequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__FECAEARequest ? type : NULL);
}

SOAP_FMAC3 afip3__FECAEARequest ** SOAP_FMAC4 soap_in_PointerToafip3__FECAEARequest(struct soap *soap, const char *tag, afip3__FECAEARequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__FECAEARequest **)soap_malloc(soap, sizeof(afip3__FECAEARequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__FECAEARequest *)soap_instantiate_afip3__FECAEARequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__FECAEARequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__FECAEARequest, sizeof(afip3__FECAEARequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__FECAEARequest(struct soap *soap, afip3__FECAEARequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__FECAEARequest(soap, tag ? tag : "afip3:FECAEARequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__FECAEARequest ** SOAP_FMAC4 soap_get_PointerToafip3__FECAEARequest(struct soap *soap, afip3__FECAEARequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__FECAEARequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__FECompConsultaResponse(struct soap *soap, afip3__FECompConsultaResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__FECompConsultaResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__FECompConsultaResponse(struct soap *soap, const char *tag, int id, afip3__FECompConsultaResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__FECompConsultaResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__FECompConsultaResponse ? type : NULL);
}

SOAP_FMAC3 afip3__FECompConsultaResponse ** SOAP_FMAC4 soap_in_PointerToafip3__FECompConsultaResponse(struct soap *soap, const char *tag, afip3__FECompConsultaResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__FECompConsultaResponse **)soap_malloc(soap, sizeof(afip3__FECompConsultaResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__FECompConsultaResponse *)soap_instantiate_afip3__FECompConsultaResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__FECompConsultaResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__FECompConsultaResponse, sizeof(afip3__FECompConsultaResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__FECompConsultaResponse(struct soap *soap, afip3__FECompConsultaResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__FECompConsultaResponse(soap, tag ? tag : "afip3:FECompConsultaResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__FECompConsultaResponse ** SOAP_FMAC4 soap_get_PointerToafip3__FECompConsultaResponse(struct soap *soap, afip3__FECompConsultaResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__FECompConsultaResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__FECompConsultaReq(struct soap *soap, afip3__FECompConsultaReq *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__FECompConsultaReq))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__FECompConsultaReq(struct soap *soap, const char *tag, int id, afip3__FECompConsultaReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__FECompConsultaReq, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__FECompConsultaReq ? type : NULL);
}

SOAP_FMAC3 afip3__FECompConsultaReq ** SOAP_FMAC4 soap_in_PointerToafip3__FECompConsultaReq(struct soap *soap, const char *tag, afip3__FECompConsultaReq **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__FECompConsultaReq **)soap_malloc(soap, sizeof(afip3__FECompConsultaReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__FECompConsultaReq *)soap_instantiate_afip3__FECompConsultaReq(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__FECompConsultaReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__FECompConsultaReq, sizeof(afip3__FECompConsultaReq), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__FECompConsultaReq(struct soap *soap, afip3__FECompConsultaReq *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__FECompConsultaReq(soap, tag ? tag : "afip3:FECompConsultaReq", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__FECompConsultaReq ** SOAP_FMAC4 soap_get_PointerToafip3__FECompConsultaReq(struct soap *soap, afip3__FECompConsultaReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__FECompConsultaReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__FERecuperaLastCbteResponse(struct soap *soap, afip3__FERecuperaLastCbteResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__FERecuperaLastCbteResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__FERecuperaLastCbteResponse(struct soap *soap, const char *tag, int id, afip3__FERecuperaLastCbteResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__FERecuperaLastCbteResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__FERecuperaLastCbteResponse ? type : NULL);
}

SOAP_FMAC3 afip3__FERecuperaLastCbteResponse ** SOAP_FMAC4 soap_in_PointerToafip3__FERecuperaLastCbteResponse(struct soap *soap, const char *tag, afip3__FERecuperaLastCbteResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__FERecuperaLastCbteResponse **)soap_malloc(soap, sizeof(afip3__FERecuperaLastCbteResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__FERecuperaLastCbteResponse *)soap_instantiate_afip3__FERecuperaLastCbteResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__FERecuperaLastCbteResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__FERecuperaLastCbteResponse, sizeof(afip3__FERecuperaLastCbteResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__FERecuperaLastCbteResponse(struct soap *soap, afip3__FERecuperaLastCbteResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__FERecuperaLastCbteResponse(soap, tag ? tag : "afip3:FERecuperaLastCbteResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__FERecuperaLastCbteResponse ** SOAP_FMAC4 soap_get_PointerToafip3__FERecuperaLastCbteResponse(struct soap *soap, afip3__FERecuperaLastCbteResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__FERecuperaLastCbteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__DummyResponse(struct soap *soap, afip3__DummyResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__DummyResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__DummyResponse(struct soap *soap, const char *tag, int id, afip3__DummyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__DummyResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__DummyResponse ? type : NULL);
}

SOAP_FMAC3 afip3__DummyResponse ** SOAP_FMAC4 soap_in_PointerToafip3__DummyResponse(struct soap *soap, const char *tag, afip3__DummyResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__DummyResponse **)soap_malloc(soap, sizeof(afip3__DummyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__DummyResponse *)soap_instantiate_afip3__DummyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__DummyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__DummyResponse, sizeof(afip3__DummyResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__DummyResponse(struct soap *soap, afip3__DummyResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__DummyResponse(soap, tag ? tag : "afip3:DummyResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__DummyResponse ** SOAP_FMAC4 soap_get_PointerToafip3__DummyResponse(struct soap *soap, afip3__DummyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__DummyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__FERegXReqResponse(struct soap *soap, afip3__FERegXReqResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__FERegXReqResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__FERegXReqResponse(struct soap *soap, const char *tag, int id, afip3__FERegXReqResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__FERegXReqResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__FERegXReqResponse ? type : NULL);
}

SOAP_FMAC3 afip3__FERegXReqResponse ** SOAP_FMAC4 soap_in_PointerToafip3__FERegXReqResponse(struct soap *soap, const char *tag, afip3__FERegXReqResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__FERegXReqResponse **)soap_malloc(soap, sizeof(afip3__FERegXReqResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__FERegXReqResponse *)soap_instantiate_afip3__FERegXReqResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__FERegXReqResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__FERegXReqResponse, sizeof(afip3__FERegXReqResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__FERegXReqResponse(struct soap *soap, afip3__FERegXReqResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__FERegXReqResponse(soap, tag ? tag : "afip3:FERegXReqResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__FERegXReqResponse ** SOAP_FMAC4 soap_get_PointerToafip3__FERegXReqResponse(struct soap *soap, afip3__FERegXReqResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__FERegXReqResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__FECAEResponse(struct soap *soap, afip3__FECAEResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__FECAEResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__FECAEResponse(struct soap *soap, const char *tag, int id, afip3__FECAEResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__FECAEResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__FECAEResponse ? type : NULL);
}

SOAP_FMAC3 afip3__FECAEResponse ** SOAP_FMAC4 soap_in_PointerToafip3__FECAEResponse(struct soap *soap, const char *tag, afip3__FECAEResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__FECAEResponse **)soap_malloc(soap, sizeof(afip3__FECAEResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__FECAEResponse *)soap_instantiate_afip3__FECAEResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__FECAEResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__FECAEResponse, sizeof(afip3__FECAEResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__FECAEResponse(struct soap *soap, afip3__FECAEResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__FECAEResponse(soap, tag ? tag : "afip3:FECAEResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__FECAEResponse ** SOAP_FMAC4 soap_get_PointerToafip3__FECAEResponse(struct soap *soap, afip3__FECAEResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__FECAEResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__FECAERequest(struct soap *soap, afip3__FECAERequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__FECAERequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__FECAERequest(struct soap *soap, const char *tag, int id, afip3__FECAERequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__FECAERequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__FECAERequest ? type : NULL);
}

SOAP_FMAC3 afip3__FECAERequest ** SOAP_FMAC4 soap_in_PointerToafip3__FECAERequest(struct soap *soap, const char *tag, afip3__FECAERequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__FECAERequest **)soap_malloc(soap, sizeof(afip3__FECAERequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__FECAERequest *)soap_instantiate_afip3__FECAERequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__FECAERequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__FECAERequest, sizeof(afip3__FECAERequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__FECAERequest(struct soap *soap, afip3__FECAERequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__FECAERequest(soap, tag ? tag : "afip3:FECAERequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__FECAERequest ** SOAP_FMAC4 soap_get_PointerToafip3__FECAERequest(struct soap *soap, afip3__FECAERequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__FECAERequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__FEAuthRequest(struct soap *soap, afip3__FEAuthRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__FEAuthRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__FEAuthRequest(struct soap *soap, const char *tag, int id, afip3__FEAuthRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__FEAuthRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__FEAuthRequest ? type : NULL);
}

SOAP_FMAC3 afip3__FEAuthRequest ** SOAP_FMAC4 soap_in_PointerToafip3__FEAuthRequest(struct soap *soap, const char *tag, afip3__FEAuthRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__FEAuthRequest **)soap_malloc(soap, sizeof(afip3__FEAuthRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__FEAuthRequest *)soap_instantiate_afip3__FEAuthRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__FEAuthRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__FEAuthRequest, sizeof(afip3__FEAuthRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__FEAuthRequest(struct soap *soap, afip3__FEAuthRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__FEAuthRequest(soap, tag ? tag : "afip3:FEAuthRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__FEAuthRequest ** SOAP_FMAC4 soap_get_PointerToafip3__FEAuthRequest(struct soap *soap, afip3__FEAuthRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__FEAuthRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__PaisTipo(struct soap *soap, afip3__PaisTipo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__PaisTipo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__PaisTipo(struct soap *soap, const char *tag, int id, afip3__PaisTipo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__PaisTipo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__PaisTipo ? type : NULL);
}

SOAP_FMAC3 afip3__PaisTipo ** SOAP_FMAC4 soap_in_PointerToafip3__PaisTipo(struct soap *soap, const char *tag, afip3__PaisTipo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__PaisTipo **)soap_malloc(soap, sizeof(afip3__PaisTipo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__PaisTipo *)soap_instantiate_afip3__PaisTipo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__PaisTipo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__PaisTipo, sizeof(afip3__PaisTipo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__PaisTipo(struct soap *soap, afip3__PaisTipo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__PaisTipo(soap, tag ? tag : "afip3:PaisTipo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__PaisTipo ** SOAP_FMAC4 soap_get_PointerToafip3__PaisTipo(struct soap *soap, afip3__PaisTipo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__PaisTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__ArrayOfPaisTipo(struct soap *soap, afip3__ArrayOfPaisTipo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__ArrayOfPaisTipo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__ArrayOfPaisTipo(struct soap *soap, const char *tag, int id, afip3__ArrayOfPaisTipo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__ArrayOfPaisTipo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__ArrayOfPaisTipo ? type : NULL);
}

SOAP_FMAC3 afip3__ArrayOfPaisTipo ** SOAP_FMAC4 soap_in_PointerToafip3__ArrayOfPaisTipo(struct soap *soap, const char *tag, afip3__ArrayOfPaisTipo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__ArrayOfPaisTipo **)soap_malloc(soap, sizeof(afip3__ArrayOfPaisTipo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__ArrayOfPaisTipo *)soap_instantiate_afip3__ArrayOfPaisTipo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__ArrayOfPaisTipo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__ArrayOfPaisTipo, sizeof(afip3__ArrayOfPaisTipo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__ArrayOfPaisTipo(struct soap *soap, afip3__ArrayOfPaisTipo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__ArrayOfPaisTipo(soap, tag ? tag : "afip3:ArrayOfPaisTipo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__ArrayOfPaisTipo ** SOAP_FMAC4 soap_get_PointerToafip3__ArrayOfPaisTipo(struct soap *soap, afip3__ArrayOfPaisTipo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__ArrayOfPaisTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__DocTipo(struct soap *soap, afip3__DocTipo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__DocTipo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__DocTipo(struct soap *soap, const char *tag, int id, afip3__DocTipo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__DocTipo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__DocTipo ? type : NULL);
}

SOAP_FMAC3 afip3__DocTipo ** SOAP_FMAC4 soap_in_PointerToafip3__DocTipo(struct soap *soap, const char *tag, afip3__DocTipo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__DocTipo **)soap_malloc(soap, sizeof(afip3__DocTipo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__DocTipo *)soap_instantiate_afip3__DocTipo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__DocTipo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__DocTipo, sizeof(afip3__DocTipo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__DocTipo(struct soap *soap, afip3__DocTipo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__DocTipo(soap, tag ? tag : "afip3:DocTipo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__DocTipo ** SOAP_FMAC4 soap_get_PointerToafip3__DocTipo(struct soap *soap, afip3__DocTipo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__DocTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__ArrayOfDocTipo(struct soap *soap, afip3__ArrayOfDocTipo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__ArrayOfDocTipo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__ArrayOfDocTipo(struct soap *soap, const char *tag, int id, afip3__ArrayOfDocTipo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__ArrayOfDocTipo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__ArrayOfDocTipo ? type : NULL);
}

SOAP_FMAC3 afip3__ArrayOfDocTipo ** SOAP_FMAC4 soap_in_PointerToafip3__ArrayOfDocTipo(struct soap *soap, const char *tag, afip3__ArrayOfDocTipo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__ArrayOfDocTipo **)soap_malloc(soap, sizeof(afip3__ArrayOfDocTipo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__ArrayOfDocTipo *)soap_instantiate_afip3__ArrayOfDocTipo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__ArrayOfDocTipo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__ArrayOfDocTipo, sizeof(afip3__ArrayOfDocTipo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__ArrayOfDocTipo(struct soap *soap, afip3__ArrayOfDocTipo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__ArrayOfDocTipo(soap, tag ? tag : "afip3:ArrayOfDocTipo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__ArrayOfDocTipo ** SOAP_FMAC4 soap_get_PointerToafip3__ArrayOfDocTipo(struct soap *soap, afip3__ArrayOfDocTipo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__ArrayOfDocTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__CbteTipo(struct soap *soap, afip3__CbteTipo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__CbteTipo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__CbteTipo(struct soap *soap, const char *tag, int id, afip3__CbteTipo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__CbteTipo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__CbteTipo ? type : NULL);
}

SOAP_FMAC3 afip3__CbteTipo ** SOAP_FMAC4 soap_in_PointerToafip3__CbteTipo(struct soap *soap, const char *tag, afip3__CbteTipo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__CbteTipo **)soap_malloc(soap, sizeof(afip3__CbteTipo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__CbteTipo *)soap_instantiate_afip3__CbteTipo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__CbteTipo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__CbteTipo, sizeof(afip3__CbteTipo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__CbteTipo(struct soap *soap, afip3__CbteTipo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__CbteTipo(soap, tag ? tag : "afip3:CbteTipo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__CbteTipo ** SOAP_FMAC4 soap_get_PointerToafip3__CbteTipo(struct soap *soap, afip3__CbteTipo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__CbteTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__ArrayOfCbteTipo(struct soap *soap, afip3__ArrayOfCbteTipo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__ArrayOfCbteTipo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__ArrayOfCbteTipo(struct soap *soap, const char *tag, int id, afip3__ArrayOfCbteTipo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__ArrayOfCbteTipo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__ArrayOfCbteTipo ? type : NULL);
}

SOAP_FMAC3 afip3__ArrayOfCbteTipo ** SOAP_FMAC4 soap_in_PointerToafip3__ArrayOfCbteTipo(struct soap *soap, const char *tag, afip3__ArrayOfCbteTipo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__ArrayOfCbteTipo **)soap_malloc(soap, sizeof(afip3__ArrayOfCbteTipo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__ArrayOfCbteTipo *)soap_instantiate_afip3__ArrayOfCbteTipo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__ArrayOfCbteTipo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__ArrayOfCbteTipo, sizeof(afip3__ArrayOfCbteTipo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__ArrayOfCbteTipo(struct soap *soap, afip3__ArrayOfCbteTipo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__ArrayOfCbteTipo(soap, tag ? tag : "afip3:ArrayOfCbteTipo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__ArrayOfCbteTipo ** SOAP_FMAC4 soap_get_PointerToafip3__ArrayOfCbteTipo(struct soap *soap, afip3__ArrayOfCbteTipo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__ArrayOfCbteTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__PtoVenta(struct soap *soap, afip3__PtoVenta *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__PtoVenta))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__PtoVenta(struct soap *soap, const char *tag, int id, afip3__PtoVenta *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__PtoVenta, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__PtoVenta ? type : NULL);
}

SOAP_FMAC3 afip3__PtoVenta ** SOAP_FMAC4 soap_in_PointerToafip3__PtoVenta(struct soap *soap, const char *tag, afip3__PtoVenta **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__PtoVenta **)soap_malloc(soap, sizeof(afip3__PtoVenta *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__PtoVenta *)soap_instantiate_afip3__PtoVenta(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__PtoVenta **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__PtoVenta, sizeof(afip3__PtoVenta), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__PtoVenta(struct soap *soap, afip3__PtoVenta *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__PtoVenta(soap, tag ? tag : "afip3:PtoVenta", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__PtoVenta ** SOAP_FMAC4 soap_get_PointerToafip3__PtoVenta(struct soap *soap, afip3__PtoVenta **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__PtoVenta(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__ArrayOfPtoVenta(struct soap *soap, afip3__ArrayOfPtoVenta *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__ArrayOfPtoVenta))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__ArrayOfPtoVenta(struct soap *soap, const char *tag, int id, afip3__ArrayOfPtoVenta *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__ArrayOfPtoVenta, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__ArrayOfPtoVenta ? type : NULL);
}

SOAP_FMAC3 afip3__ArrayOfPtoVenta ** SOAP_FMAC4 soap_in_PointerToafip3__ArrayOfPtoVenta(struct soap *soap, const char *tag, afip3__ArrayOfPtoVenta **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__ArrayOfPtoVenta **)soap_malloc(soap, sizeof(afip3__ArrayOfPtoVenta *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__ArrayOfPtoVenta *)soap_instantiate_afip3__ArrayOfPtoVenta(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__ArrayOfPtoVenta **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__ArrayOfPtoVenta, sizeof(afip3__ArrayOfPtoVenta), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__ArrayOfPtoVenta(struct soap *soap, afip3__ArrayOfPtoVenta *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__ArrayOfPtoVenta(soap, tag ? tag : "afip3:ArrayOfPtoVenta", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__ArrayOfPtoVenta ** SOAP_FMAC4 soap_get_PointerToafip3__ArrayOfPtoVenta(struct soap *soap, afip3__ArrayOfPtoVenta **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__ArrayOfPtoVenta(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__ConceptoTipo(struct soap *soap, afip3__ConceptoTipo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__ConceptoTipo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__ConceptoTipo(struct soap *soap, const char *tag, int id, afip3__ConceptoTipo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__ConceptoTipo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__ConceptoTipo ? type : NULL);
}

SOAP_FMAC3 afip3__ConceptoTipo ** SOAP_FMAC4 soap_in_PointerToafip3__ConceptoTipo(struct soap *soap, const char *tag, afip3__ConceptoTipo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__ConceptoTipo **)soap_malloc(soap, sizeof(afip3__ConceptoTipo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__ConceptoTipo *)soap_instantiate_afip3__ConceptoTipo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__ConceptoTipo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__ConceptoTipo, sizeof(afip3__ConceptoTipo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__ConceptoTipo(struct soap *soap, afip3__ConceptoTipo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__ConceptoTipo(soap, tag ? tag : "afip3:ConceptoTipo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__ConceptoTipo ** SOAP_FMAC4 soap_get_PointerToafip3__ConceptoTipo(struct soap *soap, afip3__ConceptoTipo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__ConceptoTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__ArrayOfConceptoTipo(struct soap *soap, afip3__ArrayOfConceptoTipo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__ArrayOfConceptoTipo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__ArrayOfConceptoTipo(struct soap *soap, const char *tag, int id, afip3__ArrayOfConceptoTipo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__ArrayOfConceptoTipo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__ArrayOfConceptoTipo ? type : NULL);
}

SOAP_FMAC3 afip3__ArrayOfConceptoTipo ** SOAP_FMAC4 soap_in_PointerToafip3__ArrayOfConceptoTipo(struct soap *soap, const char *tag, afip3__ArrayOfConceptoTipo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__ArrayOfConceptoTipo **)soap_malloc(soap, sizeof(afip3__ArrayOfConceptoTipo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__ArrayOfConceptoTipo *)soap_instantiate_afip3__ArrayOfConceptoTipo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__ArrayOfConceptoTipo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__ArrayOfConceptoTipo, sizeof(afip3__ArrayOfConceptoTipo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__ArrayOfConceptoTipo(struct soap *soap, afip3__ArrayOfConceptoTipo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__ArrayOfConceptoTipo(soap, tag ? tag : "afip3:ArrayOfConceptoTipo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__ArrayOfConceptoTipo ** SOAP_FMAC4 soap_get_PointerToafip3__ArrayOfConceptoTipo(struct soap *soap, afip3__ArrayOfConceptoTipo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__ArrayOfConceptoTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__OpcionalTipo(struct soap *soap, afip3__OpcionalTipo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__OpcionalTipo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__OpcionalTipo(struct soap *soap, const char *tag, int id, afip3__OpcionalTipo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__OpcionalTipo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__OpcionalTipo ? type : NULL);
}

SOAP_FMAC3 afip3__OpcionalTipo ** SOAP_FMAC4 soap_in_PointerToafip3__OpcionalTipo(struct soap *soap, const char *tag, afip3__OpcionalTipo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__OpcionalTipo **)soap_malloc(soap, sizeof(afip3__OpcionalTipo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__OpcionalTipo *)soap_instantiate_afip3__OpcionalTipo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__OpcionalTipo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__OpcionalTipo, sizeof(afip3__OpcionalTipo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__OpcionalTipo(struct soap *soap, afip3__OpcionalTipo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__OpcionalTipo(soap, tag ? tag : "afip3:OpcionalTipo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__OpcionalTipo ** SOAP_FMAC4 soap_get_PointerToafip3__OpcionalTipo(struct soap *soap, afip3__OpcionalTipo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__OpcionalTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__ArrayOfOpcionalTipo(struct soap *soap, afip3__ArrayOfOpcionalTipo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__ArrayOfOpcionalTipo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__ArrayOfOpcionalTipo(struct soap *soap, const char *tag, int id, afip3__ArrayOfOpcionalTipo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__ArrayOfOpcionalTipo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__ArrayOfOpcionalTipo ? type : NULL);
}

SOAP_FMAC3 afip3__ArrayOfOpcionalTipo ** SOAP_FMAC4 soap_in_PointerToafip3__ArrayOfOpcionalTipo(struct soap *soap, const char *tag, afip3__ArrayOfOpcionalTipo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__ArrayOfOpcionalTipo **)soap_malloc(soap, sizeof(afip3__ArrayOfOpcionalTipo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__ArrayOfOpcionalTipo *)soap_instantiate_afip3__ArrayOfOpcionalTipo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__ArrayOfOpcionalTipo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__ArrayOfOpcionalTipo, sizeof(afip3__ArrayOfOpcionalTipo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__ArrayOfOpcionalTipo(struct soap *soap, afip3__ArrayOfOpcionalTipo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__ArrayOfOpcionalTipo(soap, tag ? tag : "afip3:ArrayOfOpcionalTipo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__ArrayOfOpcionalTipo ** SOAP_FMAC4 soap_get_PointerToafip3__ArrayOfOpcionalTipo(struct soap *soap, afip3__ArrayOfOpcionalTipo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__ArrayOfOpcionalTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__IvaTipo(struct soap *soap, afip3__IvaTipo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__IvaTipo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__IvaTipo(struct soap *soap, const char *tag, int id, afip3__IvaTipo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__IvaTipo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__IvaTipo ? type : NULL);
}

SOAP_FMAC3 afip3__IvaTipo ** SOAP_FMAC4 soap_in_PointerToafip3__IvaTipo(struct soap *soap, const char *tag, afip3__IvaTipo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__IvaTipo **)soap_malloc(soap, sizeof(afip3__IvaTipo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__IvaTipo *)soap_instantiate_afip3__IvaTipo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__IvaTipo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__IvaTipo, sizeof(afip3__IvaTipo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__IvaTipo(struct soap *soap, afip3__IvaTipo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__IvaTipo(soap, tag ? tag : "afip3:IvaTipo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__IvaTipo ** SOAP_FMAC4 soap_get_PointerToafip3__IvaTipo(struct soap *soap, afip3__IvaTipo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__IvaTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__ArrayOfIvaTipo(struct soap *soap, afip3__ArrayOfIvaTipo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__ArrayOfIvaTipo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__ArrayOfIvaTipo(struct soap *soap, const char *tag, int id, afip3__ArrayOfIvaTipo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__ArrayOfIvaTipo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__ArrayOfIvaTipo ? type : NULL);
}

SOAP_FMAC3 afip3__ArrayOfIvaTipo ** SOAP_FMAC4 soap_in_PointerToafip3__ArrayOfIvaTipo(struct soap *soap, const char *tag, afip3__ArrayOfIvaTipo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__ArrayOfIvaTipo **)soap_malloc(soap, sizeof(afip3__ArrayOfIvaTipo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__ArrayOfIvaTipo *)soap_instantiate_afip3__ArrayOfIvaTipo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__ArrayOfIvaTipo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__ArrayOfIvaTipo, sizeof(afip3__ArrayOfIvaTipo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__ArrayOfIvaTipo(struct soap *soap, afip3__ArrayOfIvaTipo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__ArrayOfIvaTipo(soap, tag ? tag : "afip3:ArrayOfIvaTipo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__ArrayOfIvaTipo ** SOAP_FMAC4 soap_get_PointerToafip3__ArrayOfIvaTipo(struct soap *soap, afip3__ArrayOfIvaTipo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__ArrayOfIvaTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__Moneda(struct soap *soap, afip3__Moneda *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__Moneda))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__Moneda(struct soap *soap, const char *tag, int id, afip3__Moneda *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__Moneda, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__Moneda ? type : NULL);
}

SOAP_FMAC3 afip3__Moneda ** SOAP_FMAC4 soap_in_PointerToafip3__Moneda(struct soap *soap, const char *tag, afip3__Moneda **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__Moneda **)soap_malloc(soap, sizeof(afip3__Moneda *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__Moneda *)soap_instantiate_afip3__Moneda(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__Moneda **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__Moneda, sizeof(afip3__Moneda), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__Moneda(struct soap *soap, afip3__Moneda *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__Moneda(soap, tag ? tag : "afip3:Moneda", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__Moneda ** SOAP_FMAC4 soap_get_PointerToafip3__Moneda(struct soap *soap, afip3__Moneda **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__Moneda(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__ArrayOfMoneda(struct soap *soap, afip3__ArrayOfMoneda *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__ArrayOfMoneda))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__ArrayOfMoneda(struct soap *soap, const char *tag, int id, afip3__ArrayOfMoneda *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__ArrayOfMoneda, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__ArrayOfMoneda ? type : NULL);
}

SOAP_FMAC3 afip3__ArrayOfMoneda ** SOAP_FMAC4 soap_in_PointerToafip3__ArrayOfMoneda(struct soap *soap, const char *tag, afip3__ArrayOfMoneda **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__ArrayOfMoneda **)soap_malloc(soap, sizeof(afip3__ArrayOfMoneda *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__ArrayOfMoneda *)soap_instantiate_afip3__ArrayOfMoneda(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__ArrayOfMoneda **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__ArrayOfMoneda, sizeof(afip3__ArrayOfMoneda), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__ArrayOfMoneda(struct soap *soap, afip3__ArrayOfMoneda *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__ArrayOfMoneda(soap, tag ? tag : "afip3:ArrayOfMoneda", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__ArrayOfMoneda ** SOAP_FMAC4 soap_get_PointerToafip3__ArrayOfMoneda(struct soap *soap, afip3__ArrayOfMoneda **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__ArrayOfMoneda(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__TributoTipo(struct soap *soap, afip3__TributoTipo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__TributoTipo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__TributoTipo(struct soap *soap, const char *tag, int id, afip3__TributoTipo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__TributoTipo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__TributoTipo ? type : NULL);
}

SOAP_FMAC3 afip3__TributoTipo ** SOAP_FMAC4 soap_in_PointerToafip3__TributoTipo(struct soap *soap, const char *tag, afip3__TributoTipo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__TributoTipo **)soap_malloc(soap, sizeof(afip3__TributoTipo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__TributoTipo *)soap_instantiate_afip3__TributoTipo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__TributoTipo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__TributoTipo, sizeof(afip3__TributoTipo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__TributoTipo(struct soap *soap, afip3__TributoTipo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__TributoTipo(soap, tag ? tag : "afip3:TributoTipo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__TributoTipo ** SOAP_FMAC4 soap_get_PointerToafip3__TributoTipo(struct soap *soap, afip3__TributoTipo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__TributoTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__ArrayOfTributoTipo(struct soap *soap, afip3__ArrayOfTributoTipo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__ArrayOfTributoTipo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__ArrayOfTributoTipo(struct soap *soap, const char *tag, int id, afip3__ArrayOfTributoTipo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__ArrayOfTributoTipo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__ArrayOfTributoTipo ? type : NULL);
}

SOAP_FMAC3 afip3__ArrayOfTributoTipo ** SOAP_FMAC4 soap_in_PointerToafip3__ArrayOfTributoTipo(struct soap *soap, const char *tag, afip3__ArrayOfTributoTipo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__ArrayOfTributoTipo **)soap_malloc(soap, sizeof(afip3__ArrayOfTributoTipo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__ArrayOfTributoTipo *)soap_instantiate_afip3__ArrayOfTributoTipo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__ArrayOfTributoTipo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__ArrayOfTributoTipo, sizeof(afip3__ArrayOfTributoTipo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__ArrayOfTributoTipo(struct soap *soap, afip3__ArrayOfTributoTipo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__ArrayOfTributoTipo(soap, tag ? tag : "afip3:ArrayOfTributoTipo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__ArrayOfTributoTipo ** SOAP_FMAC4 soap_get_PointerToafip3__ArrayOfTributoTipo(struct soap *soap, afip3__ArrayOfTributoTipo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__ArrayOfTributoTipo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__Cotizacion(struct soap *soap, afip3__Cotizacion *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__Cotizacion))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__Cotizacion(struct soap *soap, const char *tag, int id, afip3__Cotizacion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__Cotizacion, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__Cotizacion ? type : NULL);
}

SOAP_FMAC3 afip3__Cotizacion ** SOAP_FMAC4 soap_in_PointerToafip3__Cotizacion(struct soap *soap, const char *tag, afip3__Cotizacion **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__Cotizacion **)soap_malloc(soap, sizeof(afip3__Cotizacion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__Cotizacion *)soap_instantiate_afip3__Cotizacion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__Cotizacion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__Cotizacion, sizeof(afip3__Cotizacion), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__Cotizacion(struct soap *soap, afip3__Cotizacion *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__Cotizacion(soap, tag ? tag : "afip3:Cotizacion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__Cotizacion ** SOAP_FMAC4 soap_get_PointerToafip3__Cotizacion(struct soap *soap, afip3__Cotizacion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__Cotizacion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__FECAEASinMov(struct soap *soap, afip3__FECAEASinMov *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__FECAEASinMov))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__FECAEASinMov(struct soap *soap, const char *tag, int id, afip3__FECAEASinMov *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__FECAEASinMov, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__FECAEASinMov ? type : NULL);
}

SOAP_FMAC3 afip3__FECAEASinMov ** SOAP_FMAC4 soap_in_PointerToafip3__FECAEASinMov(struct soap *soap, const char *tag, afip3__FECAEASinMov **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__FECAEASinMov **)soap_malloc(soap, sizeof(afip3__FECAEASinMov *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__FECAEASinMov *)soap_instantiate_afip3__FECAEASinMov(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__FECAEASinMov **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__FECAEASinMov, sizeof(afip3__FECAEASinMov), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__FECAEASinMov(struct soap *soap, afip3__FECAEASinMov *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__FECAEASinMov(soap, tag ? tag : "afip3:FECAEASinMov", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__FECAEASinMov ** SOAP_FMAC4 soap_get_PointerToafip3__FECAEASinMov(struct soap *soap, afip3__FECAEASinMov **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__FECAEASinMov(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__ArrayOfFECAEASinMov(struct soap *soap, afip3__ArrayOfFECAEASinMov *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__ArrayOfFECAEASinMov))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__ArrayOfFECAEASinMov(struct soap *soap, const char *tag, int id, afip3__ArrayOfFECAEASinMov *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__ArrayOfFECAEASinMov, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__ArrayOfFECAEASinMov ? type : NULL);
}

SOAP_FMAC3 afip3__ArrayOfFECAEASinMov ** SOAP_FMAC4 soap_in_PointerToafip3__ArrayOfFECAEASinMov(struct soap *soap, const char *tag, afip3__ArrayOfFECAEASinMov **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__ArrayOfFECAEASinMov **)soap_malloc(soap, sizeof(afip3__ArrayOfFECAEASinMov *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__ArrayOfFECAEASinMov *)soap_instantiate_afip3__ArrayOfFECAEASinMov(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__ArrayOfFECAEASinMov **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__ArrayOfFECAEASinMov, sizeof(afip3__ArrayOfFECAEASinMov), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__ArrayOfFECAEASinMov(struct soap *soap, afip3__ArrayOfFECAEASinMov *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__ArrayOfFECAEASinMov(soap, tag ? tag : "afip3:ArrayOfFECAEASinMov", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__ArrayOfFECAEASinMov ** SOAP_FMAC4 soap_get_PointerToafip3__ArrayOfFECAEASinMov(struct soap *soap, afip3__ArrayOfFECAEASinMov **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__ArrayOfFECAEASinMov(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__FECAEAGet(struct soap *soap, afip3__FECAEAGet *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__FECAEAGet))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__FECAEAGet(struct soap *soap, const char *tag, int id, afip3__FECAEAGet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__FECAEAGet, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__FECAEAGet ? type : NULL);
}

SOAP_FMAC3 afip3__FECAEAGet ** SOAP_FMAC4 soap_in_PointerToafip3__FECAEAGet(struct soap *soap, const char *tag, afip3__FECAEAGet **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__FECAEAGet **)soap_malloc(soap, sizeof(afip3__FECAEAGet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__FECAEAGet *)soap_instantiate_afip3__FECAEAGet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__FECAEAGet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__FECAEAGet, sizeof(afip3__FECAEAGet), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__FECAEAGet(struct soap *soap, afip3__FECAEAGet *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__FECAEAGet(soap, tag ? tag : "afip3:FECAEAGet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__FECAEAGet ** SOAP_FMAC4 soap_get_PointerToafip3__FECAEAGet(struct soap *soap, afip3__FECAEAGet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__FECAEAGet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__FECAEADetResponse(struct soap *soap, afip3__FECAEADetResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__FECAEADetResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__FECAEADetResponse(struct soap *soap, const char *tag, int id, afip3__FECAEADetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__FECAEADetResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__FECAEADetResponse ? type : NULL);
}

SOAP_FMAC3 afip3__FECAEADetResponse ** SOAP_FMAC4 soap_in_PointerToafip3__FECAEADetResponse(struct soap *soap, const char *tag, afip3__FECAEADetResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__FECAEADetResponse **)soap_malloc(soap, sizeof(afip3__FECAEADetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__FECAEADetResponse *)soap_instantiate_afip3__FECAEADetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__FECAEADetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__FECAEADetResponse, sizeof(afip3__FECAEADetResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__FECAEADetResponse(struct soap *soap, afip3__FECAEADetResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__FECAEADetResponse(soap, tag ? tag : "afip3:FECAEADetResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__FECAEADetResponse ** SOAP_FMAC4 soap_get_PointerToafip3__FECAEADetResponse(struct soap *soap, afip3__FECAEADetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__FECAEADetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__ArrayOfFECAEADetResponse(struct soap *soap, afip3__ArrayOfFECAEADetResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__ArrayOfFECAEADetResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__ArrayOfFECAEADetResponse(struct soap *soap, const char *tag, int id, afip3__ArrayOfFECAEADetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__ArrayOfFECAEADetResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__ArrayOfFECAEADetResponse ? type : NULL);
}

SOAP_FMAC3 afip3__ArrayOfFECAEADetResponse ** SOAP_FMAC4 soap_in_PointerToafip3__ArrayOfFECAEADetResponse(struct soap *soap, const char *tag, afip3__ArrayOfFECAEADetResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__ArrayOfFECAEADetResponse **)soap_malloc(soap, sizeof(afip3__ArrayOfFECAEADetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__ArrayOfFECAEADetResponse *)soap_instantiate_afip3__ArrayOfFECAEADetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__ArrayOfFECAEADetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__ArrayOfFECAEADetResponse, sizeof(afip3__ArrayOfFECAEADetResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__ArrayOfFECAEADetResponse(struct soap *soap, afip3__ArrayOfFECAEADetResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__ArrayOfFECAEADetResponse(soap, tag ? tag : "afip3:ArrayOfFECAEADetResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__ArrayOfFECAEADetResponse ** SOAP_FMAC4 soap_get_PointerToafip3__ArrayOfFECAEADetResponse(struct soap *soap, afip3__ArrayOfFECAEADetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__ArrayOfFECAEADetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__FECAEACabResponse(struct soap *soap, afip3__FECAEACabResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__FECAEACabResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__FECAEACabResponse(struct soap *soap, const char *tag, int id, afip3__FECAEACabResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__FECAEACabResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__FECAEACabResponse ? type : NULL);
}

SOAP_FMAC3 afip3__FECAEACabResponse ** SOAP_FMAC4 soap_in_PointerToafip3__FECAEACabResponse(struct soap *soap, const char *tag, afip3__FECAEACabResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__FECAEACabResponse **)soap_malloc(soap, sizeof(afip3__FECAEACabResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__FECAEACabResponse *)soap_instantiate_afip3__FECAEACabResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__FECAEACabResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__FECAEACabResponse, sizeof(afip3__FECAEACabResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__FECAEACabResponse(struct soap *soap, afip3__FECAEACabResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__FECAEACabResponse(soap, tag ? tag : "afip3:FECAEACabResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__FECAEACabResponse ** SOAP_FMAC4 soap_get_PointerToafip3__FECAEACabResponse(struct soap *soap, afip3__FECAEACabResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__FECAEACabResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__FECAEADetRequest(struct soap *soap, afip3__FECAEADetRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__FECAEADetRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__FECAEADetRequest(struct soap *soap, const char *tag, int id, afip3__FECAEADetRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__FECAEADetRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__FECAEADetRequest ? type : NULL);
}

SOAP_FMAC3 afip3__FECAEADetRequest ** SOAP_FMAC4 soap_in_PointerToafip3__FECAEADetRequest(struct soap *soap, const char *tag, afip3__FECAEADetRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__FECAEADetRequest **)soap_malloc(soap, sizeof(afip3__FECAEADetRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__FECAEADetRequest *)soap_instantiate_afip3__FECAEADetRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__FECAEADetRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__FECAEADetRequest, sizeof(afip3__FECAEADetRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__FECAEADetRequest(struct soap *soap, afip3__FECAEADetRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__FECAEADetRequest(soap, tag ? tag : "afip3:FECAEADetRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__FECAEADetRequest ** SOAP_FMAC4 soap_get_PointerToafip3__FECAEADetRequest(struct soap *soap, afip3__FECAEADetRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__FECAEADetRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__ArrayOfFECAEADetRequest(struct soap *soap, afip3__ArrayOfFECAEADetRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__ArrayOfFECAEADetRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__ArrayOfFECAEADetRequest(struct soap *soap, const char *tag, int id, afip3__ArrayOfFECAEADetRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__ArrayOfFECAEADetRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__ArrayOfFECAEADetRequest ? type : NULL);
}

SOAP_FMAC3 afip3__ArrayOfFECAEADetRequest ** SOAP_FMAC4 soap_in_PointerToafip3__ArrayOfFECAEADetRequest(struct soap *soap, const char *tag, afip3__ArrayOfFECAEADetRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__ArrayOfFECAEADetRequest **)soap_malloc(soap, sizeof(afip3__ArrayOfFECAEADetRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__ArrayOfFECAEADetRequest *)soap_instantiate_afip3__ArrayOfFECAEADetRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__ArrayOfFECAEADetRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__ArrayOfFECAEADetRequest, sizeof(afip3__ArrayOfFECAEADetRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__ArrayOfFECAEADetRequest(struct soap *soap, afip3__ArrayOfFECAEADetRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__ArrayOfFECAEADetRequest(soap, tag ? tag : "afip3:ArrayOfFECAEADetRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__ArrayOfFECAEADetRequest ** SOAP_FMAC4 soap_get_PointerToafip3__ArrayOfFECAEADetRequest(struct soap *soap, afip3__ArrayOfFECAEADetRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__ArrayOfFECAEADetRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__FECAEACabRequest(struct soap *soap, afip3__FECAEACabRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__FECAEACabRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__FECAEACabRequest(struct soap *soap, const char *tag, int id, afip3__FECAEACabRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__FECAEACabRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__FECAEACabRequest ? type : NULL);
}

SOAP_FMAC3 afip3__FECAEACabRequest ** SOAP_FMAC4 soap_in_PointerToafip3__FECAEACabRequest(struct soap *soap, const char *tag, afip3__FECAEACabRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__FECAEACabRequest **)soap_malloc(soap, sizeof(afip3__FECAEACabRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__FECAEACabRequest *)soap_instantiate_afip3__FECAEACabRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__FECAEACabRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__FECAEACabRequest, sizeof(afip3__FECAEACabRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__FECAEACabRequest(struct soap *soap, afip3__FECAEACabRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__FECAEACabRequest(soap, tag ? tag : "afip3:FECAEACabRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__FECAEACabRequest ** SOAP_FMAC4 soap_get_PointerToafip3__FECAEACabRequest(struct soap *soap, afip3__FECAEACabRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__FECAEACabRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__FECompConsResponse(struct soap *soap, afip3__FECompConsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__FECompConsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__FECompConsResponse(struct soap *soap, const char *tag, int id, afip3__FECompConsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__FECompConsResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__FECompConsResponse ? type : NULL);
}

SOAP_FMAC3 afip3__FECompConsResponse ** SOAP_FMAC4 soap_in_PointerToafip3__FECompConsResponse(struct soap *soap, const char *tag, afip3__FECompConsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__FECompConsResponse **)soap_malloc(soap, sizeof(afip3__FECompConsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__FECompConsResponse *)soap_instantiate_afip3__FECompConsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__FECompConsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__FECompConsResponse, sizeof(afip3__FECompConsResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__FECompConsResponse(struct soap *soap, afip3__FECompConsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__FECompConsResponse(soap, tag ? tag : "afip3:FECompConsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__FECompConsResponse ** SOAP_FMAC4 soap_get_PointerToafip3__FECompConsResponse(struct soap *soap, afip3__FECompConsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__FECompConsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__Err(struct soap *soap, afip3__Err *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__Err))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__Err(struct soap *soap, const char *tag, int id, afip3__Err *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__Err, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__Err ? type : NULL);
}

SOAP_FMAC3 afip3__Err ** SOAP_FMAC4 soap_in_PointerToafip3__Err(struct soap *soap, const char *tag, afip3__Err **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__Err **)soap_malloc(soap, sizeof(afip3__Err *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__Err *)soap_instantiate_afip3__Err(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__Err **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__Err, sizeof(afip3__Err), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__Err(struct soap *soap, afip3__Err *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__Err(soap, tag ? tag : "afip3:Err", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__Err ** SOAP_FMAC4 soap_get_PointerToafip3__Err(struct soap *soap, afip3__Err **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__Err(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__Evt(struct soap *soap, afip3__Evt *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__Evt))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__Evt(struct soap *soap, const char *tag, int id, afip3__Evt *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__Evt, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__Evt ? type : NULL);
}

SOAP_FMAC3 afip3__Evt ** SOAP_FMAC4 soap_in_PointerToafip3__Evt(struct soap *soap, const char *tag, afip3__Evt **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__Evt **)soap_malloc(soap, sizeof(afip3__Evt *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__Evt *)soap_instantiate_afip3__Evt(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__Evt **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__Evt, sizeof(afip3__Evt), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__Evt(struct soap *soap, afip3__Evt *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__Evt(soap, tag ? tag : "afip3:Evt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__Evt ** SOAP_FMAC4 soap_get_PointerToafip3__Evt(struct soap *soap, afip3__Evt **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__Evt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__Obs(struct soap *soap, afip3__Obs *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__Obs))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__Obs(struct soap *soap, const char *tag, int id, afip3__Obs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__Obs, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__Obs ? type : NULL);
}

SOAP_FMAC3 afip3__Obs ** SOAP_FMAC4 soap_in_PointerToafip3__Obs(struct soap *soap, const char *tag, afip3__Obs **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__Obs **)soap_malloc(soap, sizeof(afip3__Obs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__Obs *)soap_instantiate_afip3__Obs(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__Obs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__Obs, sizeof(afip3__Obs), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__Obs(struct soap *soap, afip3__Obs *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__Obs(soap, tag ? tag : "afip3:Obs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__Obs ** SOAP_FMAC4 soap_get_PointerToafip3__Obs(struct soap *soap, afip3__Obs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__Obs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__ArrayOfObs(struct soap *soap, afip3__ArrayOfObs *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__ArrayOfObs))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__ArrayOfObs(struct soap *soap, const char *tag, int id, afip3__ArrayOfObs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__ArrayOfObs, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__ArrayOfObs ? type : NULL);
}

SOAP_FMAC3 afip3__ArrayOfObs ** SOAP_FMAC4 soap_in_PointerToafip3__ArrayOfObs(struct soap *soap, const char *tag, afip3__ArrayOfObs **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__ArrayOfObs **)soap_malloc(soap, sizeof(afip3__ArrayOfObs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__ArrayOfObs *)soap_instantiate_afip3__ArrayOfObs(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__ArrayOfObs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__ArrayOfObs, sizeof(afip3__ArrayOfObs), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__ArrayOfObs(struct soap *soap, afip3__ArrayOfObs *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__ArrayOfObs(soap, tag ? tag : "afip3:ArrayOfObs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__ArrayOfObs ** SOAP_FMAC4 soap_get_PointerToafip3__ArrayOfObs(struct soap *soap, afip3__ArrayOfObs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__ArrayOfObs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__FECAEDetResponse(struct soap *soap, afip3__FECAEDetResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__FECAEDetResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__FECAEDetResponse(struct soap *soap, const char *tag, int id, afip3__FECAEDetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__FECAEDetResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__FECAEDetResponse ? type : NULL);
}

SOAP_FMAC3 afip3__FECAEDetResponse ** SOAP_FMAC4 soap_in_PointerToafip3__FECAEDetResponse(struct soap *soap, const char *tag, afip3__FECAEDetResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__FECAEDetResponse **)soap_malloc(soap, sizeof(afip3__FECAEDetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__FECAEDetResponse *)soap_instantiate_afip3__FECAEDetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__FECAEDetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__FECAEDetResponse, sizeof(afip3__FECAEDetResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__FECAEDetResponse(struct soap *soap, afip3__FECAEDetResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__FECAEDetResponse(soap, tag ? tag : "afip3:FECAEDetResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__FECAEDetResponse ** SOAP_FMAC4 soap_get_PointerToafip3__FECAEDetResponse(struct soap *soap, afip3__FECAEDetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__FECAEDetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__ArrayOfErr(struct soap *soap, afip3__ArrayOfErr *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__ArrayOfErr))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__ArrayOfErr(struct soap *soap, const char *tag, int id, afip3__ArrayOfErr *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__ArrayOfErr, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__ArrayOfErr ? type : NULL);
}

SOAP_FMAC3 afip3__ArrayOfErr ** SOAP_FMAC4 soap_in_PointerToafip3__ArrayOfErr(struct soap *soap, const char *tag, afip3__ArrayOfErr **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__ArrayOfErr **)soap_malloc(soap, sizeof(afip3__ArrayOfErr *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__ArrayOfErr *)soap_instantiate_afip3__ArrayOfErr(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__ArrayOfErr **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__ArrayOfErr, sizeof(afip3__ArrayOfErr), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__ArrayOfErr(struct soap *soap, afip3__ArrayOfErr *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__ArrayOfErr(soap, tag ? tag : "afip3:ArrayOfErr", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__ArrayOfErr ** SOAP_FMAC4 soap_get_PointerToafip3__ArrayOfErr(struct soap *soap, afip3__ArrayOfErr **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__ArrayOfErr(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__ArrayOfEvt(struct soap *soap, afip3__ArrayOfEvt *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__ArrayOfEvt))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__ArrayOfEvt(struct soap *soap, const char *tag, int id, afip3__ArrayOfEvt *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__ArrayOfEvt, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__ArrayOfEvt ? type : NULL);
}

SOAP_FMAC3 afip3__ArrayOfEvt ** SOAP_FMAC4 soap_in_PointerToafip3__ArrayOfEvt(struct soap *soap, const char *tag, afip3__ArrayOfEvt **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__ArrayOfEvt **)soap_malloc(soap, sizeof(afip3__ArrayOfEvt *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__ArrayOfEvt *)soap_instantiate_afip3__ArrayOfEvt(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__ArrayOfEvt **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__ArrayOfEvt, sizeof(afip3__ArrayOfEvt), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__ArrayOfEvt(struct soap *soap, afip3__ArrayOfEvt *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__ArrayOfEvt(soap, tag ? tag : "afip3:ArrayOfEvt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__ArrayOfEvt ** SOAP_FMAC4 soap_get_PointerToafip3__ArrayOfEvt(struct soap *soap, afip3__ArrayOfEvt **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__ArrayOfEvt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__ArrayOfFECAEDetResponse(struct soap *soap, afip3__ArrayOfFECAEDetResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__ArrayOfFECAEDetResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__ArrayOfFECAEDetResponse(struct soap *soap, const char *tag, int id, afip3__ArrayOfFECAEDetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__ArrayOfFECAEDetResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__ArrayOfFECAEDetResponse ? type : NULL);
}

SOAP_FMAC3 afip3__ArrayOfFECAEDetResponse ** SOAP_FMAC4 soap_in_PointerToafip3__ArrayOfFECAEDetResponse(struct soap *soap, const char *tag, afip3__ArrayOfFECAEDetResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__ArrayOfFECAEDetResponse **)soap_malloc(soap, sizeof(afip3__ArrayOfFECAEDetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__ArrayOfFECAEDetResponse *)soap_instantiate_afip3__ArrayOfFECAEDetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__ArrayOfFECAEDetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__ArrayOfFECAEDetResponse, sizeof(afip3__ArrayOfFECAEDetResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__ArrayOfFECAEDetResponse(struct soap *soap, afip3__ArrayOfFECAEDetResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__ArrayOfFECAEDetResponse(soap, tag ? tag : "afip3:ArrayOfFECAEDetResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__ArrayOfFECAEDetResponse ** SOAP_FMAC4 soap_get_PointerToafip3__ArrayOfFECAEDetResponse(struct soap *soap, afip3__ArrayOfFECAEDetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__ArrayOfFECAEDetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__FECAECabResponse(struct soap *soap, afip3__FECAECabResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__FECAECabResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__FECAECabResponse(struct soap *soap, const char *tag, int id, afip3__FECAECabResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__FECAECabResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__FECAECabResponse ? type : NULL);
}

SOAP_FMAC3 afip3__FECAECabResponse ** SOAP_FMAC4 soap_in_PointerToafip3__FECAECabResponse(struct soap *soap, const char *tag, afip3__FECAECabResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__FECAECabResponse **)soap_malloc(soap, sizeof(afip3__FECAECabResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__FECAECabResponse *)soap_instantiate_afip3__FECAECabResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__FECAECabResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__FECAECabResponse, sizeof(afip3__FECAECabResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__FECAECabResponse(struct soap *soap, afip3__FECAECabResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__FECAECabResponse(soap, tag ? tag : "afip3:FECAECabResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__FECAECabResponse ** SOAP_FMAC4 soap_get_PointerToafip3__FECAECabResponse(struct soap *soap, afip3__FECAECabResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__FECAECabResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__Comprador(struct soap *soap, afip3__Comprador *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__Comprador))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__Comprador(struct soap *soap, const char *tag, int id, afip3__Comprador *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__Comprador, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__Comprador ? type : NULL);
}

SOAP_FMAC3 afip3__Comprador ** SOAP_FMAC4 soap_in_PointerToafip3__Comprador(struct soap *soap, const char *tag, afip3__Comprador **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__Comprador **)soap_malloc(soap, sizeof(afip3__Comprador *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__Comprador *)soap_instantiate_afip3__Comprador(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__Comprador **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__Comprador, sizeof(afip3__Comprador), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__Comprador(struct soap *soap, afip3__Comprador *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__Comprador(soap, tag ? tag : "afip3:Comprador", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__Comprador ** SOAP_FMAC4 soap_get_PointerToafip3__Comprador(struct soap *soap, afip3__Comprador **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__Comprador(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__Opcional(struct soap *soap, afip3__Opcional *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__Opcional))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__Opcional(struct soap *soap, const char *tag, int id, afip3__Opcional *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__Opcional, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__Opcional ? type : NULL);
}

SOAP_FMAC3 afip3__Opcional ** SOAP_FMAC4 soap_in_PointerToafip3__Opcional(struct soap *soap, const char *tag, afip3__Opcional **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__Opcional **)soap_malloc(soap, sizeof(afip3__Opcional *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__Opcional *)soap_instantiate_afip3__Opcional(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__Opcional **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__Opcional, sizeof(afip3__Opcional), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__Opcional(struct soap *soap, afip3__Opcional *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__Opcional(soap, tag ? tag : "afip3:Opcional", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__Opcional ** SOAP_FMAC4 soap_get_PointerToafip3__Opcional(struct soap *soap, afip3__Opcional **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__Opcional(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__AlicIva(struct soap *soap, afip3__AlicIva *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__AlicIva))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__AlicIva(struct soap *soap, const char *tag, int id, afip3__AlicIva *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__AlicIva, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__AlicIva ? type : NULL);
}

SOAP_FMAC3 afip3__AlicIva ** SOAP_FMAC4 soap_in_PointerToafip3__AlicIva(struct soap *soap, const char *tag, afip3__AlicIva **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__AlicIva **)soap_malloc(soap, sizeof(afip3__AlicIva *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__AlicIva *)soap_instantiate_afip3__AlicIva(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__AlicIva **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__AlicIva, sizeof(afip3__AlicIva), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__AlicIva(struct soap *soap, afip3__AlicIva *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__AlicIva(soap, tag ? tag : "afip3:AlicIva", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__AlicIva ** SOAP_FMAC4 soap_get_PointerToafip3__AlicIva(struct soap *soap, afip3__AlicIva **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__AlicIva(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__Tributo(struct soap *soap, afip3__Tributo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__Tributo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__Tributo(struct soap *soap, const char *tag, int id, afip3__Tributo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__Tributo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__Tributo ? type : NULL);
}

SOAP_FMAC3 afip3__Tributo ** SOAP_FMAC4 soap_in_PointerToafip3__Tributo(struct soap *soap, const char *tag, afip3__Tributo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__Tributo **)soap_malloc(soap, sizeof(afip3__Tributo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__Tributo *)soap_instantiate_afip3__Tributo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__Tributo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__Tributo, sizeof(afip3__Tributo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__Tributo(struct soap *soap, afip3__Tributo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__Tributo(soap, tag ? tag : "afip3:Tributo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__Tributo ** SOAP_FMAC4 soap_get_PointerToafip3__Tributo(struct soap *soap, afip3__Tributo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__Tributo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__CbteAsoc(struct soap *soap, afip3__CbteAsoc *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__CbteAsoc))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__CbteAsoc(struct soap *soap, const char *tag, int id, afip3__CbteAsoc *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__CbteAsoc, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__CbteAsoc ? type : NULL);
}

SOAP_FMAC3 afip3__CbteAsoc ** SOAP_FMAC4 soap_in_PointerToafip3__CbteAsoc(struct soap *soap, const char *tag, afip3__CbteAsoc **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__CbteAsoc **)soap_malloc(soap, sizeof(afip3__CbteAsoc *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__CbteAsoc *)soap_instantiate_afip3__CbteAsoc(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__CbteAsoc **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__CbteAsoc, sizeof(afip3__CbteAsoc), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__CbteAsoc(struct soap *soap, afip3__CbteAsoc *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__CbteAsoc(soap, tag ? tag : "afip3:CbteAsoc", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__CbteAsoc ** SOAP_FMAC4 soap_get_PointerToafip3__CbteAsoc(struct soap *soap, afip3__CbteAsoc **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__CbteAsoc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__ArrayOfComprador(struct soap *soap, afip3__ArrayOfComprador *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__ArrayOfComprador))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__ArrayOfComprador(struct soap *soap, const char *tag, int id, afip3__ArrayOfComprador *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__ArrayOfComprador, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__ArrayOfComprador ? type : NULL);
}

SOAP_FMAC3 afip3__ArrayOfComprador ** SOAP_FMAC4 soap_in_PointerToafip3__ArrayOfComprador(struct soap *soap, const char *tag, afip3__ArrayOfComprador **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__ArrayOfComprador **)soap_malloc(soap, sizeof(afip3__ArrayOfComprador *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__ArrayOfComprador *)soap_instantiate_afip3__ArrayOfComprador(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__ArrayOfComprador **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__ArrayOfComprador, sizeof(afip3__ArrayOfComprador), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__ArrayOfComprador(struct soap *soap, afip3__ArrayOfComprador *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__ArrayOfComprador(soap, tag ? tag : "afip3:ArrayOfComprador", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__ArrayOfComprador ** SOAP_FMAC4 soap_get_PointerToafip3__ArrayOfComprador(struct soap *soap, afip3__ArrayOfComprador **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__ArrayOfComprador(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__ArrayOfOpcional(struct soap *soap, afip3__ArrayOfOpcional *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__ArrayOfOpcional))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__ArrayOfOpcional(struct soap *soap, const char *tag, int id, afip3__ArrayOfOpcional *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__ArrayOfOpcional, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__ArrayOfOpcional ? type : NULL);
}

SOAP_FMAC3 afip3__ArrayOfOpcional ** SOAP_FMAC4 soap_in_PointerToafip3__ArrayOfOpcional(struct soap *soap, const char *tag, afip3__ArrayOfOpcional **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__ArrayOfOpcional **)soap_malloc(soap, sizeof(afip3__ArrayOfOpcional *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__ArrayOfOpcional *)soap_instantiate_afip3__ArrayOfOpcional(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__ArrayOfOpcional **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__ArrayOfOpcional, sizeof(afip3__ArrayOfOpcional), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__ArrayOfOpcional(struct soap *soap, afip3__ArrayOfOpcional *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__ArrayOfOpcional(soap, tag ? tag : "afip3:ArrayOfOpcional", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__ArrayOfOpcional ** SOAP_FMAC4 soap_get_PointerToafip3__ArrayOfOpcional(struct soap *soap, afip3__ArrayOfOpcional **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__ArrayOfOpcional(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__ArrayOfAlicIva(struct soap *soap, afip3__ArrayOfAlicIva *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__ArrayOfAlicIva))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__ArrayOfAlicIva(struct soap *soap, const char *tag, int id, afip3__ArrayOfAlicIva *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__ArrayOfAlicIva, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__ArrayOfAlicIva ? type : NULL);
}

SOAP_FMAC3 afip3__ArrayOfAlicIva ** SOAP_FMAC4 soap_in_PointerToafip3__ArrayOfAlicIva(struct soap *soap, const char *tag, afip3__ArrayOfAlicIva **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__ArrayOfAlicIva **)soap_malloc(soap, sizeof(afip3__ArrayOfAlicIva *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__ArrayOfAlicIva *)soap_instantiate_afip3__ArrayOfAlicIva(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__ArrayOfAlicIva **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__ArrayOfAlicIva, sizeof(afip3__ArrayOfAlicIva), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__ArrayOfAlicIva(struct soap *soap, afip3__ArrayOfAlicIva *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__ArrayOfAlicIva(soap, tag ? tag : "afip3:ArrayOfAlicIva", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__ArrayOfAlicIva ** SOAP_FMAC4 soap_get_PointerToafip3__ArrayOfAlicIva(struct soap *soap, afip3__ArrayOfAlicIva **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__ArrayOfAlicIva(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__ArrayOfTributo(struct soap *soap, afip3__ArrayOfTributo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__ArrayOfTributo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__ArrayOfTributo(struct soap *soap, const char *tag, int id, afip3__ArrayOfTributo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__ArrayOfTributo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__ArrayOfTributo ? type : NULL);
}

SOAP_FMAC3 afip3__ArrayOfTributo ** SOAP_FMAC4 soap_in_PointerToafip3__ArrayOfTributo(struct soap *soap, const char *tag, afip3__ArrayOfTributo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__ArrayOfTributo **)soap_malloc(soap, sizeof(afip3__ArrayOfTributo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__ArrayOfTributo *)soap_instantiate_afip3__ArrayOfTributo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__ArrayOfTributo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__ArrayOfTributo, sizeof(afip3__ArrayOfTributo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__ArrayOfTributo(struct soap *soap, afip3__ArrayOfTributo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__ArrayOfTributo(soap, tag ? tag : "afip3:ArrayOfTributo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__ArrayOfTributo ** SOAP_FMAC4 soap_get_PointerToafip3__ArrayOfTributo(struct soap *soap, afip3__ArrayOfTributo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__ArrayOfTributo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__ArrayOfCbteAsoc(struct soap *soap, afip3__ArrayOfCbteAsoc *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__ArrayOfCbteAsoc))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__ArrayOfCbteAsoc(struct soap *soap, const char *tag, int id, afip3__ArrayOfCbteAsoc *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__ArrayOfCbteAsoc, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__ArrayOfCbteAsoc ? type : NULL);
}

SOAP_FMAC3 afip3__ArrayOfCbteAsoc ** SOAP_FMAC4 soap_in_PointerToafip3__ArrayOfCbteAsoc(struct soap *soap, const char *tag, afip3__ArrayOfCbteAsoc **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__ArrayOfCbteAsoc **)soap_malloc(soap, sizeof(afip3__ArrayOfCbteAsoc *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__ArrayOfCbteAsoc *)soap_instantiate_afip3__ArrayOfCbteAsoc(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__ArrayOfCbteAsoc **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__ArrayOfCbteAsoc, sizeof(afip3__ArrayOfCbteAsoc), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__ArrayOfCbteAsoc(struct soap *soap, afip3__ArrayOfCbteAsoc *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__ArrayOfCbteAsoc(soap, tag ? tag : "afip3:ArrayOfCbteAsoc", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__ArrayOfCbteAsoc ** SOAP_FMAC4 soap_get_PointerToafip3__ArrayOfCbteAsoc(struct soap *soap, afip3__ArrayOfCbteAsoc **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__ArrayOfCbteAsoc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__FECAEDetRequest(struct soap *soap, afip3__FECAEDetRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__FECAEDetRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__FECAEDetRequest(struct soap *soap, const char *tag, int id, afip3__FECAEDetRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__FECAEDetRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__FECAEDetRequest ? type : NULL);
}

SOAP_FMAC3 afip3__FECAEDetRequest ** SOAP_FMAC4 soap_in_PointerToafip3__FECAEDetRequest(struct soap *soap, const char *tag, afip3__FECAEDetRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__FECAEDetRequest **)soap_malloc(soap, sizeof(afip3__FECAEDetRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__FECAEDetRequest *)soap_instantiate_afip3__FECAEDetRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__FECAEDetRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__FECAEDetRequest, sizeof(afip3__FECAEDetRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__FECAEDetRequest(struct soap *soap, afip3__FECAEDetRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__FECAEDetRequest(soap, tag ? tag : "afip3:FECAEDetRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__FECAEDetRequest ** SOAP_FMAC4 soap_get_PointerToafip3__FECAEDetRequest(struct soap *soap, afip3__FECAEDetRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__FECAEDetRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__ArrayOfFECAEDetRequest(struct soap *soap, afip3__ArrayOfFECAEDetRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__ArrayOfFECAEDetRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__ArrayOfFECAEDetRequest(struct soap *soap, const char *tag, int id, afip3__ArrayOfFECAEDetRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__ArrayOfFECAEDetRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__ArrayOfFECAEDetRequest ? type : NULL);
}

SOAP_FMAC3 afip3__ArrayOfFECAEDetRequest ** SOAP_FMAC4 soap_in_PointerToafip3__ArrayOfFECAEDetRequest(struct soap *soap, const char *tag, afip3__ArrayOfFECAEDetRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__ArrayOfFECAEDetRequest **)soap_malloc(soap, sizeof(afip3__ArrayOfFECAEDetRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__ArrayOfFECAEDetRequest *)soap_instantiate_afip3__ArrayOfFECAEDetRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__ArrayOfFECAEDetRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__ArrayOfFECAEDetRequest, sizeof(afip3__ArrayOfFECAEDetRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__ArrayOfFECAEDetRequest(struct soap *soap, afip3__ArrayOfFECAEDetRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__ArrayOfFECAEDetRequest(soap, tag ? tag : "afip3:ArrayOfFECAEDetRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__ArrayOfFECAEDetRequest ** SOAP_FMAC4 soap_get_PointerToafip3__ArrayOfFECAEDetRequest(struct soap *soap, afip3__ArrayOfFECAEDetRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__ArrayOfFECAEDetRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToafip3__FECAECabRequest(struct soap *soap, afip3__FECAECabRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_afip3__FECAECabRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToafip3__FECAECabRequest(struct soap *soap, const char *tag, int id, afip3__FECAECabRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_afip3__FECAECabRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_afip3__FECAECabRequest ? type : NULL);
}

SOAP_FMAC3 afip3__FECAECabRequest ** SOAP_FMAC4 soap_in_PointerToafip3__FECAECabRequest(struct soap *soap, const char *tag, afip3__FECAECabRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (afip3__FECAECabRequest **)soap_malloc(soap, sizeof(afip3__FECAECabRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (afip3__FECAECabRequest *)soap_instantiate_afip3__FECAECabRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (afip3__FECAECabRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_afip3__FECAECabRequest, sizeof(afip3__FECAECabRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToafip3__FECAECabRequest(struct soap *soap, afip3__FECAECabRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToafip3__FECAECabRequest(soap, tag ? tag : "afip3:FECAECabRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 afip3__FECAECabRequest ** SOAP_FMAC4 soap_get_PointerToafip3__FECAECabRequest(struct soap *soap, afip3__FECAECabRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToafip3__FECAECabRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToafip3__PaisTipo(struct soap *soap, std::vector<afip3__PaisTipo *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToafip3__PaisTipo(struct soap *soap, const std::vector<afip3__PaisTipo *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<afip3__PaisTipo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToafip3__PaisTipo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToafip3__PaisTipo(struct soap *soap, const char *tag, int id, const std::vector<afip3__PaisTipo *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<afip3__PaisTipo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToafip3__PaisTipo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<afip3__PaisTipo *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToafip3__PaisTipo(struct soap *soap, const char *tag, std::vector<afip3__PaisTipo *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToafip3__PaisTipo(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		afip3__PaisTipo *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip3__PaisTipo, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__PaisTipo, sizeof(afip3__PaisTipo), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerToafip3__PaisTipo(soap, tag, NULL, "afip3:PaisTipo"))
				break;
		}
		else
		{	if (!soap_in_PointerToafip3__PaisTipo(soap, tag, &n, "afip3:PaisTipo"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<afip3__PaisTipo *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToafip3__PaisTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToafip3__PaisTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<afip3__PaisTipo *> *p;
	size_t k = sizeof(std::vector<afip3__PaisTipo *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__PaisTipo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<afip3__PaisTipo *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<afip3__PaisTipo *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<afip3__PaisTipo *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToafip3__DocTipo(struct soap *soap, std::vector<afip3__DocTipo *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToafip3__DocTipo(struct soap *soap, const std::vector<afip3__DocTipo *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<afip3__DocTipo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToafip3__DocTipo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToafip3__DocTipo(struct soap *soap, const char *tag, int id, const std::vector<afip3__DocTipo *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<afip3__DocTipo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToafip3__DocTipo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<afip3__DocTipo *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToafip3__DocTipo(struct soap *soap, const char *tag, std::vector<afip3__DocTipo *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToafip3__DocTipo(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		afip3__DocTipo *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip3__DocTipo, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__DocTipo, sizeof(afip3__DocTipo), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerToafip3__DocTipo(soap, tag, NULL, "afip3:DocTipo"))
				break;
		}
		else
		{	if (!soap_in_PointerToafip3__DocTipo(soap, tag, &n, "afip3:DocTipo"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<afip3__DocTipo *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToafip3__DocTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToafip3__DocTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<afip3__DocTipo *> *p;
	size_t k = sizeof(std::vector<afip3__DocTipo *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__DocTipo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<afip3__DocTipo *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<afip3__DocTipo *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<afip3__DocTipo *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToafip3__CbteTipo(struct soap *soap, std::vector<afip3__CbteTipo *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToafip3__CbteTipo(struct soap *soap, const std::vector<afip3__CbteTipo *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<afip3__CbteTipo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToafip3__CbteTipo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToafip3__CbteTipo(struct soap *soap, const char *tag, int id, const std::vector<afip3__CbteTipo *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<afip3__CbteTipo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToafip3__CbteTipo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<afip3__CbteTipo *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToafip3__CbteTipo(struct soap *soap, const char *tag, std::vector<afip3__CbteTipo *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToafip3__CbteTipo(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		afip3__CbteTipo *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip3__CbteTipo, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__CbteTipo, sizeof(afip3__CbteTipo), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerToafip3__CbteTipo(soap, tag, NULL, "afip3:CbteTipo"))
				break;
		}
		else
		{	if (!soap_in_PointerToafip3__CbteTipo(soap, tag, &n, "afip3:CbteTipo"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<afip3__CbteTipo *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToafip3__CbteTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToafip3__CbteTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<afip3__CbteTipo *> *p;
	size_t k = sizeof(std::vector<afip3__CbteTipo *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__CbteTipo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<afip3__CbteTipo *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<afip3__CbteTipo *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<afip3__CbteTipo *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToafip3__PtoVenta(struct soap *soap, std::vector<afip3__PtoVenta *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToafip3__PtoVenta(struct soap *soap, const std::vector<afip3__PtoVenta *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<afip3__PtoVenta *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToafip3__PtoVenta(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToafip3__PtoVenta(struct soap *soap, const char *tag, int id, const std::vector<afip3__PtoVenta *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<afip3__PtoVenta *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToafip3__PtoVenta(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<afip3__PtoVenta *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToafip3__PtoVenta(struct soap *soap, const char *tag, std::vector<afip3__PtoVenta *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToafip3__PtoVenta(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		afip3__PtoVenta *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip3__PtoVenta, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__PtoVenta, sizeof(afip3__PtoVenta), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerToafip3__PtoVenta(soap, tag, NULL, "afip3:PtoVenta"))
				break;
		}
		else
		{	if (!soap_in_PointerToafip3__PtoVenta(soap, tag, &n, "afip3:PtoVenta"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<afip3__PtoVenta *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToafip3__PtoVenta(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToafip3__PtoVenta(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<afip3__PtoVenta *> *p;
	size_t k = sizeof(std::vector<afip3__PtoVenta *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__PtoVenta, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<afip3__PtoVenta *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<afip3__PtoVenta *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<afip3__PtoVenta *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToafip3__ConceptoTipo(struct soap *soap, std::vector<afip3__ConceptoTipo *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToafip3__ConceptoTipo(struct soap *soap, const std::vector<afip3__ConceptoTipo *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<afip3__ConceptoTipo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToafip3__ConceptoTipo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToafip3__ConceptoTipo(struct soap *soap, const char *tag, int id, const std::vector<afip3__ConceptoTipo *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<afip3__ConceptoTipo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToafip3__ConceptoTipo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<afip3__ConceptoTipo *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToafip3__ConceptoTipo(struct soap *soap, const char *tag, std::vector<afip3__ConceptoTipo *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToafip3__ConceptoTipo(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		afip3__ConceptoTipo *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip3__ConceptoTipo, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__ConceptoTipo, sizeof(afip3__ConceptoTipo), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerToafip3__ConceptoTipo(soap, tag, NULL, "afip3:ConceptoTipo"))
				break;
		}
		else
		{	if (!soap_in_PointerToafip3__ConceptoTipo(soap, tag, &n, "afip3:ConceptoTipo"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<afip3__ConceptoTipo *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToafip3__ConceptoTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToafip3__ConceptoTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<afip3__ConceptoTipo *> *p;
	size_t k = sizeof(std::vector<afip3__ConceptoTipo *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__ConceptoTipo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<afip3__ConceptoTipo *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<afip3__ConceptoTipo *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<afip3__ConceptoTipo *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToafip3__OpcionalTipo(struct soap *soap, std::vector<afip3__OpcionalTipo *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToafip3__OpcionalTipo(struct soap *soap, const std::vector<afip3__OpcionalTipo *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<afip3__OpcionalTipo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToafip3__OpcionalTipo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToafip3__OpcionalTipo(struct soap *soap, const char *tag, int id, const std::vector<afip3__OpcionalTipo *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<afip3__OpcionalTipo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToafip3__OpcionalTipo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<afip3__OpcionalTipo *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToafip3__OpcionalTipo(struct soap *soap, const char *tag, std::vector<afip3__OpcionalTipo *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToafip3__OpcionalTipo(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		afip3__OpcionalTipo *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip3__OpcionalTipo, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__OpcionalTipo, sizeof(afip3__OpcionalTipo), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerToafip3__OpcionalTipo(soap, tag, NULL, "afip3:OpcionalTipo"))
				break;
		}
		else
		{	if (!soap_in_PointerToafip3__OpcionalTipo(soap, tag, &n, "afip3:OpcionalTipo"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<afip3__OpcionalTipo *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToafip3__OpcionalTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToafip3__OpcionalTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<afip3__OpcionalTipo *> *p;
	size_t k = sizeof(std::vector<afip3__OpcionalTipo *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__OpcionalTipo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<afip3__OpcionalTipo *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<afip3__OpcionalTipo *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<afip3__OpcionalTipo *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToafip3__IvaTipo(struct soap *soap, std::vector<afip3__IvaTipo *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToafip3__IvaTipo(struct soap *soap, const std::vector<afip3__IvaTipo *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<afip3__IvaTipo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToafip3__IvaTipo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToafip3__IvaTipo(struct soap *soap, const char *tag, int id, const std::vector<afip3__IvaTipo *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<afip3__IvaTipo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToafip3__IvaTipo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<afip3__IvaTipo *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToafip3__IvaTipo(struct soap *soap, const char *tag, std::vector<afip3__IvaTipo *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToafip3__IvaTipo(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		afip3__IvaTipo *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip3__IvaTipo, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__IvaTipo, sizeof(afip3__IvaTipo), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerToafip3__IvaTipo(soap, tag, NULL, "afip3:IvaTipo"))
				break;
		}
		else
		{	if (!soap_in_PointerToafip3__IvaTipo(soap, tag, &n, "afip3:IvaTipo"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<afip3__IvaTipo *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToafip3__IvaTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToafip3__IvaTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<afip3__IvaTipo *> *p;
	size_t k = sizeof(std::vector<afip3__IvaTipo *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__IvaTipo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<afip3__IvaTipo *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<afip3__IvaTipo *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<afip3__IvaTipo *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToafip3__Moneda(struct soap *soap, std::vector<afip3__Moneda *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToafip3__Moneda(struct soap *soap, const std::vector<afip3__Moneda *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<afip3__Moneda *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToafip3__Moneda(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToafip3__Moneda(struct soap *soap, const char *tag, int id, const std::vector<afip3__Moneda *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<afip3__Moneda *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToafip3__Moneda(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<afip3__Moneda *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToafip3__Moneda(struct soap *soap, const char *tag, std::vector<afip3__Moneda *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToafip3__Moneda(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		afip3__Moneda *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip3__Moneda, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Moneda, sizeof(afip3__Moneda), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerToafip3__Moneda(soap, tag, NULL, "afip3:Moneda"))
				break;
		}
		else
		{	if (!soap_in_PointerToafip3__Moneda(soap, tag, &n, "afip3:Moneda"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<afip3__Moneda *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToafip3__Moneda(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToafip3__Moneda(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<afip3__Moneda *> *p;
	size_t k = sizeof(std::vector<afip3__Moneda *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Moneda, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<afip3__Moneda *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<afip3__Moneda *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<afip3__Moneda *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToafip3__TributoTipo(struct soap *soap, std::vector<afip3__TributoTipo *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToafip3__TributoTipo(struct soap *soap, const std::vector<afip3__TributoTipo *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<afip3__TributoTipo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToafip3__TributoTipo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToafip3__TributoTipo(struct soap *soap, const char *tag, int id, const std::vector<afip3__TributoTipo *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<afip3__TributoTipo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToafip3__TributoTipo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<afip3__TributoTipo *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToafip3__TributoTipo(struct soap *soap, const char *tag, std::vector<afip3__TributoTipo *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToafip3__TributoTipo(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		afip3__TributoTipo *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip3__TributoTipo, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__TributoTipo, sizeof(afip3__TributoTipo), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerToafip3__TributoTipo(soap, tag, NULL, "afip3:TributoTipo"))
				break;
		}
		else
		{	if (!soap_in_PointerToafip3__TributoTipo(soap, tag, &n, "afip3:TributoTipo"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<afip3__TributoTipo *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToafip3__TributoTipo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToafip3__TributoTipo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<afip3__TributoTipo *> *p;
	size_t k = sizeof(std::vector<afip3__TributoTipo *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__TributoTipo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<afip3__TributoTipo *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<afip3__TributoTipo *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<afip3__TributoTipo *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToafip3__FECAEASinMov(struct soap *soap, std::vector<afip3__FECAEASinMov *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToafip3__FECAEASinMov(struct soap *soap, const std::vector<afip3__FECAEASinMov *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<afip3__FECAEASinMov *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToafip3__FECAEASinMov(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToafip3__FECAEASinMov(struct soap *soap, const char *tag, int id, const std::vector<afip3__FECAEASinMov *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<afip3__FECAEASinMov *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToafip3__FECAEASinMov(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<afip3__FECAEASinMov *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToafip3__FECAEASinMov(struct soap *soap, const char *tag, std::vector<afip3__FECAEASinMov *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToafip3__FECAEASinMov(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		afip3__FECAEASinMov *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip3__FECAEASinMov, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEASinMov, sizeof(afip3__FECAEASinMov), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerToafip3__FECAEASinMov(soap, tag, NULL, "afip3:FECAEASinMov"))
				break;
		}
		else
		{	if (!soap_in_PointerToafip3__FECAEASinMov(soap, tag, &n, "afip3:FECAEASinMov"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<afip3__FECAEASinMov *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToafip3__FECAEASinMov(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToafip3__FECAEASinMov(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<afip3__FECAEASinMov *> *p;
	size_t k = sizeof(std::vector<afip3__FECAEASinMov *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEASinMov, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<afip3__FECAEASinMov *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<afip3__FECAEASinMov *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<afip3__FECAEASinMov *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToafip3__FECAEADetResponse(struct soap *soap, std::vector<afip3__FECAEADetResponse *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToafip3__FECAEADetResponse(struct soap *soap, const std::vector<afip3__FECAEADetResponse *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<afip3__FECAEADetResponse *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToafip3__FECAEADetResponse(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToafip3__FECAEADetResponse(struct soap *soap, const char *tag, int id, const std::vector<afip3__FECAEADetResponse *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<afip3__FECAEADetResponse *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToafip3__FECAEADetResponse(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<afip3__FECAEADetResponse *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToafip3__FECAEADetResponse(struct soap *soap, const char *tag, std::vector<afip3__FECAEADetResponse *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToafip3__FECAEADetResponse(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		afip3__FECAEADetResponse *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip3__FECAEADetResponse, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEADetResponse, sizeof(afip3__FECAEADetResponse), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerToafip3__FECAEADetResponse(soap, tag, NULL, "afip3:FECAEADetResponse"))
				break;
		}
		else
		{	if (!soap_in_PointerToafip3__FECAEADetResponse(soap, tag, &n, "afip3:FECAEADetResponse"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<afip3__FECAEADetResponse *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToafip3__FECAEADetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToafip3__FECAEADetResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<afip3__FECAEADetResponse *> *p;
	size_t k = sizeof(std::vector<afip3__FECAEADetResponse *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEADetResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<afip3__FECAEADetResponse *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<afip3__FECAEADetResponse *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<afip3__FECAEADetResponse *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToafip3__FECAEADetRequest(struct soap *soap, std::vector<afip3__FECAEADetRequest *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToafip3__FECAEADetRequest(struct soap *soap, const std::vector<afip3__FECAEADetRequest *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<afip3__FECAEADetRequest *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToafip3__FECAEADetRequest(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToafip3__FECAEADetRequest(struct soap *soap, const char *tag, int id, const std::vector<afip3__FECAEADetRequest *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<afip3__FECAEADetRequest *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToafip3__FECAEADetRequest(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<afip3__FECAEADetRequest *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToafip3__FECAEADetRequest(struct soap *soap, const char *tag, std::vector<afip3__FECAEADetRequest *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToafip3__FECAEADetRequest(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		afip3__FECAEADetRequest *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip3__FECAEADetRequest, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEADetRequest, sizeof(afip3__FECAEADetRequest), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerToafip3__FECAEADetRequest(soap, tag, NULL, "afip3:FECAEADetRequest"))
				break;
		}
		else
		{	if (!soap_in_PointerToafip3__FECAEADetRequest(soap, tag, &n, "afip3:FECAEADetRequest"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<afip3__FECAEADetRequest *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToafip3__FECAEADetRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToafip3__FECAEADetRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<afip3__FECAEADetRequest *> *p;
	size_t k = sizeof(std::vector<afip3__FECAEADetRequest *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEADetRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<afip3__FECAEADetRequest *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<afip3__FECAEADetRequest *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<afip3__FECAEADetRequest *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToafip3__Err(struct soap *soap, std::vector<afip3__Err *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToafip3__Err(struct soap *soap, const std::vector<afip3__Err *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<afip3__Err *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToafip3__Err(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToafip3__Err(struct soap *soap, const char *tag, int id, const std::vector<afip3__Err *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<afip3__Err *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToafip3__Err(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<afip3__Err *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToafip3__Err(struct soap *soap, const char *tag, std::vector<afip3__Err *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToafip3__Err(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		afip3__Err *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip3__Err, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Err, sizeof(afip3__Err), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerToafip3__Err(soap, tag, NULL, "afip3:Err"))
				break;
		}
		else
		{	if (!soap_in_PointerToafip3__Err(soap, tag, &n, "afip3:Err"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<afip3__Err *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToafip3__Err(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToafip3__Err(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<afip3__Err *> *p;
	size_t k = sizeof(std::vector<afip3__Err *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Err, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<afip3__Err *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<afip3__Err *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<afip3__Err *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToafip3__Evt(struct soap *soap, std::vector<afip3__Evt *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToafip3__Evt(struct soap *soap, const std::vector<afip3__Evt *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<afip3__Evt *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToafip3__Evt(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToafip3__Evt(struct soap *soap, const char *tag, int id, const std::vector<afip3__Evt *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<afip3__Evt *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToafip3__Evt(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<afip3__Evt *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToafip3__Evt(struct soap *soap, const char *tag, std::vector<afip3__Evt *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToafip3__Evt(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		afip3__Evt *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip3__Evt, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Evt, sizeof(afip3__Evt), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerToafip3__Evt(soap, tag, NULL, "afip3:Evt"))
				break;
		}
		else
		{	if (!soap_in_PointerToafip3__Evt(soap, tag, &n, "afip3:Evt"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<afip3__Evt *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToafip3__Evt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToafip3__Evt(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<afip3__Evt *> *p;
	size_t k = sizeof(std::vector<afip3__Evt *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Evt, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<afip3__Evt *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<afip3__Evt *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<afip3__Evt *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToafip3__Obs(struct soap *soap, std::vector<afip3__Obs *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToafip3__Obs(struct soap *soap, const std::vector<afip3__Obs *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<afip3__Obs *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToafip3__Obs(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToafip3__Obs(struct soap *soap, const char *tag, int id, const std::vector<afip3__Obs *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<afip3__Obs *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToafip3__Obs(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<afip3__Obs *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToafip3__Obs(struct soap *soap, const char *tag, std::vector<afip3__Obs *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToafip3__Obs(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		afip3__Obs *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip3__Obs, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Obs, sizeof(afip3__Obs), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerToafip3__Obs(soap, tag, NULL, "afip3:Obs"))
				break;
		}
		else
		{	if (!soap_in_PointerToafip3__Obs(soap, tag, &n, "afip3:Obs"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<afip3__Obs *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToafip3__Obs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToafip3__Obs(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<afip3__Obs *> *p;
	size_t k = sizeof(std::vector<afip3__Obs *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Obs, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<afip3__Obs *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<afip3__Obs *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<afip3__Obs *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToafip3__FECAEDetResponse(struct soap *soap, std::vector<afip3__FECAEDetResponse *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToafip3__FECAEDetResponse(struct soap *soap, const std::vector<afip3__FECAEDetResponse *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<afip3__FECAEDetResponse *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToafip3__FECAEDetResponse(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToafip3__FECAEDetResponse(struct soap *soap, const char *tag, int id, const std::vector<afip3__FECAEDetResponse *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<afip3__FECAEDetResponse *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToafip3__FECAEDetResponse(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<afip3__FECAEDetResponse *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToafip3__FECAEDetResponse(struct soap *soap, const char *tag, std::vector<afip3__FECAEDetResponse *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToafip3__FECAEDetResponse(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		afip3__FECAEDetResponse *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip3__FECAEDetResponse, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEDetResponse, sizeof(afip3__FECAEDetResponse), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerToafip3__FECAEDetResponse(soap, tag, NULL, "afip3:FECAEDetResponse"))
				break;
		}
		else
		{	if (!soap_in_PointerToafip3__FECAEDetResponse(soap, tag, &n, "afip3:FECAEDetResponse"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<afip3__FECAEDetResponse *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToafip3__FECAEDetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToafip3__FECAEDetResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<afip3__FECAEDetResponse *> *p;
	size_t k = sizeof(std::vector<afip3__FECAEDetResponse *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEDetResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<afip3__FECAEDetResponse *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<afip3__FECAEDetResponse *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<afip3__FECAEDetResponse *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToafip3__Comprador(struct soap *soap, std::vector<afip3__Comprador *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToafip3__Comprador(struct soap *soap, const std::vector<afip3__Comprador *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<afip3__Comprador *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToafip3__Comprador(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToafip3__Comprador(struct soap *soap, const char *tag, int id, const std::vector<afip3__Comprador *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<afip3__Comprador *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToafip3__Comprador(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<afip3__Comprador *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToafip3__Comprador(struct soap *soap, const char *tag, std::vector<afip3__Comprador *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToafip3__Comprador(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		afip3__Comprador *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip3__Comprador, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Comprador, sizeof(afip3__Comprador), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerToafip3__Comprador(soap, tag, NULL, "afip3:Comprador"))
				break;
		}
		else
		{	if (!soap_in_PointerToafip3__Comprador(soap, tag, &n, "afip3:Comprador"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<afip3__Comprador *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToafip3__Comprador(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToafip3__Comprador(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<afip3__Comprador *> *p;
	size_t k = sizeof(std::vector<afip3__Comprador *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Comprador, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<afip3__Comprador *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<afip3__Comprador *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<afip3__Comprador *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToafip3__Opcional(struct soap *soap, std::vector<afip3__Opcional *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToafip3__Opcional(struct soap *soap, const std::vector<afip3__Opcional *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<afip3__Opcional *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToafip3__Opcional(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToafip3__Opcional(struct soap *soap, const char *tag, int id, const std::vector<afip3__Opcional *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<afip3__Opcional *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToafip3__Opcional(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<afip3__Opcional *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToafip3__Opcional(struct soap *soap, const char *tag, std::vector<afip3__Opcional *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToafip3__Opcional(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		afip3__Opcional *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip3__Opcional, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Opcional, sizeof(afip3__Opcional), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerToafip3__Opcional(soap, tag, NULL, "afip3:Opcional"))
				break;
		}
		else
		{	if (!soap_in_PointerToafip3__Opcional(soap, tag, &n, "afip3:Opcional"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<afip3__Opcional *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToafip3__Opcional(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToafip3__Opcional(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<afip3__Opcional *> *p;
	size_t k = sizeof(std::vector<afip3__Opcional *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Opcional, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<afip3__Opcional *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<afip3__Opcional *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<afip3__Opcional *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToafip3__AlicIva(struct soap *soap, std::vector<afip3__AlicIva *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToafip3__AlicIva(struct soap *soap, const std::vector<afip3__AlicIva *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<afip3__AlicIva *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToafip3__AlicIva(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToafip3__AlicIva(struct soap *soap, const char *tag, int id, const std::vector<afip3__AlicIva *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<afip3__AlicIva *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToafip3__AlicIva(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<afip3__AlicIva *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToafip3__AlicIva(struct soap *soap, const char *tag, std::vector<afip3__AlicIva *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToafip3__AlicIva(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		afip3__AlicIva *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip3__AlicIva, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__AlicIva, sizeof(afip3__AlicIva), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerToafip3__AlicIva(soap, tag, NULL, "afip3:AlicIva"))
				break;
		}
		else
		{	if (!soap_in_PointerToafip3__AlicIva(soap, tag, &n, "afip3:AlicIva"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<afip3__AlicIva *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToafip3__AlicIva(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToafip3__AlicIva(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<afip3__AlicIva *> *p;
	size_t k = sizeof(std::vector<afip3__AlicIva *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__AlicIva, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<afip3__AlicIva *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<afip3__AlicIva *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<afip3__AlicIva *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToafip3__Tributo(struct soap *soap, std::vector<afip3__Tributo *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToafip3__Tributo(struct soap *soap, const std::vector<afip3__Tributo *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<afip3__Tributo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToafip3__Tributo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToafip3__Tributo(struct soap *soap, const char *tag, int id, const std::vector<afip3__Tributo *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<afip3__Tributo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToafip3__Tributo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<afip3__Tributo *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToafip3__Tributo(struct soap *soap, const char *tag, std::vector<afip3__Tributo *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToafip3__Tributo(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		afip3__Tributo *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip3__Tributo, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Tributo, sizeof(afip3__Tributo), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerToafip3__Tributo(soap, tag, NULL, "afip3:Tributo"))
				break;
		}
		else
		{	if (!soap_in_PointerToafip3__Tributo(soap, tag, &n, "afip3:Tributo"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<afip3__Tributo *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToafip3__Tributo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToafip3__Tributo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<afip3__Tributo *> *p;
	size_t k = sizeof(std::vector<afip3__Tributo *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__Tributo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<afip3__Tributo *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<afip3__Tributo *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<afip3__Tributo *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToafip3__CbteAsoc(struct soap *soap, std::vector<afip3__CbteAsoc *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToafip3__CbteAsoc(struct soap *soap, const std::vector<afip3__CbteAsoc *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<afip3__CbteAsoc *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToafip3__CbteAsoc(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToafip3__CbteAsoc(struct soap *soap, const char *tag, int id, const std::vector<afip3__CbteAsoc *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<afip3__CbteAsoc *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToafip3__CbteAsoc(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<afip3__CbteAsoc *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToafip3__CbteAsoc(struct soap *soap, const char *tag, std::vector<afip3__CbteAsoc *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToafip3__CbteAsoc(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		afip3__CbteAsoc *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip3__CbteAsoc, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__CbteAsoc, sizeof(afip3__CbteAsoc), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerToafip3__CbteAsoc(soap, tag, NULL, "afip3:CbteAsoc"))
				break;
		}
		else
		{	if (!soap_in_PointerToafip3__CbteAsoc(soap, tag, &n, "afip3:CbteAsoc"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<afip3__CbteAsoc *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToafip3__CbteAsoc(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToafip3__CbteAsoc(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<afip3__CbteAsoc *> *p;
	size_t k = sizeof(std::vector<afip3__CbteAsoc *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__CbteAsoc, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<afip3__CbteAsoc *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<afip3__CbteAsoc *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<afip3__CbteAsoc *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToafip3__FECAEDetRequest(struct soap *soap, std::vector<afip3__FECAEDetRequest *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToafip3__FECAEDetRequest(struct soap *soap, const std::vector<afip3__FECAEDetRequest *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<afip3__FECAEDetRequest *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToafip3__FECAEDetRequest(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToafip3__FECAEDetRequest(struct soap *soap, const char *tag, int id, const std::vector<afip3__FECAEDetRequest *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<afip3__FECAEDetRequest *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToafip3__FECAEDetRequest(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<afip3__FECAEDetRequest *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToafip3__FECAEDetRequest(struct soap *soap, const char *tag, std::vector<afip3__FECAEDetRequest *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToafip3__FECAEDetRequest(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		afip3__FECAEDetRequest *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_afip3__FECAEDetRequest, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEDetRequest, sizeof(afip3__FECAEDetRequest), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerToafip3__FECAEDetRequest(soap, tag, NULL, "afip3:FECAEDetRequest"))
				break;
		}
		else
		{	if (!soap_in_PointerToafip3__FECAEDetRequest(soap, tag, &n, "afip3:FECAEDetRequest"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<afip3__FECAEDetRequest *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToafip3__FECAEDetRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToafip3__FECAEDetRequest(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<afip3__FECAEDetRequest *> *p;
	size_t k = sizeof(std::vector<afip3__FECAEDetRequest *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerToafip3__FECAEDetRequest, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<afip3__FECAEDetRequest *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<afip3__FECAEDetRequest *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<afip3__FECAEDetRequest *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
